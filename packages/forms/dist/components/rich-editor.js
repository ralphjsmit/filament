// node_modules/orderedmap/dist/index.js
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self.find(key), content = self.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey) content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1) return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size) return this;
    return new OrderedMap(map2.content.concat(this.subtract(map2).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size) return this;
    return new OrderedMap(this.subtract(map2).content.concat(map2.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map2) {
    var result = this;
    map2 = OrderedMap.from(map2);
    for (var i = 0; i < map2.content.length; i += 2)
      result = result.remove(map2.content[i]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value;
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content);
};
var dist_default = OrderedMap;

// node_modules/prosemirror-model/dist/index.js
function findDiffStart(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size3 = childA.nodeSize;
    if (childA == childB) {
      posA -= size3;
      posB -= size3;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size3;
    posB -= size3;
  }
}
var Fragment = class _Fragment {
  /**
  @internal
  */
  constructor(content, size3) {
    this.content = content;
    this.size = size3 || 0;
    if (size3 == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start), Math.min(child.content.size, to - start), f, nodeStart + start);
      }
      pos = end;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text = "", first2 = true;
    this.nodesBetween(from2, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content[content.length - 1] = last.withText(last.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new _Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size3 = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from2) {
          if (pos < from2 || end > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size3 += child.nodeSize;
        }
        pos = end;
      }
    return new _Fragment(result, size3);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return _Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new _Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index, node) {
    let current = this.content[index];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size3 = this.size + node.nodeSize - current.nodeSize;
    copy2[index] = node;
    return new _Fragment(copy2, size3);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new _Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new _Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index) {
    let found2 = this.content[index];
    if (!found2)
      throw new RangeError("Index " + index + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content[index] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos, round2 = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos || round2 > 0)
          return retIndex(i + 1, end);
        return retIndex(i, curPos);
      }
      curPos = end;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return _Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new _Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return _Fragment.empty;
    let joined, size3 = 0;
    for (let i = 0; i < array.length; i++) {
      let node = array[i];
      size3 += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new _Fragment(joined || array, size3);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return _Fragment.empty;
    if (nodes instanceof _Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new _Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
};
Fragment.empty = new Fragment([], 0);
var found = { index: 0, offset: 0 };
function retIndex(index, offset3) {
  found.index = index;
  found.offset = offset3;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}
var Mark = class _Mark2 {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type.create(json.attrs);
    type.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return _Mark2.none;
    if (marks instanceof _Mark2)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
};
Mark.none = [];
var ReplaceError = class extends Error {
};
var Slice = class _Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new _Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return _Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new _Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new _Slice(fragment, openStart, openEnd);
  }
};
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index, offset: offset3 } = content.findIndex(from2), child = content.maybeChild(index);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset3 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from2 - offset3 - 1, to - offset3 - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index, offset: offset3 } = content.findIndex(dist), child = content.maybeChild(index);
  if (offset3 == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset3 - 1, insert);
  return inner && content.replaceChild(index, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice2.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice2, $from);
    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice2.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)
  };
}
var ResolvedPos = class _ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index = this.index(this.depth);
    if (index == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
    return dOff ? parent.child(index).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index).cut(0, dOff);
    return index == 0 ? null : this.parent.child(index - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index).marks;
    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks = main.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc3, pos) {
    if (!(pos >= 0 && pos <= doc3.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start = 0, parentOffset = pos;
    for (let node = doc3; ; ) {
      let { index, offset: offset3 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset3;
      path.push(node, index, start + offset3);
      if (!rem)
        break;
      node = node.child(index);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start += offset3 + 1;
    }
    return new _ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc3, pos) {
    let cache = resolveCache.get(doc3);
    if (cache) {
      for (let i = 0; i < cache.elts.length; i++) {
        let elt = cache.elts[i];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc3, cache = new ResolveCache());
    }
    let result = cache.elts[cache.i] = _ResolvedPos.resolve(doc3, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result;
  }
};
var ResolveCache = class {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
};
var resolveCacheSize = 12;
var resolveCache = /* @__PURE__ */ new WeakMap();
var NodeRange = class {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
};
var emptyAttrs = /* @__PURE__ */ Object.create(null);
var Node2 = class _Node2 {
  /**
  @internal
  */
  constructor(type, attrs, content, marks = Mark.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index) {
    return this.content.child(index);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content.maybeChild(index);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new _Node2(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new _Node2(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start, $to.pos - start);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index, offset: offset3 } = node.content.findIndex(pos);
      node = node.maybeChild(index);
      if (!node)
        return null;
      if (offset3 == pos || node.isText)
        return node;
      pos -= offset3 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index, offset: offset3 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index), index, offset: offset3 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index, offset: offset3 } = this.content.findIndex(pos);
    if (offset3 < pos)
      return { node: this.content.child(index), index, offset: offset3 };
    let node = this.content.child(index - 1);
    return { node, index: index - 1, offset: offset3 - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start, end);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start; i < end; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start = this.contentMatchAt(from2).matchType(type);
    let end = start && start.matchFragment(this.content, to);
    return end ? end.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark.none;
    for (let i = 0; i < this.marks.length; i++) {
      let mark = this.marks[i];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _ in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    let node = schema.nodeType(json.type).create(json.attrs, content, marks);
    node.type.checkAttrs(node.attrs);
    return node;
  }
};
Node2.prototype.text = void 0;
var TextNode = class _TextNode extends Node2 {
  /**
  @internal
  */
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new _TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
};
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
var ContentMatch = class _ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return _ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start = 0, end = frag.childCount) {
    let cur = this;
    for (let i = start; cur && i < end; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
};
ContentMatch.empty = new ContentMatch(true);
var TokenStream = class {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
};
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.isInGroup(name))
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from2, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile(expr2.expr, from2), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values, type, name) {
  for (let name2 in values)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(typeName, name, attrs[name]);
  return result;
}
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node2(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node2(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node2(this, attrs, content.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _ in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
function validateType(typeName, attrName, type) {
  let types = type.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
var Attribute = class {
  constructor(typeName, attrName, options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
    this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
var MarkType = class _MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark(this, defaults2) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
};
var Schema = class {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      if (type.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type.isInline || !type.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type;
      }
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(json) {
    return Node2.fromJSON(this, json);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(json) {
    return Mark.fromJSON(this, json);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
var DOMParser = class _DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return false;
      let node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, Mark.none, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, Mark.none, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
  }
};
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = { ol: true, ul: true };
var OPT_PRESERVE_WS = 1;
var OPT_PRESERVE_WS_FULL = 2;
var OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
var NodeContext = class {
  constructor(type, attrs, marks, solid, match, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start = this.type.contentMatch, wrap2;
        if (wrap2 = start.findWrapping(node.type)) {
          this.match = start;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m;
      if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text = last;
        if (last.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
};
var ParseContext = class {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
    if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS !== "full") {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value), marks, !/\S/.test(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom, marks);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top.content.length && top.content[0].isInline && this.open) {
          this.open--;
          top = this.top;
        }
        sync = true;
        if (!top.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom, marks);
        break out;
      }
      let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
      if (innerMarks)
        this.addAll(dom, innerMarks);
      if (sync)
        this.sync(top);
      this.needsBlock = oldNeedsBlock;
    } else {
      let innerMarks = this.readStyles(dom, marks);
      if (innerMarks)
        this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
    }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks, true);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom, marks) {
    let styles = dom.style;
    if (styles && styles.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
        if (value)
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m) => !rule.clearMark(m));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks, false));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
      this.findAtPoint(parent, index);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node, marks, cautious) {
    let route, sync;
    for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length + penalty)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid) {
        if (cautious)
          break;
        penalty += 2;
      }
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      marks = this.enterInner(route[i], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node, marks, cautious) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node, marks, cautious);
    if (innerMarks) {
      this.closeExtra();
      let top = this.top;
      if (top.match)
        top.match = top.match.matchType(node.type);
      let nodeMarks = Mark.none;
      for (let m of innerMarks.concat(node.marks))
        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
          nodeMarks = m.addToSet(nodeMarks);
      top.content.push(node.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, marks, preserveWS) {
    let innerMarks = this.findPlace(type.create(attrs), marks, false);
    if (innerMarks)
      innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type, attrs, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.match = top.match && top.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
      options |= OPT_OPEN_LEFT;
    let applyMarks = Mark.none;
    marks = marks.filter((m) => {
      if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
        applyMarks = m.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset3) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset3)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
};
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type, next } = match.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
var DOMSerializer = class _DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc(options).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push([add, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options) {
    let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options = {}) {
    let dom = this.serializeNodeInner(node, options);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline3, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc(options), toDOM(mark, inline3), null, mark.attrs);
  }
  static renderSpec(doc3, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc3, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
};
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options) {
  return options.document || window.document;
}
var suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i = 0; i < value.length; i++)
            scan(value[i]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result;
}
function renderSpec(doc3, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc3.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);
  let attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else
          dom.setAttribute(name, attrs[name]);
      }
  }
  for (let i = start; i < structure.length; i++) {
    let child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc3, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}

// node_modules/prosemirror-transform/dist/index.js
var lower16 = 65535;
var factor16 = Math.pow(2, 16);
function makeRecover(index, offset3) {
  return index + offset3 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1;
var DEL_AFTER = 2;
var DEL_ACROSS = 4;
var DEL_SIDE = 8;
var MapResult = class {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
};
var StepMap = class _StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && _StepMap.empty)
      return _StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result = start + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
        let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start : pos != end)
          del2 |= DEL_SIDE;
        return new MapResult(result, del2, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
      if (pos <= end && i == index * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new _StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
};
StepMap.empty = new StepMap([]);
var Mapping = class _Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps, mirror, from2 = 0, to = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new _Mapping(this._maps, this.mirror, from2, to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map2, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map2);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new _Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this._maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map2 = this._maps[i], result = map2.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this._maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
};
var stepsByID = /* @__PURE__ */ Object.create(null);
var Step = class {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
};
var StepResult = class _StepResult {
  /**
  @internal
  */
  constructor(doc3, failed) {
    this.doc = doc3;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc3) {
    return new _StepResult(doc3, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new _StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc3, from2, to, slice2) {
    try {
      return _StepResult.ok(doc3.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return _StepResult.fail(e.message);
      throw e;
    }
  }
};
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
var AddMarkStep = class _AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addMark", AddMarkStep);
var RemoveMarkStep = class _RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc3) {
    let oldSlice = doc3.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc3), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc3, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new _RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeMark", RemoveMarkStep);
var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new _AddNodeMarkStep(this.pos, node.marks[i]);
        return new _AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("addNodeMark", AddNodeMarkStep);
var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
};
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
var ReplaceStep = class _ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && contentBetween(doc3, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc3, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc3) {
    return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice, this.structure);
  }
  merge(other) {
    if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new _ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
};
Step.jsonID("replace", ReplaceStep);
var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc3) {
    if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc3.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc3, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc3) {
    let gap = this.gapTo - this.gapFrom;
    return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
};
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc3, from2, to) {
  let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr2, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr2.doc.nodesBetween(from2, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from2), end = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s) => tr2.step(s));
  added.forEach((s) => tr2.step(s));
}
function removeMark(tr2, from2, to, mark) {
  let matched = [], step = 0;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end, step });
        }
      }
    }
  });
  matched.forEach((m) => tr2.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr2, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node = tr2.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr2.step(new RemoveMarkStep(cur, end, child.marks[j]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m, newline = /\r?\n|\r/g, slice2;
        while (m = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr2.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr2.step(replSteps[i]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
function liftTarget(range) {
  let parent = range.parent;
  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (let depth = range.depth; ; --depth) {
    let node = range.$from.node(depth);
    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
      break;
  }
  return null;
}
function lift(tr2, range, target) {
  let { $from, $to, depth } = range;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after = Fragment.from($to.node(d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr2.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range, nodeType, attrs = null, innerRange = range) {
  let around = findWrappingOutside(range, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  let { parent, startIndex, endIndex } = range;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr2, range, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start = range.start, end = range.end;
  tr2.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr2, from2, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr2.steps.length;
  tr2.doc.nodesBetween(from2, to, (node, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr2.doc, tr2.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr2, node, pos, mapFrom);
      clearIncompatible(tr2, tr2.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
      let mapping = tr2.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr2.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr2, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr2, node, pos, mapFrom) {
  node.forEach((child, offset3) => {
    if (child.isText) {
      let m, newline = /\r?\n|\r/g;
      while (m = newline.exec(child.text)) {
        let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset3 + m.index);
        tr2.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr2, node, pos, mapFrom) {
  node.forEach((child, offset3) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start = tr2.mapping.slice(mapFrom).map(pos + 1 + offset3);
      tr2.replaceWith(start, start + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc3, pos, type) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}
function setNodeMarkup(tr2, pos, type, attrs, marks) {
  let node = tr2.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr2.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr2.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc3, pos, depth = 1, typesAfter) {
  let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    let node = $pos.node(d), index2 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index2, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr2, pos, depth = 1, typesAfter) {
  let $pos = tr2.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = Fragment.from($pos.node(d).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr2.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc3, pos) {
  let $pos = doc3.resolve(pos), index = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}
function canAppendWithSubstitutedLinebreaks(a, b) {
  if (!b.content.size)
    a.type.compatibleContent(b.type);
  let match = a.contentMatchAt(a.childCount);
  let { linebreakReplacement } = a.type.schema;
  for (let i = 0; i < b.childCount; i++) {
    let child = b.child(i);
    let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
    match = match.matchType(type);
    if (!match)
      return false;
    if (!a.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable2(a, b) {
  return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
}
function joinPoint(doc3, pos, dir = -1) {
  let $pos = doc3.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before, after, index = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index, index + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join(tr2, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr2.doc.type.schema;
  let $before = tr2.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr2.steps.length;
  if (convertNewlines === false) {
    let $after = tr2.doc.resolve(pos + depth);
    replaceLinebreaks(tr2, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr2, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr2.mapping.slice(mapFrom), start = mapping.map(pos - depth);
  tr2.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr2.doc.resolve(start);
    replaceNewlines(tr2, $full.node(), $full.before(), tr2.steps.length);
  }
  return tr2;
}
function insertPoint(doc3, pos, nodeType) {
  let $pos = doc3.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.before(d + 1);
      if (index > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.after(d + 1);
      if (index < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc3, pos, slice2) {
  let $pos = doc3.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc3.resolve(from2), $to = doc3.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
var Fitter = class {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top = this.frontier[this.depth], level;
    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      let { match, type } = this.frontier[i];
      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      let fit = contentAfterFits($to, i, type, match, dropInner);
      if (!fit)
        continue;
      for (let d = i - 1; d >= 0; d--) {
        let { match: match2, type: type2 } = this.frontier[d];
        let matches2 = contentAfterFits($to, d, type2, match2, true);
        if (!matches2 || matches2.childCount)
          continue scan;
      }
      return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top = this.frontier[this.depth];
    top.match = top.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
};
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}
function invalidMarks(type, fragment, start) {
  for (let i = start; i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr2, from2, to, slice2) {
  if (!slice2.size)
    return tr2.deleteRange(from2, to);
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr2.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr2.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice2.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice2.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks))
        return tr2.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr2.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr2.replace(from2, to, slice2);
    if (tr2.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr2, from2, to, node) {
  if (!node.isInline && from2 == to && tr2.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr2.doc, from2, node.type);
    if (point != null)
      from2 = to = point;
  }
  tr2.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange(tr2, from2, to) {
  let $from = tr2.doc.resolve(from2), $to = tr2.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr2.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr2.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
      return tr2.delete($from.before(d), to);
  }
  tr2.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
      result.push(d);
  }
  return result;
}
var AttrStep = class _AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let node = doc3.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new _AttrStep(json.pos, json.attr, json.value);
  }
};
Step.jsonID("attr", AttrStep);
var DocAttrStep = class _DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc3) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc3.attrs)
      attrs[name] = doc3.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc3.type.create(attrs, doc3.content, doc3.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc3) {
    return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new _DocAttrStep(json.attr, json.value);
  }
};
Step.jsonID("docAttr", DocAttrStep);
var TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
var Transform = class {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc3) {
    this.doc = doc3;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc3;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node) {
    replaceRangeWith(this, from2, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range, target) {
    lift(this, range, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range, wrappers) {
    wrap(this, range, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type, attrs = null) {
    setBlockType(this, from2, to, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    let node = this.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at position " + pos);
    if (mark instanceof Mark) {
      if (mark.isInSet(node.marks))
        this.step(new RemoveNodeMarkStep(pos, mark));
    } else {
      let set = node.marks, found2, steps = [];
      while (found2 = mark.isInSet(set)) {
        steps.push(new RemoveNodeMarkStep(pos, found2));
        set = found2.removeFromSet(set);
      }
      for (let i = steps.length - 1; i >= 0; i--)
        this.step(steps[i]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
};

// node_modules/prosemirror-state/dist/index.js
var classesById = /* @__PURE__ */ Object.create(null);
var Selection = class {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr2, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      tr2.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr2, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr2, node) {
    let mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr2.deleteRange(from2, to);
      } else {
        tr2.replaceRangeWith(from2, to, node);
        selectionToInsertionEnd(tr2, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc3) {
    return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc3) {
    return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc3, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc3, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
};
Selection.prototype.visible = true;
var SelectionRange = class {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
};
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
var TextSelection = class _TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc3, mapping) {
    let $head = doc3.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc3.resolve(mapping.map(this.anchor));
    return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr2, content = Slice.empty) {
    super.replace(tr2, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr2.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc3, anchor, head = anchor) {
    let $anchor = doc3.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new _TextSelection($anchor, $head);
  }
};
Selection.jsonID("text", TextSelection);
var TextBookmark = class _TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc3) {
    return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));
  }
};
var NodeSelection = class _NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc3, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc3.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new _NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof _NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new _NodeSelection(doc3.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc3, from2) {
    return new _NodeSelection(doc3.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
};
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = class _NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
};
var AllSelection = class _AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc3) {
    super(doc3.resolve(0), doc3.resolve(doc3.content.size));
  }
  replace(tr2, content = Slice.empty) {
    if (content == Slice.empty) {
      tr2.delete(0, tr2.doc.content.size);
      let sel = Selection.atStart(tr2.doc);
      if (!sel.eq(tr2.selection))
        tr2.setSelection(sel);
    } else {
      super.replace(tr2, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc3) {
    return new _AllSelection(doc3);
  }
  map(doc3) {
    return new _AllSelection(doc3);
  }
  eq(other) {
    return other instanceof _AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
};
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map() {
    return this;
  },
  resolve(doc3) {
    return new AllSelection(doc3);
  }
};
function findSelectionIn(doc3, node, pos, index, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc3, pos);
  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr2, startLen, bias) {
  let last = tr2.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr2.mapping.maps[last], end;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
var UPDATED_SEL = 1;
var UPDATED_MARKS = 2;
var UPDATED_SCROLL = 4;
var Transaction = class extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc3) {
    super.addStep(step, doc3);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _ in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
};
function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}
var FieldDesc = class {
  constructor(name, desc, self) {
    this.name = name;
    this.init = bind(desc.init, self);
    this.apply = bind(desc.apply, self);
  }
};
var baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr2) {
      return tr2.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr2) {
      return tr2.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr2, _marks, _old, state) {
      return state.selection.$cursor ? tr2.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr2, prev) {
      return tr2.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
var Configuration = class {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
};
var EditorState = class _EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr2) {
    return this.applyTransaction(tr2).state;
  }
  /**
  @internal
  */
  filterTransaction(tr2, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr2, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr2 = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr2 && newState.filterTransaction(tr2, i)) {
            tr2.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr2);
            newState = newState.applyInner(tr2);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr2) {
    if (!tr2.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new _EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr2, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new _EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new _EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new _EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node2.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
};
function bindProps(obj, self, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self, {});
    target[prop] = val;
  }
  return target;
}
var Plugin = class {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};
var keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
var PluginKey = class {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
};

// node_modules/prosemirror-view/dist/index.js
var domIndex = function(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
};
var parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
var textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
var clearReusedRange = function() {
  reusedRange = null;
};
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  var _a;
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      let child = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (child.nodeType == 1 && child.contentEditable == "false") {
        if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection)
          off += dir;
        else
          return false;
      } else {
        node = child;
        off = dir < 0 ? nodeSize(node) : 0;
      }
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset3) {
  for (; ; ) {
    if (node.nodeType == 3 && offset3)
      return node;
    if (node.nodeType == 1 && offset3 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset3 - 1];
      offset3 = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset3 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset3) {
  for (; ; ) {
    if (node.nodeType == 3 && offset3 < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset3 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset3];
      offset3 = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset3 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset3, parent) {
  for (let atStart = offset3 == 0, atEnd = offset3 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
var selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc3) {
  let elt = doc3.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc3, x, y) {
  if (doc3.caretPositionFromPoint) {
    try {
      let pos = doc3.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_) {
    }
  }
  if (doc3.caretRangeFromPoint) {
    let range = doc3.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc2 = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc3) {
  let vp = doc3.defaultView && doc3.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc3.documentElement.clientWidth,
    top: 0,
    bottom: doc3.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc3 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc3.body;
    let bounding = atTop ? windowRect(doc3) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc3.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc3 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc3)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i = 0; i < stack.length; i++) {
    let { dom, top, left } = stack[i];
    if (dom.scrollTop != top + dTop)
      dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left)
      dom.scrollLeft = left;
  }
}
var preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset3 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset3 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset3 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset3 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset3 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset3, bias);
}
function posFromCaret(view, node, offset3, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset3, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc3 = view.dom.ownerDocument, node, offset3 = 0;
  let caret = caretFromPoint(doc3, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset3 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset3 = Math.min(offset3, node.childNodes.length);
      if (offset3 < node.childNodes.length) {
        let next = node.childNodes[offset3], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset3++;
      }
    }
    let prev;
    if (webkit && offset3 && node.nodeType == 1 && (prev = node.childNodes[offset3 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset3--;
    if (node == view.dom && offset3 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset3 == 0 || node.nodeType != 1 || node.childNodes[offset3 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset3, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset3, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset3 : offset3 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset3, offset3), side);
      if (gecko && offset3 && /\s/.test(node.nodeValue[offset3 - 1]) && offset3 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset3 - 1, offset3 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset3, offset3 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset3, to = offset3, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset3) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset3 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset3 && (side < 0 || offset3 == nodeSize(node))) {
      let before = node.childNodes[offset3 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset3 < nodeSize(node)) {
      let after = node.childNodes[offset3];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset3 && (side < 0 || offset3 == nodeSize(node))) {
    let before = node.childNodes[offset3 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset3 < nodeSize(node)) {
    let after = node.childNodes[offset3];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0)
    return rect;
  let x = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top) {
  if (rect.height == 0)
    return rect;
  let y = top ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset3 = $head.parentOffset, atStart = !offset3, atEnd = offset3 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
var NOT_DIRTY = 0;
var CHILD_DIRTY = 1;
var CONTENT_DIRTY = 2;
var NODE_DIRTY = 3;
var ViewDesc = class {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size3 = 0;
    for (let i = 0; i < this.children.length; i++)
      size3 += this.children[i].size;
    return size3;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset3, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset3 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset3];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset3 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset3 == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset3 == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset3, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset3, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset3 = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset3 + child.size;
      if (offset3 == pos && end != offset3) {
        while (!child.border && child.children.length) {
          for (let i2 = 0; i2 < child.children.length; i2++) {
            let inner = child.children[i2];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end)
        return child.descAt(pos - offset3 - child.border);
      offset3 = end;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset3 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end = curPos + child.size;
      if (end > pos || child instanceof TrailingHackViewDesc) {
        offset3 = pos - curPos;
        break;
      }
      curPos = end;
    }
    if (offset3)
      return this.children[i].domFromPos(offset3 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset3 = base2, i = 0; ; i++) {
      let child = this.children[i], end = offset3 + child.size;
      if (fromOffset == -1 && from2 <= end) {
        let childBase = offset3 + child.border;
        if (from2 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset3;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
        to = end;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset3 = end;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset3 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset3 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset3];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset3 = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset3 + child.size;
      if (from2 > offset3 && to < end)
        return child.setSelection(anchor - offset3 - child.border, head - offset3 - child.border, view, force);
      offset3 = end;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset3 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset3 && node.nodeValue[offset3 - 1] == "\n");
        if (brKludge && offset3 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset3 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset3 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset3 + child.size;
      if (offset3 == end ? from2 <= end && to >= offset3 : from2 < end && to > offset3) {
        let startInside = offset3 + child.border, endInside = end - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset3 || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset3 = end;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  get ignoreForSelection() {
    return false;
  }
  isText(text) {
    return false;
  }
};
var WidgetViewDesc = class extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self)
          return pos;
        if (self.parent)
          return self.parent.posBeforeChild(self);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
};
var CompositionViewDesc = class extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset3) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset3 ? this.size : 0);
    return this.posAtStart + offset3;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
};
var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline3, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline3);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline3), null, mark.attrs);
    return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size3 = this.size;
    if (to < size3)
      nodes = replaceNodes(nodes, to, size3, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
};
var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline3 = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline3, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline3, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline3, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline3, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
};
function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc3);
  let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset3, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset3, this.node.text.length);
    return super.localPosFromDOM(dom, offset3, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
};
var TrailingHackViewDesc = class extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
};
var CustomNodeViewDesc = class extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
};
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
var OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top.class = (top.class ? top.class + " " : "") + val;
      else if (name == "style")
        top.style = (top.style ? top.style + ";" : "") + val;
      else if (name != "nodeName")
        top[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
var ViewTreeUpdater = class {
  constructor(top, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start, end) {
    if (start == end)
      return;
    for (let i = start; i < end; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start, end - start);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline3, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline3, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index) {
    let found2 = -1, targetDesc;
    if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index, view) {
    let child = this.top.children[index];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
};
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node = desc.node;
    if (!node)
      continue;
    if (node != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches2.push(desc);
  }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset3 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset3, child), i);
      offset3 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset3) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index;
    if (restNode) {
      index = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset3)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset3 && locals[decoIndex].to > offset3)
      active.push(locals[decoIndex++]);
    let end = offset3 + child.nodeSize;
    if (child.isText) {
      let cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end) {
        restNode = child.cut(cutAt - offset3);
        child = child.cut(0, cutAt - offset3);
        end = cutAt;
        index = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset3, child), index);
    offset3 = end;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start = off, end = off += child.size;
    if (start >= to || end <= from2) {
      result.push(child);
    } else {
      if (start < from2)
        result.push(child.slice(0, from2 - start, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end > to)
        result.push(child.slice(to - start, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc3 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc3.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min2 = head, max2 = head;
      for (let i = 0; i < domSel.rangeCount; i++) {
        let range = domSel.getRangeAt(i);
        min2 = Math.min(min2, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max2 = Math.max(max2, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min2 < 0)
        return null;
      [anchor, head] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
      $head = doc3.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc3.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset3 } = view.docView.domFromPos(pos, 0);
  let after = offset3 < node.childNodes.length ? node.childNodes[offset3] : null;
  let before = offset3 ? node.childNodes[offset3 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc3 = view.dom.ownerDocument;
  doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset3 = domSel.anchorOffset;
  doc3.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset3) {
      doc3.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setStart(node.parentNode, domIndex(node) + 1);
  else
    range.setStart(node, 0);
  range.collapse(true);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset3 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset3 < nodeLen(node) && isIgnorable(node.childNodes[offset3], -1))
    force = true;
  for (; ; ) {
    if (offset3 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset3 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset3;
        } else if (before.nodeType == 3) {
          node = before;
          offset3 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset3 = 0;
      } else {
        node = prev;
        offset3 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset3);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset3 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset3 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset3];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset3;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset3 = len = 0;
      } else {
        node = next;
        offset3 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset3) {
  while (node && offset3 == node.childNodes.length && !hasBlockDesc(node)) {
    offset3 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset3 < node.childNodes.length) {
    let next = node.childNodes[offset3];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset3 = 0;
  }
}
function textNodeBefore(node, offset3) {
  while (node && !offset3 && !hasBlockDesc(node)) {
    offset3 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset3) {
    let next = node.childNodes[offset3 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset3 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset3) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset3)) {
      node = after;
      offset3 = 0;
    } else if (before = textNodeBefore(node, offset3)) {
      node = before;
      offset3 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset3);
    range.setStart(node, offset3);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset3);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr2 = view.state.tr;
    if (dir < 0)
      tr2.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr2.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr2);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc3 = detachedDoc(), wrap2 = doc3.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc3.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text, slice: slice2 };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text)
    return null;
  let asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode)
      return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap2, from2 = 0) {
  for (let i = wrap2.length - 1; i >= from2; i--)
    node = wrap2[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
var _policy = null;
function maybeWrapTrusted(html) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html;
  if (!_policy)
    _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
  return _policy.createHTML(html);
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html);
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
var handlers = {};
var editHandlers = {};
var passiveHandlers = { touchstart: true, touchmove: true };
var InputState = class {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
};
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    let deflt = () => view.state.tr.insertText(text).scrollIntoView();
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))
      view.dispatch(deflt());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr2 = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr2.setMeta("pointer", true);
  view.dispatch(tr2);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc3 = view.state.doc;
  if (inside == -1) {
    if (doc3.inlineContent) {
      updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc3.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc3, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = class {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
};
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
var timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset3 = sel.focusOffset; node && node.nodeType == 1 && offset3 != 0; ) {
          let before = offset3 < 0 ? node.lastChild : node.childNodes[offset3 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset3 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view), cur = view.state.selection;
    if (sel && !sel.eq(cur))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr2 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr2.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
var Dragging = class {
  constructor(slice2, move, node) {
    this.slice = slice2;
    this.move = move;
    this.node = node;
  }
};
var dragCopyModifier = mac ? "altKey" : "ctrlKey";
function dragMoves(view, event) {
  let moves = view.someProp("dragCopies", (test) => !test(event));
  return moves != null ? moves : !event[dragCopyModifier];
}
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice2, dragMoves(view, event), node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && dragMoves(view, event));
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr2 = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr2);
    else
      tr2.deleteSelection();
  }
  let pos = tr2.mapping.map(insertPos);
  let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr2.doc;
  if (isNode2)
    tr2.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr2.replaceRange(pos, pos, slice2);
  if (tr2.doc.eq(beforeInsert))
    return;
  let $pos = tr2.doc.resolve(pos);
  if (isNode2 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr2.setSelection(new NodeSelection($pos));
  } else {
    let end = tr2.mapping.map(insertPos);
    tr2.mapping.maps[tr2.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
    tr2.setSelection(selectionBetween(view, $pos, tr2.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr2.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
var WidgetType = class _WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset3, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset3, pos - offset3, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
};
var InlineType = class _InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset3, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset3;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset3;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof _InlineType;
  }
  destroy() {
  }
};
var NodeType2 = class _NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset3, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset3, to.pos - offset3, this);
  }
  valid(node, span) {
    let { index, offset: offset3 } = node.content.findIndex(span.from), child;
    return offset3 == span.from && !(child = node.child(index)).isText && offset3 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
};
var Decoration = class _Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new _Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset3 = 0) {
    return this.type.eq(other.type) && this.from + offset3 == other.from && this.to + offset3 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset3, oldOffset) {
    return this.type.map(mapping, this, offset3, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new _Decoration(from2, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
};
var none = [];
var noSpec = {};
var DecorationSet = class _DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc3, decorations) {
    return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start, end, predicate) {
    let result = [];
    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
    return result;
  }
  findInner(start, end, result, offset3, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset3, span.to + offset3));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end && this.children[i + 1] > start) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset3 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc3, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc3, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset3, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset3, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset3, oldOffset, options);
    else
      return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc3, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return _DecorationSet.create(doc3, decorations);
    return this.addInner(doc3, decorations, 0);
  }
  addInner(doc3, decorations, offset3) {
    let children, childIndex = 0;
    doc3.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset3, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset3);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc3, local[i]))
        local.splice(i--, 1);
    return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset3) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from2 = children[i] + offset3, to = children[i + 1] + offset3;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset3)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new _DecorationSet(local, children) : empty;
  }
  forChild(offset3, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return _DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset3) {
        if (this.children[i] == offset3)
          child = this.children[i + 2];
        break;
      }
    let start = offset3 + 1, end = start + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
        let from2 = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new _DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
  forEachSet(f) {
    f(this);
  }
};
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;
var DecorationGroup = class _DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc3) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));
    return _DecorationGroup.from(mappedDecos);
  }
  forChild(offset3, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset3, child);
      if (result == empty)
        continue;
      if (result instanceof _DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return _DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
  forEachSet(f) {
    for (let i = 0; i < this.members.length; i++)
      this.members[i].forEachSet(f);
  }
};
function mapChildren(oldChildren, newLocal, mapping, node, offset3, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end = children[i2 + 1];
        if (end < 0 || oldStart > end + baseOffset - moved)
          continue;
        let start = children[i2] + baseOffset - moved;
        if (oldEnd >= start) {
          children[i2 + 1] = oldStart <= start ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset3;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset3;
      let { index, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset3, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j < children.length && children[j] < from2)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset3) {
  if (!offset3 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset3, span.to + offset3, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset3, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset3, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset3) {
  if (node.isLeaf)
    return null;
  let end = offset3 + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset3 && span.to < end) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result.push(array[i]);
  return result;
}
function buildTree(spans, node, offset3, options) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset3);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset3 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset3).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;
var SelectionState = class {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
};
var DOMObserver = class {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let [a, b] = brs;
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++) {
        let node = mut.addedNodes[i];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
};
var cssChecked = /* @__PURE__ */ new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found2;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
    let desc = view.docView.nearestDesc(p, true);
    if (desc && desc.node.isBlock)
      return p;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc3 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc3, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr2 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr2.setMeta("pointer", true);
      else if (origin == "key")
        tr2.scrollIntoView();
      if (compositionID)
        tr2.setMeta("composition", compositionID);
      view.dispatch(tr2);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from2, to);
  let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr2 = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr2.setMeta("composition", compositionID);
          view.dispatch(tr2);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc3.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && !/\S/.test(parse.doc.textBetween($from.pos, $to.pos, "", "")) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head > $from.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let mkTr = (base2) => {
    let tr2 = base2 || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
    if (parse.sel) {
      let sel2 = resolveSelection(view, tr2.doc, parse.sel);
      if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr2.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
        tr2.setSelection(sel2);
    }
    if (compositionID)
      tr2.setMeta("composition", compositionID);
    return tr2.scrollIntoView();
  };
  let markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      let tr2 = mkTr(view.state.tr.delete(chFrom, chTo));
      let marks = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));
      if (marks)
        tr2.ensureMarks(marks);
      view.dispatch(tr2);
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      let tr2 = mkTr(view.state.tr);
      if (markChange.type == "add")
        tr2.addMark(chFrom, chTo, markChange.mark);
      else
        tr2.removeMark(chFrom, chTo, markChange.mark);
      view.dispatch(tr2);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));
      if (!view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text, deflt)))
        view.dispatch(deflt());
    }
  } else {
    view.dispatch(mkTr());
  }
}
function resolveSelection(view, doc3, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)
    return null;
  return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end == start + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start = a.findDiffStart(b, pos);
  if (start == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move;
    if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endA = start + (endA - endB);
    endB = start;
  }
  return { start, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
var EditorView = class {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
    else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset3, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset3, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(slice2) {
    return serializeForClipboard(this, slice2);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
};
EditorView.prototype.dispatch = function(tr2) {
  let dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction)
    dispatchTransaction.call(this, tr2);
  else
    this.updateState(this.state.apply(tr2));
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}

// node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++) base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
var code;
function keyName(event) {
  var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}

// node_modules/prosemirror-keymap/dist/index.js
var mac3 = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
var windows2 = typeof navigator != "undefined" && /Win/.test(navigator.platform);
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift4, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift4 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac3)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift4)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName(prop)] = map2[prop];
  return copy2;
}
function modifiers(name, event, shift4 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift4 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(windows2 && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}

// node_modules/prosemirror-commands/dist/index.js
var deleteSelection = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
var joinBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr2 = state.tr.step(delStep);
          tr2.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr2.doc, $cut.pos - before.nodeSize));
          dispatch(tr2.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
var joinTextblockBackward = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
var joinTextblockForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
function joinTextblocksAround(state, $cut, dispatch) {
  let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch) {
    let tr2 = state.tr.step(step);
    tr2.setSelection(TextSelection.create(tr2.doc, beforePos));
    dispatch(tr2.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
var selectNodeBackward = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
var joinForward = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr2 = state.tr.step(delStep);
        tr2.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr2.doc.resolve(tr2.mapping.map($cut.pos)), 1) : NodeSelection.create(tr2.doc, tr2.mapping.map($cut.pos)));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
var selectNodeForward = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
var joinUp = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr2 = state.tr.join(point);
    if (nodeSel)
      tr2.setSelection(NodeSelection.create(tr2.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var joinDown = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
var lift2 = (state, dispatch) => {
  let { $from, $to } = state.selection;
  let range = $from.blockRange($to), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
var newlineInCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
var exitCode = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr2 = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr2.setSelection(Selection.near(tr2.doc.resolve(pos), 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var createParagraphNear = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr2 = state.tr.insert(side, type.createAndFill());
    tr2.setSelection(TextSelection.create(tr2.doc, side + 1));
    dispatch(tr2.scrollIntoView());
  }
  return true;
};
var liftEmptyBlock = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d = $from.depth; ; d--) {
      let node = $from.node(d);
      if (node.isBlock) {
        atEnd = $from.end(d) == $from.pos + ($from.depth - d);
        atStart = $from.start(d) == $from.pos - ($from.depth - d);
        deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
        let splitType = splitNode && splitNode($to.parent, atEnd, $from);
        types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));
        splitDepth = d;
        break;
      } else {
        if (d == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr2 = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
      tr2.deleteSelection();
    let splitPos = tr2.mapping.map($from.pos);
    let can = canSplit(tr2.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr2.doc, splitPos, types.length, types);
    }
    if (!can)
      return false;
    tr2.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first2 = tr2.mapping.map($from.before(splitDepth)), $first = tr2.doc.resolve(first2);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr2.setNodeMarkup(tr2.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch)
      dispatch(tr2.scrollIntoView());
    return true;
  };
}
var splitBlock = splitBlockAs();
var selectParentNode = (state, dispatch) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
var selectAll = (state, dispatch) => {
  if (dispatch)
    dispatch(state.tr.setSelection(new AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap2 = Fragment.from(conn[i].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
      let $joinAt = tr2.doc.resolve(end + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr2.doc, $joinAt.pos))
        tr2.join($joinAt.pos);
      dispatch(tr2.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end = Fragment.empty;
        for (let i = wrap2.length - 1; i >= 0; i--)
          end = Fragment.from(wrap2[i].copy(end));
        let tr2 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
        dispatch(tr2.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);
function wrapIn(nodeType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType2(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index = $pos.index();
          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr2 = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        tr2.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch(tr2.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands) {
  return function(state, dispatch, view) {
    for (let i = 0; i < commands.length; i++)
      if (commands[i](state, dispatch, view))
        return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (let key in pcBaseKeymap)
  macBaseKeymap[key] = pcBaseKeymap[key];
var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;

// node_modules/prosemirror-schema-list/dist/index.js
function wrapInList(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to);
    if (!range)
      return false;
    let tr2 = dispatch ? state.tr : null;
    if (!wrapRangeInList(tr2, range, listType, attrs))
      return false;
    if (dispatch)
      dispatch(tr2.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr2, range, listType, attrs = null) {
  let doJoin = false, outerRange = range, doc3 = range.$from.doc;
  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
    if (range.$from.index(range.depth - 1) == 0)
      return false;
    let $insert = doc3.resolve(range.start - 2);
    outerRange = new NodeRange($insert, $insert, range.depth);
    if (range.endIndex < range.parent.childCount)
      range = new NodeRange(range.$from, doc3.resolve(range.$to.end(range.depth)), range.depth);
    doJoin = true;
  }
  let wrap2 = findWrapping(outerRange, listType, attrs, range);
  if (!wrap2)
    return false;
  if (tr2)
    doWrapInList(tr2, range, wrap2, doJoin, listType);
  return true;
}
function doWrapInList(tr2, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr2.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr2.doc, splitPos, splitDepth)) {
      tr2.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr2;
}
function liftListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr2 = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    tr2.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr2.doc.resolve(range.$from.pos), tr2.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr2.lift(range, target);
  let $after = tr2.doc.resolve(tr2.mapping.map(end, -1) - 1);
  if (canJoin(tr2.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr2.join($after.pos);
  dispatch(tr2.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr2 = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr2.delete(pos - 1, pos + 1);
  }
  let $start = tr2.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr2.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr2.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr2.scrollIntoView());
  return true;
}
function sinkListItem(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}

// node_modules/@tiptap/core/dist/index.js
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc3 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc3;
    },
    get tr() {
      selection = transaction.selection;
      doc3 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
var CommandManager = class {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr: tr2 } = state;
    const props = this.buildProps(tr2);
    return Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args) => {
          const callback = command2(...args)(props);
          if (!tr2.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr2);
          }
          return callback;
        };
        return [name, method];
      })
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr2 = startTr || state.tr;
    const run32 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr2.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr2);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(
        Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args) => {
            const props = this.buildProps(tr2, shouldDispatch);
            const callback = command2(...args)(props);
            callbacks.push(callback);
            return chain;
          };
          return [name, chainedCommand];
        })
      ),
      run: run32
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr2 = startTr || state.tr;
    const props = this.buildProps(tr2, dispatch);
    const formattedCommands = Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
      })
    );
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr2, dispatch)
    };
  }
  buildProps(tr2, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props = {
      tr: tr2,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr2
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr2, shouldDispatch),
      can: () => this.createCan(tr2),
      get commands() {
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          })
        );
      }
    };
    return props;
  }
};
var EventEmitter = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  once(event, fn) {
    const onceFn = (...args) => {
      this.off(event, onceFn);
      fn.apply(this, args);
    };
    return this.on(event, onceFn);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
var removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  if (typeof window === "undefined") {
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  }
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options) {
  if (content instanceof Node2 || content instanceof Fragment) {
    return content;
  }
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
      } else {
        DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${invalidContent}`)
        });
      }
    }
    const parser = DOMParser.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(elementFromString(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function createDocument(content, schema, parseOptions = {}, options = {}) {
  return createNodeFromContent(content, schema, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options.errorOnInvalidContent
  });
}
function defaultBlockAt2(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildrenInRange(node, range, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range.from, range.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function flattenExtensions(extensions) {
  return extensions.map((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addExtensions = getExtensionField(extension, "addExtensions", context);
    if (addExtensions) {
      return [extension, ...flattenExtensions(addExtensions())];
    }
    return extension;
  }).flat(10);
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    validate: void 0,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField(
      extension,
      "addGlobalAttributes",
      context
    );
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(
      extension,
      "addAttributes",
      context
    );
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const styleMap = /* @__PURE__ */ new Map();
        existingStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        newStyles.forEach((style2) => {
          const [property, val] = style2.split(":").map((part) => part.trim());
          styleMap.set(property, val);
        });
        mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) == null ? void 0 : _a.name;
  const nodes = Object.fromEntries(
    nodeExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraNodeFields = extensions.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraNodeFields,
        content: callOrReturn(getExtensionField(extension, "content", context)),
        marks: callOrReturn(getExtensionField(extension, "marks", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        inline: callOrReturn(getExtensionField(extension, "inline", context)),
        atom: callOrReturn(getExtensionField(extension, "atom", context)),
        selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
        draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        whitespace: callOrReturn(getExtensionField(extension, "whitespace", context)),
        linebreakReplacement: callOrReturn(
          getExtensionField(extension, "linebreakReplacement", context)
        ),
        defining: callOrReturn(getExtensionField(extension, "defining", context)),
        isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
        attrs: Object.fromEntries(
          extensionAttributes.map((extensionAttribute) => {
            var _a2, _b;
            return [
              extensionAttribute.name,
              { default: (_a2 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a2.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }
            ];
          })
        )
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node) => renderHTML({
          node,
          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
        });
      }
      const renderText = getExtensionField(extension, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension.name, schema];
    })
  );
  const marks = Object.fromEntries(
    markExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraMarkFields = extensions.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraMarkFields,
        inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
        excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
        group: callOrReturn(getExtensionField(extension, "group", context)),
        spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
        code: callOrReturn(getExtensionField(extension, "code", context)),
        attrs: Object.fromEntries(
          extensionAttributes.map((extensionAttribute) => {
            var _a2, _b;
            return [
              extensionAttribute.name,
              { default: (_a2 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a2.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }
            ];
          })
        )
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark) => renderHTML({
          mark,
          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
        });
      }
      return [extension.name, schema];
    })
  );
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function findDuplicates(items) {
  const filtered = items.filter((el, index) => items.indexOf(el) !== index);
  return Array.from(new Set(filtered));
}
function sortExtensions(extensions) {
  const defaultPriority = 100;
  return extensions.sort((a, b) => {
    const priorityA = getExtensionField(a, "priority") || defaultPriority;
    const priorityB = getExtensionField(b, "priority") || defaultPriority;
    if (priorityA > priorityB) {
      return -1;
    }
    if (priorityA < priorityB) {
      return 1;
    }
    return 0;
  });
}
function resolveExtensions(extensions) {
  const resolvedExtensions = sortExtensions(flattenExtensions(extensions));
  const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
  if (duplicatedNames.length) {
    console.warn(
      `[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`
    );
  }
  return resolvedExtensions;
}
function getTextBetween(startNode, range, options) {
  const { from: from2, to } = range;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text = "";
  startNode.nodesBetween(from2, to, (node, pos, parent, index) => {
    var _a;
    if (node.isBlock && pos > from2) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers == null ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index,
          range
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a = node == null ? void 0 : node.text) == null ? void 0 : _a.slice(Math.max(from2, pos) - pos, to - pos);
    }
  });
  return text;
}
function getText2(node, options) {
  const range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options);
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(
    Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText])
  );
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from2, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from2, to, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from2, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from2, to, (node2) => {
    nodes.push(node2);
  });
  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array, by = JSON.stringify) {
  const seen = {};
  return array.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {
    const rest = uniqueChanges.filter((_, i) => i !== index);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from2, to } = steps[index];
      if (from2 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from2, to });
    } else {
      stepMap.forEach((from2, to) => {
        ranges.push({ from: from2, to });
      });
    }
    ranges.forEach(({ from: from2, to }) => {
      const newStart = mapping.slice(index).map(from2, -1);
      const newEnd = mapping.slice(index).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
      attributes
    );
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  var _a;
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a = start.node.marks[0]) == null ? void 0 : _a.attrs);
  const mark = findMarkInSet([...start.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarksBetween(from2, to, doc3) {
  const marks = [];
  if (from2 === to) {
    doc3.resolve(from2).marks().forEach((mark) => {
      const $pos = doc3.resolve(from2);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc3.nodesBetween(from2, to, (node, pos) => {
      if (!node || (node == null ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(
        ...node.marks.map((mark) => ({
          from: pos,
          to: pos + node.nodeSize,
          mark
        }))
      );
    });
  }
  return marks;
}
var getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {
  const $pos = state.doc.resolve(pos);
  let currentDepth = maxDepth;
  let node = null;
  while (currentDepth > 0 && node === null) {
    const currentNode = $pos.node(currentDepth);
    if ((currentNode == null ? void 0 : currentNode.type.name) === typeOrName) {
      node = currentNode;
    } else {
      currentDepth -= 1;
    }
  }
  return [node, currentDepth];
};
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(
    Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    })
  );
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
    var _a, _b;
    const chunk = ((_b = (_a = node.type.spec).toText) == null ? void 0 : _b.call(_a, {
      node,
      pos,
      parent,
      index
    })) || node.textContent || "%leaf%";
    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(
        ...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        }))
      );
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from2, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
var isAtEndOfNode = (state, nodeType) => {
  const { $from, $to, $anchor } = state.selection;
  if (nodeType) {
    const parentNode2 = findParentNode((node) => node.type.name === nodeType)(state.selection);
    if (!parentNode2) {
      return false;
    }
    const $parentPos = state.doc.resolve(parentNode2.pos + 1);
    if ($anchor.pos + 1 === $parentPos.end()) {
      return true;
    }
    return false;
  }
  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {
    return false;
  }
  return true;
};
var isAtStartOfNode = (state) => {
  const { $from, $to } = state.selection;
  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {
    return false;
  }
  return true;
};
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node, {
  checkChildren = true,
  ignoreWhitespace = false
} = {}) {
  var _a;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a = node.text) != null ? _a : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function posToDOMRect(view, from2, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from2, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start = view.coordsAtPos(resolvedFrom);
  const end = view.coordsAtPos(resolvedEnd, -1);
  const top = Math.min(start.top, end.top);
  const bottom = Math.max(start.bottom, end.bottom);
  const left = Math.min(start.left, end.left);
  const right = Math.max(start.right, end.right);
  const width = right - left;
  const height = bottom - top;
  const x = left;
  const y = top;
  const data = {
    top,
    bottom,
    left,
    right,
    width,
    height,
    x,
    y
  };
  return {
    ...data,
    toJSON: () => data
  };
}
function resolveFocusPosition(doc3, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc3);
  const selectionAtEnd = Selection.atEnd(doc3);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc3, minMax(0, minPos, maxPos), minMax(doc3.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc3, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function selectionToInsertionEnd2(tr2, startLen, bias) {
  const last = tr2.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr2.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr2.mapping.maps[last];
  let end = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr2.setSelection(Selection.near(tr2.doc.resolve(end), bias));
}
var InputRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var inputRuleMatcherHandler = (text, find2) => {
  if (isRegExp(find2)) {
    return find2.exec(text);
  }
  const inputRuleMatch = find2(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run(config) {
  var _a;
  const { editor, from: from2, to, text, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if (
    // check for code node
    $from.parent.type.spec.code || // check for code mark
    !!((_a = $from.nodeBefore || $from.nodeAfter) == null ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr2 = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr2
    });
    const range = {
      from: from2 - (match[0].length - text.length),
      to
    };
    const { commands, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range,
      match,
      commands,
      chain,
      can
    });
    if (handler === null || !tr2.steps.length) {
      return;
    }
    tr2.setMeta(plugin, {
      transform: tr2,
      from: from2,
      to,
      text
    });
    view.dispatch(tr2);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr2, prev, state) {
        const stored = tr2.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr2.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text === "string") {
              text = text;
            } else {
              text = getHTMLFromFragment(Fragment.from(text), state.schema);
            }
            const { from: from2 } = simulatedInputMeta;
            const to = from2 + text.length;
            run({
              editor,
              from: from2,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr2.selectionSet || tr2.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text) {
        return run({
          editor,
          from: from2,
          to,
          text,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key]) && isPlainObject(target[key])) {
        output[key] = mergeDeep(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var Extendable = class {
  constructor(config = {}) {
    this.type = "extendable";
    this.parent = null;
    this.child = null;
    this.name = "";
    this.config = {
      name: this.name
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
  }
  get options() {
    return {
      ...callOrReturn(
        getExtensionField(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...callOrReturn(
        getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(options = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new this.constructor({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = "name" in extendedConfig ? extendedConfig.name : extension.parent.name;
    return extension;
  }
};
var Mark2 = class _Mark extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "mark";
  }
  static create(config = {}) {
    return new _Mark(config);
  }
  static handleExit({ editor, mark }) {
    const { tr: tr2 } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr2.removeStoredMark(removeMark2);
      }
      tr2.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr2);
      return true;
    }
    return false;
  }
  configure(options) {
    return super.configure(options);
  }
  extend(extendedConfig) {
    return super.extend(extendedConfig);
  }
};
function isNumber(value) {
  return typeof value === "number";
}
var PasteRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var pasteRuleMatcherHandler = (text, find2, event) => {
  if (isRegExp(find2)) {
    return [...text.matchAll(find2)];
  }
  const matches2 = find2(text, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run2(config) {
  const { editor, state, from: from2, to, rule, pasteEvent, dropEvent } = config;
  const { commands, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from2, to, (node, pos) => {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from2, pos);
    const resolvedTo = Math.min(to, pos + node.content.size);
    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start = resolvedFrom + match.index + 1;
      const end = start + match[0].length;
      const range = {
        from: state.tr.mapping.map(start),
        to: state.tr.mapping.map(end)
      };
      const handler = rule.handler({
        state,
        range,
        match,
        commands,
        chain,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
var tiptapDragFromOtherEditor = null;
var createClipboardPasteEvent = (text) => {
  var _a;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  (_a = event.clipboardData) == null ? void 0 : _a.setData("text/html", text);
  return event;
};
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent;
  try {
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  } catch {
    dropEvent = null;
  }
  const processEvent = ({
    state,
    from: from2,
    to,
    rule,
    pasteEvt
  }) => {
    const tr2 = state.tr;
    const chainableState = createChainableState({
      state,
      transaction: tr2
    });
    const handler = run2({
      editor,
      state: chainableState,
      from: Math.max(from2 - 1, 0),
      to: to.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr2.steps.length) {
      return;
    }
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch {
      dropEvent = null;
    }
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr2;
  };
  const plugins = rules.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) == null ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
          if (dragSourceElement) {
            tiptapDragFromOtherEditor = editor;
          }
        };
        const handleDragend = () => {
          if (tiptapDragFromOtherEditor) {
            tiptapDragFromOtherEditor = null;
          }
        };
        window.addEventListener("dragstart", handleDragstart);
        window.addEventListener("dragend", handleDragend);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
            window.removeEventListener("dragend", handleDragend);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            if (!isDroppedFromProseMirror) {
              const dragFromOtherEditor = tiptapDragFromOtherEditor;
              if (dragFromOtherEditor) {
                setTimeout(() => {
                  const selection = dragFromOtherEditor.state.selection;
                  if (selection) {
                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                  }
                }, 10);
              }
            }
            return false;
          },
          paste: (_view, event) => {
            var _a;
            const html = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html == null ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          let { text } = simulatedPasteMeta;
          if (typeof text === "string") {
            text = text;
          } else {
            text = getHTMLFromFragment(Fragment.from(text), state.schema);
          }
          const { from: from22 } = simulatedPasteMeta;
          const to2 = from22 + text.length;
          const pasteEvt = createClipboardPasteEvent(text);
          return processEvent({
            rule,
            state,
            from: from22,
            to: { b: to2 },
            pasteEvt
          });
        }
        const from2 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from2) || !to || from2 === to.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from: from2,
          to,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
var ExtensionManager = class {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = resolveExtensions(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((commands, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands;
      }
      return {
        ...commands,
        ...addCommands()
      };
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor } = this;
    const extensions = sortExtensions([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(
        extension,
        "addKeyboardShortcuts",
        context
      );
      let defaultBindings = {};
      if (extension.type === "mark" && getExtensionField(extension, "exitable", context)) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(
          Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
            return [shortcut, () => method({ editor })];
          })
        );
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(
        extension,
        "addProseMirrorPlugins",
        context
      );
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(
      nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: this.editor.extensionStorage[extension.name],
          editor,
          type: getNodeType(extension.name, this.schema)
        };
        const addNodeView = getExtensionField(extension, "addNodeView", context);
        if (!addNodeView) {
          return [];
        }
        const nodeview = (node, view, getPos, decorations, innerDecorations) => {
          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
          return addNodeView()({
            // pass-through
            node,
            view,
            getPos,
            decorations,
            innerDecorations,
            // tiptap-specific
            editor,
            extension,
            HTMLAttributes
          });
        };
        return [extension.name, nodeview];
      })
    );
  }
  get markViews() {
    const { editor } = this;
    const { markExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(
      markExtensions.filter((extension) => !!getExtensionField(extension, "addMarkView")).map((extension) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
        const context = {
          name: extension.name,
          options: extension.options,
          storage: this.editor.extensionStorage[extension.name],
          editor,
          type: getMarkType(extension.name, this.schema)
        };
        const addMarkView = getExtensionField(extension, "addMarkView", context);
        if (!addMarkView) {
          return [];
        }
        const markView = (mark, view, inline3) => {
          const HTMLAttributes = getRenderedAttributes(mark, extensionAttributes);
          return addMarkView()({
            // pass-through
            mark,
            view,
            inline: inline3,
            // tiptap-specific
            editor,
            extension,
            HTMLAttributes
          });
        };
        return [extension.name, markView];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const extensions = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      extensions.map((extension) => [extension.name, extension.storage])
    );
    extensions.forEach((extension) => {
      var _a;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) != null ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      const onCreate = getExtensionField(extension, "onCreate", context);
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      const onSelectionUpdate = getExtensionField(
        extension,
        "onSelectionUpdate",
        context
      );
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      const onFocus = getExtensionField(extension, "onFocus", context);
      const onBlur = getExtensionField(extension, "onBlur", context);
      const onDestroy = getExtensionField(extension, "onDestroy", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate) {
        this.editor.on("create", onCreate);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy) {
        this.editor.on("destroy", onDestroy);
      }
    });
  }
};
ExtensionManager.resolve = resolveExtensions;
ExtensionManager.sort = sortExtensions;
ExtensionManager.flatten = flattenExtensions;
var extensions_exports = {};
__export(extensions_exports, {
  ClipboardTextSerializer: () => ClipboardTextSerializer,
  Commands: () => Commands,
  Delete: () => Delete,
  Drop: () => Drop,
  Editable: () => Editable,
  FocusEvents: () => FocusEvents,
  Keymap: () => Keymap,
  Paste: () => Paste,
  Tabindex: () => Tabindex,
  focusEventsPluginKey: () => focusEventsPluginKey
});
var Extension = class _Extension extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "extension";
  }
  static create(config = {}) {
    return new _Extension(config);
  }
  configure(options) {
    return super.configure(options);
  }
  extend(extendedConfig) {
    return super.extend(extendedConfig);
  }
};
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc3, selection } = state;
            const { ranges } = selection;
            const from2 = Math.min(...ranges.map((range2) => range2.$from.pos));
            const to = Math.max(...ranges.map((range2) => range2.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range = { from: from2, to };
            return getTextBetween(doc3, range, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var commands_exports = {};
__export(commands_exports, {
  blur: () => blur,
  clearContent: () => clearContent,
  clearNodes: () => clearNodes,
  command: () => command,
  createParagraphNear: () => createParagraphNear2,
  cut: () => cut,
  deleteCurrentNode: () => deleteCurrentNode,
  deleteNode: () => deleteNode,
  deleteRange: () => deleteRange2,
  deleteSelection: () => deleteSelection2,
  enter: () => enter,
  exitCode: () => exitCode2,
  extendMarkRange: () => extendMarkRange,
  first: () => first,
  focus: () => focus,
  forEach: () => forEach,
  insertContent: () => insertContent,
  insertContentAt: () => insertContentAt,
  joinBackward: () => joinBackward2,
  joinDown: () => joinDown2,
  joinForward: () => joinForward2,
  joinItemBackward: () => joinItemBackward,
  joinItemForward: () => joinItemForward,
  joinTextblockBackward: () => joinTextblockBackward2,
  joinTextblockForward: () => joinTextblockForward2,
  joinUp: () => joinUp2,
  keyboardShortcut: () => keyboardShortcut,
  lift: () => lift3,
  liftEmptyBlock: () => liftEmptyBlock2,
  liftListItem: () => liftListItem2,
  newlineInCode: () => newlineInCode2,
  resetAttributes: () => resetAttributes,
  scrollIntoView: () => scrollIntoView,
  selectAll: () => selectAll2,
  selectNodeBackward: () => selectNodeBackward2,
  selectNodeForward: () => selectNodeForward2,
  selectParentNode: () => selectParentNode2,
  selectTextblockEnd: () => selectTextblockEnd2,
  selectTextblockStart: () => selectTextblockStart2,
  setContent: () => setContent,
  setMark: () => setMark,
  setMeta: () => setMeta,
  setNode: () => setNode,
  setNodeSelection: () => setNodeSelection,
  setTextSelection: () => setTextSelection,
  sinkListItem: () => sinkListItem2,
  splitBlock: () => splitBlock2,
  splitListItem: () => splitListItem,
  toggleList: () => toggleList,
  toggleMark: () => toggleMark,
  toggleNode: () => toggleNode,
  toggleWrap: () => toggleWrap,
  undoInputRule: () => undoInputRule,
  unsetAllMarks: () => unsetAllMarks,
  unsetMark: () => unsetMark,
  updateAttributes: () => updateAttributes,
  wrapIn: () => wrapIn2,
  wrapInList: () => wrapInList2
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      ;
      view.dom.blur();
      (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = true) => ({ commands }) => {
  return commands.setContent("", { emitUpdate });
};
var clearNodes = () => ({ state, tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc3, mapping } = tr2;
      const $mappedFrom = doc3.resolve(mapping.map(pos));
      const $mappedTo = doc3.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr2.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr2.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn) => (props) => {
  return fn(props);
};
var createParagraphNear2 = () => ({ state, dispatch }) => {
  return createParagraphNear(state, dispatch);
};
var cut = (originRange, targetPos) => ({ editor, tr: tr2 }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr2.deleteRange(originRange.from, originRange.to);
  const newPos = tr2.mapping.map(targetPos);
  tr2.insert(newPos, contentSlice.content);
  tr2.setSelection(new TextSelection(tr2.doc.resolve(newPos - 1)));
  return true;
};
var deleteCurrentNode = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode = (typeOrName) => ({ tr: tr2, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr2.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch) {
        const from2 = $pos.before(depth);
        const to = $pos.after(depth);
        tr2.delete(from2, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange2 = (range) => ({ tr: tr2, dispatch }) => {
  const { from: from2, to } = range;
  if (dispatch) {
    tr2.delete(from2, to);
  }
  return true;
};
var deleteSelection2 = () => ({ state, dispatch }) => {
  return deleteSelection(state, dispatch);
};
var enter = () => ({ commands }) => {
  return commands.keyboardShortcut("Enter");
};
var exitCode2 = () => ({ state, dispatch }) => {
  return exitCode(state, dispatch);
};
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc3, selection } = tr2;
  const { $from, from: from2, to } = selection;
  if (dispatch) {
    const range = getMarkRange($from, type, attributes);
    if (range && range.from <= from2 && range.to >= to) {
      const newSelection = TextSelection.create(doc3, range.from, range.to);
      tr2.setSelection(newSelection);
    }
  }
  return true;
};
var first = (commands) => (props) => {
  const items = typeof commands === "function" ? commands(props) : commands;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) {
      return true;
    }
  }
  return false;
};
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus = (position = null, options = {}) => ({ editor, view, tr: tr2, dispatch }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS() || isAndroid()) {
      ;
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options == null ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr2.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr2.setSelection(selection);
    }
    if (isSameSelection && tr2.storedMarks) {
      tr2.setStoredMarks(tr2.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn) => (props) => {
  return items.every((item, index) => fn(item, { ...props, index }));
};
var insertContent = (value, options) => ({ tr: tr2, commands }) => {
  return commands.insertContentAt({ from: tr2.selection.from, to: tr2.selection.to }, value, options);
};
var isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
var insertContentAt = (position, value, options) => ({ tr: tr2, dispatch, editor }) => {
  var _a;
  if (dispatch) {
    options = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content;
    const { selection } = editor.state;
    const emitContentError = (error) => {
      editor.emit("contentError", {
        editor,
        error,
        disableCollaboration: () => {
          if ("collaboration" in editor.storage && typeof editor.storage.collaboration === "object" && editor.storage.collaboration) {
            ;
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
    };
    const parseOptions = {
      preserveWhitespace: "full",
      ...options.parseOptions
    };
    if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {
      try {
        createNodeFromContent(value, editor.schema, {
          parseOptions,
          errorOnInvalidContent: true
        });
      } catch (e) {
        emitContentError(e);
      }
    }
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions,
        errorOnInvalidContent: (_a = options.errorOnInvalidContent) != null ? _a : editor.options.enableContentCheck
      });
    } catch (e) {
      emitContentError(e);
      return false;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr2.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr2.insertText(newContent, from2, to);
    } else {
      newContent = content;
      const fromSelectionAtStart = selection.$from.parentOffset === 0;
      const isTextSelection2 = selection.$from.node().isText || selection.$from.node().isTextblock;
      if (fromSelectionAtStart && isTextSelection2) {
        from2 = Math.max(0, from2 - 1);
      }
      tr2.replaceWith(from2, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd2(tr2, tr2.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr2.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options.applyPasteRules) {
      tr2.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
var joinUp2 = () => ({ state, dispatch }) => {
  return joinUp(state, dispatch);
};
var joinDown2 = () => ({ state, dispatch }) => {
  return joinDown(state, dispatch);
};
var joinBackward2 = () => ({ state, dispatch }) => {
  return joinBackward(state, dispatch);
};
var joinForward2 = () => ({ state, dispatch }) => {
  return joinForward(state, dispatch);
};
var joinItemBackward = () => ({ state, dispatch, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch, tr: tr2 }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr2.join(point, 2);
    if (dispatch) {
      dispatch(tr2);
    }
    return true;
  } catch {
    return false;
  }
};
var joinTextblockBackward2 = () => ({ state, dispatch }) => {
  return joinTextblockBackward(state, dispatch);
};
var joinTextblockForward2 = () => ({ state, dispatch }) => {
  return joinTextblockForward(state, dispatch);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName2(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift4;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift4 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift4) {
    result = `Shift-${result}`;
  }
  return result;
}
var keyboardShortcut = (name) => ({ editor, view, tr: tr2, dispatch }) => {
  const keys2 = normalizeKeyName2(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr2.mapping);
    if (newStep && dispatch) {
      tr2.maybeStep(newStep);
    }
  });
  return true;
};
var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift2(state, dispatch);
};
var liftEmptyBlock2 = () => ({ state, dispatch }) => {
  return liftEmptyBlock(state, dispatch);
};
var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem(type)(state, dispatch);
};
var newlineInCode2 = () => ({ state, dispatch }) => {
  return newlineInCode(state, dispatch);
};
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr2.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView = () => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    tr2.scrollIntoView();
  }
  return true;
};
var selectAll2 = () => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const selection = new AllSelection(tr2.doc);
    tr2.setSelection(selection);
  }
  return true;
};
var selectNodeBackward2 = () => ({ state, dispatch }) => {
  return selectNodeBackward(state, dispatch);
};
var selectNodeForward2 = () => ({ state, dispatch }) => {
  return selectNodeForward(state, dispatch);
};
var selectParentNode2 = () => ({ state, dispatch }) => {
  return selectParentNode(state, dispatch);
};
var selectTextblockEnd2 = () => ({ state, dispatch }) => {
  return selectTextblockEnd(state, dispatch);
};
var selectTextblockStart2 = () => ({ state, dispatch }) => {
  return selectTextblockStart(state, dispatch);
};
var setContent = (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) => ({ editor, tr: tr2, dispatch, commands }) => {
  const { doc: doc3 } = tr2;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument(content, editor.schema, parseOptions, {
      errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
    });
    if (dispatch) {
      tr2.replaceWith(0, doc3.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch) {
    tr2.setMeta("preventUpdate", !emitUpdate);
  }
  return commands.insertContentAt({ from: 0, to: doc3.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
  });
};
function canSetMark(state, tr2, newMarkType) {
  var _a;
  const { selection } = tr2;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a = state.storedMarks) != null ? _a : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr2.addStoredMark(
        type.create({
          ...oldAttributes,
          ...attributes
        })
      );
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr2.addMark(
                  trimmedFrom,
                  trimmedTo,
                  type.create({
                    ...mark.attrs,
                    ...attributes
                  })
                );
              }
            });
          } else {
            tr2.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr2, type);
};
var setMeta = (key, value) => ({ tr: tr2 }) => {
  tr2.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands }) => {
    const canSetBlock = setBlockType2(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType2(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);
  }).run();
};
var setNodeSelection = (position) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr2;
    const from2 = minMax(position, 0, doc3.content.size);
    const selection = NodeSelection.create(doc3, from2);
    tr2.setSelection(selection);
  }
  return true;
};
var setTextSelection = (position) => ({ tr: tr2, dispatch }) => {
  if (dispatch) {
    const { doc: doc3 } = tr2;
    const { from: from2, to } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc3).from;
    const maxPos = TextSelection.atEnd(doc3).to;
    const resolvedFrom = minMax(from2, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc3, resolvedFrom, resolvedEnd);
    tr2.setSelection(selection);
  }
  return true;
};
var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem(type)(state, dispatch);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks == null ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr: tr2, state, dispatch, editor }) => {
  const { selection, doc: doc3 } = tr2;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc3, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr2.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr2.doc, tr2.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr2.deleteSelection();
      }
      tr2.split(tr2.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr2.mapping.map($from.before());
        const $first = tr2.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr2.setNodeMarkup(tr2.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr2.scrollIntoView();
  }
  return can;
};
var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr: tr2, state, dispatch, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = (
        // eslint-disable-next-line no-nested-ternary
        $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3
      );
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a = type.contentMatch.defaultType) == null ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start = $from.before($from.depth - (depthBefore - 1));
      tr2.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr2.doc.nodesBetween(start, tr2.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr2.setSelection(TextSelection.near(tr2.doc.resolve(sel)));
      }
      tr2.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr2.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr2.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr2.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const before = tr2.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr2.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && canJoin(tr2.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr2.join(list.pos);
  return true;
};
var joinListForwards = (tr2, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr2.selection);
  if (!list) {
    return true;
  }
  const after = tr2.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr2.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && canJoin(tr2.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr2.join(after);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr2, state, dispatch, chain, commands, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr2.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr2.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr2, listType)).command(() => joinListForwards(tr2, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands.setNode(toggleType, attributesToCopy);
  }
  return commands.setNode(type, { ...attributesToCopy, ...attributes });
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands.lift(type);
  }
  return commands.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr2 = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr2.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr2.doc.resolve(undoable.from).marks();
          tr2.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr2.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr: tr2, dispatch }) => {
  const { selection } = tr2;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options = {}) => ({ tr: tr2, state, dispatch }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr2;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) == null ? void 0 : _a.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr2.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr2.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr2.removeStoredMark(type);
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr2, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr2.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr2.selection.empty) {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
        });
      } else {
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (pos < from2 && nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from2);
            trimmedTo = Math.min(pos + node.nodeSize, to);
            lastPos = pos;
            lastNode = node;
          }
          if (pos >= from2 && pos <= to) {
            if (nodeType && nodeType === node.type) {
              tr2.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom2 = Math.max(pos, from2);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to);
                  tr2.addMark(
                    trimmedFrom2,
                    trimmedTo2,
                    markType.create({
                      ...mark.attrs,
                      ...attributes
                    })
                  );
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== void 0) {
          tr2.setNodeMarkup(lastPos, void 0, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr2.addMark(
                trimmedFrom,
                trimmedTo,
                markType.create({
                  ...mark.attrs,
                  ...attributes
                })
              );
            }
          });
        }
      }
    });
  }
  return true;
};
var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn(type, attributes)(state, dispatch);
};
var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList(type, attributes)(state, dispatch);
};
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands_exports
    };
  }
});
var Delete = Extension.create({
  name: "delete",
  onUpdate({ transaction, appendedTransactions }) {
    var _a, _b, _c;
    const callback = () => {
      var _a2, _b2, _c2, _d;
      if ((_d = (_c2 = (_b2 = (_a2 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a2.delete) == null ? void 0 : _b2.filterTransaction) == null ? void 0 : _c2.call(_b2, transaction)) != null ? _d : transaction.getMeta("y-sync$")) {
        return;
      }
      const nextTransaction = combineTransactionSteps(transaction.before, [transaction, ...appendedTransactions]);
      const changes = getChangedRanges(nextTransaction);
      changes.forEach((change) => {
        if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {
          nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from2) => {
            const to = from2 + node.nodeSize - 2;
            const isFullyWithinRange = change.oldRange.from <= from2 && to <= change.oldRange.to;
            this.editor.emit("delete", {
              type: "node",
              node,
              from: from2,
              to,
              newFrom: nextTransaction.mapping.map(from2),
              newTo: nextTransaction.mapping.map(to),
              deletedRange: change.oldRange,
              newRange: change.newRange,
              partial: !isFullyWithinRange,
              editor: this.editor,
              transaction,
              combinedTransform: nextTransaction
            });
          });
        }
      });
      const mapping = nextTransaction.mapping;
      nextTransaction.steps.forEach((step, index) => {
        var _a3, _b3;
        if (step instanceof RemoveMarkStep) {
          const newStart = mapping.slice(index).map(step.from, -1);
          const newEnd = mapping.slice(index).map(step.to);
          const oldStart = mapping.invert().map(newStart, -1);
          const oldEnd = mapping.invert().map(newEnd);
          const foundBeforeMark = (_a3 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a3.marks.some((mark) => mark.eq(step.mark));
          const foundAfterMark = (_b3 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b3.marks.some((mark) => mark.eq(step.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: step.mark,
            from: step.from,
            to: step.to,
            deletedRange: {
              from: oldStart,
              to: oldEnd
            },
            newRange: {
              from: newStart,
              to: newEnd
            },
            partial: Boolean(foundAfterMark || foundBeforeMark),
            editor: this.editor,
            transaction,
            combinedTransform: nextTransaction
          });
        }
      });
    };
    if ((_c = (_b = (_a = this.editor.options.coreExtensionOptions) == null ? void 0 : _a.delete) == null ? void 0 : _b.async) != null ? _c : true) {
      setTimeout(callback, 0);
    } else {
      callback();
    }
  }
});
var Drop = Extension.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_, e, slice2, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: slice2,
              moved
            });
          }
        }
      })
    ];
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var focusEventsPluginKey = new PluginKey("focusEvents");
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: focusEventsPluginKey,
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands.command(({ tr: tr2 }) => {
        const { selection, doc: doc3 } = tr2;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr2.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc3).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands.clearNodes();
      }),
      () => commands.deleteSelection(),
      () => commands.joinBackward(),
      () => commands.selectNodeBackward()
    ]);
    const handleDelete2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.deleteSelection(),
      () => commands.deleteCurrentNode(),
      () => commands.joinForward(),
      () => commands.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands }) => [
      () => commands.newlineInCode(),
      () => commands.createParagraphNear(),
      () => commands.liftEmptyBlock(),
      () => commands.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace2,
      "Mod-Backspace": handleBackspace2,
      "Shift-Backspace": handleBackspace2,
      Delete: handleDelete2,
      "Mod-Delete": handleDelete2,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace2,
      "Alt-Backspace": handleBackspace2,
      "Ctrl-d": handleDelete2,
      "Ctrl-Alt-Backspace": handleDelete2,
      "Alt-Delete": handleDelete2,
      "Alt-d": handleDelete2,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr22) => tr22.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from: from2, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from2 === allFrom && to === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty2 = isNodeEmpty(newState.doc);
          if (!isEmpty2) {
            return;
          }
          const tr2 = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr2
          });
          const { commands } = new CommandManager({
            editor: this.editor,
            state
          });
          commands.clearNodes();
          if (!tr2.steps.length) {
            return;
          }
          return tr2;
        }
      })
    ];
  }
});
var Paste = Extension.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e, slice2) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: slice2
            });
          }
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var NodePos = class _NodePos {
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a;
    return (_a = this.actualDepth) != null ? _a : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from2 = this.from;
    let to = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from2 = this.from + 1;
      to = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from2, to }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new _NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node, offset3) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const isNonTextAtom = node.isAtom && !node.isText;
      const targetPos = this.pos + offset3 + (isNonTextAtom ? 0 : 1);
      if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {
        return;
      }
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index = 0; index < attrKeys.length; index += 1) {
            const key = attrKeys[index];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes = [];
    if (!this.children || this.children.length === 0) {
      return nodes;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
        if (doesAllAttributesMatch) {
          nodes.push(childPos);
        }
      }
      if (firstItemOnly && nodes.length > 0) {
        return;
      }
      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes;
  }
  setAttribute(attributes) {
    const { tr: tr2 } = this.editor.state;
    tr2.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...attributes
    });
    this.editor.view.dispatch(tr2);
  }
};
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor = class extends EventEmitter {
  constructor(options = {}) {
    super();
    this.css = null;
    this.editorView = null;
    this.isFocused = false;
    this.isInitialized = false;
    this.extensionStorage = {};
    this.instanceId = Math.random().toString(36).slice(2, 9);
    this.options = {
      element: typeof document !== "undefined" ? document.createElement("div") : null,
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      emitContentError: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("contentError", this.options.onContentError);
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("drop", ({ event, slice: slice2, moved }) => this.options.onDrop(event, slice2, moved));
    this.on("paste", ({ event, slice: slice2 }) => this.options.onPaste(event, slice2));
    this.on("delete", this.options.onDelete);
    const initialDoc = this.createDoc();
    const selection = resolveFocusPosition(initialDoc, this.options.autofocus);
    this.editorState = EditorState.create({
      doc: initialDoc,
      schema: this.schema,
      selection: selection || void 0
    });
    if (this.options.element) {
      this.mount(this.options.element);
    }
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(el) {
    if (typeof document === "undefined") {
      throw new Error(
        `[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.`
      );
    }
    this.createView(el);
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
      this.isInitialized = true;
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    var _a;
    if (this.editorView) {
      const dom = this.editorView.dom;
      if (dom == null ? void 0 : dom.editor) {
        delete dom.editor;
      }
      this.editorView.destroy();
    }
    this.editorView = null;
    this.isInitialized = false;
    (_a = this.css) == null ? void 0 : _a.remove();
    this.css = null;
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && typeof document !== "undefined") {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.editorView || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    if (this.editorView) {
      return this.editorView;
    }
    return new Proxy(
      {
        state: this.editorState,
        updateState: (state) => {
          this.editorState = state;
        },
        dispatch: (tr2) => {
          this.editorState = this.state.apply(tr2);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: false,
        dragging: null,
        editable: true,
        isDestroyed: false
      },
      {
        get: (obj, key) => {
          if (key === "state") {
            return this.editorState;
          }
          if (key in obj) {
            return Reflect.get(obj, key);
          }
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${key}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    if (this.editorView) {
      this.editorState = this.view.state;
    }
    return this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
    return state;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(nameOrPluginKeyToRemove) {
    if (this.isDestroyed) {
      return void 0;
    }
    const prevPlugins = this.state.plugins;
    let plugins = prevPlugins;
    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));
    });
    if (prevPlugins.length === plugins.length) {
      return void 0;
    }
    const state = this.state.reconfigure({
      plugins
    });
    this.view.updateState(state);
    return state;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var _a, _b;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b = (_a = this.options.coreExtensionOptions) == null ? void 0 : _a.clipboardTextSerializer) == null ? void 0 : _b.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex,
      Drop,
      Paste,
      Delete
    ].filter((ext) => {
      if (typeof this.options.enableCoreExtensions === "object") {
        return this.options.enableCoreExtensions[ext.name] !== false;
      }
      return true;
    }) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension == null ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let doc3;
    try {
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
        throw e;
      }
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          if ("collaboration" in this.storage && typeof this.storage.collaboration === "object" && this.storage.collaboration) {
            ;
            this.storage.collaboration.isDisabled = true;
          }
          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
          this.createExtensionManager();
        }
      });
      doc3 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: false
      });
    }
    return doc3;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(element) {
    var _a;
    this.editorView = new EditorView(element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(_a = this.options.editorProps) == null ? void 0 : _a.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: this.editorState
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    this.injectCSS();
    const dom = this.view.dom;
    dom.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    if (this.view.isDestroyed) {
      return;
    }
    this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn) {
    this.isCapturingTransaction = true;
    fn();
    this.isCapturingTransaction = false;
    const tr2 = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr2;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a;
        return (_a = this.capturedTransaction) == null ? void 0 : _a.step(step);
      });
      return;
    }
    const { state, transactions } = this.state.applyTransaction(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    const rootTrWasApplied = transactions.includes(transaction);
    const prevState = this.state;
    this.emit("beforeTransaction", {
      editor: this,
      transaction,
      nextState: state
    });
    if (!rootTrWasApplied) {
      return;
    }
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction,
      appendedTransactions: transactions.slice(1)
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const mostRecentFocusTr = transactions.findLast((tr2) => tr2.getMeta("focus") || tr2.getMeta("blur"));
    const focus2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("focus");
    const blur2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        transaction: mostRecentFocusTr
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        transaction: mostRecentFocusTr
      });
    }
    if (transaction.getMeta("preventUpdate") || !transactions.some((tr2) => tr2.docChanged) || prevState.doc.eq(state.doc)) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction,
      appendedTransactions: transactions.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText2(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    this.unmount();
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a, _b;
    return (_b = (_a = this.editorView) == null ? void 0 : _a.isDestroyed) != null ? _b : true;
  }
  $node(selector, attributes) {
    var _a;
    return ((_a = this.$doc) == null ? void 0 : _a.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a;
    return ((_a = this.$doc) == null ? void 0 : _a.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        const markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr: tr2 } = state;
      const start = range.from;
      let end = range.to;
      const newNode = config.type.create(attributes);
      if (match[1]) {
        const offset3 = match[0].lastIndexOf(match[1]);
        let matchStart = start + offset3;
        if (matchStart > end) {
          matchStart = end;
        } else {
          end = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr2.insertText(lastChar, start + match[0].length - 1);
        tr2.replaceWith(matchStart, end, newNode);
      } else if (match[0]) {
        const insertionStart = config.type.isInline ? start : start - 1;
        tr2.insert(insertionStart, config.type.create(attributes)).delete(tr2.mapping.map(start), tr2.mapping.map(end));
      }
      tr2.scrollIntoView();
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match }) => {
      const $start = state.doc.resolve(range.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range, match, chain }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const tr2 = state.tr.delete(range.from, range.to);
      const $start = tr2.doc.resolve(range.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr2.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr2.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain().updateAttributes(nodeType, attributes).run();
      }
      const before = tr2.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr2.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
        tr2.join(range.from - 1);
      }
    }
  });
}
function escapeForRegEx(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var Node3 = class _Node extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "node";
  }
  static create(config = {}) {
    return new _Node(config);
  }
  configure(options) {
    return super.configure(options);
  }
  extend(extendedConfig) {
    return super.extend(extendedConfig);
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr: tr2 } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr2.delete(textEnd, range.to);
        }
        if (textStart > range.from) {
          tr2.delete(range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr2.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr2.removeStoredMark(config.type);
      }
    }
  });
}

// node_modules/prosemirror-dropcursor/dist/index.js
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
var DropCursorView = class {
  constructor(editorView, options) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
    let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          let halfWidth = this.width / 2 * scaleY;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top - halfWidth, bottom: top + halfWidth };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      let halfWidth = this.width / 2 * scaleX;
      rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
      parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
      parentTop = rect2.top - parent.scrollTop * parentScaleY;
    }
    this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
    this.element.style.top = (rect.top - parentTop) / scaleY + "px";
    this.element.style.width = (rect.right - rect.left) / scaleX + "px";
    this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (!this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
};

// node_modules/prosemirror-gapcursor/dist/index.js
var GapCursor = class _GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc3, mapping) {
    let $pos = doc3.resolve(mapping.map(this.head));
    return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof _GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc3, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new _GapCursor(doc3.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search: for (; ; ) {
      if (!mustMove && _GapCursor.valid($pos))
        return $pos;
      let pos = $pos.pos, next = null;
      for (let d = $pos.depth; ; d--) {
        let parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break;
        } else if (d == 0) {
          return null;
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (_GapCursor.valid($cur))
          return $cur;
      }
      for (; ; ) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search;
          }
          break;
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (_GapCursor.valid($cur))
          return $cur;
      }
      return null;
    }
  }
};
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = class _GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new _GapBookmark(mapping.map(this.pos));
  }
  resolve(doc3) {
    let $pos = doc3.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
};
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.index(d), parent = $pos.node(d);
    if (index == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});
function arrow(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment.from(insert[i].createAndFill(null, frag));
  let tr2 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr2.setSelection(TextSelection.near(tr2.doc.resolve($from.pos + 1)));
  view.dispatch(tr2);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}

// node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var dist_default2 = RopeSequence;

// node_modules/prosemirror-history/dist/index.js
var max_empty_items = 500;
var Branch = class _Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end = this.items.length;
    for (; ; end--) {
      let next = this.items.get(end - 1);
      if (next.selection) {
        --end;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new _Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new _Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new _Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map2, step, selection));
      } else {
        rebasedItems.push(new Item(map2));
      }
    }, start);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
    let branch = new _Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new _Branch(dist_default2.from(items.reverse()), events);
  }
};
Branch.empty = new Branch(dist_default2.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = class _Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new _Item(step.getMap().invert(), step, this.selection);
    }
  }
};
var HistoryState = class {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
};
var DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr2, options) {
  let historyTr = tr2.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr2.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr2.getMeta("appendedTransaction");
  if (tr2.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr2, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr2.mapping.maps), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr2, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr2.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr2.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr2.time || 0) - options.newGroupDelay || !isAdjacentTo(tr2, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr2.mapping) : rangesFor(tr2.mapping.maps);
    return new HistoryState(history2.done.addTransform(tr2, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr2.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr2.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr2, rebased), history2.undone.rebased(tr2, rebased), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr2.mapping.maps), history2.undone.addMaps(tr2.mapping.maps), mapRanges(history2.prevRanges, tr2.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start, end) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start <= prevRanges[i + 1] && end >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)
    maps[i].forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr2, hist, state) {
        return applyTransaction(hist, state, tr2, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll) {
  return (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr2 = histTransaction(hist, state, redo2);
      if (tr2)
        dispatch(scroll ? tr2.scrollIntoView() : tr2);
    }
    return true;
  };
}
var undo = buildCommand(false, true);
var redo = buildCommand(true, true);
var undoNoScroll = buildCommand(false, false);
var redoNoScroll = buildCommand(true, false);

// node_modules/@tiptap/extensions/dist/index.js
var CharacterCount = Extension.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (text) => text.length,
      wordCounter: (text) => text.split(" ").filter((word) => word !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (options) => {
      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;
      const mode = (options == null ? void 0 : options.mode) || this.options.mode;
      if (mode === "textSize") {
        const text = node.textBetween(0, node.content.size, void 0, " ");
        return this.options.textCounter(text);
      }
      return node.nodeSize;
    };
    this.storage.words = (options) => {
      const node = (options == null ? void 0 : options.node) || this.editor.state.doc;
      const text = node.textBetween(0, node.content.size, " ", " ");
      return this.options.wordCounter(text);
    };
  },
  addProseMirrorPlugins() {
    let initialEvaluationDone = false;
    return [
      new Plugin({
        key: new PluginKey("characterCount"),
        appendTransaction: (transactions, oldState, newState) => {
          if (initialEvaluationDone) {
            return;
          }
          const limit = this.options.limit;
          if (limit === null || limit === void 0 || limit === 0) {
            initialEvaluationDone = true;
            return;
          }
          const initialContentSize = this.storage.characters({ node: newState.doc });
          if (initialContentSize > limit) {
            const over = initialContentSize - limit;
            const from2 = 0;
            const to = over;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`
            );
            const tr2 = newState.tr.deleteRange(from2, to);
            initialEvaluationDone = true;
            return tr2;
          }
          initialEvaluationDone = true;
        },
        filterTransaction: (transaction, state) => {
          const limit = this.options.limit;
          if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {
            return true;
          }
          const oldSize = this.storage.characters({ node: state.doc });
          const newSize = this.storage.characters({ node: transaction.doc });
          if (newSize <= limit) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize <= oldSize) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize > oldSize) {
            return false;
          }
          const isPaste = transaction.getMeta("paste");
          if (!isPaste) {
            return false;
          }
          const pos = transaction.selection.$head.pos;
          const over = newSize - limit;
          const from2 = pos - over;
          const to = pos;
          transaction.deleteRange(from2, to);
          const updatedSize = this.storage.characters({ node: transaction.doc });
          if (updatedSize > limit) {
            return false;
          }
          return true;
        }
      })
    ];
  }
});
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [dropCursor(this.options)];
  }
});
var Focus = Extension.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("focus"),
        props: {
          decorations: ({ doc: doc3, selection }) => {
            const { isEditable, isFocused } = this.editor;
            const { anchor } = selection;
            const decorations = [];
            if (!isEditable || !isFocused) {
              return DecorationSet.create(doc3, []);
            }
            let maxLevels = 0;
            if (this.options.mode === "deepest") {
              doc3.descendants((node, pos) => {
                if (node.isText) {
                  return;
                }
                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
                if (!isCurrent) {
                  return false;
                }
                maxLevels += 1;
              });
            }
            let currentLevel = 0;
            doc3.descendants((node, pos) => {
              if (node.isText) {
                return false;
              }
              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
              if (!isCurrent) {
                return false;
              }
              currentLevel += 1;
              const outOfScope = this.options.mode === "deepest" && maxLevels - currentLevel > 0 || this.options.mode === "shallowest" && currentLevel > 1;
              if (outOfScope) {
                return this.options.mode === "deepest";
              }
              decorations.push(
                Decoration.node(pos, pos + node.nodeSize, {
                  class: this.options.className
                })
              );
            });
            return DecorationSet.create(doc3, decorations);
          }
        }
      })
    ];
  }
});
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [gapCursor()];
  },
  extendNodeSchema(extension) {
    var _a;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context))) != null ? _a : null
    };
  }
});
var Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something \u2026",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc3, selection }) => {
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const isEmptyDoc = this.editor.isEmpty;
            doc3.descendants((node, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
              const isEmpty2 = !node.isLeaf && isNodeEmpty(node);
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty2) {
                const classes = [this.options.emptyNodeClass];
                if (isEmptyDoc) {
                  classes.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: classes.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc3, decorations);
          }
        }
      })
    ];
  }
});
var Selection2 = Extension.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor, options } = this;
    return [
      new Plugin({
        key: new PluginKey("selection"),
        props: {
          decorations(state) {
            if (state.selection.empty || editor.isFocused || !editor.isEditable || isNodeSelection(state.selection)) {
              return null;
            }
            return DecorationSet.create(state.doc, [
              Decoration.inline(state.selection.from, state.selection.to, {
                class: options.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function nodeEqualsType({ types, node }) {
  return node && Array.isArray(types) && types.includes(node.type) || (node == null ? void 0 : node.type) === types;
}
var TrailingNode = Extension.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: "paragraph",
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    const plugin = new PluginKey(this.name);
    const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value]) => value).filter((node) => (this.options.notAfter || []).concat(this.options.node).includes(node.name));
    return [
      new Plugin({
        key: plugin,
        appendTransaction: (_, __, state) => {
          const { doc: doc3, tr: tr2, schema } = state;
          const shouldInsertNodeAtEnd = plugin.getState(state);
          const endPosition = doc3.content.size;
          const type = schema.nodes[this.options.node];
          if (!shouldInsertNodeAtEnd) {
            return;
          }
          return tr2.insert(endPosition, type.create());
        },
        state: {
          init: (_, state) => {
            const lastNode = state.tr.doc.lastChild;
            return !nodeEqualsType({ node: lastNode, types: disabledNodes });
          },
          apply: (tr2, value) => {
            if (!tr2.docChanged) {
              return value;
            }
            const lastNode = tr2.doc.lastChild;
            return !nodeEqualsType({ node: lastNode, types: disabledNodes });
          }
        }
      })
    ];
  }
});
var UndoRedo = Extension.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch }) => {
        return undo(state, dispatch);
      },
      redo: () => ({ state, dispatch }) => {
        return redo(state, dispatch);
      }
    };
  },
  addProseMirrorPlugins() {
    return [history(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-\u044F": () => this.editor.commands.undo(),
      "Shift-Mod-\u044F": () => this.editor.commands.redo()
    };
  }
});

// node_modules/@tiptap/core/dist/jsx-runtime/jsx-runtime.js
var h = (tag, attributes) => {
  if (tag === "slot") {
    return 0;
  }
  if (tag instanceof Function) {
    return tag(attributes);
  }
  const { children, ...rest } = attributes != null ? attributes : {};
  if (tag === "svg") {
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  }
  return [tag, rest, children];
};

// node_modules/@tiptap/extension-blockquote/dist/index.js
var inputRegex = /^\s*>\s$/;
var Blockquote = Node3.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [{ tag: "blockquote" }];
  },
  renderHTML({ HTMLAttributes }) {
    return /* @__PURE__ */ h("blockquote", { ...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ h("slot", {}) });
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands }) => {
        return commands.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands }) => {
        return commands.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands }) => {
        return commands.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  }
});
var index_default = Blockquote;

// node_modules/@tiptap/extension-bold/dist/index.js
var starInputRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
var starPasteRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
var underscoreInputRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
var underscorePasteRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
var Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return /* @__PURE__ */ h("strong", { ...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ h("slot", {}) });
  },
  addCommands() {
    return {
      setBold: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleBold: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetBold: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});
var index_default2 = Bold;

// node_modules/@tiptap/extension-code/dist/index.js
var inputRegex2 = /(^|[^`])`([^`]+)`(?!`)/;
var pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;
var Code = Mark2.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleCode: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetCode: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});
var index_default3 = Code;

// node_modules/@tiptap/extension-code-block/dist/index.js
var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock = Node3.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (element) => {
          var _a;
          const { languageClassPrefix } = this.options;
          const classNames = [...((_a = element.firstElementChild) == null ? void 0 : _a.classList) || []];
          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands }) => {
        return commands.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands }) => {
        return commands.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty2, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty2 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr: tr2 }) => {
          tr2.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc3 } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after = $from.after();
        if (after === void 0) {
          return false;
        }
        const nodeAfter = doc3.nodeAt(after);
        if (nodeAfter) {
          return editor.commands.command(({ tr: tr2 }) => {
            tr2.setSelection(Selection.near(doc3.resolve(after)));
            return true;
          });
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData == null ? void 0 : vscodeData.mode;
            if (!text || !language) {
              return false;
            }
            const { tr: tr2, schema } = view.state;
            const textNode = schema.text(text.replace(/\r\n?/g, "\n"));
            tr2.replaceSelectionWith(this.type.create({ language }, textNode));
            if (tr2.selection.$from.parent.type !== this.type) {
              tr2.setSelection(TextSelection.near(tr2.doc.resolve(Math.max(0, tr2.selection.from - 2))));
            }
            tr2.setMeta("paste", true);
            view.dispatch(tr2);
            return true;
          }
        }
      })
    ];
  }
});
var index_default4 = CodeBlock;

// packages/forms/resources/js/components/rich-editor/extension-custom-block.js
var extension_custom_block_default = Node3.create({
  name: "customBlock",
  group: "block",
  atom: true,
  defining: true,
  draggable: true,
  selectable: true,
  isolating: true,
  allowGapCursor: true,
  inline: false,
  addNodeView() {
    return ({
      editor,
      node,
      getPos,
      HTMLAttributes,
      decorations,
      extension
    }) => {
      const dom = document.createElement("div");
      dom.setAttribute("data-config", node.attrs.config);
      dom.setAttribute("data-id", node.attrs.id);
      dom.setAttribute("data-type", "customBlock");
      const header = document.createElement("div");
      header.className = "fi-fo-rich-editor-custom-block-header fi-not-prose";
      dom.appendChild(header);
      if (editor.isEditable && typeof node.attrs.config === "object" && node.attrs.config !== null && Object.keys(node.attrs.config).length > 0) {
        const editButtonContainer = document.createElement("div");
        editButtonContainer.className = "fi-fo-rich-editor-custom-block-edit-btn-ctn";
        header.appendChild(editButtonContainer);
        const editButton = document.createElement("button");
        editButton.className = "fi-icon-btn";
        editButton.type = "button";
        editButton.innerHTML = extension.options.editCustomBlockButtonIconHtml;
        editButton.addEventListener(
          "click",
          () => extension.options.editCustomBlockUsing(
            node.attrs.id,
            node.attrs.config
          )
        );
        editButtonContainer.appendChild(editButton);
      }
      const heading = document.createElement("p");
      heading.className = "fi-fo-rich-editor-custom-block-heading";
      heading.textContent = node.attrs.label;
      header.appendChild(heading);
      if (editor.isEditable) {
        const deleteButtonContainer = document.createElement("div");
        deleteButtonContainer.className = "fi-fo-rich-editor-custom-block-delete-btn-ctn";
        header.appendChild(deleteButtonContainer);
        const deleteButton = document.createElement("button");
        deleteButton.className = "fi-icon-btn";
        deleteButton.type = "button";
        deleteButton.innerHTML = extension.options.deleteCustomBlockButtonIconHtml;
        deleteButton.addEventListener(
          "click",
          () => editor.chain().setNodeSelection(getPos()).deleteSelection().run()
        );
        deleteButtonContainer.appendChild(deleteButton);
      }
      if (node.attrs.preview) {
        const preview = document.createElement("div");
        preview.className = "fi-fo-rich-editor-custom-block-preview fi-not-prose";
        preview.innerHTML = atob(node.attrs.preview);
        dom.appendChild(preview);
      }
      return {
        dom
      };
    };
  },
  addOptions() {
    return {
      deleteCustomBlockButtonIconHtml: null,
      editCustomBlockButtonIconHtml: null,
      editCustomBlockUsing: () => {
      },
      insertCustomBlockUsing: () => {
      }
    };
  },
  addAttributes() {
    return {
      config: {
        default: null,
        parseHTML: (element) => JSON.parse(element.getAttribute("data-config"))
      },
      id: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-id"),
        renderHTML: (attributes) => {
          if (!attributes.id) {
            return {};
          }
          return {
            "data-id": attributes.id
          };
        }
      },
      label: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-label"),
        rendered: false
      },
      preview: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-preview"),
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["div", mergeAttributes(HTMLAttributes)];
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.command(({ tr: tr2, state }) => {
        let isCustomBlock = false;
        const { selection } = state;
        const { empty: empty2, anchor } = selection;
        if (!empty2) {
          return false;
        }
        let customBlockNode = new Node2();
        let customBlockPos = 0;
        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {
          if (node.type.name === this.name) {
            isCustomBlock = true;
            customBlockNode = node;
            customBlockPos = pos;
            return false;
          }
        });
        return isCustomBlock;
      })
    };
  },
  addProseMirrorPlugins() {
    const { insertCustomBlockUsing } = this.options;
    return [
      new Plugin({
        props: {
          handleDrop(view, event) {
            if (!event) {
              return false;
            }
            event.preventDefault();
            if (!event.dataTransfer.getData("customBlock")) {
              return false;
            }
            const customBlockId = event.dataTransfer.getData("customBlock");
            insertCustomBlockUsing(
              customBlockId,
              view.posAtCoords({
                left: event.clientX,
                top: event.clientY
              }).pos
            );
            return false;
          }
        }
      })
    ];
  }
});

// node_modules/@tiptap/extension-document/dist/index.js
var Document = Node3.create({
  name: "doc",
  topNode: true,
  content: "block+"
});
var index_default5 = Document;

// node_modules/@tiptap/extension-dropcursor/dist/index.js
var index_default6 = Dropcursor;

// node_modules/@tiptap/extension-heading/dist/index.js
var Heading = Node3.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce(
      (items, level) => ({
        ...items,
        ...{
          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
        }
      }),
      {}
    );
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});
var index_default7 = Heading;

// node_modules/@tiptap/extension-italic/dist/index.js
var starInputRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
var starPasteRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
var underscoreInputRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
var underscorePasteRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
var Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleItalic: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex2,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex2,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex2,
        type: this.type
      })
    ];
  }
});
var index_default8 = Italic;

// node_modules/@tiptap/extension-image/dist/index.js
var inputRegex3 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var Image = Node3.create({
  name: "image",
  addOptions() {
    return {
      inline: false,
      allowBase64: false,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      },
      width: {
        default: null
      },
      height: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["img", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setImage: (options) => ({ commands }) => {
        return commands.insertContent({
          type: this.name,
          attrs: options
        });
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: inputRegex3,
        type: this.type,
        getAttributes: (match) => {
          const [, , alt, src, title] = match;
          return { src, alt, title };
        }
      })
    ];
  }
});
var index_default9 = Image;

// packages/forms/resources/js/components/rich-editor/extension-image.js
var extension_image_default = index_default9.extend({
  addAttributes() {
    return {
      ...this.parent?.(),
      id: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-id"),
        renderHTML: (attributes) => {
          if (!attributes.id) {
            return {};
          }
          return {
            "data-id": attributes.id
          };
        }
      }
    };
  }
});

// node_modules/linkifyjs/dist/linkify.mjs
var encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xF6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
var encodedUtlds = "\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2";
var assign = (target, properties) => {
  for (const key in properties) {
    target[key] = properties[key];
  }
  return target;
};
var numeric = "numeric";
var ascii = "ascii";
var alpha = "alpha";
var asciinumeric = "asciinumeric";
var alphanumeric = "alphanumeric";
var domain = "domain";
var emoji = "emoji";
var scheme = "scheme";
var slashscheme = "slashscheme";
var whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t) < 0) {
      group.push(t);
    }
  }
}
function flagsForToken(t, groups) {
  const result = {};
  for (const c in groups) {
    if (groups[c].indexOf(t) >= 0) {
      result[c] = true;
    }
  }
  return result;
}
function State(token = null) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i = 0; i < state.jr.length; i++) {
      const regex = state.jr[i][0];
      const nextState2 = state.jr[i][1];
      if (nextState2 && regex.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly = false) {
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t, allFlags, groups);
        } else if (flags) {
          addToGroups(t, flags, groups);
        }
      }
      nextState.t = t;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
var ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
var tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
var ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
var tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
var WORD = "WORD";
var UWORD = "UWORD";
var ASCIINUMERICAL = "ASCIINUMERICAL";
var ALPHANUMERICAL = "ALPHANUMERICAL";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var UTLD = "UTLD";
var SCHEME = "SCHEME";
var SLASH_SCHEME = "SLASH_SCHEME";
var NUM = "NUM";
var WS = "WS";
var NL = "NL";
var OPENBRACE = "OPENBRACE";
var CLOSEBRACE = "CLOSEBRACE";
var OPENBRACKET = "OPENBRACKET";
var CLOSEBRACKET = "CLOSEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEPAREN = "CLOSEPAREN";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
var FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
var LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
var RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
var LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
var RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
var FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
var FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var FULLWIDTHMIDDLEDOT = "FULLWIDTHMIDDLEDOT";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var EMOJI$1 = "EMOJI";
var SYM = "SYM";
var tk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL,
  AMPERSAND,
  APOSTROPHE,
  ASCIINUMERICAL,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  CLOSEANGLEBRACKET,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEPAREN,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EMOJI: EMOJI$1,
  EQUALS,
  EXCLAMATION,
  FULLWIDTHGREATERTHAN,
  FULLWIDTHLEFTPAREN,
  FULLWIDTHLESSTHAN,
  FULLWIDTHMIDDLEDOT,
  FULLWIDTHRIGHTPAREN,
  HYPHEN,
  LEFTCORNERBRACKET,
  LEFTWHITECORNERBRACKET,
  LOCALHOST,
  NL,
  NUM,
  OPENANGLEBRACKET,
  OPENBRACE,
  OPENBRACKET,
  OPENPAREN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  RIGHTCORNERBRACKET,
  RIGHTWHITECORNERBRACKET,
  SCHEME,
  SEMI,
  SLASH,
  SLASH_SCHEME,
  SYM,
  TILDE,
  TLD,
  UNDERSCORE,
  UTLD,
  UWORD,
  WORD,
  WS
});
var ASCII_LETTER = /[a-z]/;
var LETTER = /\p{L}/u;
var EMOJI = /\p{Emoji}/u;
var DIGIT = /\d/;
var SPACE = /\s/;
var CR = "\r";
var LF = "\n";
var EMOJI_VARIATION = "\uFE0F";
var EMOJI_JOINER = "\u200D";
var OBJECT_REPLACEMENT = "\uFFFC";
var tlds = null;
var utlds = null;
function init$2(customSchemes = []) {
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, "\uFF08", FULLWIDTHLEFTPAREN);
  tt(Start, "\uFF09", FULLWIDTHRIGHTPAREN);
  tt(Start, "\u300C", LEFTCORNERBRACKET);
  tt(Start, "\u300D", RIGHTCORNERBRACKET);
  tt(Start, "\u300E", LEFTWHITECORNERBRACKET);
  tt(Start, "\u300F", RIGHTWHITECORNERBRACKET);
  tt(Start, "\uFF1C", FULLWIDTHLESSTHAN);
  tt(Start, "\uFF1E", FULLWIDTHGREATERTHAN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  tt(Start, "\u30FB", FULLWIDTHMIDDLEDOT);
  const Num = tr(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr(Num, DIGIT, Num);
  const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {
    [asciinumeric]: true
  });
  const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {
    [alphanumeric]: true
  });
  const Word = tr(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr(Word, DIGIT, Asciinumeric);
  tr(Word, ASCII_LETTER, Word);
  tr(Asciinumeric, DIGIT, Asciinumeric);
  tr(Asciinumeric, ASCII_LETTER, Asciinumeric);
  const UWord = tr(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr(UWord, ASCII_LETTER);
  tr(UWord, DIGIT, Alphanumeric);
  tr(UWord, LETTER, UWord);
  tr(Alphanumeric, DIGIT, Alphanumeric);
  tr(Alphanumeric, ASCII_LETTER);
  tr(Alphanumeric, LETTER, Alphanumeric);
  const Nl2 = tt(Start, LF, NL, {
    [whitespace]: true
  });
  const Cr = tt(Start, CR, WS, {
    [whitespace]: true
  });
  const Ws = tr(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt(Start, OBJECT_REPLACEMENT, Ws);
  tt(Cr, LF, Nl2);
  tt(Cr, OBJECT_REPLACEMENT, Ws);
  tr(Cr, SPACE, Ws);
  tt(Ws, CR);
  tt(Ws, LF);
  tr(Ws, SPACE, Ws);
  tt(Ws, OBJECT_REPLACEMENT, Ws);
  const Emoji = tr(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tt(Emoji, "#");
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tt(EmojiJoiner, "#");
  tr(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];
  for (let i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (let i = 0; i < utlds.length; i++) {
    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
  for (let i = 0; i < customSchemes.length; i++) {
    const sch = customSchemes[i][0];
    const optionalSlashSlash = customSchemes[i][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign({
      groups
    }, tk)
  };
}
function run$1(start, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index = 0;
  while (index < len) {
    let first2 = str.charCodeAt(index);
    let second;
    let char = first2 < 55296 || first2 > 56319 || index + 1 === len || (second = str.charCodeAt(index + 1)) < 56320 || second > 57343 ? str[index] : str.slice(index, index + 2);
    result.push(char);
    index += char.length;
  }
  return result;
}
function fastts(state, input, t, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i = 0; i < len - 1; i++) {
    const char = input[i];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack = [];
  let i = 0;
  let digits = "0123456789";
  while (i < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack.join(""));
      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
        stack.pop();
      }
      i += popDigitCount;
    } else {
      stack.push(encoded[i]);
      i++;
    }
  }
  return words;
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop,
  formatHref: noop,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender = null) {
  let o = assign({}, defaults);
  if (opts) {
    o = assign(o, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  this.o = o;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop(val) {
  return val;
}
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options) {
    const val = this.toString();
    const truncate = options.get("truncate", val, this);
    const formatted = options.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "\u2026" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options) {
    return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol = defaults.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options) {
    return {
      type: this.t,
      value: this.toFormattedString(options),
      isLink: this.isLink,
      href: this.toFormattedHref(options),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options) {
    return options.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options) {
    const token = this;
    const href = this.toHref(options.get("defaultProtocol"));
    const formattedHref = options.get("formatHref", href, this);
    const tagName = options.get("tagName", href, token);
    const content = this.toFormattedString(options);
    const attributes = {};
    const className = options.get("className", href, token);
    const target = options.get("target", href, token);
    const rel = options.get("rel", href, token);
    const attrs = options.getObj("attributes", href, token);
    const eventListeners = options.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      assign(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}
var Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2 = defaults.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var makeState = (arg) => new State(arg);
function init$1({
  groups
}) {
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  tt(DomainHyphen, HYPHEN, DomainHyphen);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  tt(SchemeColon, QUERY, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // （）
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 「」
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 『』
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // ＜＞
  ];
  for (let i = 0; i < bracketPairs.length; i++) {
    const [OPEN, CLOSE] = bracketPairs[i];
    const UrlOpen = tt(Url$1, OPEN);
    tt(UrlNonaccept, OPEN, UrlOpen);
    tt(UrlOpen, CLOSE, Url$1);
    const UrlOpenQ = makeState(Url);
    ta(UrlOpen, qsAccepting, UrlOpenQ);
    const UrlOpenSyms = makeState();
    ta(UrlOpen, qsNonAccepting);
    ta(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt(UrlOpenQ, CLOSE, Url$1);
    tt(UrlOpenSyms, CLOSE, Url$1);
  }
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run3(start, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var warn = typeof console !== "undefined" && console && console.warn || (() => {
});
var warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
var INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
  return INIT;
}
function registerCustomProtocol(scheme2, optionalSlashSlash = false) {
  if (INIT.initialized) {
    warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
  return INIT;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run3(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
tokenize.scan = run$1;
function find(str, type = null, opts = null) {
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options = new Options(opts);
  const tokens = tokenize(str);
  const filtered = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.isLink && (!type || token.t === type) && options.check(token)) {
      filtered.push(token.toFormattedObject(options));
    }
  }
  return filtered;
}

// node_modules/@tiptap/extension-link/dist/index.js
function isValidLinkStructure(tokens) {
  if (tokens.length === 1) {
    return tokens[0].isLink;
  }
  if (tokens.length === 3 && tokens[1].isLink) {
    return ["()", "[]"].includes(tokens[0].value + tokens[2].value);
  }
  return false;
}
function autolink(options) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr: tr2 } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(
            textBlock.pos,
            textBlock.pos + textBlock.node.nodeSize,
            void 0,
            " "
          );
        } else if (nodesInChangedRanges.length && // We want to make sure to include the block seperator argument to treat hard breaks like spaces.
        newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s) => s !== "");
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map((t) => t.toObject(options.defaultProtocol));
          if (!isValidLinkStructure(linksBeforeSpace)) {
            return false;
          }
          linksBeforeSpace.filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => options.validate(link.value)).filter((link) => options.shouldAutoLink(link.value)).forEach((link) => {
            if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options.type)) {
              return;
            }
            tr2.addMark(
              link.from,
              link.to,
              options.type.create({
                href: link.href
              })
            );
          });
        }
      });
      if (!tr2.steps.length) {
        return;
      }
      return tr2;
    }
  });
}
function clickHandler(options) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a, _b;
        if (event.button !== 0) {
          return false;
        }
        if (!view.editable) {
          return false;
        }
        let link = null;
        if (event.target instanceof HTMLAnchorElement) {
          link = event.target;
        } else {
          let a = event.target;
          const els = [];
          while (a.nodeName !== "DIV") {
            els.push(a);
            a = a.parentNode;
          }
          link = els.find((value) => value.nodeName === "A");
        }
        if (!link) {
          return false;
        }
        const attrs = getAttributes(view.state, options.type.name);
        const href = (_a = link == null ? void 0 : link.href) != null ? _a : attrs.href;
        const target = (_b = link == null ? void 0 : link.target) != null ? _b : attrs.target;
        if (link && href) {
          window.open(href, target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice2) => {
        const { state } = view;
        const { selection } = state;
        const { empty: empty2 } = selection;
        if (empty2) {
          return false;
        }
        let textContent = "";
        slice2.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find(
          (item) => item.isLink && item.value === textContent
        );
        if (!textContent || !link) {
          return false;
        }
        return options.editor.commands.setMark(options.type, {
          href: link.href
        });
      }
    }
  });
}
var ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function isAllowedUri(uri, protocols) {
  const allowedProtocols = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return !uri || uri.replace(ATTR_WHITESPACE, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var Link = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  exitable: true,
  onCreate() {
    if (this.options.validate && !this.options.shouldAutoLink) {
      this.options.shouldAutoLink = this.options.validate;
      console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.");
    }
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),
      validate: (url) => !!url,
      shouldAutoLink: (url) => !!url
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(element) {
          return element.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (dom) => {
          const href = dom.getAttribute("href");
          if (!href || !this.options.isAllowedUri(href, {
            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          })) {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    if (!this.options.isAllowedUri(HTMLAttributes.href, {
      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    })) {
      return ["a", mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }), 0];
    }
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text) => {
          const foundLinks = [];
          if (text) {
            const { protocols, defaultProtocol } = this.options;
            const links = find(text).filter(
              (item) => item.isLink && this.options.isAllowedUri(item.value, {
                defaultValidate: (href) => !!isAllowedUri(href, protocols),
                protocols,
                defaultProtocol
              })
            );
            if (links.length) {
              links.forEach(
                (link) => foundLinks.push({
                  text: link.value,
                  data: {
                    href: link.href
                  },
                  index: link.start
                })
              );
            }
          }
          return foundLinks;
        },
        type: this.type,
        getAttributes: (match) => {
          var _a;
          return {
            href: (_a = match.data) == null ? void 0 : _a.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    const { protocols, defaultProtocol } = this.options;
    if (this.options.autolink) {
      plugins.push(
        autolink({
          type: this.type,
          defaultProtocol: this.options.defaultProtocol,
          validate: (url) => this.options.isAllowedUri(url, {
            defaultValidate: (href) => !!isAllowedUri(href, protocols),
            protocols,
            defaultProtocol
          }),
          shouldAutoLink: this.options.shouldAutoLink
        })
      );
    }
    if (this.options.openOnClick === true) {
      plugins.push(
        clickHandler({
          type: this.type
        })
      );
    }
    if (this.options.linkOnPaste) {
      plugins.push(
        pasteHandler({
          editor: this.editor,
          defaultProtocol: this.options.defaultProtocol,
          type: this.type
        })
      );
    }
    return plugins;
  }
});
var index_default10 = Link;

// node_modules/@tiptap/extension-list/dist/index.js
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var ListItemName = "listItem";
var TextStyleName = "textStyle";
var bulletListInputRegex = /^\s*([-+*])\s$/;
var BulletList = Node3.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [{ tag: "ul" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
        }
        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: bulletListInputRegex,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: bulletListInputRegex,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyleName);
        },
        editor: this.editor
      });
    }
    return [inputRule];
  }
});
var ListItem = Node3.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
var listHelpers_exports = {};
__export2(listHelpers_exports, {
  findListItemPos: () => findListItemPos,
  getNextListDepth: () => getNextListDepth,
  handleBackspace: () => handleBackspace,
  handleDelete: () => handleDelete,
  hasListBefore: () => hasListBefore,
  hasListItemAfter: () => hasListItemAfter,
  hasListItemBefore: () => hasListItemBefore,
  listItemHasSubList: () => listItemHasSubList,
  nextListIsDeeper: () => nextListIsDeeper,
  nextListIsHigher: () => nextListIsHigher
});
var findListItemPos = (typeOrName, state) => {
  const { $from } = state.selection;
  const nodeType = getNodeType(typeOrName, state.schema);
  let currentNode = null;
  let currentDepth = $from.depth;
  let currentPos = $from.pos;
  let targetDepth = null;
  while (currentDepth > 0 && targetDepth === null) {
    currentNode = $from.node(currentDepth);
    if (currentNode.type === nodeType) {
      targetDepth = currentDepth;
    } else {
      currentDepth -= 1;
      currentPos -= 1;
    }
  }
  if (targetDepth === null) {
    return null;
  }
  return { $pos: state.doc.resolve(currentPos), depth: targetDepth };
};
var getNextListDepth = (typeOrName, state) => {
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos) {
    return false;
  }
  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4);
  return depth;
};
var hasListBefore = (editorState, name, parentListTypes) => {
  const { $anchor } = editorState.selection;
  const previousNodePos = Math.max(0, $anchor.pos - 2);
  const previousNode = editorState.doc.resolve(previousNodePos).node();
  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {
    return false;
  }
  return true;
};
var hasListItemBefore = (typeOrName, state) => {
  var _a;
  const { $anchor } = state.selection;
  const $targetPos = state.doc.resolve($anchor.pos - 2);
  if ($targetPos.index() === 0) {
    return false;
  }
  if (((_a = $targetPos.nodeBefore) == null ? void 0 : _a.type.name) !== typeOrName) {
    return false;
  }
  return true;
};
var listItemHasSubList = (typeOrName, state, node) => {
  if (!node) {
    return false;
  }
  const nodeType = getNodeType(typeOrName, state.schema);
  let hasSubList = false;
  node.descendants((child) => {
    if (child.type === nodeType) {
      hasSubList = true;
    }
  });
  return hasSubList;
};
var handleBackspace = (editor, name, parentListTypes) => {
  if (editor.commands.undoInputRule()) {
    return true;
  }
  if (editor.state.selection.from !== editor.state.selection.to) {
    return false;
  }
  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {
    const { $anchor } = editor.state.selection;
    const $listPos = editor.state.doc.resolve($anchor.before() - 1);
    const listDescendants = [];
    $listPos.node().descendants((node, pos) => {
      if (node.type.name === name) {
        listDescendants.push({ node, pos });
      }
    });
    const lastItem = listDescendants.at(-1);
    if (!lastItem) {
      return false;
    }
    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);
    return editor.chain().cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end()).joinForward().run();
  }
  if (!isNodeActive(editor.state, name)) {
    return false;
  }
  if (!isAtStartOfNode(editor.state)) {
    return false;
  }
  const listItemPos = findListItemPos(name, editor.state);
  if (!listItemPos) {
    return false;
  }
  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);
  const prevNode = $prev.node(listItemPos.depth);
  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);
  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {
    return editor.commands.joinItemBackward();
  }
  return editor.chain().liftListItem(name).run();
};
var nextListIsDeeper = (typeOrName, state) => {
  const listDepth = getNextListDepth(typeOrName, state);
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos || !listDepth) {
    return false;
  }
  if (listDepth > listItemPos.depth) {
    return true;
  }
  return false;
};
var nextListIsHigher = (typeOrName, state) => {
  const listDepth = getNextListDepth(typeOrName, state);
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos || !listDepth) {
    return false;
  }
  if (listDepth < listItemPos.depth) {
    return true;
  }
  return false;
};
var handleDelete = (editor, name) => {
  if (!isNodeActive(editor.state, name)) {
    return false;
  }
  if (!isAtEndOfNode(editor.state, name)) {
    return false;
  }
  const { selection } = editor.state;
  const { $from, $to } = selection;
  if (!selection.empty && $from.sameParent($to)) {
    return false;
  }
  if (nextListIsDeeper(name, editor.state)) {
    return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();
  }
  if (nextListIsHigher(name, editor.state)) {
    return editor.chain().joinForward().joinBackward().run();
  }
  return editor.commands.joinItemForward();
};
var hasListItemAfter = (typeOrName, state) => {
  var _a;
  const { $anchor } = state.selection;
  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);
  if ($targetPos.index() === $targetPos.parent.childCount - 1) {
    return false;
  }
  if (((_a = $targetPos.nodeAfter) == null ? void 0 : _a.type.name) !== typeOrName) {
    return false;
  }
  return true;
};
var ListKeymap = Extension.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleDelete(editor, itemName)) {
            handled = true;
          }
        });
        return handled;
      },
      "Mod-Delete": ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleDelete(editor, itemName)) {
            handled = true;
          }
        });
        return handled;
      },
      Backspace: ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleBackspace(editor, itemName, wrapperNames)) {
            handled = true;
          }
        });
        return handled;
      },
      "Mod-Backspace": ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleBackspace(editor, itemName, wrapperNames)) {
            handled = true;
          }
        });
        return handled;
      }
    };
  }
});
var ListItemName2 = "listItem";
var TextStyleName2 = "textStyle";
var orderedListInputRegex = /^(\d+)\.\s$/;
var OrderedList = Node3.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      },
      type: {
        default: null,
        parseHTML: (element) => element.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start, ...attributesWithoutStart } = HTMLAttributes;
    return start === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands, chain }) => {
        if (this.options.keepAttributes) {
          return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();
        }
        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: orderedListInputRegex,
      type: this.type,
      getAttributes: (match) => ({ start: +match[1] }),
      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: orderedListInputRegex,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName2) }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
        editor: this.editor
      });
    }
    return [inputRule];
  }
});
var inputRegex4 = /^\s*(\[([( |x])?\])\s$/;
var TaskItem = Node3.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: false,
      HTMLAttributes: {},
      taskListTypeName: "taskList"
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: true,
  addAttributes() {
    return {
      checked: {
        default: false,
        keepOnSplit: false,
        parseHTML: (element) => {
          const dataChecked = element.getAttribute("data-checked");
          return dataChecked === "" || dataChecked === "true";
        },
        renderHTML: (attributes) => ({
          "data-checked": attributes.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "li",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: node.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const shortcuts = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    if (!this.options.nested) {
      return shortcuts;
    }
    return {
      ...shortcuts,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    };
  },
  addNodeView() {
    return ({ node, HTMLAttributes, getPos, editor }) => {
      const listItem = document.createElement("li");
      const checkboxWrapper = document.createElement("label");
      const checkboxStyler = document.createElement("span");
      const checkbox = document.createElement("input");
      const content = document.createElement("div");
      checkboxWrapper.contentEditable = "false";
      checkbox.type = "checkbox";
      checkbox.addEventListener("mousedown", (event) => event.preventDefault());
      checkbox.addEventListener("change", (event) => {
        if (!editor.isEditable && !this.options.onReadOnlyChecked) {
          checkbox.checked = !checkbox.checked;
          return;
        }
        const { checked } = event.target;
        if (editor.isEditable && typeof getPos === "function") {
          editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr: tr2 }) => {
            const position = getPos();
            if (typeof position !== "number") {
              return false;
            }
            const currentNode = tr2.doc.nodeAt(position);
            tr2.setNodeMarkup(position, void 0, {
              ...currentNode == null ? void 0 : currentNode.attrs,
              checked
            });
            return true;
          }).run();
        }
        if (!editor.isEditable && this.options.onReadOnlyChecked) {
          if (!this.options.onReadOnlyChecked(node, checked)) {
            checkbox.checked = !checkbox.checked;
          }
        }
      });
      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {
        listItem.setAttribute(key, value);
      });
      listItem.dataset.checked = node.attrs.checked;
      checkbox.checked = node.attrs.checked;
      checkboxWrapper.append(checkbox, checkboxStyler);
      listItem.append(checkboxWrapper, content);
      Object.entries(HTMLAttributes).forEach(([key, value]) => {
        listItem.setAttribute(key, value);
      });
      return {
        dom: listItem,
        contentDOM: content,
        update: (updatedNode) => {
          if (updatedNode.type !== this.type) {
            return false;
          }
          listItem.dataset.checked = updatedNode.attrs.checked;
          checkbox.checked = updatedNode.attrs.checked;
          return true;
        }
      };
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex4,
        type: this.type,
        getAttributes: (match) => ({
          checked: match[match.length - 1] === "x"
        })
      })
    ];
  }
});
var TaskList = Node3.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands }) => {
        return commands.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
var ListKit = Extension.create({
  name: "listKit",
  addExtensions() {
    const extensions = [];
    if (this.options.bulletList !== false) {
      extensions.push(BulletList.configure(this.options.bulletList));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem.configure(this.options.listItem));
    }
    if (this.options.listKeymap !== false) {
      extensions.push(ListKeymap.configure(this.options.listKeymap));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList.configure(this.options.orderedList));
    }
    if (this.options.taskItem !== false) {
      extensions.push(TaskItem.configure(this.options.taskItem));
    }
    if (this.options.taskList !== false) {
      extensions.push(TaskList.configure(this.options.taskList));
    }
    return extensions;
  }
});

// packages/forms/resources/js/components/rich-editor/extension-local-files.js
var allowedMimeTypes = ["image/png", "image/jpeg", "image/gif", "image/webp"];
var dispatchFormEvent = (editorView, name, detail = {}) => {
  editorView.dom.closest("form")?.dispatchEvent(
    new CustomEvent(name, {
      composed: true,
      cancelable: true,
      detail
    })
  );
};
var LocalFilesPlugin = ({
  editor,
  get$WireUsing,
  key,
  statePath,
  uploadingMessage
}) => {
  const getFileAttachmentUrl = (fileKey) => get$WireUsing().callSchemaComponentMethod(
    key,
    "getUploadedFileAttachmentTemporaryUrl",
    {
      attachment: fileKey
    }
  );
  return new Plugin({
    key: new PluginKey("localFiles"),
    props: {
      handleDrop(editorView, event) {
        if (!event.dataTransfer?.files.length) {
          return false;
        }
        const files = Array.from(event.dataTransfer.files).filter(
          (file) => allowedMimeTypes.includes(file.type)
        );
        if (!files.length) {
          return false;
        }
        dispatchFormEvent(editorView, "form-processing-started", {
          message: uploadingMessage
        });
        event.preventDefault();
        event.stopPropagation();
        const position = editorView.posAtCoords({
          left: event.clientX,
          top: event.clientY
        });
        files.forEach((file, fileIndex) => {
          editor.setEditable(false);
          editorView.dom.dispatchEvent(
            new CustomEvent("rich-editor-uploading-file", {
              bubbles: true,
              detail: {
                key,
                livewireId: get$WireUsing().id
              }
            })
          );
          const fileReader = new FileReader();
          fileReader.readAsDataURL(file);
          fileReader.onload = () => {
            editor.chain().insertContentAt(position?.pos ?? 0, {
              type: "image",
              attrs: {
                class: "fi-loading",
                src: fileReader.result
              }
            }).run();
          };
          let fileKey = ("10000000-1000-4000-8000" + -1e11).replace(
            /[018]/g,
            (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
          );
          get$WireUsing().upload(
            `componentFileAttachments.${statePath}.${fileKey}`,
            file,
            () => {
              getFileAttachmentUrl(fileKey).then((url) => {
                if (!url) {
                  return;
                }
                editor.chain().updateAttributes("image", {
                  class: null,
                  id: fileKey,
                  src: url
                }).run();
                editor.setEditable(true);
                editorView.dom.dispatchEvent(
                  new CustomEvent(
                    "rich-editor-uploaded-file",
                    {
                      bubbles: true,
                      detail: {
                        key,
                        livewireId: get$WireUsing().id
                      }
                    }
                  )
                );
                if (fileIndex === files.length - 1) {
                  dispatchFormEvent(
                    editorView,
                    "form-processing-finished"
                  );
                }
              });
            }
          );
        });
        return true;
      },
      handlePaste(editorView, event) {
        if (!event.clipboardData?.files.length) {
          return false;
        }
        const files = Array.from(event.clipboardData.files).filter(
          (file) => allowedMimeTypes.includes(file.type)
        );
        if (!files.length) {
          return false;
        }
        event.preventDefault();
        event.stopPropagation();
        dispatchFormEvent(editorView, "form-processing-started", {
          message: uploadingMessage
        });
        files.forEach((file, fileIndex) => {
          editor.setEditable(false);
          editorView.dom.dispatchEvent(
            new CustomEvent("rich-editor-uploading-file", {
              bubbles: true,
              detail: {
                key,
                livewireId: get$WireUsing().id
              }
            })
          );
          const fileReader = new FileReader();
          fileReader.readAsDataURL(file);
          fileReader.onload = () => {
            editor.chain().insertContentAt(editor.state.selection.anchor, {
              type: "image",
              attrs: {
                class: "fi-loading",
                src: fileReader.result
              }
            }).run();
          };
          let fileKey = ("10000000-1000-4000-8000" + -1e11).replace(
            /[018]/g,
            (c) => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
          );
          get$WireUsing().upload(
            `componentFileAttachments.${statePath}.${fileKey}`,
            file,
            () => {
              getFileAttachmentUrl(fileKey).then((url) => {
                if (!url) {
                  return;
                }
                editor.chain().updateAttributes("image", {
                  class: null,
                  id: fileKey,
                  src: url
                }).run();
                editor.setEditable(true);
                editorView.dom.dispatchEvent(
                  new CustomEvent(
                    "rich-editor-uploaded-file",
                    {
                      bubbles: true,
                      detail: {
                        key,
                        livewireId: get$WireUsing().id
                      }
                    }
                  )
                );
                if (fileIndex === files.length - 1) {
                  dispatchFormEvent(
                    editorView,
                    "form-processing-finished"
                  );
                }
              });
            }
          );
        });
        return true;
      }
    }
  });
};
var extension_local_files_default = Extension.create({
  name: "localFiles",
  addOptions() {
    return {
      key: null,
      statePath: null,
      uploadingMessage: null,
      get$WireUsing: null
    };
  },
  addProseMirrorPlugins() {
    return [
      LocalFilesPlugin({
        editor: this.editor,
        ...this.options
      })
    ];
  }
});

// node_modules/@tiptap/suggestion/dist/index.js
function findSuggestionMatch(config) {
  var _a;
  const { char, allowSpaces: allowSpacesOption, allowToIncludeChar, allowedPrefixes, startOfLine, $position } = config;
  const allowSpaces = allowSpacesOption && !allowToIncludeChar;
  const escapedChar = escapeForRegEx(char);
  const suffix = new RegExp(`\\s${escapedChar}$`);
  const prefix = startOfLine ? "^" : "";
  const finalEscapedChar = allowToIncludeChar ? "" : escapedChar;
  const regexp = allowSpaces ? new RegExp(`${prefix}${escapedChar}.*?(?=\\s${finalEscapedChar}|$)`, "gm") : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\s${finalEscapedChar}]*`, "gm");
  const text = ((_a = $position.nodeBefore) == null ? void 0 : _a.isText) && $position.nodeBefore.text;
  if (!text) {
    return null;
  }
  const textFrom = $position.pos - text.length;
  const match = Array.from(text.matchAll(regexp)).pop();
  if (!match || match.input === void 0 || match.index === void 0) {
    return null;
  }
  const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);
  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes == null ? void 0 : allowedPrefixes.join("")}\0]?$`).test(matchPrefix);
  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {
    return null;
  }
  const from2 = textFrom + match.index;
  let to = from2 + match[0].length;
  if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {
    match[0] += " ";
    to += 1;
  }
  if (from2 < $position.pos && to >= $position.pos) {
    return {
      range: {
        from: from2,
        to
      },
      query: match[0].slice(char.length),
      text: match[0]
    };
  }
  return null;
}
var SuggestionPluginKey = new PluginKey("suggestion");
function Suggestion({
  pluginKey = SuggestionPluginKey,
  editor,
  char = "@",
  allowSpaces = false,
  allowToIncludeChar = false,
  allowedPrefixes = [" "],
  startOfLine = false,
  decorationTag = "span",
  decorationClass = "suggestion",
  command: command2 = () => null,
  items = () => [],
  render = () => ({}),
  allow = () => true,
  findSuggestionMatch: findSuggestionMatch2 = findSuggestionMatch
}) {
  let props;
  const renderer = render == null ? void 0 : render();
  const plugin = new Plugin({
    key: pluginKey,
    view() {
      return {
        update: async (view, prevState) => {
          var _a, _b, _c, _d, _e, _f, _g;
          const prev = (_a = this.key) == null ? void 0 : _a.getState(prevState);
          const next = (_b = this.key) == null ? void 0 : _b.getState(view.state);
          const moved = prev.active && next.active && prev.range.from !== next.range.from;
          const started = !prev.active && next.active;
          const stopped = prev.active && !next.active;
          const changed = !started && !stopped && prev.query !== next.query;
          const handleStart = started || moved && changed;
          const handleChange = changed || moved;
          const handleExit = stopped || moved && changed;
          if (!handleStart && !handleChange && !handleExit) {
            return;
          }
          const state = handleExit && !handleStart ? prev : next;
          const decorationNode = view.dom.querySelector(`[data-decoration-id="${state.decorationId}"]`);
          props = {
            editor,
            range: state.range,
            query: state.query,
            text: state.text,
            items: [],
            command: (commandProps) => {
              return command2({
                editor,
                range: state.range,
                props: commandProps
              });
            },
            decorationNode,
            // virtual node for positioning
            // this can be used for building popups without a DOM node
            clientRect: decorationNode ? () => {
              var _a2;
              const { decorationId } = (_a2 = this.key) == null ? void 0 : _a2.getState(editor.state);
              const currentDecorationNode = view.dom.querySelector(`[data-decoration-id="${decorationId}"]`);
              return (currentDecorationNode == null ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;
            } : null
          };
          if (handleStart) {
            (_c = renderer == null ? void 0 : renderer.onBeforeStart) == null ? void 0 : _c.call(renderer, props);
          }
          if (handleChange) {
            (_d = renderer == null ? void 0 : renderer.onBeforeUpdate) == null ? void 0 : _d.call(renderer, props);
          }
          if (handleChange || handleStart) {
            props.items = await items({
              editor,
              query: state.query
            });
          }
          if (handleExit) {
            (_e = renderer == null ? void 0 : renderer.onExit) == null ? void 0 : _e.call(renderer, props);
          }
          if (handleChange) {
            (_f = renderer == null ? void 0 : renderer.onUpdate) == null ? void 0 : _f.call(renderer, props);
          }
          if (handleStart) {
            (_g = renderer == null ? void 0 : renderer.onStart) == null ? void 0 : _g.call(renderer, props);
          }
        },
        destroy: () => {
          var _a;
          if (!props) {
            return;
          }
          (_a = renderer == null ? void 0 : renderer.onExit) == null ? void 0 : _a.call(renderer, props);
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init() {
        const state = {
          active: false,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: false
        };
        return state;
      },
      // Apply changes to the plugin state from a view transaction.
      apply(transaction, prev, _oldState, state) {
        const { isEditable } = editor;
        const { composing } = editor.view;
        const { selection } = transaction;
        const { empty: empty2, from: from2 } = selection;
        const next = { ...prev };
        next.composing = composing;
        if (isEditable && (empty2 || editor.view.composing)) {
          if ((from2 < prev.range.from || from2 > prev.range.to) && !composing && !prev.composing) {
            next.active = false;
          }
          const match = findSuggestionMatch2({
            char,
            allowSpaces,
            allowToIncludeChar,
            allowedPrefixes,
            startOfLine,
            $position: selection.$from
          });
          const decorationId = `id_${Math.floor(Math.random() * 4294967295)}`;
          if (match && allow({
            editor,
            state,
            range: match.range,
            isActive: prev.active
          })) {
            next.active = true;
            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;
            next.range = match.range;
            next.query = match.query;
            next.text = match.text;
          } else {
            next.active = false;
          }
        } else {
          next.active = false;
        }
        if (!next.active) {
          next.decorationId = null;
          next.range = { from: 0, to: 0 };
          next.query = null;
          next.text = null;
        }
        return next;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown(view, event) {
        var _a;
        const { active, range } = plugin.getState(view.state);
        if (!active) {
          return false;
        }
        return ((_a = renderer == null ? void 0 : renderer.onKeyDown) == null ? void 0 : _a.call(renderer, { view, event, range })) || false;
      },
      // Setup decorator on the currently active suggestion.
      decorations(state) {
        const { active, range, decorationId } = plugin.getState(state);
        if (!active) {
          return null;
        }
        return DecorationSet.create(state.doc, [
          Decoration.inline(range.from, range.to, {
            nodeName: decorationTag,
            class: decorationClass,
            "data-decoration-id": decorationId
          })
        ]);
      }
    }
  });
  return plugin;
}
var index_default11 = Suggestion;

// packages/forms/resources/js/components/rich-editor/extension-merge-tag.js
var getSuggestionOptions = function({
  editor: tiptapEditor,
  overrideSuggestionOptions,
  extensionName
}) {
  const pluginKey = new PluginKey();
  return {
    editor: tiptapEditor,
    char: "{{",
    pluginKey,
    command: ({ editor, range, props }) => {
      const nodeAfter = editor.view.state.selection.$to.nodeAfter;
      const overrideSpace = nodeAfter?.text?.startsWith(" ");
      if (overrideSpace) {
        range.to += 1;
      }
      editor.chain().focus().insertContentAt(range, [
        {
          type: extensionName,
          attrs: { ...props }
        },
        {
          type: "text",
          text: " "
        }
      ]).run();
      editor.view.dom.ownerDocument.defaultView?.getSelection()?.collapseToEnd();
    },
    allow: ({ state, range }) => {
      const $from = state.doc.resolve(range.from);
      const type = state.schema.nodes[extensionName];
      const allow = !!$from.parent.type.contentMatch.matchType(type);
      return allow;
    },
    ...overrideSuggestionOptions
  };
};
var extension_merge_tag_default = Node3.create({
  name: "mergeTag",
  priority: 101,
  addStorage() {
    return {
      suggestions: [],
      getSuggestionFromChar: () => null
    };
  },
  addOptions() {
    return {
      HTMLAttributes: {},
      renderText({ node }) {
        return `{{ ${node.attrs.label ?? node.attrs.id} }}`;
      },
      deleteTriggerWithBackspace: false,
      renderHTML({ options, node }) {
        return [
          "span",
          mergeAttributes(
            this.HTMLAttributes,
            options.HTMLAttributes
          ),
          `${node.attrs.label ?? node.attrs.id}`
        ];
      },
      suggestions: [],
      suggestion: {}
    };
  },
  group: "inline",
  inline: true,
  selectable: false,
  atom: true,
  addAttributes() {
    return {
      id: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-id"),
        renderHTML: (attributes) => {
          if (!attributes.id) {
            return {};
          }
          return {
            "data-id": attributes.id
          };
        }
      },
      label: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-label"),
        renderHTML: (attributes) => {
          if (!attributes.label) {
            return {};
          }
          return {
            "data-label": attributes.label
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `span[data-type="${this.name}"]`
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    const suggestion = this.editor?.extensionStorage?.[this.name]?.getSuggestionFromChar(
      "{{"
    );
    const mergedOptions = { ...this.options };
    mergedOptions.HTMLAttributes = mergeAttributes(
      { "data-type": this.name },
      this.options.HTMLAttributes,
      HTMLAttributes
    );
    const html = this.options.renderHTML({
      options: mergedOptions,
      node,
      suggestion
    });
    if (typeof html === "string") {
      return [
        "span",
        mergeAttributes(
          { "data-type": this.name },
          this.options.HTMLAttributes,
          HTMLAttributes
        ),
        html
      ];
    }
    return html;
  },
  renderText({ node }) {
    const args = {
      options: this.options,
      node,
      suggestion: this.editor?.extensionStorage?.[this.name]?.getSuggestionFromChar("{{")
    };
    return this.options.renderText(args);
  },
  addKeyboardShortcuts() {
    return {
      Backspace: () => this.editor.commands.command(({ tr: tr2, state }) => {
        let isMergeTag = false;
        const { selection } = state;
        const { empty: empty2, anchor } = selection;
        if (!empty2) {
          return false;
        }
        let mergeTagNode = new Node2();
        let mergeTagPos = 0;
        state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {
          if (node.type.name === this.name) {
            isMergeTag = true;
            mergeTagNode = node;
            mergeTagPos = pos;
            return false;
          }
        });
        if (isMergeTag) {
          tr2.insertText(
            this.options.deleteTriggerWithBackspace ? "" : "{{",
            mergeTagPos,
            mergeTagPos + mergeTagNode.nodeSize
          );
        }
        return isMergeTag;
      })
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.storage.suggestions.map(index_default11),
      // Create a plugin for each suggestion configuration
      new Plugin({
        props: {
          handleDrop(view, event) {
            if (!event) {
              return false;
            }
            event.preventDefault();
            if (!event.dataTransfer.getData("mergeTag")) {
              return false;
            }
            const mergeTagId = event.dataTransfer.getData("mergeTag");
            view.dispatch(
              view.state.tr.insert(
                view.posAtCoords({
                  left: event.clientX,
                  top: event.clientY
                }).pos,
                view.state.schema.nodes.mergeTag.create({
                  id: mergeTagId
                })
              )
            );
            return false;
          }
        }
      })
    ];
  },
  onBeforeCreate() {
    this.storage.suggestions = (this.options.suggestions.length ? this.options.suggestions : [this.options.suggestion]).map(
      (suggestion) => getSuggestionOptions({
        editor: this.editor,
        overrideSuggestionOptions: suggestion,
        extensionName: this.name
      })
    );
    this.storage.getSuggestionFromChar = (char) => {
      const suggestion = this.storage.suggestions.find(
        (s) => s.char === char
      );
      if (suggestion) {
        return suggestion;
      }
      if (this.storage.suggestions.length) {
        return this.storage.suggestions[0];
      }
      return null;
    };
  }
});

// node_modules/@tiptap/extension-paragraph/dist/index.js
var Paragraph = Node3.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands }) => {
        return commands.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});
var index_default12 = Paragraph;

// node_modules/@tiptap/extension-placeholder/dist/index.js
var index_default13 = Placeholder;

// node_modules/@tiptap/extension-strike/dist/index.js
var inputRegex5 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
var pasteRegex2 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
var Strike = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleStrike: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex5,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex2,
        type: this.type
      })
    ];
  }
});
var index_default14 = Strike;

// node_modules/@tiptap/extension-subscript/dist/index.js
var Subscript = Mark2.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "sub") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sub", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleSubscript: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetSubscript: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
});
var index_default15 = Subscript;

// node_modules/@tiptap/extension-superscript/dist/index.js
var Superscript = Mark2.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(value) {
          if (value !== "super") {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["sup", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleSuperscript: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetSuperscript: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
});
var index_default16 = Superscript;

// node_modules/prosemirror-tables/dist/index.js
var readFromCache;
var addToCache;
if (typeof WeakMap != "undefined") {
  let cache = /* @__PURE__ */ new WeakMap();
  readFromCache = (key) => cache.get(key);
  addToCache = (key, value) => {
    cache.set(key, value);
    return value;
  };
} else {
  const cache = [];
  const cacheSize = 10;
  let cachePos = 0;
  readFromCache = (key) => {
    for (let i = 0; i < cache.length; i += 2)
      if (cache[i] == key) return cache[i + 1];
  };
  addToCache = (key, value) => {
    if (cachePos == cacheSize) cachePos = 0;
    cache[cachePos++] = key;
    return cache[cachePos++] = value;
  };
}
var TableMap = class {
  constructor(width, height, map2, problems) {
    this.width = width;
    this.height = height;
    this.map = map2;
    this.problems = problems;
  }
  // Find the dimensions of the cell at the given position.
  findCell(pos) {
    for (let i = 0; i < this.map.length; i++) {
      const curPos = this.map[i];
      if (curPos != pos) continue;
      const left = i % this.width;
      const top = i / this.width | 0;
      let right = left + 1;
      let bottom = top + 1;
      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {
        right++;
      }
      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {
        bottom++;
      }
      return { left, top, right, bottom };
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(pos) {
    for (let i = 0; i < this.map.length; i++) {
      if (this.map[i] == pos) {
        return i % this.width;
      }
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(pos, axis, dir) {
    const { left, right, top, bottom } = this.findCell(pos);
    if (axis == "horiz") {
      if (dir < 0 ? left == 0 : right == this.width) return null;
      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];
    } else {
      if (dir < 0 ? top == 0 : bottom == this.height) return null;
      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];
    }
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(a, b) {
    const {
      left: leftA,
      right: rightA,
      top: topA,
      bottom: bottomA
    } = this.findCell(a);
    const {
      left: leftB,
      right: rightB,
      top: topB,
      bottom: bottomB
    } = this.findCell(b);
    return {
      left: Math.min(leftA, leftB),
      top: Math.min(topA, topB),
      right: Math.max(rightA, rightB),
      bottom: Math.max(bottomA, bottomB)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(rect) {
    const result = [];
    const seen = {};
    for (let row = rect.top; row < rect.bottom; row++) {
      for (let col = rect.left; col < rect.right; col++) {
        const index = row * this.width + col;
        const pos = this.map[index];
        if (seen[pos]) continue;
        seen[pos] = true;
        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {
          continue;
        }
        result.push(pos);
      }
    }
    return result;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(row, col, table) {
    for (let i = 0, rowStart = 0; ; i++) {
      const rowEnd = rowStart + table.child(i).nodeSize;
      if (i == row) {
        let index = col + row * this.width;
        const rowEndIndex = (row + 1) * this.width;
        while (index < rowEndIndex && this.map[index] < rowStart) index++;
        return index == rowEndIndex ? rowEnd - 1 : this.map[index];
      }
      rowStart = rowEnd;
    }
  }
  // Find the table map for the given table node.
  static get(table) {
    return readFromCache(table) || addToCache(table, computeMap(table));
  }
};
function computeMap(table) {
  if (table.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + table.type.name);
  const width = findWidth(table), height = table.childCount;
  const map2 = [];
  let mapPos = 0;
  let problems = null;
  const colWidths = [];
  for (let i = 0, e = width * height; i < e; i++) map2[i] = 0;
  for (let row = 0, pos = 0; row < height; row++) {
    const rowNode = table.child(row);
    pos++;
    for (let i = 0; ; i++) {
      while (mapPos < map2.length && map2[mapPos] != 0) mapPos++;
      if (i == rowNode.childCount) break;
      const cellNode = rowNode.child(i);
      const { colspan, rowspan, colwidth } = cellNode.attrs;
      for (let h2 = 0; h2 < rowspan; h2++) {
        if (h2 + row >= height) {
          (problems || (problems = [])).push({
            type: "overlong_rowspan",
            pos,
            n: rowspan - h2
          });
          break;
        }
        const start = mapPos + h2 * width;
        for (let w = 0; w < colspan; w++) {
          if (map2[start + w] == 0) map2[start + w] = pos;
          else
            (problems || (problems = [])).push({
              type: "collision",
              row,
              pos,
              n: colspan - w
            });
          const colW = colwidth && colwidth[w];
          if (colW) {
            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    const expectedPos = (row + 1) * width;
    let missing = 0;
    while (mapPos < expectedPos) if (map2[mapPos++] == 0) missing++;
    if (missing)
      (problems || (problems = [])).push({ type: "missing", row, n: missing });
    pos++;
  }
  if (width === 0 || height === 0)
    (problems || (problems = [])).push({ type: "zero_sized" });
  const tableMap = new TableMap(width, height, map2, problems);
  let badWidths = false;
  for (let i = 0; !badWidths && i < colWidths.length; i += 2)
    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;
  if (badWidths) findBadColWidths(tableMap, colWidths, table);
  return tableMap;
}
function findWidth(table) {
  let width = -1;
  let hasRowSpan = false;
  for (let row = 0; row < table.childCount; row++) {
    const rowNode = table.child(row);
    let rowWidth = 0;
    if (hasRowSpan)
      for (let j = 0; j < row; j++) {
        const prevRow = table.child(j);
        for (let i = 0; i < prevRow.childCount; i++) {
          const cell = prevRow.child(i);
          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;
        }
      }
    for (let i = 0; i < rowNode.childCount; i++) {
      const cell = rowNode.child(i);
      rowWidth += cell.attrs.colspan;
      if (cell.attrs.rowspan > 1) hasRowSpan = true;
    }
    if (width == -1) width = rowWidth;
    else if (width != rowWidth) width = Math.max(width, rowWidth);
  }
  return width;
}
function findBadColWidths(map2, colWidths, table) {
  if (!map2.problems) map2.problems = [];
  const seen = {};
  for (let i = 0; i < map2.map.length; i++) {
    const pos = map2.map[i];
    if (seen[pos]) continue;
    seen[pos] = true;
    const node = table.nodeAt(pos);
    if (!node) {
      throw new RangeError(`No cell with offset ${pos} found`);
    }
    let updated = null;
    const attrs = node.attrs;
    for (let j = 0; j < attrs.colspan; j++) {
      const col = (i + j) % map2.width;
      const colWidth = colWidths[col * 2];
      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))
        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;
    }
    if (updated)
      map2.problems.unshift({
        type: "colwidth mismatch",
        pos,
        colwidth: updated
      });
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth) return attrs.colwidth.slice();
  const result = [];
  for (let i = 0; i < attrs.colspan; i++) result.push(0);
  return result;
}
function tableNodeTypes(schema) {
  let result = schema.cached.tableNodeTypes;
  if (!result) {
    result = schema.cached.tableNodeTypes = {};
    for (const name in schema.nodes) {
      const type = schema.nodes[name], role = type.spec.tableRole;
      if (role) result[role] = type;
    }
  }
  return result;
}
var tableEditingKey = new PluginKey("selectingCells");
function cellAround($pos) {
  for (let d = $pos.depth - 1; d > 0; d--)
    if ($pos.node(d).type.spec.tableRole == "row")
      return $pos.node(0).resolve($pos.before(d + 1));
  return null;
}
function cellWrapping($pos) {
  for (let d = $pos.depth; d > 0; d--) {
    const role = $pos.node(d).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") return $pos.node(d);
  }
  return null;
}
function isInTable(state) {
  const $head = state.selection.$head;
  for (let d = $head.depth; d > 0; d--)
    if ($head.node(d).type.spec.tableRole == "row") return true;
  return false;
}
function selectionCell(state) {
  const sel = state.selection;
  if ("$anchorCell" in sel && sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor;
  }
  const $cell = cellAround(sel.$head) || cellNear(sel.$head);
  if ($cell) {
    return $cell;
  }
  throw new RangeError(`No cell found around position ${sel.head}`);
}
function cellNear($pos) {
  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
    const role = after.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") return $pos.doc.resolve(pos);
  }
  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {
    const role = before.type.spec.tableRole;
    if (role == "cell" || role == "header_cell")
      return $pos.doc.resolve(pos - before.nodeSize);
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
}
function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
}
function inSameTable($cellA, $cellB) {
  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
}
function nextCell($pos, axis, dir) {
  const table = $pos.node(-1);
  const map2 = TableMap.get(table);
  const tableStart = $pos.start(-1);
  const moved = map2.nextCell($pos.pos - tableStart, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);
}
function removeColSpan(attrs, pos, n = 1) {
  const result = { ...attrs, colspan: attrs.colspan - n };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    result.colwidth.splice(pos, n);
    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;
  }
  return result;
}
function addColSpan(attrs, pos, n = 1) {
  const result = { ...attrs, colspan: attrs.colspan + n };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);
  }
  return result;
}
function columnIsHeader(map2, table, col) {
  const headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (let row = 0; row < map2.height; row++)
    if (table.nodeAt(map2.map[col + row * map2.width]).type != headerCell)
      return false;
  return true;
}
var CellSelection = class _CellSelection extends Selection {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const rect = map2.rectBetween(
      $anchorCell.pos - tableStart,
      $headCell.pos - tableStart
    );
    const doc3 = $anchorCell.node(0);
    const cells = map2.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);
    cells.unshift($headCell.pos - tableStart);
    const ranges = cells.map((pos) => {
      const cell = table.nodeAt(pos);
      if (!cell) {
        throw RangeError(`No cell with offset ${pos} found`);
      }
      const from2 = tableStart + pos + 1;
      return new SelectionRange(
        doc3.resolve(from2),
        doc3.resolve(from2 + cell.content.size)
      );
    });
    super(ranges[0].$from, ranges[0].$to, ranges);
    this.$anchorCell = $anchorCell;
    this.$headCell = $headCell;
  }
  map(doc3, mapping) {
    const $anchorCell = doc3.resolve(mapping.map(this.$anchorCell.pos));
    const $headCell = doc3.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection())
        return _CellSelection.rowSelection($anchorCell, $headCell);
      else if (tableChanged && this.isColSelection())
        return _CellSelection.colSelection($anchorCell, $headCell);
      else return new _CellSelection($anchorCell, $headCell);
    }
    return TextSelection.between($anchorCell, $headCell);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const table = this.$anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const rect = map2.rectBetween(
      this.$anchorCell.pos - tableStart,
      this.$headCell.pos - tableStart
    );
    const seen = {};
    const rows = [];
    for (let row = rect.top; row < rect.bottom; row++) {
      const rowContent = [];
      for (let index = row * map2.width + rect.left, col = rect.left; col < rect.right; col++, index++) {
        const pos = map2.map[index];
        if (seen[pos]) continue;
        seen[pos] = true;
        const cellRect = map2.findCell(pos);
        let cell = table.nodeAt(pos);
        if (!cell) {
          throw RangeError(`No cell with offset ${pos} found`);
        }
        const extraLeft = rect.left - cellRect.left;
        const extraRight = cellRect.right - rect.right;
        if (extraLeft > 0 || extraRight > 0) {
          let attrs = cell.attrs;
          if (extraLeft > 0) {
            attrs = removeColSpan(attrs, 0, extraLeft);
          }
          if (extraRight > 0) {
            attrs = removeColSpan(
              attrs,
              attrs.colspan - extraRight,
              extraRight
            );
          }
          if (cellRect.left < rect.left) {
            cell = cell.type.createAndFill(attrs);
            if (!cell) {
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(attrs)}`
              );
            }
          } else {
            cell = cell.type.create(attrs, cell.content);
          }
        }
        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
          const attrs = {
            ...cell.attrs,
            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
          };
          if (cellRect.top < rect.top) {
            cell = cell.type.createAndFill(attrs);
          } else {
            cell = cell.type.create(attrs, cell.content);
          }
        }
        rowContent.push(cell);
      }
      rows.push(table.child(row).copy(Fragment.from(rowContent)));
    }
    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
    return new Slice(Fragment.from(fragment), 1, 1);
  }
  replace(tr2, content = Slice.empty) {
    const mapFrom = tr2.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      const { $from, $to } = ranges[i], mapping = tr2.mapping.slice(mapFrom);
      tr2.replace(
        mapping.map($from.pos),
        mapping.map($to.pos),
        i ? Slice.empty : content
      );
    }
    const sel = Selection.findFrom(
      tr2.doc.resolve(tr2.mapping.slice(mapFrom).map(this.to)),
      -1
    );
    if (sel) tr2.setSelection(sel);
  }
  replaceWith(tr2, node) {
    this.replace(tr2, new Slice(Fragment.from(node), 0, 0));
  }
  forEachCell(f) {
    const table = this.$anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const cells = map2.cellsInRect(
      map2.rectBetween(
        this.$anchorCell.pos - tableStart,
        this.$headCell.pos - tableStart
      )
    );
    for (let i = 0; i < cells.length; i++) {
      f(table.nodeAt(cells[i]), tableStart + cells[i]);
    }
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const anchorTop = this.$anchorCell.index(-1);
    const headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0) return false;
    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map2.findCell($anchorCell.pos - tableStart);
    const headRect = map2.findCell($headCell.pos - tableStart);
    const doc3 = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0)
        $anchorCell = doc3.resolve(tableStart + map2.map[anchorRect.left]);
      if (headRect.bottom < map2.height)
        $headCell = doc3.resolve(
          tableStart + map2.map[map2.width * (map2.height - 1) + headRect.right - 1]
        );
    } else {
      if (headRect.top > 0)
        $headCell = doc3.resolve(tableStart + map2.map[headRect.left]);
      if (anchorRect.bottom < map2.height)
        $anchorCell = doc3.resolve(
          tableStart + map2.map[map2.width * (map2.height - 1) + anchorRect.right - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const table = this.$anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const anchorLeft = map2.colCount(this.$anchorCell.pos - tableStart);
    const headLeft = map2.colCount(this.$headCell.pos - tableStart);
    if (Math.min(anchorLeft, headLeft) > 0) return false;
    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map2.width;
  }
  eq(other) {
    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map2.findCell($anchorCell.pos - tableStart);
    const headRect = map2.findCell($headCell.pos - tableStart);
    const doc3 = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0)
        $anchorCell = doc3.resolve(
          tableStart + map2.map[anchorRect.top * map2.width]
        );
      if (headRect.right < map2.width)
        $headCell = doc3.resolve(
          tableStart + map2.map[map2.width * (headRect.top + 1) - 1]
        );
    } else {
      if (headRect.left > 0)
        $headCell = doc3.resolve(tableStart + map2.map[headRect.top * map2.width]);
      if (anchorRect.right < map2.width)
        $anchorCell = doc3.resolve(
          tableStart + map2.map[map2.width * (anchorRect.top + 1) - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(doc3, json) {
    return new _CellSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));
  }
  static create(doc3, anchorCell, headCell = anchorCell) {
    return new _CellSelection(doc3.resolve(anchorCell), doc3.resolve(headCell));
  }
  getBookmark() {
    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
  }
};
CellSelection.prototype.visible = false;
Selection.jsonID("cell", CellSelection);
var CellBookmark = class _CellBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc3) {
    const $anchorCell = doc3.resolve(this.anchor), $headCell = doc3.resolve(this.head);
    if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
      return new CellSelection($anchorCell, $headCell);
    else return Selection.near($headCell, 1);
  }
};
function drawCellSelection(state) {
  if (!(state.selection instanceof CellSelection)) return null;
  const cells = [];
  state.selection.forEachCell((node, pos) => {
    cells.push(
      Decoration.node(pos, pos + node.nodeSize, { class: "selectedCell" })
    );
  });
  return DecorationSet.create(state.doc, cells);
}
function isCellBoundarySelection({ $from, $to }) {
  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;
  let afterFrom = $from.pos;
  let beforeTo = $to.pos;
  let depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++)
    if ($from.after(depth + 1) < $from.end(depth)) break;
  for (let d = $to.depth; d >= 0; d--, beforeTo--)
    if ($to.before(d + 1) > $to.start(d)) break;
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells({ $from, $to }) {
  let fromCellBoundaryNode;
  let toCellBoundaryNode;
  for (let i = $from.depth; i > 0; i--) {
    const node = $from.node(i);
    if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node;
      break;
    }
  }
  for (let i = $to.depth; i > 0; i--) {
    const node = $to.node(i);
    if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = node;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state, tr2, allowTableNodeSelection) {
  const sel = (tr2 || state).selection;
  const doc3 = (tr2 || state).doc;
  let normalize2;
  let role;
  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize2 = CellSelection.create(doc3, sel.from);
    } else if (role == "row") {
      const $cell = doc3.resolve(sel.from + 1);
      normalize2 = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      const map2 = TableMap.get(sel.node);
      const start = sel.from + 1;
      const lastCell = start + map2.map[map2.width * map2.height - 1];
      normalize2 = CellSelection.create(doc3, start + 1, lastCell);
    }
  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
    normalize2 = TextSelection.create(doc3, sel.from);
  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
    normalize2 = TextSelection.create(doc3, sel.$from.start(), sel.$from.end());
  }
  if (normalize2) (tr2 || (tr2 = state.tr)).setSelection(normalize2);
  return tr2;
}
var fixTablesKey = new PluginKey("fix-tables");
function changedDescendants(old, cur, offset3, f) {
  const oldSize = old.childCount, curSize = cur.childCount;
  outer: for (let i = 0, j = 0; i < curSize; i++) {
    const child = cur.child(i);
    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {
      if (old.child(scan) == child) {
        j = scan + 1;
        offset3 += child.nodeSize;
        continue outer;
      }
    }
    f(child, offset3);
    if (j < oldSize && old.child(j).sameMarkup(child))
      changedDescendants(old.child(j), child, offset3 + 1, f);
    else child.nodesBetween(0, child.content.size, f, offset3 + 1);
    offset3 += child.nodeSize;
  }
}
function fixTables(state, oldState) {
  let tr2;
  const check = (node, pos) => {
    if (node.type.spec.tableRole == "table")
      tr2 = fixTable(state, node, pos, tr2);
  };
  if (!oldState) state.doc.descendants(check);
  else if (oldState.doc != state.doc)
    changedDescendants(oldState.doc, state.doc, 0, check);
  return tr2;
}
function fixTable(state, table, tablePos, tr2) {
  const map2 = TableMap.get(table);
  if (!map2.problems) return tr2;
  if (!tr2) tr2 = state.tr;
  const mustAdd = [];
  for (let i = 0; i < map2.height; i++) mustAdd.push(0);
  for (let i = 0; i < map2.problems.length; i++) {
    const prob = map2.problems[i];
    if (prob.type == "collision") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      const attrs = cell.attrs;
      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;
      tr2.setNodeMarkup(
        tr2.mapping.map(tablePos + 1 + prob.pos),
        null,
        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)
      );
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr2.setNodeMarkup(tr2.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        rowspan: cell.attrs.rowspan - prob.n
      });
    } else if (prob.type == "colwidth mismatch") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr2.setNodeMarkup(tr2.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        colwidth: prob.colwidth
      });
    } else if (prob.type == "zero_sized") {
      const pos = tr2.mapping.map(tablePos);
      tr2.delete(pos, pos + table.nodeSize);
    }
  }
  let first2, last;
  for (let i = 0; i < mustAdd.length; i++)
    if (mustAdd[i]) {
      if (first2 == null) first2 = i;
      last = i;
    }
  for (let i = 0, pos = tablePos + 1; i < map2.height; i++) {
    const row = table.child(i);
    const end = pos + row.nodeSize;
    const add = mustAdd[i];
    if (add > 0) {
      let role = "cell";
      if (row.firstChild) {
        role = row.firstChild.type.spec.tableRole;
      }
      const nodes = [];
      for (let j = 0; j < add; j++) {
        const node = tableNodeTypes(state.schema)[role].createAndFill();
        if (node) nodes.push(node);
      }
      const side = (i == 0 || first2 == i - 1) && last == i ? pos + 1 : end - 1;
      tr2.insert(tr2.mapping.map(side), nodes);
    }
    pos = end;
  }
  return tr2.setMeta(fixTablesKey, { fixTables: true });
}
function selectedRect(state) {
  const sel = state.selection;
  const $pos = selectionCell(state);
  const table = $pos.node(-1);
  const tableStart = $pos.start(-1);
  const map2 = TableMap.get(table);
  const rect = sel instanceof CellSelection ? map2.rectBetween(
    sel.$anchorCell.pos - tableStart,
    sel.$headCell.pos - tableStart
  ) : map2.findCell($pos.pos - tableStart);
  return { ...rect, tableStart, map: map2, table };
}
function addColumn(tr2, { map: map2, tableStart, table }, col) {
  let refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map2, table, col + refColumn)) {
    refColumn = col == 0 || col == map2.width ? null : 0;
  }
  for (let row = 0; row < map2.height; row++) {
    const index = row * map2.width + col;
    if (col > 0 && col < map2.width && map2.map[index - 1] == map2.map[index]) {
      const pos = map2.map[index];
      const cell = table.nodeAt(pos);
      tr2.setNodeMarkup(
        tr2.mapping.map(tableStart + pos),
        null,
        addColSpan(cell.attrs, col - map2.colCount(pos))
      );
      row += cell.attrs.rowspan - 1;
    } else {
      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map2.map[index + refColumn]).type;
      const pos = map2.positionAt(row, col, table);
      tr2.insert(tr2.mapping.map(tableStart + pos), type.createAndFill());
    }
  }
  return tr2;
}
function addColumnBefore(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.left));
  }
  return true;
}
function addColumnAfter(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr2, { map: map2, table, tableStart }, col) {
  const mapStart = tr2.mapping.maps.length;
  for (let row = 0; row < map2.height; ) {
    const index = row * map2.width + col;
    const pos = map2.map[index];
    const cell = table.nodeAt(pos);
    const attrs = cell.attrs;
    if (col > 0 && map2.map[index - 1] == pos || col < map2.width - 1 && map2.map[index + 1] == pos) {
      tr2.setNodeMarkup(
        tr2.mapping.slice(mapStart).map(tableStart + pos),
        null,
        removeColSpan(attrs, col - map2.colCount(pos))
      );
    } else {
      const start = tr2.mapping.slice(mapStart).map(tableStart + pos);
      tr2.delete(start, start + cell.nodeSize);
    }
    row += attrs.rowspan;
  }
}
function deleteColumn(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    const tr2 = state.tr;
    if (rect.left == 0 && rect.right == rect.map.width) return false;
    for (let i = rect.right - 1; ; i--) {
      removeColumn(tr2, rect, i);
      if (i == rect.left) break;
      const table = rect.tableStart ? tr2.doc.nodeAt(rect.tableStart - 1) : tr2.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(table);
    }
    dispatch(tr2);
  }
  return true;
}
function rowIsHeader(map2, table, row) {
  var _a;
  const headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (let col = 0; col < map2.width; col++)
    if (((_a = table.nodeAt(map2.map[col + row * map2.width])) == null ? void 0 : _a.type) != headerCell)
      return false;
  return true;
}
function addRow(tr2, { map: map2, tableStart, table }, row) {
  var _a;
  let rowPos = tableStart;
  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;
  const cells = [];
  let refRow = row > 0 ? -1 : 0;
  if (rowIsHeader(map2, table, row + refRow))
    refRow = row == 0 || row == map2.height ? null : 0;
  for (let col = 0, index = map2.width * row; col < map2.width; col++, index++) {
    if (row > 0 && row < map2.height && map2.map[index] == map2.map[index - map2.width]) {
      const pos = map2.map[index];
      const attrs = table.nodeAt(pos).attrs;
      tr2.setNodeMarkup(tableStart + pos, null, {
        ...attrs,
        rowspan: attrs.rowspan + 1
      });
      col += attrs.colspan - 1;
    } else {
      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map2.map[index + refRow * map2.width])) == null ? void 0 : _a.type;
      const node = type == null ? void 0 : type.createAndFill();
      if (node) cells.push(node);
    }
  }
  tr2.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));
  return tr2;
}
function addRowBefore(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.top));
  }
  return true;
}
function addRowAfter(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.bottom));
  }
  return true;
}
function removeRow(tr2, { map: map2, table, tableStart }, row) {
  let rowPos = 0;
  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;
  const nextRow = rowPos + table.child(row).nodeSize;
  const mapFrom = tr2.mapping.maps.length;
  tr2.delete(rowPos + tableStart, nextRow + tableStart);
  const seen = /* @__PURE__ */ new Set();
  for (let col = 0, index = row * map2.width; col < map2.width; col++, index++) {
    const pos = map2.map[index];
    if (seen.has(pos)) continue;
    seen.add(pos);
    if (row > 0 && pos == map2.map[index - map2.width]) {
      const attrs = table.nodeAt(pos).attrs;
      tr2.setNodeMarkup(tr2.mapping.slice(mapFrom).map(pos + tableStart), null, {
        ...attrs,
        rowspan: attrs.rowspan - 1
      });
      col += attrs.colspan - 1;
    } else if (row < map2.height && pos == map2.map[index + map2.width]) {
      const cell = table.nodeAt(pos);
      const attrs = cell.attrs;
      const copy2 = cell.type.create(
        { ...attrs, rowspan: cell.attrs.rowspan - 1 },
        cell.content
      );
      const newPos = map2.positionAt(row + 1, col, table);
      tr2.insert(tr2.mapping.slice(mapFrom).map(tableStart + newPos), copy2);
      col += attrs.colspan - 1;
    }
  }
}
function deleteRow(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state), tr2 = state.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height) return false;
    for (let i = rect.bottom - 1; ; i--) {
      removeRow(tr2, rect, i);
      if (i == rect.top) break;
      const table = rect.tableStart ? tr2.doc.nodeAt(rect.tableStart - 1) : tr2.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(rect.table);
    }
    dispatch(tr2);
  }
  return true;
}
function isEmpty(cell) {
  const c = cell.content;
  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;
}
function cellsOverlapRectangle({ width, height, map: map2 }, rect) {
  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;
  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
  for (let i = rect.top; i < rect.bottom; i++) {
    if (rect.left > 0 && map2[indexLeft] == map2[indexLeft - 1] || rect.right < width && map2[indexRight] == map2[indexRight + 1])
      return true;
    indexLeft += width;
    indexRight += width;
  }
  for (let i = rect.left; i < rect.right; i++) {
    if (rect.top > 0 && map2[indexTop] == map2[indexTop - width] || rect.bottom < height && map2[indexBottom] == map2[indexBottom + width])
      return true;
    indexTop++;
    indexBottom++;
  }
  return false;
}
function mergeCells(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)
    return false;
  const rect = selectedRect(state), { map: map2 } = rect;
  if (cellsOverlapRectangle(map2, rect)) return false;
  if (dispatch) {
    const tr2 = state.tr;
    const seen = {};
    let content = Fragment.empty;
    let mergedPos;
    let mergedCell;
    for (let row = rect.top; row < rect.bottom; row++) {
      for (let col = rect.left; col < rect.right; col++) {
        const cellPos = map2.map[row * map2.width + col];
        const cell = rect.table.nodeAt(cellPos);
        if (seen[cellPos] || !cell) continue;
        seen[cellPos] = true;
        if (mergedPos == null) {
          mergedPos = cellPos;
          mergedCell = cell;
        } else {
          if (!isEmpty(cell)) content = content.append(cell.content);
          const mapped = tr2.mapping.map(cellPos + rect.tableStart);
          tr2.delete(mapped, mapped + cell.nodeSize);
        }
      }
    }
    if (mergedPos == null || mergedCell == null) {
      return true;
    }
    tr2.setNodeMarkup(mergedPos + rect.tableStart, null, {
      ...addColSpan(
        mergedCell.attrs,
        mergedCell.attrs.colspan,
        rect.right - rect.left - mergedCell.attrs.colspan
      ),
      rowspan: rect.bottom - rect.top
    });
    if (content.size) {
      const end = mergedPos + 1 + mergedCell.content.size;
      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;
      tr2.replaceWith(start + rect.tableStart, end + rect.tableStart, content);
    }
    tr2.setSelection(
      new CellSelection(tr2.doc.resolve(mergedPos + rect.tableStart))
    );
    dispatch(tr2);
  }
  return true;
}
function splitCell(state, dispatch) {
  const nodeTypes = tableNodeTypes(state.schema);
  return splitCellWithType(({ node }) => {
    return nodeTypes[node.type.spec.tableRole];
  })(state, dispatch);
}
function splitCellWithType(getCellType) {
  return (state, dispatch) => {
    var _a;
    const sel = state.selection;
    let cellNode;
    let cellPos;
    if (!(sel instanceof CellSelection)) {
      cellNode = cellWrapping(sel.$from);
      if (!cellNode) return false;
      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;
    } else {
      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode == null || cellPos == null) {
      return false;
    }
    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
      return false;
    }
    if (dispatch) {
      let baseAttrs = cellNode.attrs;
      const attrs = [];
      const colwidth = baseAttrs.colwidth;
      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };
      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };
      const rect = selectedRect(state), tr2 = state.tr;
      for (let i = 0; i < rect.right - rect.left; i++)
        attrs.push(
          colwidth ? {
            ...baseAttrs,
            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null
          } : baseAttrs
        );
      let lastCell;
      for (let row = rect.top; row < rect.bottom; row++) {
        let pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row == rect.top) pos += cellNode.nodeSize;
        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {
          if (col == rect.left && row == rect.top) continue;
          tr2.insert(
            lastCell = tr2.mapping.map(pos + rect.tableStart, 1),
            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])
          );
        }
      }
      tr2.setNodeMarkup(
        cellPos,
        getCellType({ node: cellNode, row: rect.top, col: rect.left }),
        attrs[0]
      );
      if (sel instanceof CellSelection)
        tr2.setSelection(
          new CellSelection(
            tr2.doc.resolve(sel.$anchorCell.pos),
            lastCell ? tr2.doc.resolve(lastCell) : void 0
          )
        );
      dispatch(tr2);
    }
    return true;
  };
}
function setCellAttr(name, value) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    const $cell = selectionCell(state);
    if ($cell.nodeAfter.attrs[name] === value) return false;
    if (dispatch) {
      const tr2 = state.tr;
      if (state.selection instanceof CellSelection)
        state.selection.forEachCell((node, pos) => {
          if (node.attrs[name] !== value)
            tr2.setNodeMarkup(pos, null, {
              ...node.attrs,
              [name]: value
            });
        });
      else
        tr2.setNodeMarkup($cell.pos, null, {
          ...$cell.nodeAfter.attrs,
          [name]: value
        });
      dispatch(tr2);
    }
    return true;
  };
}
function deprecated_toggleHeader(type) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr2 = state.tr;
      const cells = rect.map.cellsInRect(
        type == "column" ? {
          left: rect.left,
          top: 0,
          right: rect.right,
          bottom: rect.map.height
        } : type == "row" ? {
          left: 0,
          top: rect.top,
          right: rect.map.width,
          bottom: rect.bottom
        } : rect
      );
      const nodes = cells.map((pos) => rect.table.nodeAt(pos));
      for (let i = 0; i < cells.length; i++)
        if (nodes[i].type == types.header_cell)
          tr2.setNodeMarkup(
            rect.tableStart + cells[i],
            types.cell,
            nodes[i].attrs
          );
      if (tr2.steps.length == 0)
        for (let i = 0; i < cells.length; i++)
          tr2.setNodeMarkup(
            rect.tableStart + cells[i],
            types.header_cell,
            nodes[i].attrs
          );
      dispatch(tr2);
    }
    return true;
  };
}
function isHeaderEnabledByType(type, rect, types) {
  const cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type == "row" ? rect.map.width : 1,
    bottom: type == "column" ? rect.map.height : 1
  });
  for (let i = 0; i < cellPositions.length; i++) {
    const cell = rect.table.nodeAt(cellPositions[i]);
    if (cell && cell.type !== types.header_cell) {
      return false;
    }
  }
  return true;
}
function toggleHeader(type, options) {
  options = options || { useDeprecatedLogic: false };
  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr2 = state.tr;
      const isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
      const isHeaderColumnEnabled = isHeaderEnabledByType(
        "column",
        rect,
        types
      );
      const isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
      const selectionStartsAt = isHeaderEnabled ? 1 : 0;
      const cellsRect = type == "column" ? {
        left: 0,
        top: selectionStartsAt,
        right: 1,
        bottom: rect.map.height
      } : type == "row" ? {
        left: selectionStartsAt,
        top: 0,
        right: rect.map.width,
        bottom: 1
      } : rect;
      const newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
        const cellPos = relativeCellPos + rect.tableStart;
        const cell = tr2.doc.nodeAt(cellPos);
        if (cell) {
          tr2.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });
      dispatch(tr2);
    }
    return true;
  };
}
var toggleHeaderRow = toggleHeader("row", {
  useDeprecatedLogic: true
});
var toggleHeaderColumn = toggleHeader("column", {
  useDeprecatedLogic: true
});
var toggleHeaderCell = toggleHeader("cell", {
  useDeprecatedLogic: true
});
function findNextCell($cell, dir) {
  if (dir < 0) {
    const before = $cell.nodeBefore;
    if (before) return $cell.pos - before.nodeSize;
    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
      const rowNode = $cell.node(-1).child(row);
      const lastChild = rowNode.lastChild;
      if (lastChild) {
        return rowEnd - 1 - lastChild.nodeSize;
      }
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) {
      return $cell.pos + $cell.nodeAfter.nodeSize;
    }
    const table = $cell.node(-1);
    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {
      const rowNode = table.child(row);
      if (rowNode.childCount) return rowStart + 1;
      rowStart += rowNode.nodeSize;
    }
  }
  return null;
}
function goToNextCell(direction) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    const cell = findNextCell(selectionCell(state), direction);
    if (cell == null) return false;
    if (dispatch) {
      const $cell = state.doc.resolve(cell);
      dispatch(
        state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView()
      );
    }
    return true;
  };
}
function deleteTable(state, dispatch) {
  const $pos = state.selection.$anchor;
  for (let d = $pos.depth; d > 0; d--) {
    const node = $pos.node(d);
    if (node.type.spec.tableRole == "table") {
      if (dispatch)
        dispatch(
          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()
        );
      return true;
    }
  }
  return false;
}
function deleteCellSelection(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection)) return false;
  if (dispatch) {
    const tr2 = state.tr;
    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell((cell, pos) => {
      if (!cell.content.eq(baseContent))
        tr2.replace(
          tr2.mapping.map(pos + 1),
          tr2.mapping.map(pos + cell.nodeSize - 1),
          new Slice(baseContent, 0, 0)
        );
    });
    if (tr2.docChanged) dispatch(tr2);
  }
  return true;
}
function pastedCells(slice2) {
  if (!slice2.size) return null;
  let { content, openStart, openEnd } = slice2;
  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content = content.child(0).content;
  }
  const first2 = content.child(0);
  const role = first2.type.spec.tableRole;
  const schema = first2.type.schema, rows = [];
  if (role == "row") {
    for (let i = 0; i < content.childCount; i++) {
      let cells = content.child(i).content;
      const left = i ? 0 : Math.max(0, openStart - 1);
      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left || right)
        cells = fitSlice(
          tableNodeTypes(schema).row,
          new Slice(cells, left, right)
        ).content;
      rows.push(cells);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(
      openStart || openEnd ? fitSlice(
        tableNodeTypes(schema).row,
        new Slice(content, openStart, openEnd)
      ).content : content
    );
  } else {
    return null;
  }
  return ensureRectangular(schema, rows);
}
function ensureRectangular(schema, rows) {
  const widths = [];
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    for (let j = row.childCount - 1; j >= 0; j--) {
      const { rowspan, colspan } = row.child(j).attrs;
      for (let r = i; r < i + rowspan; r++)
        widths[r] = (widths[r] || 0) + colspan;
    }
  }
  let width = 0;
  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);
  for (let r = 0; r < widths.length; r++) {
    if (r >= rows.length) rows.push(Fragment.empty);
    if (widths[r] < width) {
      const empty2 = tableNodeTypes(schema).cell.createAndFill();
      const cells = [];
      for (let i = widths[r]; i < width; i++) {
        cells.push(empty2);
      }
      rows[r] = rows[r].append(Fragment.from(cells));
    }
  }
  return { height: rows.length, width, rows };
}
function fitSlice(nodeType, slice2) {
  const node = nodeType.createAndFill();
  const tr2 = new Transform(node).replace(0, node.content.size, slice2);
  return tr2.doc;
}
function clipCells({ width, height, rows }, newWidth, newHeight) {
  if (width != newWidth) {
    const added = [];
    const newRows = [];
    for (let row = 0; row < rows.length; row++) {
      const frag = rows[row], cells = [];
      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {
        let cell = frag.child(i % frag.childCount);
        if (col + cell.attrs.colspan > newWidth)
          cell = cell.type.createChecked(
            removeColSpan(
              cell.attrs,
              cell.attrs.colspan,
              col + cell.attrs.colspan - newWidth
            ),
            cell.content
          );
        cells.push(cell);
        col += cell.attrs.colspan;
        for (let j = 1; j < cell.attrs.rowspan; j++)
          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    const newRows = [];
    for (let row = 0, i = 0; row < newHeight; row++, i++) {
      const cells = [], source = rows[i % height];
      for (let j = 0; j < source.childCount; j++) {
        let cell = source.child(j);
        if (row + cell.attrs.rowspan > newHeight)
          cell = cell.type.create(
            {
              ...cell.attrs,
              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)
            },
            cell.content
          );
        cells.push(cell);
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    height = newHeight;
  }
  return { width, height, rows };
}
function growTable(tr2, map2, table, start, width, height, mapFrom) {
  const schema = tr2.doc.type.schema;
  const types = tableNodeTypes(schema);
  let empty2;
  let emptyHead;
  if (width > map2.width) {
    for (let row = 0, rowEnd = 0; row < map2.height; row++) {
      const rowNode = table.child(row);
      rowEnd += rowNode.nodeSize;
      const cells = [];
      let add;
      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)
        add = empty2 || (empty2 = types.cell.createAndFill());
      else add = emptyHead || (emptyHead = types.header_cell.createAndFill());
      for (let i = map2.width; i < width; i++) cells.push(add);
      tr2.insert(tr2.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);
    }
  }
  if (height > map2.height) {
    const cells = [];
    for (let i = 0, start2 = (map2.height - 1) * map2.width; i < Math.max(map2.width, width); i++) {
      const header = i >= map2.width ? false : table.nodeAt(map2.map[start2 + i]).type == types.header_cell;
      cells.push(
        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty2 || (empty2 = types.cell.createAndFill())
      );
    }
    const emptyRow = types.row.create(null, Fragment.from(cells)), rows = [];
    for (let i = map2.height; i < height; i++) rows.push(emptyRow);
    tr2.insert(tr2.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);
  }
  return !!(empty2 || emptyHead);
}
function isolateHorizontal(tr2, map2, table, start, left, right, top, mapFrom) {
  if (top == 0 || top == map2.height) return false;
  let found2 = false;
  for (let col = left; col < right; col++) {
    const index = top * map2.width + col, pos = map2.map[index];
    if (map2.map[index - map2.width] == pos) {
      found2 = true;
      const cell = table.nodeAt(pos);
      const { top: cellTop, left: cellLeft } = map2.findCell(pos);
      tr2.setNodeMarkup(tr2.mapping.slice(mapFrom).map(pos + start), null, {
        ...cell.attrs,
        rowspan: top - cellTop
      });
      tr2.insert(
        tr2.mapping.slice(mapFrom).map(map2.positionAt(top, cellLeft, table)),
        cell.type.createAndFill({
          ...cell.attrs,
          rowspan: cellTop + cell.attrs.rowspan - top
        })
      );
      col += cell.attrs.colspan - 1;
    }
  }
  return found2;
}
function isolateVertical(tr2, map2, table, start, top, bottom, left, mapFrom) {
  if (left == 0 || left == map2.width) return false;
  let found2 = false;
  for (let row = top; row < bottom; row++) {
    const index = row * map2.width + left, pos = map2.map[index];
    if (map2.map[index - 1] == pos) {
      found2 = true;
      const cell = table.nodeAt(pos);
      const cellLeft = map2.colCount(pos);
      const updatePos = tr2.mapping.slice(mapFrom).map(pos + start);
      tr2.setNodeMarkup(
        updatePos,
        null,
        removeColSpan(
          cell.attrs,
          left - cellLeft,
          cell.attrs.colspan - (left - cellLeft)
        )
      );
      tr2.insert(
        updatePos + cell.nodeSize,
        cell.type.createAndFill(
          removeColSpan(cell.attrs, 0, left - cellLeft)
        )
      );
      row += cell.attrs.rowspan - 1;
    }
  }
  return found2;
}
function insertCells(state, dispatch, tableStart, rect, cells) {
  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;
  if (!table) {
    throw new Error("No table found");
  }
  let map2 = TableMap.get(table);
  const { top, left } = rect;
  const right = left + cells.width, bottom = top + cells.height;
  const tr2 = state.tr;
  let mapFrom = 0;
  function recomp() {
    table = tableStart ? tr2.doc.nodeAt(tableStart - 1) : tr2.doc;
    if (!table) {
      throw new Error("No table found");
    }
    map2 = TableMap.get(table);
    mapFrom = tr2.mapping.maps.length;
  }
  if (growTable(tr2, map2, table, tableStart, right, bottom, mapFrom)) recomp();
  if (isolateHorizontal(tr2, map2, table, tableStart, left, right, top, mapFrom))
    recomp();
  if (isolateHorizontal(tr2, map2, table, tableStart, left, right, bottom, mapFrom))
    recomp();
  if (isolateVertical(tr2, map2, table, tableStart, top, bottom, left, mapFrom))
    recomp();
  if (isolateVertical(tr2, map2, table, tableStart, top, bottom, right, mapFrom))
    recomp();
  for (let row = top; row < bottom; row++) {
    const from2 = map2.positionAt(row, left, table), to = map2.positionAt(row, right, table);
    tr2.replace(
      tr2.mapping.slice(mapFrom).map(from2 + tableStart),
      tr2.mapping.slice(mapFrom).map(to + tableStart),
      new Slice(cells.rows[row - top], 0, 0)
    );
  }
  recomp();
  tr2.setSelection(
    new CellSelection(
      tr2.doc.resolve(tableStart + map2.positionAt(top, left, table)),
      tr2.doc.resolve(tableStart + map2.positionAt(bottom - 1, right - 1, table))
    )
  );
  dispatch(tr2);
}
var handleKeyDown2 = keydownHandler({
  ArrowLeft: arrow2("horiz", -1),
  ArrowRight: arrow2("horiz", 1),
  ArrowUp: arrow2("vert", -1),
  ArrowDown: arrow2("vert", 1),
  "Shift-ArrowLeft": shiftArrow("horiz", -1),
  "Shift-ArrowRight": shiftArrow("horiz", 1),
  "Shift-ArrowUp": shiftArrow("vert", -1),
  "Shift-ArrowDown": shiftArrow("vert", 1),
  Backspace: deleteCellSelection,
  "Mod-Backspace": deleteCellSelection,
  Delete: deleteCellSelection,
  "Mod-Delete": deleteCellSelection
});
function maybeSetSelection(state, dispatch, selection) {
  if (selection.eq(state.selection)) return false;
  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());
  return true;
}
function arrow2(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(
        state,
        dispatch,
        Selection.near(sel.$headCell, dir)
      );
    }
    if (axis != "horiz" && !sel.empty) return false;
    const end = atEndOfCell(view, axis, dir);
    if (end == null) return false;
    if (axis == "horiz") {
      return maybeSetSelection(
        state,
        dispatch,
        Selection.near(state.doc.resolve(sel.head + dir), dir)
      );
    } else {
      const $cell = state.doc.resolve(end);
      const $next = nextCell($cell, axis, dir);
      let newSel;
      if ($next) newSel = Selection.near($next, 1);
      else if (dir < 0)
        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
      else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
      return maybeSetSelection(state, dispatch, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    let cellSel;
    if (sel instanceof CellSelection) {
      cellSel = sel;
    } else {
      const end = atEndOfCell(view, axis, dir);
      if (end == null) return false;
      cellSel = new CellSelection(state.doc.resolve(end));
    }
    const $head = nextCell(cellSel.$headCell, axis, dir);
    if (!$head) return false;
    return maybeSetSelection(
      state,
      dispatch,
      new CellSelection(cellSel.$anchorCell, $head)
    );
  };
}
function handleTripleClick2(view, pos) {
  const doc3 = view.state.doc, $cell = cellAround(doc3.resolve(pos));
  if (!$cell) return false;
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _, slice2) {
  if (!isInTable(view.state)) return false;
  let cells = pastedCells(slice2);
  const sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells)
      cells = {
        width: 1,
        height: 1,
        rows: [
          Fragment.from(
            fitSlice(tableNodeTypes(view.state.schema).cell, slice2)
          )
        ]
      };
    const table = sel.$anchorCell.node(-1);
    const start = sel.$anchorCell.start(-1);
    const rect = TableMap.get(table).rectBetween(
      sel.$anchorCell.pos - start,
      sel.$headCell.pos - start
    );
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start, rect, cells);
    return true;
  } else if (cells) {
    const $cell = selectionCell(view.state);
    const start = $cell.start(-1);
    insertCells(
      view.state,
      view.dispatch,
      start,
      TableMap.get($cell.node(-1)).findCell($cell.pos - start),
      cells
    );
    return true;
  } else {
    return false;
  }
}
function handleMouseDown(view, startEvent) {
  var _a;
  if (startEvent.ctrlKey || startEvent.metaKey) return;
  const startDOMCell = domInCell(view, startEvent.target);
  let $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    return;
  }
  function setCellSelection($anchor2, event) {
    let $head = cellUnderMouse(view, event);
    const starting = tableEditingKey.getState(view.state) == null;
    if (!$head || !inSameTable($anchor2, $head)) {
      if (starting) $head = $anchor2;
      else return;
    }
    const selection = new CellSelection($anchor2, $head);
    if (starting || !view.state.selection.eq(selection)) {
      const tr2 = view.state.tr.setSelection(selection);
      if (starting) tr2.setMeta(tableEditingKey, $anchor2.pos);
      view.dispatch(tr2);
    }
  }
  function stop() {
    view.root.removeEventListener("mouseup", stop);
    view.root.removeEventListener("dragstart", stop);
    view.root.removeEventListener("mousemove", move);
    if (tableEditingKey.getState(view.state) != null)
      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
  }
  function move(_event) {
    const event = _event;
    const anchor = tableEditingKey.getState(view.state);
    let $anchor2;
    if (anchor != null) {
      $anchor2 = view.state.doc.resolve(anchor);
    } else if (domInCell(view, event.target) != startDOMCell) {
      $anchor2 = cellUnderMouse(view, startEvent);
      if (!$anchor2) return stop();
    }
    if ($anchor2) setCellSelection($anchor2, event);
  }
  view.root.addEventListener("mouseup", stop);
  view.root.addEventListener("dragstart", stop);
  view.root.addEventListener("mousemove", move);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection)) return null;
  const { $head } = view.state.selection;
  for (let d = $head.depth - 1; d >= 0; d--) {
    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);
    if (index != (dir < 0 ? 0 : parent.childCount)) return null;
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      const cellPos = $head.before(d);
      const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode) {
    if (dom.nodeName == "TD" || dom.nodeName == "TH") {
      return dom;
    }
  }
  return null;
}
function cellUnderMouse(view, event) {
  const mousePos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (!mousePos) return null;
  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
}
var TableView = class {
  constructor(node, defaultCellMinWidth) {
    this.node = node;
    this.defaultCellMinWidth = defaultCellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.table.style.setProperty(
      "--default-cell-min-width",
      `${defaultCellMinWidth}px`
    );
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(node) {
    if (node.type != this.node.type) return false;
    this.node = node;
    updateColumnsOnResize(
      node,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    );
    return true;
  }
  ignoreMutation(record) {
    return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
  }
};
function updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {
  var _a;
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node.firstChild;
  if (!row) return;
  for (let i = 0, col = 0; i < row.childCount; i++) {
    const { colspan, colwidth } = row.child(i).attrs;
    for (let j = 0; j < colspan; j++, col++) {
      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
      const cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || defaultCellMinWidth;
      if (!hasWidth) fixedWidth = false;
      if (!nextDOM) {
        const col2 = document.createElement("col");
        col2.style.width = cssWidth;
        colgroup.appendChild(col2);
      } else {
        if (nextDOM.style.width != cssWidth) {
          nextDOM.style.width = cssWidth;
        }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    const after = nextDOM.nextSibling;
    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = totalWidth + "px";
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = totalWidth + "px";
  }
}
var columnResizingPluginKey = new PluginKey(
  "tableColumnResizing"
);
function columnResizing({
  handleWidth = 5,
  cellMinWidth = 25,
  defaultCellMinWidth = 100,
  View = TableView,
  lastColumnResizable = true
} = {}) {
  const plugin = new Plugin({
    key: columnResizingPluginKey,
    state: {
      init(_, state) {
        var _a, _b;
        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;
        const tableName = tableNodeTypes(state.schema).table.name;
        if (View && nodeViews) {
          nodeViews[tableName] = (node, view) => {
            return new View(node, defaultCellMinWidth, view);
          };
        }
        return new ResizeState(-1, false);
      },
      apply(tr2, prev) {
        return prev.apply(tr2);
      }
    },
    props: {
      attributes: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        return pluginState && pluginState.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (view, event) => {
          handleMouseMove(view, event, handleWidth, lastColumnResizable);
        },
        mouseleave: (view) => {
          handleMouseLeave(view);
        },
        mousedown: (view, event) => {
          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);
        }
      },
      decorations: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        if (pluginState && pluginState.activeHandle > -1) {
          return handleDecorations(state, pluginState.activeHandle);
        }
      },
      nodeViews: {}
    }
  });
  return plugin;
}
var ResizeState = class _ResizeState {
  constructor(activeHandle, dragging) {
    this.activeHandle = activeHandle;
    this.dragging = dragging;
  }
  apply(tr2) {
    const state = this;
    const action = tr2.getMeta(columnResizingPluginKey);
    if (action && action.setHandle != null)
      return new _ResizeState(action.setHandle, false);
    if (action && action.setDragging !== void 0)
      return new _ResizeState(state.activeHandle, action.setDragging);
    if (state.activeHandle > -1 && tr2.docChanged) {
      let handle = tr2.mapping.map(state.activeHandle, -1);
      if (!pointsAtCell(tr2.doc.resolve(handle))) {
        handle = -1;
      }
      return new _ResizeState(handle, state.dragging);
    }
    return state;
  }
};
function handleMouseMove(view, event, handleWidth, lastColumnResizable) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState) return;
  if (!pluginState.dragging) {
    const target = domCellAround(event.target);
    let cell = -1;
    if (target) {
      const { left, right } = target.getBoundingClientRect();
      if (event.clientX - left <= handleWidth)
        cell = edgeCell(view, event, "left", handleWidth);
      else if (right - event.clientX <= handleWidth)
        cell = edgeCell(view, event, "right", handleWidth);
    }
    if (cell != pluginState.activeHandle) {
      if (!lastColumnResizable && cell !== -1) {
        const $cell = view.state.doc.resolve(cell);
        const table = $cell.node(-1);
        const map2 = TableMap.get(table);
        const tableStart = $cell.start(-1);
        const col = map2.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;
        if (col == map2.width - 1) {
          return;
        }
      }
      updateHandle(view, cell);
    }
  }
}
function handleMouseLeave(view) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)
    updateHandle(view, -1);
}
function handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {
  var _a;
  if (!view.editable) return false;
  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)
    return false;
  const cell = view.state.doc.nodeAt(pluginState.activeHandle);
  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, {
      setDragging: { startX: event.clientX, startWidth: width }
    })
  );
  function finish(event2) {
    win.removeEventListener("mouseup", finish);
    win.removeEventListener("mousemove", move);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (pluginState2 == null ? void 0 : pluginState2.dragging) {
      updateColumnWidth(
        view,
        pluginState2.activeHandle,
        draggedWidth(pluginState2.dragging, event2, cellMinWidth)
      );
      view.dispatch(
        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })
      );
    }
  }
  function move(event2) {
    if (!event2.which) return finish(event2);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (!pluginState2) return;
    if (pluginState2.dragging) {
      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
      displayColumnWidth(
        view,
        pluginState2.activeHandle,
        dragged,
        defaultCellMinWidth
      );
    }
  }
  displayColumnWidth(
    view,
    pluginState.activeHandle,
    width,
    defaultCellMinWidth
  );
  win.addEventListener("mouseup", finish);
  win.addEventListener("mousemove", move);
  event.preventDefault();
  return true;
}
function currentColWidth(view, cellPos, { colspan, colwidth }) {
  const width = colwidth && colwidth[colwidth.length - 1];
  if (width) return width;
  const dom = view.domAtPos(cellPos);
  const node = dom.node.childNodes[dom.offset];
  let domWidth = node.offsetWidth, parts = colspan;
  if (colwidth) {
    for (let i = 0; i < colspan; i++)
      if (colwidth[i]) {
        domWidth -= colwidth[i];
        parts--;
      }
  }
  return domWidth / parts;
}
function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH")
    target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
  return target;
}
function edgeCell(view, event, side, handleWidth) {
  const offset3 = side == "right" ? -handleWidth : handleWidth;
  const found2 = view.posAtCoords({
    left: event.clientX + offset3,
    top: event.clientY
  });
  if (!found2) return -1;
  const { pos } = found2;
  const $cell = cellAround(view.state.doc.resolve(pos));
  if (!$cell) return -1;
  if (side == "right") return $cell.pos;
  const map2 = TableMap.get($cell.node(-1)), start = $cell.start(-1);
  const index = map2.map.indexOf($cell.pos - start);
  return index % map2.width == 0 ? -1 : start + map2.map[index - 1];
}
function draggedWidth(dragging, event, resizeMinWidth) {
  const offset3 = event.clientX - dragging.startX;
  return Math.max(resizeMinWidth, dragging.startWidth + offset3);
}
function updateHandle(view, value) {
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })
  );
}
function updateColumnWidth(view, cell, width) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), map2 = TableMap.get(table), start = $cell.start(-1);
  const col = map2.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  const tr2 = view.state.tr;
  for (let row = 0; row < map2.height; row++) {
    const mapIndex = row * map2.width + col;
    if (row && map2.map[mapIndex] == map2.map[mapIndex - map2.width]) continue;
    const pos = map2.map[mapIndex];
    const attrs = table.nodeAt(pos).attrs;
    const index = attrs.colspan == 1 ? 0 : col - map2.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index] == width) continue;
    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index] = width;
    tr2.setNodeMarkup(start + pos, null, { ...attrs, colwidth });
  }
  if (tr2.docChanged) view.dispatch(tr2);
}
function displayColumnWidth(view, cell, width, defaultCellMinWidth) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), start = $cell.start(-1);
  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  let dom = view.domAtPos($cell.start(-1)).node;
  while (dom && dom.nodeName != "TABLE") {
    dom = dom.parentNode;
  }
  if (!dom) return;
  updateColumnsOnResize(
    table,
    dom.firstChild,
    dom,
    defaultCellMinWidth,
    col,
    width
  );
}
function zeroes(n) {
  return Array(n).fill(0);
}
function handleDecorations(state, cell) {
  var _a;
  const decorations = [];
  const $cell = state.doc.resolve(cell);
  const table = $cell.node(-1);
  if (!table) {
    return DecorationSet.empty;
  }
  const map2 = TableMap.get(table);
  const start = $cell.start(-1);
  const col = map2.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  for (let row = 0; row < map2.height; row++) {
    const index = col + row * map2.width;
    if ((col == map2.width - 1 || map2.map[index] != map2.map[index + 1]) && (row == 0 || map2.map[index] != map2.map[index - map2.width])) {
      const cellPos = map2.map[index];
      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;
      const dom = document.createElement("div");
      dom.className = "column-resize-handle";
      if ((_a = columnResizingPluginKey.getState(state)) == null ? void 0 : _a.dragging) {
        decorations.push(
          Decoration.node(
            start + cellPos,
            start + cellPos + table.nodeAt(cellPos).nodeSize,
            {
              class: "column-resize-dragging"
            }
          )
        );
      }
      decorations.push(Decoration.widget(pos, dom));
    }
  }
  return DecorationSet.create(state.doc, decorations);
}
function tableEditing({
  allowTableNodeSelection = false
} = {}) {
  return new Plugin({
    key: tableEditingKey,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(tr2, cur) {
        const set = tr2.getMeta(tableEditingKey);
        if (set != null) return set == -1 ? null : set;
        if (cur == null || !tr2.docChanged) return cur;
        const { deleted, pos } = tr2.mapping.mapResult(cur);
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      handleDOMEvents: {
        mousedown: handleMouseDown
      },
      createSelectionBetween(view) {
        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
      },
      handleTripleClick: handleTripleClick2,
      handleKeyDown: handleKeyDown2,
      handlePaste
    },
    appendTransaction(_, oldState, state) {
      return normalizeSelection(
        state,
        fixTables(state, oldState),
        allowTableNodeSelection
      );
    }
  });
}

// node_modules/@tiptap/extension-table/dist/index.js
var TableCell = Node3.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (element) => {
          const colwidth = element.getAttribute("colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: true,
  parseHTML() {
    return [{ tag: "td" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["td", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
var TableHeader = Node3.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (element) => {
          const colwidth = element.getAttribute("colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: true,
  parseHTML() {
    return [{ tag: "th" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["th", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
var TableRow = Node3.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [{ tag: "tr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["tr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
function getColStyleDeclaration(minWidth, width) {
  if (width) {
    return ["width", `${Math.max(width, minWidth)}px`];
  }
  return ["min-width", `${minWidth}px`];
}
function updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
  var _a;
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node.firstChild;
  if (row !== null) {
    for (let i = 0, col = 0; i < row.childCount; i += 1) {
      const { colspan, colwidth } = row.child(i).attrs;
      for (let j = 0; j < colspan; j += 1, col += 1) {
        const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
        const cssWidth = hasWidth ? `${hasWidth}px` : "";
        totalWidth += hasWidth || cellMinWidth;
        if (!hasWidth) {
          fixedWidth = false;
        }
        if (!nextDOM) {
          const colElement = document.createElement("col");
          const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth);
          colElement.style.setProperty(propertyKey, propertyValue);
          colgroup.appendChild(colElement);
        } else {
          if (nextDOM.style.width !== cssWidth) {
            const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth);
            nextDOM.style.setProperty(propertyKey, propertyValue);
          }
          nextDOM = nextDOM.nextSibling;
        }
      }
    }
  }
  while (nextDOM) {
    const after = nextDOM.nextSibling;
    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = `${totalWidth}px`;
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = `${totalWidth}px`;
  }
}
var TableView2 = class {
  constructor(node, cellMinWidth) {
    this.node = node;
    this.cellMinWidth = cellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumns(node, this.colgroup, this.table, cellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(node) {
    if (node.type !== this.node.type) {
      return false;
    }
    this.node = node;
    updateColumns(node, this.colgroup, this.table, this.cellMinWidth);
    return true;
  }
  ignoreMutation(mutation) {
    return mutation.type === "attributes" && (mutation.target === this.table || this.colgroup.contains(mutation.target));
  }
};
function createColGroup(node, cellMinWidth, overrideCol, overrideValue) {
  let totalWidth = 0;
  let fixedWidth = true;
  const cols = [];
  const row = node.firstChild;
  if (!row) {
    return {};
  }
  for (let i = 0, col = 0; i < row.childCount; i += 1) {
    const { colspan, colwidth } = row.child(i).attrs;
    for (let j = 0; j < colspan; j += 1, col += 1) {
      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth) {
        fixedWidth = false;
      }
      const [property, value] = getColStyleDeclaration(cellMinWidth, hasWidth);
      cols.push(["col", { style: `${property}: ${value}` }]);
    }
  }
  const tableWidth = fixedWidth ? `${totalWidth}px` : "";
  const tableMinWidth = fixedWidth ? "" : `${totalWidth}px`;
  const colgroup = ["colgroup", {}, ...cols];
  return { colgroup, tableWidth, tableMinWidth };
}
function createCell(cellType, cellContent) {
  if (cellContent) {
    return cellType.createChecked(null, cellContent);
  }
  return cellType.createAndFill();
}
function getTableNodeTypes(schema) {
  if (schema.cached.tableNodeTypes) {
    return schema.cached.tableNodeTypes;
  }
  const roles = {};
  Object.keys(schema.nodes).forEach((type) => {
    const nodeType = schema.nodes[type];
    if (nodeType.spec.tableRole) {
      roles[nodeType.spec.tableRole] = nodeType;
    }
  });
  schema.cached.tableNodeTypes = roles;
  return roles;
}
function createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {
  const types = getTableNodeTypes(schema);
  const headerCells = [];
  const cells = [];
  for (let index = 0; index < colsCount; index += 1) {
    const cell = createCell(types.cell, cellContent);
    if (cell) {
      cells.push(cell);
    }
    if (withHeaderRow) {
      const headerCell = createCell(types.header_cell, cellContent);
      if (headerCell) {
        headerCells.push(headerCell);
      }
    }
  }
  const rows = [];
  for (let index = 0; index < rowsCount; index += 1) {
    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));
  }
  return types.table.createChecked(null, rows);
}
function isCellSelection(value) {
  return value instanceof CellSelection;
}
var deleteTableWhenAllCellsSelected = ({ editor }) => {
  const { selection } = editor.state;
  if (!isCellSelection(selection)) {
    return false;
  }
  let cellCount = 0;
  const table = findParentNodeClosestToPos(selection.ranges[0].$from, (node) => {
    return node.type.name === "table";
  });
  table == null ? void 0 : table.node.descendants((node) => {
    if (node.type.name === "table") {
      return false;
    }
    if (["tableCell", "tableHeader"].includes(node.type.name)) {
      cellCount += 1;
    }
  });
  const allCellsSelected = cellCount === selection.ranges.length;
  if (!allCellsSelected) {
    return false;
  }
  editor.commands.deleteTable();
  return true;
};
var Table = Node3.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: false,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: TableView2,
      lastColumnResizable: true,
      allowTableNodeSelection: false
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: true,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node, HTMLAttributes }) {
    const { colgroup, tableWidth, tableMinWidth } = createColGroup(node, this.options.cellMinWidth);
    const table = [
      "table",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        style: tableWidth ? `width: ${tableWidth}` : `min-width: ${tableMinWidth}`
      }),
      colgroup,
      ["tbody", 0]
    ];
    return table;
  },
  addCommands() {
    return {
      insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr: tr2, dispatch, editor }) => {
        const node = createTable(editor.schema, rows, cols, withHeaderRow);
        if (dispatch) {
          const offset3 = tr2.selection.from + 1;
          tr2.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection.near(tr2.doc.resolve(offset3)));
        }
        return true;
      },
      addColumnBefore: () => ({ state, dispatch }) => {
        return addColumnBefore(state, dispatch);
      },
      addColumnAfter: () => ({ state, dispatch }) => {
        return addColumnAfter(state, dispatch);
      },
      deleteColumn: () => ({ state, dispatch }) => {
        return deleteColumn(state, dispatch);
      },
      addRowBefore: () => ({ state, dispatch }) => {
        return addRowBefore(state, dispatch);
      },
      addRowAfter: () => ({ state, dispatch }) => {
        return addRowAfter(state, dispatch);
      },
      deleteRow: () => ({ state, dispatch }) => {
        return deleteRow(state, dispatch);
      },
      deleteTable: () => ({ state, dispatch }) => {
        return deleteTable(state, dispatch);
      },
      mergeCells: () => ({ state, dispatch }) => {
        return mergeCells(state, dispatch);
      },
      splitCell: () => ({ state, dispatch }) => {
        return splitCell(state, dispatch);
      },
      toggleHeaderColumn: () => ({ state, dispatch }) => {
        return toggleHeader("column")(state, dispatch);
      },
      toggleHeaderRow: () => ({ state, dispatch }) => {
        return toggleHeader("row")(state, dispatch);
      },
      toggleHeaderCell: () => ({ state, dispatch }) => {
        return toggleHeaderCell(state, dispatch);
      },
      mergeOrSplit: () => ({ state, dispatch }) => {
        if (mergeCells(state, dispatch)) {
          return true;
        }
        return splitCell(state, dispatch);
      },
      setCellAttribute: (name, value) => ({ state, dispatch }) => {
        return setCellAttr(name, value)(state, dispatch);
      },
      goToNextCell: () => ({ state, dispatch }) => {
        return goToNextCell(1)(state, dispatch);
      },
      goToPreviousCell: () => ({ state, dispatch }) => {
        return goToNextCell(-1)(state, dispatch);
      },
      fixTables: () => ({ state, dispatch }) => {
        if (dispatch) {
          fixTables(state);
        }
        return true;
      },
      setCellSelection: (position) => ({ tr: tr2, dispatch }) => {
        if (dispatch) {
          const selection = CellSelection.create(tr2.doc, position.anchorCell, position.headCell);
          tr2.setSelection(selection);
        }
        return true;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => {
        if (this.editor.commands.goToNextCell()) {
          return true;
        }
        if (!this.editor.can().addRowAfter()) {
          return false;
        }
        return this.editor.chain().addRowAfter().goToNextCell().run();
      },
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: deleteTableWhenAllCellsSelected,
      "Mod-Backspace": deleteTableWhenAllCellsSelected,
      Delete: deleteTableWhenAllCellsSelected,
      "Mod-Delete": deleteTableWhenAllCellsSelected
    };
  },
  addProseMirrorPlugins() {
    const isResizable = this.options.resizable && this.editor.isEditable;
    return [
      ...isResizable ? [
        columnResizing({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      tableEditing({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(extension) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      tableRole: callOrReturn(getExtensionField(extension, "tableRole", context))
    };
  }
});
var TableKit = Extension.create({
  name: "tableKit",
  addExtensions() {
    const extensions = [];
    if (this.options.table !== false) {
      extensions.push(Table.configure(this.options.table));
    }
    if (this.options.tableCell !== false) {
      extensions.push(TableCell.configure(this.options.tableCell));
    }
    if (this.options.tableHeader !== false) {
      extensions.push(TableHeader.configure(this.options.tableHeader));
    }
    if (this.options.tableRow !== false) {
      extensions.push(TableRow.configure(this.options.tableRow));
    }
    return extensions;
  }
});

// node_modules/@tiptap/extension-text/dist/index.js
var Text2 = Node3.create({
  name: "text",
  group: "inline"
});
var index_default17 = Text2;

// node_modules/@tiptap/extension-underline/dist/index.js
var Underline = Mark2.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleUnderline: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
var index_default18 = Underline;

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide2(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide2(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide2(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide2(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide2(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
var autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = placements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements$1[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements$1[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide2(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements$1[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d) => {
        const alignment2 = getAlignment(d.placement);
        return [d.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0)
        ) : (
          // Check only the mainAxis.
          d.overflows[0]
        ), d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d) => d[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d[0]) ? 2 : 3
      ).every((v) => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide2(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide2(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => d.overflows[0] > 0 && getSideAxis(d.placement) === initialSideAxis)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
function getBoundingRect(rects) {
  const minX = min(...rects.map((rect) => rect.left));
  const minY = min(...rects.map((rect) => rect.top));
  const maxX = max(...rects.map((rect) => rect.right));
  const maxY = max(...rects.map((rect) => rect.bottom));
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getRectsByLine(rects) {
  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);
  const groups = [];
  let prevRect = null;
  for (let i = 0; i < sortedRects.length; i++) {
    const rect = sortedRects[i];
    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
      groups.push([rect]);
    } else {
      groups[groups.length - 1].push(rect);
    }
    prevRect = rect;
  }
  return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
}
var inline = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "inline",
    options,
    async fn(state) {
      const {
        placement,
        elements,
        rects,
        platform: platform2,
        strategy
      } = state;
      const {
        padding = 2,
        x,
        y
      } = evaluate(options, state);
      const nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []);
      const clientRects = getRectsByLine(nativeClientRects);
      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
      const paddingObject = getPaddingObject(padding);
      function getBoundingClientRect2() {
        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
          return clientRects.find((rect) => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;
        }
        if (clientRects.length >= 2) {
          if (getSideAxis(placement) === "y") {
            const firstRect = clientRects[0];
            const lastRect = clientRects[clientRects.length - 1];
            const isTop = getSide2(placement) === "top";
            const top2 = firstRect.top;
            const bottom2 = lastRect.bottom;
            const left2 = isTop ? firstRect.left : lastRect.left;
            const right2 = isTop ? firstRect.right : lastRect.right;
            const width2 = right2 - left2;
            const height2 = bottom2 - top2;
            return {
              top: top2,
              bottom: bottom2,
              left: left2,
              right: right2,
              width: width2,
              height: height2,
              x: left2,
              y: top2
            };
          }
          const isLeftSide = getSide2(placement) === "left";
          const maxRight = max(...clientRects.map((rect) => rect.right));
          const minLeft = min(...clientRects.map((rect) => rect.left));
          const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
          const top = measureRects[0].top;
          const bottom = measureRects[measureRects.length - 1].bottom;
          const left = minLeft;
          const right = maxRight;
          const width = right - left;
          const height = bottom - top;
          return {
            top,
            bottom,
            left,
            right,
            width,
            height,
            x: left,
            y: top
          };
        }
        return fallback;
      }
      const resetRects = await platform2.getElementRects({
        reference: {
          getBoundingClientRect: getBoundingClientRect2
        },
        floating: elements.floating,
        strategy
      });
      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
        return {
          reset: {
            rects: resetRects
          }
        };
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide2(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide2(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide2(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit2 = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit2 && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit2 && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode2 = getParentNode(node);
  if (isLastTraversableNode(parentNode2)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode2) && isOverflowElement(parentNode2)) {
    return parentNode2;
  }
  return getNearestOverflowAncestor(parentNode2);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect2 = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect2.left + visualOffsets.x) / scale.x;
  let y = (clientRect2.top + visualOffsets.y) / scale.y;
  let width = clientRect2.width / scale.x;
  let height = clientRect2.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect2 = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect2.top + element.clientTop;
  const left = clientRect2.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode2 = getParentNode(element);
  if (parentNode2 === stopNode || !isElement(parentNode2) || isLastTraversableNode(parentNode2)) {
    return false;
  }
  return getComputedStyle2(parentNode2).position === "fixed" || hasFixedPositionAncestor(parentNode2, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult2 = cache.get(element);
  if (cachedResult2) {
    return cachedResult2;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
var offset2 = offset;
var autoPlacement2 = autoPlacement;
var shift3 = shift2;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow4 = arrow3;
var inline2 = inline;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// packages/forms/resources/js/components/rich-editor/merge-tag-suggestion.js
var updatePosition = (editor, element) => {
  const referenceElement = {
    getBoundingClientRect: () => {
      const { from: from2, to } = editor.state.selection;
      const start = editor.view.coordsAtPos(from2);
      const end = editor.view.coordsAtPos(to);
      return {
        top: Math.min(start.top, end.top),
        bottom: Math.max(start.bottom, end.bottom),
        left: Math.min(start.left, end.left),
        right: Math.max(start.right, end.right),
        width: Math.abs(end.right - start.left),
        height: Math.abs(end.bottom - start.top),
        x: Math.min(start.left, end.left),
        y: Math.min(start.top, end.top)
      };
    }
  };
  computePosition2(referenceElement, element, {
    placement: "bottom-start",
    strategy: "absolute",
    middleware: [shift3(), flip2()]
  }).then(({ x, y, strategy }) => {
    element.style.width = "max-content";
    element.style.position = strategy;
    element.style.left = `${x}px`;
    element.style.top = `${y}px`;
  });
};
var merge_tag_suggestion_default = ({ mergeTags, noMergeTagSearchResultsMessage }) => ({
  items: ({ query }) => {
    return mergeTags.filter(
      (item) => item.toLowerCase().replace(/\s/g, "").includes(query.toLowerCase())
    );
  },
  render: () => {
    let element;
    let selectedIndex = 0;
    let currentProps = null;
    const createDropdown = () => {
      const dropdown = document.createElement("div");
      dropdown.className = "fi-dropdown-panel fi-dropdown-list";
      return dropdown;
    };
    const renderItems = () => {
      if (!element || !currentProps) return;
      const items = currentProps.items || [];
      element.innerHTML = "";
      if (items.length) {
        items.forEach((item, index) => {
          const button = document.createElement("button");
          button.className = `fi-dropdown-list-item fi-dropdown-list-item-label ${index === selectedIndex ? "fi-selected" : ""}`;
          button.textContent = item;
          button.type = "button";
          button.addEventListener("click", () => selectItem(index));
          element.appendChild(button);
        });
      } else {
        const noSearchResultsMessage = document.createElement("div");
        noSearchResultsMessage.className = "fi-dropdown-header";
        noSearchResultsMessage.textContent = noMergeTagSearchResultsMessage;
        element.appendChild(noSearchResultsMessage);
      }
    };
    const selectItem = (index) => {
      if (!currentProps) return;
      const items = currentProps.items || [];
      const item = items[index];
      if (item) {
        currentProps.command({ id: item });
      }
    };
    const upHandler = () => {
      if (!currentProps) return;
      const items = currentProps.items || [];
      if (items.length === 0) return;
      selectedIndex = (selectedIndex + items.length - 1) % items.length;
      renderItems();
    };
    const downHandler = () => {
      if (!currentProps) return;
      const items = currentProps.items || [];
      if (items.length === 0) return;
      selectedIndex = (selectedIndex + 1) % items.length;
      renderItems();
    };
    const enterHandler = () => {
      selectItem(selectedIndex);
    };
    return {
      onStart: (props) => {
        currentProps = props;
        selectedIndex = 0;
        element = createDropdown();
        element.style.position = "absolute";
        renderItems();
        document.body.appendChild(element);
        if (!props.clientRect) {
          return;
        }
        updatePosition(props.editor, element);
      },
      onUpdate: (props) => {
        currentProps = props;
        selectedIndex = 0;
        renderItems();
        if (!props.clientRect) {
          return;
        }
        updatePosition(props.editor, element);
      },
      onKeyDown: (props) => {
        if (props.event.key === "Escape") {
          if (element && element.parentNode) {
            element.parentNode.removeChild(element);
          }
          return true;
        }
        if (props.event.key === "ArrowUp") {
          upHandler();
          return true;
        }
        if (props.event.key === "ArrowDown") {
          downHandler();
          return true;
        }
        if (props.event.key === "Enter") {
          enterHandler();
          return true;
        }
        return false;
      },
      onExit: () => {
        if (element && element.parentNode) {
          element.parentNode.removeChild(element);
        }
      }
    };
  }
});

// packages/forms/resources/js/components/rich-editor/extensions.js
var extensions_default = async ({
  customExtensionUrls,
  deleteCustomBlockButtonIconHtml,
  editCustomBlockButtonIconHtml,
  editCustomBlockUsing,
  insertCustomBlockUsing,
  key,
  mergeTags,
  noMergeTagSearchResultsMessage,
  placeholder,
  statePath,
  uploadingFileMessage,
  $wire
}) => [
  index_default,
  index_default2,
  BulletList,
  index_default3,
  index_default4,
  extension_custom_block_default.configure({
    deleteCustomBlockButtonIconHtml,
    editCustomBlockButtonIconHtml,
    editCustomBlockUsing,
    insertCustomBlockUsing
  }),
  index_default5,
  index_default6,
  index_default7,
  index_default8,
  extension_image_default,
  index_default10.configure({
    autolink: true,
    openOnClick: false
  }),
  ListItem,
  extension_local_files_default.configure({
    get$WireUsing: () => $wire,
    key,
    statePath,
    uploadingMessage: uploadingFileMessage
  }),
  ...mergeTags.length ? [
    extension_merge_tag_default.configure({
      deleteTriggerWithBackspace: true,
      suggestion: merge_tag_suggestion_default({
        mergeTags,
        noMergeTagSearchResultsMessage
      })
    })
  ] : [],
  OrderedList,
  index_default12,
  index_default13.configure({
    placeholder
  }),
  index_default14,
  index_default15,
  index_default16,
  TableKit.configure({
    table: {
      resizable: true
    }
  }),
  index_default17,
  index_default18,
  UndoRedo,
  ...(await Promise.all(
    customExtensionUrls.map(async (url) => {
      const absoluteUrlRegExp = new RegExp("^(?:[a-z+]+:)?//", "i");
      if (!absoluteUrlRegExp.test(url)) {
        url = new URL(url, document.baseURI).href;
      }
      return (await import(url)).default;
    })
  )).flat()
];

// node_modules/@tiptap/extension-bubble-menu/dist/index.js
function combineDOMRects(rect1, rect2) {
  const top = Math.min(rect1.top, rect2.top);
  const bottom = Math.max(rect1.bottom, rect2.bottom);
  const left = Math.min(rect1.left, rect2.left);
  const right = Math.max(rect1.right, rect2.right);
  const width = right - left;
  const height = bottom - top;
  const x = left;
  const y = top;
  return new DOMRect(x, y, width, height);
}
var BubbleMenuView = class {
  constructor({
    editor,
    element,
    view,
    updateDelay = 250,
    resizeDelay = 60,
    shouldShow,
    options
  }) {
    this.preventHide = false;
    this.isVisible = false;
    this.floatingUIOptions = {
      strategy: "absolute",
      placement: "top",
      offset: 8,
      flip: {},
      shift: {},
      arrow: false,
      size: false,
      autoPlacement: false,
      hide: false,
      inline: false,
      onShow: void 0,
      onHide: void 0,
      onUpdate: void 0,
      onDestroy: void 0
    };
    this.shouldShow = ({ view: view2, state, from: from2, to }) => {
      const { doc: doc3, selection } = state;
      const { empty: empty2 } = selection;
      const isEmptyTextBlock = !doc3.textBetween(from2, to).length && isTextSelection(state.selection);
      const isChildOfMenu = this.element.contains(document.activeElement);
      const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty2 || isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event == null ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) == null ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      if ((event == null ? void 0 : event.relatedTarget) === this.editor.view.dom) {
        return;
      }
      this.hide();
    };
    this.handleDebouncedUpdate = (view2, oldState) => {
      const selectionChanged = !(oldState == null ? void 0 : oldState.selection.eq(view2.state.selection));
      const docChanged = !(oldState == null ? void 0 : oldState.doc.eq(view2.state.doc));
      if (!selectionChanged && !docChanged) {
        return;
      }
      if (this.updateDebounceTimer) {
        clearTimeout(this.updateDebounceTimer);
      }
      this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(view2, selectionChanged, docChanged, oldState);
      }, this.updateDelay);
    };
    this.updateHandler = (view2, selectionChanged, docChanged, oldState) => {
      const { composing } = view2;
      const isSame = !selectionChanged && !docChanged;
      if (composing || isSame) {
        return;
      }
      const shouldShow2 = this.getShouldShow(oldState);
      if (!shouldShow2) {
        this.hide();
        return;
      }
      this.updatePosition();
      this.show();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    this.updateDelay = updateDelay;
    this.resizeDelay = resizeDelay;
    this.floatingUIOptions = {
      ...this.floatingUIOptions,
      ...options
    };
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    window.addEventListener("resize", () => {
      if (this.resizeDebounceTimer) {
        clearTimeout(this.resizeDebounceTimer);
      }
      this.resizeDebounceTimer = window.setTimeout(() => {
        this.updatePosition();
      }, this.resizeDelay);
    });
    this.update(view, view.state);
    if (this.getShouldShow()) {
      this.show();
    }
  }
  get middlewares() {
    const middlewares = [];
    if (this.floatingUIOptions.flip) {
      middlewares.push(flip2(typeof this.floatingUIOptions.flip !== "boolean" ? this.floatingUIOptions.flip : void 0));
    }
    if (this.floatingUIOptions.shift) {
      middlewares.push(
        shift3(typeof this.floatingUIOptions.shift !== "boolean" ? this.floatingUIOptions.shift : void 0)
      );
    }
    if (this.floatingUIOptions.offset) {
      middlewares.push(
        offset2(typeof this.floatingUIOptions.offset !== "boolean" ? this.floatingUIOptions.offset : void 0)
      );
    }
    if (this.floatingUIOptions.arrow) {
      middlewares.push(arrow4(this.floatingUIOptions.arrow));
    }
    if (this.floatingUIOptions.size) {
      middlewares.push(size2(typeof this.floatingUIOptions.size !== "boolean" ? this.floatingUIOptions.size : void 0));
    }
    if (this.floatingUIOptions.autoPlacement) {
      middlewares.push(
        autoPlacement2(
          typeof this.floatingUIOptions.autoPlacement !== "boolean" ? this.floatingUIOptions.autoPlacement : void 0
        )
      );
    }
    if (this.floatingUIOptions.hide) {
      middlewares.push(hide2(typeof this.floatingUIOptions.hide !== "boolean" ? this.floatingUIOptions.hide : void 0));
    }
    if (this.floatingUIOptions.inline) {
      middlewares.push(
        inline2(typeof this.floatingUIOptions.inline !== "boolean" ? this.floatingUIOptions.inline : void 0)
      );
    }
    return middlewares;
  }
  updatePosition() {
    const { selection } = this.editor.state;
    let virtualElement = {
      getBoundingClientRect: () => posToDOMRect(this.view, selection.from, selection.to)
    };
    if (selection instanceof CellSelection) {
      const { $anchorCell, $headCell } = selection;
      const from2 = $anchorCell ? $anchorCell.pos : $headCell.pos;
      const to = $headCell ? $headCell.pos : $anchorCell.pos;
      const fromDOM = this.view.nodeDOM(from2);
      const toDOM = this.view.nodeDOM(to);
      if (!fromDOM || !toDOM) {
        return;
      }
      const clientRect2 = fromDOM === toDOM ? fromDOM.getBoundingClientRect() : combineDOMRects(
        fromDOM.getBoundingClientRect(),
        toDOM.getBoundingClientRect()
      );
      virtualElement = {
        getBoundingClientRect: () => clientRect2
      };
    }
    computePosition2(virtualElement, this.element, {
      placement: this.floatingUIOptions.placement,
      strategy: this.floatingUIOptions.strategy,
      middleware: this.middlewares
    }).then(({ x, y, strategy }) => {
      this.element.style.width = "max-content";
      this.element.style.position = strategy;
      this.element.style.left = `${x}px`;
      this.element.style.top = `${y}px`;
      if (this.isVisible && this.floatingUIOptions.onUpdate) {
        this.floatingUIOptions.onUpdate();
      }
    });
  }
  update(view, oldState) {
    const { state } = view;
    const hasValidSelection = state.selection.from !== state.selection.to;
    if (this.updateDelay > 0 && hasValidSelection) {
      this.handleDebouncedUpdate(view, oldState);
      return;
    }
    const selectionChanged = !(oldState == null ? void 0 : oldState.selection.eq(view.state.selection));
    const docChanged = !(oldState == null ? void 0 : oldState.doc.eq(view.state.doc));
    this.updateHandler(view, selectionChanged, docChanged, oldState);
  }
  getShouldShow(oldState) {
    var _a;
    const { state } = this.view;
    const { selection } = state;
    const { ranges } = selection;
    const from2 = Math.min(...ranges.map((range) => range.$from.pos));
    const to = Math.max(...ranges.map((range) => range.$to.pos));
    const shouldShow = (_a = this.shouldShow) == null ? void 0 : _a.call(this, {
      editor: this.editor,
      element: this.element,
      view: this.view,
      state,
      oldState,
      from: from2,
      to
    });
    return shouldShow;
  }
  show() {
    var _a;
    if (this.isVisible) {
      return;
    }
    this.element.style.visibility = "visible";
    this.element.style.opacity = "1";
    (_a = this.view.dom.parentElement) == null ? void 0 : _a.appendChild(this.element);
    if (this.floatingUIOptions.onShow) {
      this.floatingUIOptions.onShow();
    }
    this.isVisible = true;
  }
  hide() {
    if (!this.isVisible) {
      return;
    }
    this.element.style.visibility = "hidden";
    this.element.style.opacity = "0";
    this.element.remove();
    if (this.floatingUIOptions.onHide) {
      this.floatingUIOptions.onHide();
    }
    this.isVisible = false;
  }
  destroy() {
    this.hide();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
    if (this.floatingUIOptions.onDestroy) {
      this.floatingUIOptions.onDestroy();
    }
  }
};
var BubbleMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options })
  });
};
var BubbleMenu = Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});

// packages/forms/resources/js/components/rich-editor.js
function richEditorFormComponent({
  activePanel,
  deleteCustomBlockButtonIconHtml,
  editCustomBlockButtonIconHtml,
  extensions,
  key,
  isDisabled,
  isLiveDebounced,
  isLiveOnBlur,
  liveDebounce,
  livewireId,
  mergeTags,
  noMergeTagSearchResultsMessage,
  placeholder,
  state,
  statePath,
  uploadingFileMessage,
  bubbleMenus
}) {
  let editor;
  return {
    state,
    activePanel,
    editorSelection: { type: "text", anchor: 1, head: 1 },
    isUploadingFile: false,
    shouldUpdateState: true,
    editorUpdatedAt: Date.now(),
    async init() {
      editor = new Editor({
        editable: !isDisabled,
        element: this.$refs.editor,
        extensions: await extensions_default({
          customExtensionUrls: extensions,
          deleteCustomBlockButtonIconHtml,
          editCustomBlockButtonIconHtml,
          editCustomBlockUsing: (id, config) => this.$wire.mountAction(
            "customBlock",
            {
              editorSelection: this.editorSelection,
              id,
              config,
              mode: "edit"
            },
            { schemaComponent: key }
          ),
          insertCustomBlockUsing: (id, dragPosition = null) => this.$wire.mountAction(
            "customBlock",
            { id, dragPosition, mode: "insert" },
            { schemaComponent: key }
          ),
          key,
          mergeTags,
          noMergeTagSearchResultsMessage,
          placeholder,
          statePath,
          uploadingFileMessage,
          $wire: this.$wire,
          bubbleMenus
        }),
        content: this.state
      });
      bubbleMenus.forEach((menuConfig) => {
        const element = this.$refs[menuConfig.ref];
        if (!element) {
          console.warn(
            `BubbleMenu element "${menuConfig.ref}" not found.`
          );
          return;
        }
        const types = menuConfig.isActiveCondition || [];
        const shouldShow = ({ editor: editor2 }) => types.some((type) => editor2.isActive(type));
        editor.registerPlugin(
          BubbleMenuPlugin({
            editor,
            element,
            pluginKey: `bubbleMenu-${menuConfig.ref}`,
            shouldShow,
            options: {
              placement: "top",
              offset: 10
            }
          })
        );
      });
      editor.on("create", () => {
        this.editorUpdatedAt = Date.now();
      });
      editor.on(
        "update",
        Alpine.debounce(({ editor: editor2 }) => {
          this.editorUpdatedAt = Date.now();
          this.state = editor2.getJSON();
          this.shouldUpdateState = false;
          if (isLiveDebounced) {
            this.$wire.commit();
          }
        }, liveDebounce ?? 300)
      );
      editor.on("selectionUpdate", ({ transaction }) => {
        this.editorUpdatedAt = Date.now();
        this.editorSelection = transaction.selection.toJSON();
      });
      if (isLiveOnBlur) {
        editor.on("blur", () => this.$wire.commit());
      }
      this.$watch("state", () => {
        if (!this.shouldUpdateState) {
          this.shouldUpdateState = true;
          return;
        }
        editor.commands.setContent(this.state);
      });
      window.addEventListener("run-rich-editor-commands", (event) => {
        if (event.detail.livewireId !== livewireId) {
          return;
        }
        if (event.detail.key !== key) {
          return;
        }
        this.runEditorCommands(event.detail);
      });
      window.addEventListener("rich-editor-uploading-file", (event) => {
        if (event.detail.livewireId !== livewireId) {
          return;
        }
        if (event.detail.key !== key) {
          return;
        }
        this.isUploadingFile = true;
        event.stopPropagation();
      });
      window.addEventListener("rich-editor-uploaded-file", (event) => {
        if (event.detail.livewireId !== livewireId) {
          return;
        }
        if (event.detail.key !== key) {
          return;
        }
        this.isUploadingFile = false;
        event.stopPropagation();
      });
      window.dispatchEvent(
        new CustomEvent(`schema-component-${livewireId}-${key}-loaded`)
      );
    },
    getEditor() {
      return editor;
    },
    $getEditor() {
      return this.getEditor();
    },
    setEditorSelection(selection) {
      if (!selection) {
        return;
      }
      this.editorSelection = selection;
      editor.chain().command(({ tr: tr2 }) => {
        tr2.setSelection(
          Selection.fromJSON(
            editor.state.doc,
            this.editorSelection
          )
        );
        return true;
      }).run();
    },
    runEditorCommands({ commands, editorSelection }) {
      this.setEditorSelection(editorSelection);
      let commandChain = editor.chain();
      commands.forEach(
        (command2) => commandChain = commandChain[command2.name](
          ...command2.arguments ?? []
        )
      );
      commandChain.run();
    },
    togglePanel(id = null) {
      if (this.isPanelActive(id)) {
        this.activePanel = null;
        return;
      }
      this.activePanel = id;
    },
    isPanelActive(id = null) {
      if (id === null) {
        return this.activePanel !== null;
      }
      return this.activePanel === id;
    },
    insertMergeTag(id) {
      editor.chain().focus().insertContent([
        {
          type: "mergeTag",
          attrs: { id }
        },
        {
          type: "text",
          text: " "
        }
      ]).run();
    }
  };
}
export {
  richEditorFormComponent as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL29yZGVyZWRtYXAvZGlzdC9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdHJhbnNmb3JtL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXN0YXRlL2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXZpZXcvZGlzdC9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdzNjLWtleW5hbWUvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWtleW1hcC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlQ2hhaW5hYmxlU3RhdGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvQ29tbWFuZE1hbmFnZXIudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRWRpdG9yLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL0V2ZW50RW1pdHRlci50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9FeHRlbnNpb25NYW5hZ2VyLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY29tYmluZVRyYW5zYWN0aW9uU3RlcHMudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9jcmVhdGVOb2RlRnJvbUNvbnRlbnQudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2VsZW1lbnRGcm9tU3RyaW5nLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9kZWZhdWx0QmxvY2tBdC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbi50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRDaGlsZHJlbkluUmFuZ2UudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2ZpbmRQYXJlbnROb2RlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0RXh0ZW5zaW9uRmllbGQudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9mbGF0dGVuRXh0ZW5zaW9ucy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSFRNTC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldEhUTUxGcm9tRnJhZ21lbnQudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNGdW5jdGlvbi50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc0VtcHR5T2JqZWN0LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvc3BsaXRFeHRlbnNpb25zLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9tZXJnZUF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRSZW5kZXJlZEF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2Zyb21TdHJpbmcudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2ZpbmREdXBsaWNhdGVzLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvc29ydEV4dGVuc2lvbnMudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9yZXNvbHZlRXh0ZW5zaW9ucy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlSlNPTi50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dlbmVyYXRlVGV4dC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRCZXR3ZWVuLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0VGV4dC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXRNYXJrVHlwZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtBdHRyaWJ1dGVzLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0Tm9kZVR5cGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXROb2RlQXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0QXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvcmVtb3ZlRHVwbGljYXRlcy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldENoYW5nZWRSYW5nZXMudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9nZXREZWJ1Z0pTT04udHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzUmVnRXhwLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtSYW5nZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE1hcmtzQmV0d2Vlbi50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldE5vZGVBdFBvc2l0aW9uLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZUJ5TmFtZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFNwbGl0dGVkQXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2dldFRleHRDb250ZW50RnJvbU5vZGVzLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNNYXJrQWN0aXZlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNOb2RlQWN0aXZlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNBY3RpdmUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0F0RW5kT2ZOb2RlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNBdFN0YXJ0T2ZOb2RlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc0xpc3QudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9pc05vZGVFbXB0eS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzTm9kZVNlbGVjdGlvbi50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9oZWxwZXJzL2lzVGV4dFNlbGVjdGlvbi50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvbWluTWF4LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvcG9zVG9ET01SZWN0LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24udHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9yZXdyaXRlVW5rbm93bkNvbnRlbnQudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaGVscGVycy9zZWxlY3Rpb25Ub0luc2VydGlvbkVuZC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9JbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzUGxhaW5PYmplY3QudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL21lcmdlRGVlcC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9FeHRlbmRhYmxlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL01hcmsudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvUGFzdGVSdWxlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9pc051bWJlci50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2luZGV4LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMvY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvRXh0ZW5zaW9uLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2luZGV4LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2JsdXIudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY2xlYXJDb250ZW50LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2NsZWFyTm9kZXMudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvY29tbWFuZC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9jcmVhdGVQYXJhZ3JhcGhOZWFyLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2N1dC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVDdXJyZW50Tm9kZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9kZWxldGVOb2RlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZVJhbmdlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2RlbGV0ZVNlbGVjdGlvbi50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9lbnRlci50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9leGl0Q29kZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9leHRlbmRNYXJrUmFuZ2UudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZmlyc3QudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzQW5kcm9pZC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNpT1MudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZm9jdXMudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvZm9yRWFjaC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9pbnNlcnRDb250ZW50LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2luc2VydENvbnRlbnRBdC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9qb2luLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2pvaW5JdGVtQmFja3dhcmQudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvam9pbkl0ZW1Gb3J3YXJkLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2pvaW5UZXh0YmxvY2tCYWNrd2FyZC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9qb2luVGV4dGJsb2NrRm9yd2FyZC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvaXNNYWNPUy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9rZXlib2FyZFNob3J0Y3V0LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL2xpZnQudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvbGlmdEVtcHR5QmxvY2sudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvbGlmdExpc3RJdGVtLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL25ld2xpbmVJbkNvZGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2RlbGV0ZVByb3BzLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3Jlc2V0QXR0cmlidXRlcy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zY3JvbGxJbnRvVmlldy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZWxlY3RBbGwudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0Tm9kZUJhY2t3YXJkLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdE5vZGVGb3J3YXJkLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFBhcmVudE5vZGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2VsZWN0VGV4dGJsb2NrRW5kLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NlbGVjdFRleHRibG9ja1N0YXJ0LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldENvbnRlbnQudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0TWFyay50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXRNZXRhLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NldE5vZGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvc2V0Tm9kZVNlbGVjdGlvbi50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zZXRUZXh0U2VsZWN0aW9uLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NpbmtMaXN0SXRlbS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy9zcGxpdEJsb2NrLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3NwbGl0TGlzdEl0ZW0udHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdG9nZ2xlTGlzdC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy90b2dnbGVNYXJrLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3RvZ2dsZU5vZGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdG9nZ2xlV3JhcC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9jb21tYW5kcy91bmRvSW5wdXRSdWxlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3Vuc2V0QWxsTWFya3MudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvdW5zZXRNYXJrLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3VwZGF0ZUF0dHJpYnV0ZXMudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvY29tbWFuZHMvd3JhcEluLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2NvbW1hbmRzL3dyYXBJbkxpc3QudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9jb21tYW5kcy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2RlbGV0ZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2Ryb3AudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy9lZGl0YWJsZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9leHRlbnNpb25zL2ZvY3VzRXZlbnRzLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMva2V5bWFwLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2V4dGVuc2lvbnMvcGFzdGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvZXh0ZW5zaW9ucy90YWJpbmRleC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9Ob2RlUG9zLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3N0eWxlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3V0aWxpdGllcy9jcmVhdGVTdHlsZVRhZy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL21hcmtJbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy9ub2RlSW5wdXRSdWxlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL2lucHV0UnVsZXMvdGV4dGJsb2NrVHlwZUlucHV0UnVsZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9pbnB1dFJ1bGVzL3RleHRJbnB1dFJ1bGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvaW5wdXRSdWxlcy93cmFwcGluZ0lucHV0UnVsZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9qc3gtcnVudGltZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy91dGlsaXRpZXMvZXNjYXBlRm9yUmVnRXgudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvdXRpbGl0aWVzL2lzU3RyaW5nLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL01hcmtWaWV3LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL05vZGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvTm9kZVZpZXcudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvcGFzdGVSdWxlcy9tYXJrUGFzdGVSdWxlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvc3JjL3Bhc3RlUnVsZXMvbm9kZVBhc3RlUnVsZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9wYXN0ZVJ1bGVzL3RleHRQYXN0ZVJ1bGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvY29yZS9zcmMvVHJhY2tlci50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZHJvcGN1cnNvci9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcm9wZS1zZXF1ZW5jZS9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9ucy9zcmMvY2hhcmFjdGVyLWNvdW50L2NoYXJhY3Rlci1jb3VudC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb25zL3NyYy9kcm9wLWN1cnNvci9kcm9wLWN1cnNvci50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb25zL3NyYy9mb2N1cy9mb2N1cy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb25zL3NyYy9nYXAtY3Vyc29yL2dhcC1jdXJzb3IudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9ucy9zcmMvcGxhY2Vob2xkZXIvcGxhY2Vob2xkZXIudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9ucy9zcmMvc2VsZWN0aW9uL3NlbGVjdGlvbi50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb25zL3NyYy90cmFpbGluZy1ub2RlL3RyYWlsaW5nLW5vZGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9ucy9zcmMvdW5kby1yZWRvL3VuZG8tcmVkby50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL3NyYy9qc3gtcnVudGltZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9zcmMvYmxvY2txdW90ZS50c3giLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJsb2NrcXVvdGUvc3JjL2luZGV4LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ib2xkL3NyYy9ib2xkLnRzeCIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYm9sZC9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUvc3JjL2NvZGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUvc3JjL2luZGV4LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlLWJsb2NrL3NyYy9jb2RlLWJsb2NrLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlLWJsb2NrL3NyYy9pbmRleC50cyIsICIuLi8uLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9yaWNoLWVkaXRvci9leHRlbnNpb24tY3VzdG9tLWJsb2NrLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudC9zcmMvZG9jdW1lbnQudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWRvY3VtZW50L3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvci9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhlYWRpbmcvc3JjL2hlYWRpbmcudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhlYWRpbmcvc3JjL2luZGV4LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWMvc3JjL2l0YWxpYy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taW1hZ2Uvc3JjL2ltYWdlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1pbWFnZS9zcmMvaW5kZXgudHMiLCAiLi4vLi4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvcmljaC1lZGl0b3IvZXh0ZW5zaW9uLWltYWdlLmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9saW5raWZ5anMvZGlzdC9saW5raWZ5Lm1qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9zcmMvbGluay50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9zcmMvaGVscGVycy9hdXRvbGluay50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9zcmMvaGVscGVycy9jbGlja0hhbmRsZXIudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpbmsvc3JjL2hlbHBlcnMvcGFzdGVIYW5kbGVyLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saW5rL3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9zcmMvYnVsbGV0LWxpc3QvYnVsbGV0LWxpc3QudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3Qvc3JjL2l0ZW0vbGlzdC1pdGVtLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0L3NyYy9rZXltYXAvbGlzdC1rZXltYXAudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3Qvc3JjL2tleW1hcC9saXN0SGVscGVycy9pbmRleC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9zcmMva2V5bWFwL2xpc3RIZWxwZXJzL2ZpbmRMaXN0SXRlbVBvcy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9zcmMva2V5bWFwL2xpc3RIZWxwZXJzL2dldE5leHRMaXN0RGVwdGgudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3Qvc3JjL2tleW1hcC9saXN0SGVscGVycy9oYW5kbGVCYWNrc3BhY2UudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3Qvc3JjL2tleW1hcC9saXN0SGVscGVycy9oYXNMaXN0QmVmb3JlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0L3NyYy9rZXltYXAvbGlzdEhlbHBlcnMvaGFzTGlzdEl0ZW1CZWZvcmUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3Qvc3JjL2tleW1hcC9saXN0SGVscGVycy9saXN0SXRlbUhhc1N1Ykxpc3QudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3Qvc3JjL2tleW1hcC9saXN0SGVscGVycy9oYW5kbGVEZWxldGUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3Qvc3JjL2tleW1hcC9saXN0SGVscGVycy9uZXh0TGlzdElzRGVlcGVyLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0L3NyYy9rZXltYXAvbGlzdEhlbHBlcnMvbmV4dExpc3RJc0hpZ2hlci50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9zcmMva2V5bWFwL2xpc3RIZWxwZXJzL2hhc0xpc3RJdGVtQWZ0ZXIudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3Qvc3JjL2tpdC9pbmRleC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9zcmMvb3JkZXJlZC1saXN0L29yZGVyZWQtbGlzdC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9zcmMvdGFzay1pdGVtL3Rhc2staXRlbS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC9zcmMvdGFzay1saXN0L3Rhc2stbGlzdC50cyIsICIuLi8uLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9yaWNoLWVkaXRvci9leHRlbnNpb24tbG9jYWwtZmlsZXMuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvc3VnZ2VzdGlvbi9zcmMvc3VnZ2VzdGlvbi50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdWdnZXN0aW9uL3NyYy9maW5kU3VnZ2VzdGlvbk1hdGNoLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3N1Z2dlc3Rpb24vc3JjL2luZGV4LnRzIiwgIi4uLy4uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL3JpY2gtZWRpdG9yL2V4dGVuc2lvbi1tZXJnZS10YWcuanMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXBhcmFncmFwaC9zcmMvcGFyYWdyYXBoLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGgvc3JjL2luZGV4LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wbGFjZWhvbGRlci9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZS9zcmMvc3RyaWtlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1zdHJpa2Uvc3JjL2luZGV4LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1zdWJzY3JpcHQvc3JjL3N1YnNjcmlwdC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3Vic2NyaXB0L3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3VwZXJzY3JpcHQvc3JjL3N1cGVyc2NyaXB0LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1zdXBlcnNjcmlwdC9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXRhYmxlcy9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10YWJsZS9zcmMvY2VsbC90YWJsZS1jZWxsLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10YWJsZS9zcmMvaGVhZGVyL3RhYmxlLWhlYWRlci50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGFibGUvc3JjL2tpdC9pbmRleC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGFibGUvc3JjL3Jvdy90YWJsZS1yb3cudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRhYmxlL3NyYy90YWJsZS90YWJsZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGFibGUvc3JjL3RhYmxlL3V0aWxpdGllcy9jb2xTdHlsZS50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGFibGUvc3JjL3RhYmxlL1RhYmxlVmlldy50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGFibGUvc3JjL3RhYmxlL3V0aWxpdGllcy9jcmVhdGVDb2xHcm91cC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGFibGUvc3JjL3RhYmxlL3V0aWxpdGllcy9jcmVhdGVDZWxsLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10YWJsZS9zcmMvdGFibGUvdXRpbGl0aWVzL2dldFRhYmxlTm9kZVR5cGVzLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10YWJsZS9zcmMvdGFibGUvdXRpbGl0aWVzL2NyZWF0ZVRhYmxlLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10YWJsZS9zcmMvdGFibGUvdXRpbGl0aWVzL2RlbGV0ZVRhYmxlV2hlbkFsbENlbGxzU2VsZWN0ZWQudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRhYmxlL3NyYy90YWJsZS91dGlsaXRpZXMvaXNDZWxsU2VsZWN0aW9uLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0L3NyYy90ZXh0LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0L3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL3NyYy91bmRlcmxpbmUudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXVuZGVybGluZS9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLm1qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCAiLi4vLi4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvcmljaC1lZGl0b3IvbWVyZ2UtdGFnLXN1Z2dlc3Rpb24uanMiLCAiLi4vLi4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvcmljaC1lZGl0b3IvZXh0ZW5zaW9ucy5qcyIsICIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnViYmxlLW1lbnUvc3JjL2J1YmJsZS1tZW51LnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudS9zcmMvYnViYmxlLW1lbnUtcGx1Z2luLnRzIiwgIi4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudS9zcmMvaW5kZXgudHMiLCAiLi4vLi4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvcmljaC1lZGl0b3IuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIDo6LSBQZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhbiBvcmRlcmVkIG1hcHBpbmcgZnJvbVxuLy8gc3RyaW5ncyB0byB2YWx1ZXMsIHdpdGggc29tZSBjb252ZW5pZW50IHVwZGF0ZSBtZXRob2RzLlxuZnVuY3Rpb24gT3JkZXJlZE1hcChjb250ZW50KSB7XG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG59XG5cbk9yZGVyZWRNYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogT3JkZXJlZE1hcCxcblxuICBmaW5kOiBmdW5jdGlvbihrZXkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRbaV0gPT09IGtleSkgcmV0dXJuIGlcbiAgICByZXR1cm4gLTFcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nKSBcdTIxOTIgP2FueVxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWUgc3RvcmVkIHVuZGVyIGBrZXlgLCBvciByZXR1cm4gdW5kZWZpbmVkIHdoZW5cbiAgLy8gbm8gc3VjaCBrZXkgZXhpc3RzLlxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZChrZXkpO1xuICAgIHJldHVybiBmb3VuZCA9PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuY29udGVudFtmb3VuZCArIDFdXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55LCA/c3RyaW5nKSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBDcmVhdGUgYSBuZXcgbWFwIGJ5IHJlcGxhY2luZyB0aGUgdmFsdWUgb2YgYGtleWAgd2l0aCBhIG5ld1xuICAvLyB2YWx1ZSwgb3IgYWRkaW5nIGEgYmluZGluZyB0byB0aGUgZW5kIG9mIHRoZSBtYXAuIElmIGBuZXdLZXlgIGlzXG4gIC8vIGdpdmVuLCB0aGUga2V5IG9mIHRoZSBiaW5kaW5nIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGF0IGtleS5cbiAgdXBkYXRlOiBmdW5jdGlvbihrZXksIHZhbHVlLCBuZXdLZXkpIHtcbiAgICB2YXIgc2VsZiA9IG5ld0tleSAmJiBuZXdLZXkgIT0ga2V5ID8gdGhpcy5yZW1vdmUobmV3S2V5KSA6IHRoaXM7XG4gICAgdmFyIGZvdW5kID0gc2VsZi5maW5kKGtleSksIGNvbnRlbnQgPSBzZWxmLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHtcbiAgICAgIGNvbnRlbnQucHVzaChuZXdLZXkgfHwga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRbZm91bmQgKyAxXSA9IHZhbHVlO1xuICAgICAgaWYgKG5ld0tleSkgY29udGVudFtmb3VuZF0gPSBuZXdLZXk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIFJldHVybiBhIG1hcCB3aXRoIHRoZSBnaXZlbiBrZXkgcmVtb3ZlZCwgaWYgaXQgZXhpc3RlZC5cbiAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmZpbmQoa2V5KTtcbiAgICBpZiAoZm91bmQgPT0gLTEpIHJldHVybiB0aGlzXG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBjb250ZW50LnNwbGljZShmb3VuZCwgMik7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgYW55KSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBuZXcga2V5IHRvIHRoZSBzdGFydCBvZiB0aGUgbWFwLlxuICBhZGRUb1N0YXJ0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKFtrZXksIHZhbHVlXS5jb25jYXQodGhpcy5yZW1vdmUoa2V5KS5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnkpIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIG5ldyBrZXkgdG8gdGhlIGVuZCBvZiB0aGUgbWFwLlxuICBhZGRUb0VuZDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5yZW1vdmUoa2V5KS5jb250ZW50LnNsaWNlKCk7XG4gICAgY29udGVudC5wdXNoKGtleSwgdmFsdWUpO1xuICAgIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIHN0cmluZywgYW55KSBcdTIxOTIgT3JkZXJlZE1hcFxuICAvLyBBZGQgYSBrZXkgYWZ0ZXIgdGhlIGdpdmVuIGtleS4gSWYgYHBsYWNlYCBpcyBub3QgZm91bmQsIHRoZSBuZXdcbiAgLy8ga2V5IGlzIGFkZGVkIHRvIHRoZSBlbmQuXG4gIGFkZEJlZm9yZTogZnVuY3Rpb24ocGxhY2UsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgd2l0aG91dCA9IHRoaXMucmVtb3ZlKGtleSksIGNvbnRlbnQgPSB3aXRob3V0LmNvbnRlbnQuc2xpY2UoKTtcbiAgICB2YXIgZm91bmQgPSB3aXRob3V0LmZpbmQocGxhY2UpO1xuICAgIGNvbnRlbnQuc3BsaWNlKGZvdW5kID09IC0xID8gY29udGVudC5sZW5ndGggOiBmb3VuZCwgMCwga2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkpXG4gIC8vIENhbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyIGluIHRoZSBtYXAsIGluXG4gIC8vIG9yZGVyLlxuICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICBmKHRoaXMuY29udGVudFtpXSwgdGhpcy5jb250ZW50W2kgKyAxXSk7XG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgcHJlcGVuZGluZyB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYCBiZWZvcmUgdGhlIGtleXMgaW4gYG1hcGAuXG4gIHByZXBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKG1hcC5jb250ZW50LmNvbmNhdCh0aGlzLnN1YnRyYWN0KG1hcCkuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgYXBwZW5kaW5nIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgIGFmdGVyIHRoZSBrZXlzIGluIGBtYXBgLlxuICBhcHBlbmQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGlmICghbWFwLnNpemUpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKHRoaXMuc3VidHJhY3QobWFwKS5jb250ZW50LmNvbmNhdChtYXAuY29udGVudCkpXG4gIH0sXG5cbiAgLy8gOjogKHVuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIFx1MjE5MiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG1hcCBjb250YWluaW5nIGFsbCB0aGUga2V5cyBpbiB0aGlzIG1hcCB0aGF0IGRvbid0XG4gIC8vIGFwcGVhciBpbiBgbWFwYC5cbiAgc3VidHJhY3Q6IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgIG1hcCA9IE9yZGVyZWRNYXAuZnJvbShtYXApO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmNvbnRlbnQubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXN1bHQgPSByZXN1bHQucmVtb3ZlKG1hcC5jb250ZW50W2ldKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLy8gOjogKCkgXHUyMTkyIE9iamVjdFxuICAvLyBUdXJuIG9yZGVyZWQgbWFwIGludG8gYSBwbGFpbiBvYmplY3QuXG4gIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmVzdWx0W2tleV0gPSB2YWx1ZTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9LFxuXG4gIC8vIDo6IG51bWJlclxuICAvLyBUaGUgYW1vdW50IG9mIGtleXMgaW4gdGhpcyBtYXAuXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID4+IDFcbiAgfVxufTtcblxuLy8gOjogKD91bmlvbjxPYmplY3QsIE9yZGVyZWRNYXA+KSBcdTIxOTIgT3JkZXJlZE1hcFxuLy8gUmV0dXJuIGEgbWFwIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuIElmIG51bGwsIGNyZWF0ZSBhbiBlbXB0eVxuLy8gbWFwLiBJZiBnaXZlbiBhbiBvcmRlcmVkIG1hcCwgcmV0dXJuIHRoYXQgbWFwIGl0c2VsZi4gSWYgZ2l2ZW4gYW5cbi8vIG9iamVjdCwgY3JlYXRlIGEgbWFwIGZyb20gdGhlIG9iamVjdCdzIHByb3BlcnRpZXMuXG5PcmRlcmVkTWFwLmZyb20gPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPcmRlcmVkTWFwKSByZXR1cm4gdmFsdWVcbiAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgaWYgKHZhbHVlKSBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSBjb250ZW50LnB1c2gocHJvcCwgdmFsdWVbcHJvcF0pO1xuICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE9yZGVyZWRNYXA7XG4iLCAiaW1wb3J0IE9yZGVyZWRNYXAgZnJvbSAnb3JkZXJlZG1hcCc7XG5cbmZ1bmN0aW9uIGZpbmREaWZmU3RhcnQoYSwgYiwgcG9zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT0gYS5jaGlsZENvdW50IHx8IGkgPT0gYi5jaGlsZENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIGEuY2hpbGRDb3VudCA9PSBiLmNoaWxkQ291bnQgPyBudWxsIDogcG9zO1xuICAgICAgICBsZXQgY2hpbGRBID0gYS5jaGlsZChpKSwgY2hpbGRCID0gYi5jaGlsZChpKTtcbiAgICAgICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGNoaWxkQS50ZXh0W2pdID09IGNoaWxkQi50ZXh0W2pdOyBqKyspXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmREaWZmU3RhcnQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3MgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbm5lciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmREaWZmRW5kKGEsIGIsIHBvc0EsIHBvc0IpIHtcbiAgICBmb3IgKGxldCBpQSA9IGEuY2hpbGRDb3VudCwgaUIgPSBiLmNoaWxkQ291bnQ7Oykge1xuICAgICAgICBpZiAoaUEgPT0gMCB8fCBpQiA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGlBID09IGlCID8gbnVsbCA6IHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICBsZXQgY2hpbGRBID0gYS5jaGlsZCgtLWlBKSwgY2hpbGRCID0gYi5jaGlsZCgtLWlCKSwgc2l6ZSA9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgICAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgICAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGRBLnNhbWVNYXJrdXAoY2hpbGRCKSlcbiAgICAgICAgICAgIHJldHVybiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgICAgICAgIGxldCBzYW1lID0gMCwgbWluU2l6ZSA9IE1hdGgubWluKGNoaWxkQS50ZXh0Lmxlbmd0aCwgY2hpbGRCLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlIChzYW1lIDwgbWluU2l6ZSAmJiBjaGlsZEEudGV4dFtjaGlsZEEudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0gPT0gY2hpbGRCLnRleHRbY2hpbGRCLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdKSB7XG4gICAgICAgICAgICAgICAgc2FtZSsrO1xuICAgICAgICAgICAgICAgIHBvc0EtLTtcbiAgICAgICAgICAgICAgICBwb3NCLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZERpZmZFbmQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3NBIC0gMSwgcG9zQiAtIDEpO1xuICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBwb3NBIC09IHNpemU7XG4gICAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICB9XG59XG5cbi8qKlxuQSBmcmFnbWVudCByZXByZXNlbnRzIGEgbm9kZSdzIGNvbGxlY3Rpb24gb2YgY2hpbGQgbm9kZXMuXG5cbkxpa2Ugbm9kZXMsIGZyYWdtZW50cyBhcmUgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZXMsIGFuZCB5b3VcbnNob3VsZCBub3QgbXV0YXRlIHRoZW0gb3IgdGhlaXIgY29udGVudC4gUmF0aGVyLCB5b3UgY3JlYXRlIG5ld1xuaW5zdGFuY2VzIHdoZW5ldmVyIG5lZWRlZC4gVGhlIEFQSSB0cmllcyB0byBtYWtlIHRoaXMgZWFzeS5cbiovXG5jbGFzcyBGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgY2hpbGQgbm9kZXMgaW4gdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIGNvbnRlbnQsIHNpemUpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZSB8fCAwO1xuICAgICAgICBpZiAoc2l6ZSA9PSBudWxsKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSArPSBjb250ZW50W2ldLm5vZGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgYmV0d2VlbiB0aGUgZ2l2ZW4gdHdvXG4gICAgcG9zaXRpb25zIChyZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzIGZyYWdtZW50KS4gRG9lc24ndCBkZXNjZW5kXG4gICAgaW50byBhIG5vZGUgd2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICovXG4gICAgbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBub2RlU3RhcnQgPSAwLCBwYXJlbnQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXSwgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSAmJiBmKGNoaWxkLCBub2RlU3RhcnQgKyBwb3MsIHBhcmVudCB8fCBudWxsLCBpKSAhPT0gZmFsc2UgJiYgY2hpbGQuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICBjaGlsZC5ub2Rlc0JldHdlZW4oTWF0aC5tYXgoMCwgZnJvbSAtIHN0YXJ0KSwgTWF0aC5taW4oY2hpbGQuY29udGVudC5zaXplLCB0byAtIHN0YXJ0KSwgZiwgbm9kZVN0YXJ0ICsgc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIGBwb3NgIHdpbGwgYmVcbiAgICByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGZyYWdtZW50LiBUaGUgY2FsbGJhY2sgbWF5IHJldHVyblxuICAgIGBmYWxzZWAgdG8gcHJldmVudCB0cmF2ZXJzYWwgb2YgYSBnaXZlbiBub2RlJ3MgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBkZXNjZW5kYW50cyhmKSB7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuc2l6ZSwgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dHJhY3QgdGhlIHRleHQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuIFNlZSB0aGUgc2FtZSBtZXRob2Qgb25cbiAgICBbYE5vZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS50ZXh0QmV0d2VlbikuXG4gICAgKi9cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIiwgZmlyc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgbGV0IG5vZGVUZXh0ID0gbm9kZS5pc1RleHQgPyBub2RlLnRleHQuc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpXG4gICAgICAgICAgICAgICAgOiAhbm9kZS5pc0xlYWYgPyBcIlwiXG4gICAgICAgICAgICAgICAgICAgIDogbGVhZlRleHQgPyAodHlwZW9mIGxlYWZUZXh0ID09PSBcImZ1bmN0aW9uXCIgPyBsZWFmVGV4dChub2RlKSA6IGxlYWZUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBub2RlLnR5cGUuc3BlYy5sZWFmVGV4dCA/IG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0KG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNCbG9jayAmJiAobm9kZS5pc0xlYWYgJiYgbm9kZVRleHQgfHwgbm9kZS5pc1RleHRibG9jaykgJiYgYmxvY2tTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCArPSBub2RlVGV4dDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgY29tYmluZWQgY29udGVudCBvZiB0aGlzXG4gICAgZnJhZ21lbnQgYW5kIHRoZSBvdGhlci5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5sYXN0Q2hpbGQsIGZpcnN0ID0gb3RoZXIuZmlyc3RDaGlsZCwgY29udGVudCA9IHRoaXMuY29udGVudC5zbGljZSgpLCBpID0gMDtcbiAgICAgICAgaWYgKGxhc3QuaXNUZXh0ICYmIGxhc3Quc2FtZU1hcmt1cChmaXJzdCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnRbY29udGVudC5sZW5ndGggLSAxXSA9IGxhc3Qud2l0aFRleHQobGFzdC50ZXh0ICsgZmlyc3QudGV4dCk7XG4gICAgICAgICAgICBpID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IG90aGVyLmNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBjb250ZW50LnB1c2gob3RoZXIuY29udGVudFtpXSk7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCwgdGhpcy5zaXplICsgb3RoZXIuc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEN1dCBvdXQgdGhlIHN1Yi1mcmFnbWVudCBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgY3V0KGZyb20sIHRvID0gdGhpcy5zaXplKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXSwgc2l6ZSA9IDA7XG4gICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXSwgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20gfHwgZW5kID4gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pc1RleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyksIE1hdGgubWluKGNoaWxkLnRleHQubGVuZ3RoLCB0byAtIHBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MgLSAxKSwgTWF0aC5taW4oY2hpbGQuY29udGVudC5zaXplLCB0byAtIHBvcyAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChyZXN1bHQsIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGN1dEJ5SW5kZXgoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgaW4gd2hpY2ggdGhlIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4IGlzXG4gICAgcmVwbGFjZWQgYnkgdGhlIGdpdmVuIG5vZGUuXG4gICAgKi9cbiAgICByZXBsYWNlQ2hpbGQoaW5kZXgsIG5vZGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICAgICAgICBpZiAoY3VycmVudCA9PSBub2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBjb3B5ID0gdGhpcy5jb250ZW50LnNsaWNlKCk7XG4gICAgICAgIGxldCBzaXplID0gdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSAtIGN1cnJlbnQubm9kZVNpemU7XG4gICAgICAgIGNvcHlbaW5kZXhdID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb3B5LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGJ5IHByZXBlbmRpbmcgdGhlIGdpdmVuIG5vZGUgdG8gdGhpc1xuICAgIGZyYWdtZW50LlxuICAgICovXG4gICAgYWRkVG9TdGFydChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoW25vZGVdLmNvbmNhdCh0aGlzLmNvbnRlbnQpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGJ5IGFwcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4gICAgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBhZGRUb0VuZChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LmNvbmNhdChub2RlKSwgdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBmcmFnbWVudCB0byBhbm90aGVyIG9uZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoICE9IG90aGVyLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZW50W2ldLmVxKG90aGVyLmNvbnRlbnRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgZnJhZ21lbnQsIG9yIGBudWxsYCBpZiBpdCBpcyBlbXB0eS5cbiAgICAqL1xuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFswXSA6IG51bGw7IH1cbiAgICAvKipcbiAgICBUaGUgbGFzdCBjaGlsZCBvZiB0aGUgZnJhZ21lbnQsIG9yIGBudWxsYCBpZiBpdCBpcyBlbXB0eS5cbiAgICAqL1xuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSA6IG51bGw7IH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzIGluIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBnZXQgY2hpbGRDb3VudCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LiBSYWlzZSBhbiBlcnJvciB3aGVuIHRoZVxuICAgIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAqL1xuICAgIGNoaWxkKGluZGV4KSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IFwiICsgaW5kZXggKyBcIiBvdXQgb2YgcmFuZ2UgZm9yIFwiICsgdGhpcyk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgaXQgZXhpc3RzLlxuICAgICovXG4gICAgbWF5YmVDaGlsZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50W2luZGV4XSB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIGBmYCBmb3IgZXZlcnkgY2hpbGQgbm9kZSwgcGFzc2luZyB0aGUgbm9kZSwgaXRzIG9mZnNldFxuICAgIGludG8gdGhpcyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBpbmRleC5cbiAgICAqL1xuICAgIGZvckVhY2goZikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcCA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY29udGVudFtpXTtcbiAgICAgICAgICAgIGYoY2hpbGQsIHAsIGkpO1xuICAgICAgICAgICAgcCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBmaXJzdCBwb3NpdGlvbiBhdCB3aGljaCB0aGlzIGZyYWdtZW50IGFuZCBhbm90aGVyXG4gICAgZnJhZ21lbnQgZGlmZmVyLCBvciBgbnVsbGAgaWYgdGhleSBhcmUgdGhlIHNhbWUuXG4gICAgKi9cbiAgICBmaW5kRGlmZlN0YXJ0KG90aGVyLCBwb3MgPSAwKSB7XG4gICAgICAgIHJldHVybiBmaW5kRGlmZlN0YXJ0KHRoaXMsIG90aGVyLCBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBmaXJzdCBwb3NpdGlvbiwgc2VhcmNoaW5nIGZyb20gdGhlIGVuZCwgYXQgd2hpY2ggdGhpc1xuICAgIGZyYWdtZW50IGFuZCB0aGUgZ2l2ZW4gZnJhZ21lbnQgZGlmZmVyLCBvciBgbnVsbGAgaWYgdGhleSBhcmVcbiAgICB0aGUgc2FtZS4gU2luY2UgdGhpcyBwb3NpdGlvbiB3aWxsIG5vdCBiZSB0aGUgc2FtZSBpbiBib3RoXG4gICAgbm9kZXMsIGFuIG9iamVjdCB3aXRoIHR3byBzZXBhcmF0ZSBwb3NpdGlvbnMgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBmaW5kRGlmZkVuZChvdGhlciwgcG9zID0gdGhpcy5zaXplLCBvdGhlclBvcyA9IG90aGVyLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZpbmREaWZmRW5kKHRoaXMsIG90aGVyLCBwb3MsIG90aGVyUG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgaW5kZXggYW5kIGlubmVyIG9mZnNldCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gcmVsYXRpdmVcbiAgICBwb3NpdGlvbiBpbiB0aGlzIGZyYWdtZW50LiBUaGUgcmVzdWx0IG9iamVjdCB3aWxsIGJlIHJldXNlZFxuICAgIChvdmVyd3JpdHRlbikgdGhlIG5leHQgdGltZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmRJbmRleChwb3MsIHJvdW5kID0gLTEpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KDAsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPT0gdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KHRoaXMuY29udGVudC5sZW5ndGgsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPiB0aGlzLnNpemUgfHwgcG9zIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQb3NpdGlvbiAke3Bvc30gb3V0c2lkZSBvZiBmcmFnbWVudCAoJHt0aGlzfSlgKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1clBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmNoaWxkKGkpLCBlbmQgPSBjdXJQb3MgKyBjdXIubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gcG9zIHx8IHJvdW5kID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KGkgKyAxLCBlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRJbmRleChpLCBjdXJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGRlYnVnZ2luZyBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCI8XCIgKyB0aGlzLnRvU3RyaW5nSW5uZXIoKSArIFwiPlwiOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZ0lubmVyKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmpvaW4oXCIsIFwiKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudC5tYXAobiA9PiBuLnRvSlNPTigpKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgZnJhZ21lbnQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEZyYWdtZW50LmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHZhbHVlLm1hcChzY2hlbWEubm9kZUZyb21KU09OKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgZnJhZ21lbnQgZnJvbSBhbiBhcnJheSBvZiBub2Rlcy4gRW5zdXJlcyB0aGF0IGFkamFjZW50XG4gICAgdGV4dCBub2RlcyB3aXRoIHRoZSBzYW1lIG1hcmtzIGFyZSBqb2luZWQgdG9nZXRoZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgIGlmICghYXJyYXkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBsZXQgam9pbmVkLCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpICYmIG5vZGUuaXNUZXh0ICYmIGFycmF5W2kgLSAxXS5zYW1lTWFya3VwKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2luZWQpXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCA9IGFycmF5LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0gPSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC53aXRoVGV4dChqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdLnRleHQgKyBub2RlLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoam9pbmVkKSB7XG4gICAgICAgICAgICAgICAgam9pbmVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChqb2luZWQgfHwgYXJyYXksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmcmFnbWVudCBmcm9tIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBpbnRlcnByZXRlZCBhcyBhXG4gICAgc2V0IG9mIG5vZGVzLiBGb3IgYG51bGxgLCBpdCByZXR1cm5zIHRoZSBlbXB0eSBmcmFnbWVudC4gRm9yIGFcbiAgICBmcmFnbWVudCwgdGhlIGZyYWdtZW50IGl0c2VsZi4gRm9yIGEgbm9kZSBvciBhcnJheSBvZiBub2RlcywgYVxuICAgIGZyYWdtZW50IGNvbnRhaW5pbmcgdGhvc2Ugbm9kZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbShub2Rlcykge1xuICAgICAgICBpZiAoIW5vZGVzKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAobm9kZXMgaW5zdGFuY2VvZiBGcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KG5vZGVzKTtcbiAgICAgICAgaWYgKG5vZGVzLmF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZXNdLCBub2Rlcy5ub2RlU2l6ZSk7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IFwiICsgbm9kZXMgKyBcIiB0byBhIEZyYWdtZW50XCIgK1xuICAgICAgICAgICAgKG5vZGVzLm5vZGVzQmV0d2VlbiA/IFwiIChsb29rcyBsaWtlIG11bHRpcGxlIHZlcnNpb25zIG9mIHByb3NlbWlycm9yLW1vZGVsIHdlcmUgbG9hZGVkKVwiIDogXCJcIikpO1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZnJhZ21lbnQuIEludGVuZGVkIHRvIGJlIHJldXNlZCB3aGVuZXZlciBhIG5vZGUgZG9lc24ndFxuY29udGFpbiBhbnl0aGluZyAocmF0aGVyIHRoYW4gYWxsb2NhdGluZyBhIG5ldyBlbXB0eSBmcmFnbWVudCBmb3JcbmVhY2ggbGVhZiBub2RlKS5cbiovXG5GcmFnbWVudC5lbXB0eSA9IG5ldyBGcmFnbWVudChbXSwgMCk7XG5jb25zdCBmb3VuZCA9IHsgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuZnVuY3Rpb24gcmV0SW5kZXgoaW5kZXgsIG9mZnNldCkge1xuICAgIGZvdW5kLmluZGV4ID0gaW5kZXg7XG4gICAgZm91bmQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZURlZXAoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIShhICYmIHR5cGVvZiBhID09IFwib2JqZWN0XCIpIHx8XG4gICAgICAgICEoYiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYikgIT0gYXJyYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVEZWVwKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHAgaW4gYSlcbiAgICAgICAgICAgIGlmICghKHAgaW4gYikgfHwgIWNvbXBhcmVEZWVwKGFbcF0sIGJbcF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBiKVxuICAgICAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbkEgbWFyayBpcyBhIHBpZWNlIG9mIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgbm9kZSxcbnN1Y2ggYXMgaXQgYmVpbmcgZW1waGFzaXplZCwgaW4gY29kZSBmb250LCBvciBhIGxpbmsuIEl0IGhhcyBhXG50eXBlIGFuZCBvcHRpb25hbGx5IGEgc2V0IG9mIGF0dHJpYnV0ZXMgdGhhdCBwcm92aWRlIGZ1cnRoZXJcbmluZm9ybWF0aW9uIChzdWNoIGFzIHRoZSB0YXJnZXQgb2YgdGhlIGxpbmspLiBNYXJrcyBhcmUgY3JlYXRlZFxudGhyb3VnaCBhIGBTY2hlbWFgLCB3aGljaCBjb250cm9scyB3aGljaCB0eXBlcyBleGlzdCBhbmQgd2hpY2hcbmF0dHJpYnV0ZXMgdGhleSBoYXZlLlxuKi9cbmNsYXNzIE1hcmsge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdGhpcyBtYXJrLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFyay5cbiAgICAqL1xuICAgIGF0dHJzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBzZXQgb2YgbWFya3MsIGNyZWF0ZSBhIG5ldyBzZXQgd2hpY2ggY29udGFpbnMgdGhpcyBvbmUgYXNcbiAgICB3ZWxsLCBpbiB0aGUgcmlnaHQgcG9zaXRpb24uIElmIHRoaXMgbWFyayBpcyBhbHJlYWR5IGluIHRoZSBzZXQsXG4gICAgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuIElmIGFueSBtYXJrcyB0aGF0IGFyZSBzZXQgdG8gYmVcbiAgICBbZXhjbHVzaXZlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIHdpdGggdGhpcyBtYXJrIGFyZSBwcmVzZW50LFxuICAgIHRob3NlIGFyZSByZXBsYWNlZCBieSB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgY29weSwgcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBzZXRbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuZXhjbHVkZXMob3RoZXIudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlci50eXBlLmV4Y2x1ZGVzKHRoaXMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwbGFjZWQgJiYgb3RoZXIudHlwZS5yYW5rID4gdGhpcy50eXBlLnJhbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKCk7XG4gICAgICAgIGlmICghcGxhY2VkKVxuICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIHRoaXMgbWFyayBmcm9tIHRoZSBnaXZlbiBzZXQsIHJldHVybmluZyBhIG5ldyBzZXQuIElmIHRoaXNcbiAgICBtYXJrIGlzIG5vdCBpbiB0aGUgc2V0LCB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBpcyBpbiB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaGFzIHRoZSBzYW1lIHR5cGUgYW5kIGF0dHJpYnV0ZXMgYXNcbiAgICBhbm90aGVyIG1hcmsuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKHRoaXMudHlwZSA9PSBvdGhlci50eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBtYXJrIHRvIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBKU09OLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE1hcmsuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm1hcmtzW2pzb24udHlwZV07XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgJHtqc29uLnR5cGV9IGluIHRoaXMgc2NoZW1hYCk7XG4gICAgICAgIGxldCBtYXJrID0gdHlwZS5jcmVhdGUoanNvbi5hdHRycyk7XG4gICAgICAgIHR5cGUuY2hlY2tBdHRycyhtYXJrLmF0dHJzKTtcbiAgICAgICAgcmV0dXJuIG1hcms7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0d28gc2V0cyBvZiBtYXJrcyBhcmUgaWRlbnRpY2FsLlxuICAgICovXG4gICAgc3RhdGljIHNhbWVTZXQoYSwgYikge1xuICAgICAgICBpZiAoYSA9PSBiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFhW2ldLmVxKGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHByb3Blcmx5IHNvcnRlZCBtYXJrIHNldCBmcm9tIG51bGwsIGEgc2luZ2xlIG1hcmssIG9yIGFuXG4gICAgdW5zb3J0ZWQgYXJyYXkgb2YgbWFya3MuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0RnJvbShtYXJrcykge1xuICAgICAgICBpZiAoIW1hcmtzIHx8IEFycmF5LmlzQXJyYXkobWFya3MpICYmIG1hcmtzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIE1hcmsubm9uZTtcbiAgICAgICAgaWYgKG1hcmtzIGluc3RhbmNlb2YgTWFyaylcbiAgICAgICAgICAgIHJldHVybiBbbWFya3NdO1xuICAgICAgICBsZXQgY29weSA9IG1hcmtzLnNsaWNlKCk7XG4gICAgICAgIGNvcHkuc29ydCgoYSwgYikgPT4gYS50eXBlLnJhbmsgLSBiLnR5cGUucmFuayk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBtYXJrcy5cbiovXG5NYXJrLm5vbmUgPSBbXTtcblxuLyoqXG5FcnJvciB0eXBlIHJhaXNlZCBieSBbYE5vZGUucmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlcGxhY2UpIHdoZW5cbmdpdmVuIGFuIGludmFsaWQgcmVwbGFjZW1lbnQuXG4qL1xuY2xhc3MgUmVwbGFjZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuLypcblJlcGxhY2VFcnJvciA9IGZ1bmN0aW9uKHRoaXM6IGFueSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGxldCBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpXG4gIDsoZXJyIGFzIGFueSkuX19wcm90b19fID0gUmVwbGFjZUVycm9yLnByb3RvdHlwZVxuICByZXR1cm4gZXJyXG59IGFzIGFueVxuXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwbGFjZUVycm9yXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlJlcGxhY2VFcnJvclwiXG4qL1xuLyoqXG5BIHNsaWNlIHJlcHJlc2VudHMgYSBwaWVjZSBjdXQgb3V0IG9mIGEgbGFyZ2VyIGRvY3VtZW50LiBJdFxuc3RvcmVzIG5vdCBvbmx5IGEgZnJhZ21lbnQsIGJ1dCBhbHNvIHRoZSBkZXB0aCB1cCB0byB3aGljaCBub2RlcyBvblxuYm90aCBzaWRlIGFyZSBcdTIwMThvcGVuXHUyMDE5IChjdXQgdGhyb3VnaCkuXG4qL1xuY2xhc3MgU2xpY2Uge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNsaWNlLiBXaGVuIHNwZWNpZnlpbmcgYSBub24temVybyBvcGVuIGRlcHRoLCB5b3UgbXVzdFxuICAgIG1ha2Ugc3VyZSB0aGF0IHRoZXJlIGFyZSBub2RlcyBvZiBhdCBsZWFzdCB0aGF0IGRlcHRoIGF0IHRoZVxuICAgIGFwcHJvcHJpYXRlIHNpZGUgb2YgdGhlIGZyYWdtZW50XHUyMDE0aS5lLiBpZiB0aGUgZnJhZ21lbnQgaXMgYW5cbiAgICBlbXB0eSBwYXJhZ3JhcGggbm9kZSwgYG9wZW5TdGFydGAgYW5kIGBvcGVuRW5kYCBjYW4ndCBiZSBncmVhdGVyXG4gICAgdGhhbiAxLlxuICAgIFxuICAgIEl0IGlzIG5vdCBuZWNlc3NhcnkgZm9yIHRoZSBjb250ZW50IG9mIG9wZW4gbm9kZXMgdG8gY29uZm9ybSB0b1xuICAgIHRoZSBzY2hlbWEncyBjb250ZW50IGNvbnN0cmFpbnRzLCB0aG91Z2ggaXQgc2hvdWxkIGJlIGEgdmFsaWRcbiAgICBzdGFydC9lbmQvbWlkZGxlIGZvciBzdWNoIGEgbm9kZSwgZGVwZW5kaW5nIG9uIHdoaWNoIHNpZGVzIGFyZVxuICAgIG9wZW4uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc2xpY2UncyBjb250ZW50LlxuICAgICovXG4gICAgY29udGVudCwgXG4gICAgLyoqXG4gICAgVGhlIG9wZW4gZGVwdGggYXQgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudC5cbiAgICAqL1xuICAgIG9wZW5TdGFydCwgXG4gICAgLyoqXG4gICAgVGhlIG9wZW4gZGVwdGggYXQgdGhlIGVuZC5cbiAgICAqL1xuICAgIG9wZW5FbmQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgICAgIHRoaXMub3BlbkVuZCA9IG9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIHRoaXMgc2xpY2Ugd291bGQgYWRkIHdoZW4gaW5zZXJ0ZWQgaW50byBhIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuc2l6ZSAtIHRoaXMub3BlblN0YXJ0IC0gdGhpcy5vcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGluc2VydEF0KHBvcywgZnJhZ21lbnQpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBpbnNlcnRJbnRvKHRoaXMuY29udGVudCwgcG9zICsgdGhpcy5vcGVuU3RhcnQsIGZyYWdtZW50KTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQgJiYgbmV3IFNsaWNlKGNvbnRlbnQsIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlbW92ZUJldHdlZW4oZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShyZW1vdmVSYW5nZSh0aGlzLmNvbnRlbnQsIGZyb20gKyB0aGlzLm9wZW5TdGFydCwgdG8gKyB0aGlzLm9wZW5TdGFydCksIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0cyB3aGV0aGVyIHRoaXMgc2xpY2UgaXMgZXF1YWwgdG8gYW5vdGhlciBzbGljZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZXEob3RoZXIuY29udGVudCkgJiYgdGhpcy5vcGVuU3RhcnQgPT0gb3RoZXIub3BlblN0YXJ0ICYmIHRoaXMub3BlbkVuZCA9PSBvdGhlci5vcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50ICsgXCIoXCIgKyB0aGlzLm9wZW5TdGFydCArIFwiLFwiICsgdGhpcy5vcGVuRW5kICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgYSBzbGljZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBqc29uID0geyBjb250ZW50OiB0aGlzLmNvbnRlbnQudG9KU09OKCkgfTtcbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0ID4gMClcbiAgICAgICAgICAgIGpzb24ub3BlblN0YXJ0ID0gdGhpcy5vcGVuU3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLm9wZW5FbmQgPiAwKVxuICAgICAgICAgICAganNvbi5vcGVuRW5kID0gdGhpcy5vcGVuRW5kO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzbGljZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICByZXR1cm4gU2xpY2UuZW1wdHk7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSBqc29uLm9wZW5TdGFydCB8fCAwLCBvcGVuRW5kID0ganNvbi5vcGVuRW5kIHx8IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygb3BlblN0YXJ0ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9wZW5FbmQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2xpY2UuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzbGljZSBmcm9tIGEgZnJhZ21lbnQgYnkgdGFraW5nIHRoZSBtYXhpbXVtIHBvc3NpYmxlXG4gICAgb3BlbiB2YWx1ZSBvbiBib3RoIHNpZGUgb2YgdGhlIGZyYWdtZW50LlxuICAgICovXG4gICAgc3RhdGljIG1heE9wZW4oZnJhZ21lbnQsIG9wZW5Jc29sYXRpbmcgPSB0cnVlKSB7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSAwLCBvcGVuRW5kID0gMDtcbiAgICAgICAgZm9yIChsZXQgbiA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7IG4gJiYgIW4uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuID0gbi5maXJzdENoaWxkKVxuICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIGZvciAobGV0IG4gPSBmcmFnbWVudC5sYXN0Q2hpbGQ7IG4gJiYgIW4uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuID0gbi5sYXN0Q2hpbGQpXG4gICAgICAgICAgICBvcGVuRW5kKys7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoZnJhZ21lbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2xpY2UuXG4qL1xuU2xpY2UuZW1wdHkgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZW1wdHksIDAsIDApO1xuZnVuY3Rpb24gcmVtb3ZlUmFuZ2UoY29udGVudCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBjb250ZW50LmZpbmRJbmRleChmcm9tKSwgY2hpbGQgPSBjb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgIGxldCB7IGluZGV4OiBpbmRleFRvLCBvZmZzZXQ6IG9mZnNldFRvIH0gPSBjb250ZW50LmZpbmRJbmRleCh0byk7XG4gICAgaWYgKG9mZnNldCA9PSBmcm9tIHx8IGNoaWxkLmlzVGV4dCkge1xuICAgICAgICBpZiAob2Zmc2V0VG8gIT0gdG8gJiYgIWNvbnRlbnQuY2hpbGQoaW5kZXhUbykuaXNUZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZW1vdmluZyBub24tZmxhdCByYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGZyb20pLmFwcGVuZChjb250ZW50LmN1dCh0bykpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT0gaW5kZXhUbylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZW1vdmluZyBub24tZmxhdCByYW5nZVwiKTtcbiAgICByZXR1cm4gY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkocmVtb3ZlUmFuZ2UoY2hpbGQuY29udGVudCwgZnJvbSAtIG9mZnNldCAtIDEsIHRvIC0gb2Zmc2V0IC0gMSkpKTtcbn1cbmZ1bmN0aW9uIGluc2VydEludG8oY29udGVudCwgZGlzdCwgaW5zZXJ0LCBwYXJlbnQpIHtcbiAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBjb250ZW50LmZpbmRJbmRleChkaXN0KSwgY2hpbGQgPSBjb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgIGlmIChvZmZzZXQgPT0gZGlzdCB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4LCBpbnNlcnQpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBkaXN0KS5hcHBlbmQoaW5zZXJ0KS5hcHBlbmQoY29udGVudC5jdXQoZGlzdCkpO1xuICAgIH1cbiAgICBsZXQgaW5uZXIgPSBpbnNlcnRJbnRvKGNoaWxkLmNvbnRlbnQsIGRpc3QgLSBvZmZzZXQgLSAxLCBpbnNlcnQpO1xuICAgIHJldHVybiBpbm5lciAmJiBjb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgY2hpbGQuY29weShpbm5lcikpO1xufVxuZnVuY3Rpb24gcmVwbGFjZSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICAgIGlmIChzbGljZS5vcGVuU3RhcnQgPiAkZnJvbS5kZXB0aClcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluc2VydGVkIGNvbnRlbnQgZGVlcGVyIHRoYW4gaW5zZXJ0aW9uIHBvc2l0aW9uXCIpO1xuICAgIGlmICgkZnJvbS5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCAhPSAkdG8uZGVwdGggLSBzbGljZS5vcGVuRW5kKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW5jb25zaXN0ZW50IG9wZW4gZGVwdGhzXCIpO1xuICAgIHJldHVybiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIDApO1xufVxuZnVuY3Rpb24gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCkge1xuICAgIGxldCBpbmRleCA9ICRmcm9tLmluZGV4KGRlcHRoKSwgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgIGlmIChpbmRleCA9PSAkdG8uaW5kZXgoZGVwdGgpICYmIGRlcHRoIDwgJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQpIHtcbiAgICAgICAgbGV0IGlubmVyID0gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCArIDEpO1xuICAgICAgICByZXR1cm4gbm9kZS5jb3B5KG5vZGUuY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGlubmVyKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzbGljZS5jb250ZW50LnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsaWNlLm9wZW5TdGFydCAmJiAhc2xpY2Uub3BlbkVuZCAmJiAkZnJvbS5kZXB0aCA9PSBkZXB0aCAmJiAkdG8uZGVwdGggPT0gZGVwdGgpIHsgLy8gU2ltcGxlLCBmbGF0IGNhc2VcbiAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLnBhcmVudCwgY29udGVudCA9IHBhcmVudC5jb250ZW50O1xuICAgICAgICByZXR1cm4gY2xvc2UocGFyZW50LCBjb250ZW50LmN1dCgwLCAkZnJvbS5wYXJlbnRPZmZzZXQpLmFwcGVuZChzbGljZS5jb250ZW50KS5hcHBlbmQoY29udGVudC5jdXQoJHRvLnBhcmVudE9mZnNldCkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRmcm9tKTtcbiAgICAgICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgc3RhcnQsIGVuZCwgJHRvLCBkZXB0aCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSm9pbihtYWluLCBzdWIpIHtcbiAgICBpZiAoIXN1Yi50eXBlLmNvbXBhdGlibGVDb250ZW50KG1haW4udHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJDYW5ub3Qgam9pbiBcIiArIHN1Yi50eXBlLm5hbWUgKyBcIiBvbnRvIFwiICsgbWFpbi50eXBlLm5hbWUpO1xufVxuZnVuY3Rpb24gam9pbmFibGUoJGJlZm9yZSwgJGFmdGVyLCBkZXB0aCkge1xuICAgIGxldCBub2RlID0gJGJlZm9yZS5ub2RlKGRlcHRoKTtcbiAgICBjaGVja0pvaW4obm9kZSwgJGFmdGVyLm5vZGUoZGVwdGgpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGFkZE5vZGUoY2hpbGQsIHRhcmdldCkge1xuICAgIGxldCBsYXN0ID0gdGFyZ2V0Lmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiBjaGlsZC5pc1RleHQgJiYgY2hpbGQuc2FtZU1hcmt1cCh0YXJnZXRbbGFzdF0pKVxuICAgICAgICB0YXJnZXRbbGFzdF0gPSBjaGlsZC53aXRoVGV4dCh0YXJnZXRbbGFzdF0udGV4dCArIGNoaWxkLnRleHQpO1xuICAgIGVsc2VcbiAgICAgICAgdGFyZ2V0LnB1c2goY2hpbGQpO1xufVxuZnVuY3Rpb24gYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgdGFyZ2V0KSB7XG4gICAgbGV0IG5vZGUgPSAoJGVuZCB8fCAkc3RhcnQpLm5vZGUoZGVwdGgpO1xuICAgIGxldCBzdGFydEluZGV4ID0gMCwgZW5kSW5kZXggPSAkZW5kID8gJGVuZC5pbmRleChkZXB0aCkgOiBub2RlLmNoaWxkQ291bnQ7XG4gICAgaWYgKCRzdGFydCkge1xuICAgICAgICBzdGFydEluZGV4ID0gJHN0YXJ0LmluZGV4KGRlcHRoKTtcbiAgICAgICAgaWYgKCRzdGFydC5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJHN0YXJ0LnRleHRPZmZzZXQpIHtcbiAgICAgICAgICAgIGFkZE5vZGUoJHN0YXJ0Lm5vZGVBZnRlciwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspXG4gICAgICAgIGFkZE5vZGUobm9kZS5jaGlsZChpKSwgdGFyZ2V0KTtcbiAgICBpZiAoJGVuZCAmJiAkZW5kLmRlcHRoID09IGRlcHRoICYmICRlbmQudGV4dE9mZnNldClcbiAgICAgICAgYWRkTm9kZSgkZW5kLm5vZGVCZWZvcmUsIHRhcmdldCk7XG59XG5mdW5jdGlvbiBjbG9zZShub2RlLCBjb250ZW50KSB7XG4gICAgbm9kZS50eXBlLmNoZWNrQ29udGVudChjb250ZW50KTtcbiAgICByZXR1cm4gbm9kZS5jb3B5KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGgpIHtcbiAgICBsZXQgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpO1xuICAgIGxldCBvcGVuRW5kID0gJHRvLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGVuZCwgJHRvLCBkZXB0aCArIDEpO1xuICAgIGxldCBjb250ZW50ID0gW107XG4gICAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgICBpZiAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgJHN0YXJ0LmluZGV4KGRlcHRoKSA9PSAkZW5kLmluZGV4KGRlcHRoKSkge1xuICAgICAgICBjaGVja0pvaW4ob3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvcGVuU3RhcnQpXG4gICAgICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgICAgIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgICAgICBpZiAob3BlbkVuZClcbiAgICAgICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlbkVuZCwgcmVwbGFjZVR3b1dheSgkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgYWRkUmFuZ2UoJHRvLCBudWxsLCBkZXB0aCwgY29udGVudCk7XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpIHtcbiAgICBsZXQgY29udGVudCA9IFtdO1xuICAgIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKCRmcm9tLmRlcHRoID4gZGVwdGgpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBqb2luYWJsZSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpO1xuICAgICAgICBhZGROb2RlKGNsb3NlKHR5cGUsIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGFsb25nKSB7XG4gICAgbGV0IGV4dHJhID0gJGFsb25nLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0LCBwYXJlbnQgPSAkYWxvbmcubm9kZShleHRyYSk7XG4gICAgbGV0IG5vZGUgPSBwYXJlbnQuY29weShzbGljZS5jb250ZW50KTtcbiAgICBmb3IgKGxldCBpID0gZXh0cmEgLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgbm9kZSA9ICRhbG9uZy5ub2RlKGkpLmNvcHkoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUoc2xpY2Uub3BlblN0YXJ0ICsgZXh0cmEpLFxuICAgICAgICBlbmQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUobm9kZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kIC0gZXh0cmEpIH07XG59XG5cbi8qKlxuWW91IGNhbiBbX3Jlc29sdmVfXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXNvbHZlKSBhIHBvc2l0aW9uIHRvIGdldCBtb3JlXG5pbmZvcm1hdGlvbiBhYm91dCBpdC4gT2JqZWN0cyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBzdWNoIGFcbnJlc29sdmVkIHBvc2l0aW9uLCBwcm92aWRpbmcgdmFyaW91cyBwaWVjZXMgb2YgY29udGV4dFxuaW5mb3JtYXRpb24sIGFuZCBzb21lIGhlbHBlciBtZXRob2RzLlxuXG5UaHJvdWdob3V0IHRoaXMgaW50ZXJmYWNlLCBtZXRob2RzIHRoYXQgdGFrZSBhbiBvcHRpb25hbCBgZGVwdGhgXG5wYXJhbWV0ZXIgd2lsbCBpbnRlcnByZXQgdW5kZWZpbmVkIGFzIGB0aGlzLmRlcHRoYCBhbmQgbmVnYXRpdmVcbm51bWJlcnMgYXMgYHRoaXMuZGVwdGggKyB2YWx1ZWAuXG4qL1xuY2xhc3MgUmVzb2x2ZWRQb3Mge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIHRoYXQgd2FzIHJlc29sdmVkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHBhdGgsIFxuICAgIC8qKlxuICAgIFRoZSBvZmZzZXQgdGhpcyBwb3NpdGlvbiBoYXMgaW50byBpdHMgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBwYXJlbnRPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMucGFyZW50T2Zmc2V0ID0gcGFyZW50T2Zmc2V0O1xuICAgICAgICB0aGlzLmRlcHRoID0gcGF0aC5sZW5ndGggLyAzIC0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNvbHZlRGVwdGgodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHRoO1xuICAgICAgICBpZiAodmFsIDwgMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHRoICsgdmFsO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcGFyZW50IG5vZGUgdGhhdCB0aGUgcG9zaXRpb24gcG9pbnRzIGludG8uIE5vdGUgdGhhdCBldmVuIGlmXG4gICAgYSBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgdGhhdCBub2RlIGlzIG5vdCBjb25zaWRlcmVkXG4gICAgdGhlIHBhcmVudFx1MjAxNHRleHQgbm9kZXMgYXJlIFx1MjAxOGZsYXRcdTIwMTkgaW4gdGhpcyBtb2RlbCwgYW5kIGhhdmUgbm8gY29udGVudC5cbiAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLm5vZGUodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgcm9vdCBub2RlIGluIHdoaWNoIHRoZSBwb3NpdGlvbiB3YXMgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBnZXQgZG9jKCkgeyByZXR1cm4gdGhpcy5ub2RlKDApOyB9XG4gICAgLyoqXG4gICAgVGhlIGFuY2VzdG9yIG5vZGUgYXQgdGhlIGdpdmVuIGxldmVsLiBgcC5ub2RlKHAuZGVwdGgpYCBpcyB0aGVcbiAgICBzYW1lIGFzIGBwLnBhcmVudGAuXG4gICAgKi9cbiAgICBub2RlKGRlcHRoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogM107IH1cbiAgICAvKipcbiAgICBUaGUgaW5kZXggaW50byB0aGUgYW5jZXN0b3IgYXQgdGhlIGdpdmVuIGxldmVsLiBJZiB0aGlzIHBvaW50c1xuICAgIGF0IHRoZSAzcmQgbm9kZSBpbiB0aGUgMm5kIHBhcmFncmFwaCBvbiB0aGUgdG9wIGxldmVsLCBmb3JcbiAgICBleGFtcGxlLCBgcC5pbmRleCgwKWAgaXMgMSBhbmQgYHAuaW5kZXgoMSlgIGlzIDIuXG4gICAgKi9cbiAgICBpbmRleChkZXB0aCkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDMgKyAxXTsgfVxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBwb2ludGluZyBhZnRlciB0aGlzIHBvc2l0aW9uIGludG8gdGhlIGFuY2VzdG9yIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLlxuICAgICovXG4gICAgaW5kZXhBZnRlcihkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXgoZGVwdGgpICsgKGRlcHRoID09IHRoaXMuZGVwdGggJiYgIXRoaXMudGV4dE9mZnNldCA/IDAgOiAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlblxuICAgIGxldmVsLlxuICAgICovXG4gICAgc3RhcnQoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4gICAgbGV2ZWwuXG4gICAgKi9cbiAgICBlbmQoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KGRlcHRoKSArIHRoaXMubm9kZShkZXB0aCkuY29udGVudC5zaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBkaXJlY3RseSBiZWZvcmUgdGhlIHdyYXBwaW5nIG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwsIG9yLCB3aGVuIGBkZXB0aGAgaXMgYHRoaXMuZGVwdGggKyAxYCwgdGhlIG9yaWdpbmFsXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBiZWZvcmUoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGJlZm9yZSB0aGUgdG9wLWxldmVsIG5vZGVcIik7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbCwgb3IgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHdoZW4gYGRlcHRoYCBpcyBgdGhpcy5kZXB0aCArIDFgLlxuICAgICovXG4gICAgYWZ0ZXIoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIHBvc2l0aW9uIGFmdGVyIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyB0aGlzLnBhdGhbZGVwdGggKiAzXS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGlzIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCB0aGlzIHJldHVybnMgdGhlXG4gICAgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9zaXRpb24gYW5kIHRoZSBzdGFydCBvZiB0aGUgdGV4dCBub2RlLlxuICAgIFdpbGwgYmUgemVybyBmb3IgcG9zaXRpb25zIHRoYXQgcG9pbnQgYmV0d2VlbiBub2Rlcy5cbiAgICAqL1xuICAgIGdldCB0ZXh0T2Zmc2V0KCkgeyByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGUgcG9zaXRpb25cbiAgICBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgb25seSB0aGUgcGFydCBvZiB0aGF0IG5vZGUgYWZ0ZXIgdGhlXG4gICAgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBnZXQgbm9kZUFmdGVyKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgICAgaWYgKGluZGV4ID09IHBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdLCBjaGlsZCA9IHBhcmVudC5jaGlsZChpbmRleCk7XG4gICAgICAgIHJldHVybiBkT2ZmID8gcGFyZW50LmNoaWxkKGluZGV4KS5jdXQoZE9mZikgOiBjaGlsZDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBub2RlIGRpcmVjdGx5IGJlZm9yZSB0aGUgcG9zaXRpb24sIGlmIGFueS4gSWYgdGhlXG4gICAgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIG9ubHkgdGhlIHBhcnQgb2YgdGhhdCBub2RlXG4gICAgYmVmb3JlIHRoZSBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGdldCBub2RlQmVmb3JlKCkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgICBsZXQgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hpbGQoaW5kZXgpLmN1dCgwLCBkT2ZmKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09IDAgPyBudWxsIDogdGhpcy5wYXJlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIHBhcmVudCBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGRlcHRoICh3aGljaCBkZWZhdWx0cyB0byBgdGhpcy5kZXB0aGApLlxuICAgICovXG4gICAgcG9zQXRJbmRleChpbmRleCwgZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5wYXRoW2RlcHRoICogM10sIHBvcyA9IGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgICAgICAgcG9zICs9IG5vZGUuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWFya3MgYXQgdGhpcyBwb3NpdGlvbiwgZmFjdG9yaW5nIGluIHRoZSBzdXJyb3VuZGluZ1xuICAgIG1hcmtzJyBbYGluY2x1c2l2ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5pbmNsdXNpdmUpIHByb3BlcnR5LiBJZiB0aGVcbiAgICBwb3NpdGlvbiBpcyBhdCB0aGUgc3RhcnQgb2YgYSBub24tZW1wdHkgbm9kZSwgdGhlIG1hcmtzIG9mIHRoZVxuICAgIG5vZGUgYWZ0ZXIgaXQgKGlmIGFueSkgYXJlIHJldHVybmVkLlxuICAgICovXG4gICAgbWFya3MoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCwgaW5kZXggPSB0aGlzLmluZGV4KCk7XG4gICAgICAgIC8vIEluIGFuIGVtcHR5IHBhcmVudCwgcmV0dXJuIHRoZSBlbXB0eSBhcnJheVxuICAgICAgICBpZiAocGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIE1hcmsubm9uZTtcbiAgICAgICAgLy8gV2hlbiBpbnNpZGUgYSB0ZXh0IG5vZGUsIGp1c3QgcmV0dXJuIHRoZSB0ZXh0IG5vZGUncyBtYXJrc1xuICAgICAgICBpZiAodGhpcy50ZXh0T2Zmc2V0KVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5jaGlsZChpbmRleCkubWFya3M7XG4gICAgICAgIGxldCBtYWluID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXggLSAxKSwgb3RoZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIC8vIElmIHRoZSBgYWZ0ZXJgIGZsYWcgaXMgdHJ1ZSBvZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSwgbWFrZVxuICAgICAgICAvLyB0aGUgbm9kZSBhZnRlciB0aGlzIHBvc2l0aW9uIHRoZSBtYWluIHJlZmVyZW5jZS5cbiAgICAgICAgaWYgKCFtYWluKSB7XG4gICAgICAgICAgICBsZXQgdG1wID0gbWFpbjtcbiAgICAgICAgICAgIG1haW4gPSBvdGhlcjtcbiAgICAgICAgICAgIG90aGVyID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBhbGwgbWFya3MgaW4gdGhlIG1haW4gbm9kZSwgZXhjZXB0IHRob3NlIHRoYXQgaGF2ZVxuICAgICAgICAvLyBgaW5jbHVzaXZlYCBzZXQgdG8gZmFsc2UgYW5kIGFyZSBub3QgcHJlc2VudCBpbiB0aGUgb3RoZXIgbm9kZS5cbiAgICAgICAgbGV0IG1hcmtzID0gbWFpbi5tYXJrcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChtYXJrc1tpXS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSAmJiAoIW90aGVyIHx8ICFtYXJrc1tpXS5pc0luU2V0KG90aGVyLm1hcmtzKSkpXG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWFya3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGlmIGFueSwgZXhjZXB0IHRob3NlXG4gICAgdGhhdCBhcmUgbm9uLWluY2x1c2l2ZSBhbmQgbm90IHByZXNlbnQgYXQgcG9zaXRpb24gYCRlbmRgLiBUaGlzXG4gICAgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgZ2V0dGluZyB0aGUgc2V0IG9mIG1hcmtzIHRvIHByZXNlcnZlIGFmdGVyIGFcbiAgICBkZWxldGlvbi4gV2lsbCByZXR1cm4gYG51bGxgIGlmIHRoaXMgcG9zaXRpb24gaXMgYXQgdGhlIGVuZCBvZlxuICAgIGl0cyBwYXJlbnQgbm9kZSBvciBpdHMgcGFyZW50IG5vZGUgaXNuJ3QgYSB0ZXh0YmxvY2sgKGluIHdoaWNoXG4gICAgY2FzZSBubyBtYXJrcyBzaG91bGQgYmUgcHJlc2VydmVkKS5cbiAgICAqL1xuICAgIG1hcmtzQWNyb3NzKCRlbmQpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5wYXJlbnQubWF5YmVDaGlsZCh0aGlzLmluZGV4KCkpO1xuICAgICAgICBpZiAoIWFmdGVyIHx8ICFhZnRlci5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbWFya3MgPSBhZnRlci5tYXJrcywgbmV4dCA9ICRlbmQucGFyZW50Lm1heWJlQ2hpbGQoJGVuZC5pbmRleCgpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChtYXJrc1tpXS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSAmJiAoIW5leHQgfHwgIW1hcmtzW2ldLmlzSW5TZXQobmV4dC5tYXJrcykpKVxuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGVwdGggdXAgdG8gd2hpY2ggdGhpcyBwb3NpdGlvbiBhbmQgdGhlIGdpdmVuIChub24tcmVzb2x2ZWQpXG4gICAgcG9zaXRpb24gc2hhcmUgdGhlIHNhbWUgcGFyZW50IG5vZGVzLlxuICAgICovXG4gICAgc2hhcmVkRGVwdGgocG9zKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aC0tKVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnQoZGVwdGgpIDw9IHBvcyAmJiB0aGlzLmVuZChkZXB0aCkgPj0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSByYW5nZSBiYXNlZCBvbiB0aGUgcGxhY2Ugd2hlcmUgdGhpcyBwb3NpdGlvbiBhbmQgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24gZGl2ZXJnZSBhcm91bmQgYmxvY2sgY29udGVudC4gSWYgYm90aCBwb2ludCBpbnRvXG4gICAgdGhlIHNhbWUgdGV4dGJsb2NrLCBmb3IgZXhhbXBsZSwgYSByYW5nZSBhcm91bmQgdGhhdCB0ZXh0YmxvY2tcbiAgICB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGV5IHBvaW50IGludG8gZGlmZmVyZW50IGJsb2NrcywgdGhlIHJhbmdlXG4gICAgYXJvdW5kIHRob3NlIGJsb2NrcyBpbiB0aGVpciBzaGFyZWQgYW5jZXN0b3IgaXMgcmV0dXJuZWQuIFlvdSBjYW5cbiAgICBwYXNzIGluIGFuIG9wdGlvbmFsIHByZWRpY2F0ZSB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYSBwYXJlbnRcbiAgICBub2RlIHRvIHNlZSBpZiBhIHJhbmdlIGludG8gdGhhdCBwYXJlbnQgaXMgYWNjZXB0YWJsZS5cbiAgICAqL1xuICAgIGJsb2NrUmFuZ2Uob3RoZXIgPSB0aGlzLCBwcmVkKSB7XG4gICAgICAgIGlmIChvdGhlci5wb3MgPCB0aGlzLnBvcylcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5ibG9ja1JhbmdlKHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBkID0gdGhpcy5kZXB0aCAtICh0aGlzLnBhcmVudC5pbmxpbmVDb250ZW50IHx8IHRoaXMucG9zID09IG90aGVyLnBvcyA/IDEgOiAwKTsgZCA+PSAwOyBkLS0pXG4gICAgICAgICAgICBpZiAob3RoZXIucG9zIDw9IHRoaXMuZW5kKGQpICYmICghcHJlZCB8fCBwcmVkKHRoaXMubm9kZShkKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVJhbmdlKHRoaXMsIG90aGVyLCBkKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhlIGdpdmVuIHBvc2l0aW9uIHNoYXJlcyB0aGUgc2FtZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHNhbWVQYXJlbnQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXJlbnRPZmZzZXQgPT0gb3RoZXIucG9zIC0gb3RoZXIucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGdyZWF0ZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbWF4KG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5wb3MgPiB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBzbWFsbGVyIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG1pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIucG9zIDwgdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLmRlcHRoOyBpKyspXG4gICAgICAgICAgICBzdHIgKz0gKHN0ciA/IFwiL1wiIDogXCJcIikgKyB0aGlzLm5vZGUoaSkudHlwZS5uYW1lICsgXCJfXCIgKyB0aGlzLmluZGV4KGkgLSAxKTtcbiAgICAgICAgcmV0dXJuIHN0ciArIFwiOlwiICsgdGhpcy5wYXJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHJlc29sdmUoZG9jLCBwb3MpIHtcbiAgICAgICAgaWYgKCEocG9zID49IDAgJiYgcG9zIDw9IGRvYy5jb250ZW50LnNpemUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQb3NpdGlvbiBcIiArIHBvcyArIFwiIG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgbGV0IHBhdGggPSBbXTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMCwgcGFyZW50T2Zmc2V0ID0gcG9zO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gZG9jOzspIHtcbiAgICAgICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocGFyZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCByZW0gPSBwYXJlbnRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSwgaW5kZXgsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghcmVtKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gcmVtIC0gMTtcbiAgICAgICAgICAgIHN0YXJ0ICs9IG9mZnNldCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZlZFBvcyhwb3MsIHBhdGgsIHBhcmVudE9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHJlc29sdmVDYWNoZWQoZG9jLCBwb3MpIHtcbiAgICAgICAgbGV0IGNhY2hlID0gcmVzb2x2ZUNhY2hlLmdldChkb2MpO1xuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FjaGUuZWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBlbHQgPSBjYWNoZS5lbHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlbHQucG9zID09IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmVDYWNoZS5zZXQoZG9jLCBjYWNoZSA9IG5ldyBSZXNvbHZlQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBjYWNoZS5lbHRzW2NhY2hlLmldID0gUmVzb2x2ZWRQb3MucmVzb2x2ZShkb2MsIHBvcyk7XG4gICAgICAgIGNhY2hlLmkgPSAoY2FjaGUuaSArIDEpICUgcmVzb2x2ZUNhY2hlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5jbGFzcyBSZXNvbHZlQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVsdHMgPSBbXTtcbiAgICAgICAgdGhpcy5pID0gMDtcbiAgICB9XG59XG5jb25zdCByZXNvbHZlQ2FjaGVTaXplID0gMTIsIHJlc29sdmVDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4vKipcblJlcHJlc2VudHMgYSBmbGF0IHJhbmdlIG9mIGNvbnRlbnQsIGkuZS4gb25lIHRoYXQgc3RhcnRzIGFuZFxuZW5kcyBpbiB0aGUgc2FtZSBub2RlLlxuKi9cbmNsYXNzIE5vZGVSYW5nZSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbm9kZSByYW5nZS4gYCRmcm9tYCBhbmQgYCR0b2Agc2hvdWxkIHBvaW50IGludG8gdGhlXG4gICAgc2FtZSBub2RlIHVudGlsIGF0IGxlYXN0IHRoZSBnaXZlbiBgZGVwdGhgLCBzaW5jZSBhIG5vZGUgcmFuZ2VcbiAgICBkZW5vdGVzIGFuIGFkamFjZW50IHNldCBvZiBub2RlcyBpbiBhIHNpbmdsZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEEgcmVzb2x2ZWQgcG9zaXRpb24gYWxvbmcgdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50LiBNYXkgaGF2ZSBhXG4gICAgYGRlcHRoYCBncmVhdGVyIHRoYW4gdGhpcyBvYmplY3QncyBgZGVwdGhgIHByb3BlcnR5LCBzaW5jZVxuICAgIHRoZXNlIGFyZSB0aGUgcG9zaXRpb25zIHRoYXQgd2VyZSB1c2VkIHRvIGNvbXB1dGUgdGhlIHJhbmdlLFxuICAgIG5vdCByZS1yZXNvbHZlZCBwb3NpdGlvbnMgZGlyZWN0bHkgYXQgaXRzIGJvdW5kYXJpZXMuXG4gICAgKi9cbiAgICAkZnJvbSwgXG4gICAgLyoqXG4gICAgQSBwb3NpdGlvbiBhbG9uZyB0aGUgZW5kIG9mIHRoZSBjb250ZW50LiBTZWVcbiAgICBjYXZlYXQgZm9yIFtgJGZyb21gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVJhbmdlLiRmcm9tKS5cbiAgICAqL1xuICAgICR0bywgXG4gICAgLyoqXG4gICAgVGhlIGRlcHRoIG9mIHRoZSBub2RlIHRoYXQgdGhpcyByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGRlcHRoKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLmJlZm9yZSh0aGlzLmRlcHRoICsgMSk7IH1cbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy4kdG8uYWZ0ZXIodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHJhbmdlIHBvaW50cyBpbnRvLlxuICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMuJGZyb20ubm9kZSh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBpbmRleCBvZiB0aGUgcmFuZ2UgaW4gdGhlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0SW5kZXgoKSB7IHJldHVybiB0aGlzLiRmcm9tLmluZGV4KHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIGVuZCBpbmRleCBvZiB0aGUgcmFuZ2UgaW4gdGhlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgZ2V0IGVuZEluZGV4KCkgeyByZXR1cm4gdGhpcy4kdG8uaW5kZXhBZnRlcih0aGlzLmRlcHRoKTsgfVxufVxuXG5jb25zdCBlbXB0eUF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgbm9kZSBpbiB0aGUgdHJlZSB0aGF0IG1ha2VzIHVwIGFcblByb3NlTWlycm9yIGRvY3VtZW50LiBTbyBhIGRvY3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIGBOb2RlYCwgd2l0aFxuY2hpbGRyZW4gdGhhdCBhcmUgYWxzbyBpbnN0YW5jZXMgb2YgYE5vZGVgLlxuXG5Ob2RlcyBhcmUgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZXMuIEluc3RlYWQgb2YgY2hhbmdpbmcgdGhlbSwgeW91XG5jcmVhdGUgbmV3IG9uZXMgd2l0aCB0aGUgY29udGVudCB5b3Ugd2FudC4gT2xkIG9uZXMga2VlcCBwb2ludGluZ1xuYXQgdGhlIG9sZCBkb2N1bWVudCBzaGFwZS4gVGhpcyBpcyBtYWRlIGNoZWFwZXIgYnkgc2hhcmluZ1xuc3RydWN0dXJlIGJldHdlZW4gdGhlIG9sZCBhbmQgbmV3IGRhdGEgYXMgbXVjaCBhcyBwb3NzaWJsZSwgd2hpY2ggYVxudHJlZSBzaGFwZSBsaWtlIHRoaXMgKHdpdGhvdXQgYmFjayBwb2ludGVycykgbWFrZXMgZWFzeS5cblxuKipEbyBub3QqKiBkaXJlY3RseSBtdXRhdGUgdGhlIHByb3BlcnRpZXMgb2YgYSBgTm9kZWAgb2JqZWN0LiBTZWVcblt0aGUgZ3VpZGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2RvYykgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4qL1xuY2xhc3MgTm9kZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiBub2RlIHRoYXQgdGhpcyBpcy5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIEFuIG9iamVjdCBtYXBwaW5nIGF0dHJpYnV0ZSBuYW1lcyB0byB2YWx1ZXMuIFRoZSBraW5kIG9mXG4gICAgYXR0cmlidXRlcyBhbGxvd2VkIGFuZCByZXF1aXJlZCBhcmVcbiAgICBbZGV0ZXJtaW5lZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmF0dHJzKSBieSB0aGUgbm9kZSB0eXBlLlxuICAgICovXG4gICAgYXR0cnMsIFxuICAgIC8vIEEgZnJhZ21lbnQgaG9sZGluZyB0aGUgbm9kZSdzIGNoaWxkcmVuLlxuICAgIGNvbnRlbnQsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrcyAodGhpbmdzIGxpa2Ugd2hldGhlciBpdCBpcyBlbXBoYXNpemVkIG9yIHBhcnQgb2YgYVxuICAgIGxpbmspIGFwcGxpZWQgdG8gdGhpcyBub2RlLlxuICAgICovXG4gICAgbWFya3MgPSBNYXJrLm5vbmUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQgfHwgRnJhZ21lbnQuZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBhcnJheSBvZiB0aGlzIG5vZGUncyBjaGlsZCBub2Rlcy5cbiAgICAqL1xuICAgIGdldCBjaGlsZHJlbigpIHsgcmV0dXJuIHRoaXMuY29udGVudC5jb250ZW50OyB9XG4gICAgLyoqXG4gICAgVGhlIHNpemUgb2YgdGhpcyBub2RlLCBhcyBkZWZpbmVkIGJ5IHRoZSBpbnRlZ2VyLWJhc2VkIFtpbmRleGluZ1xuICAgIHNjaGVtZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jZG9jLmluZGV4aW5nKS4gRm9yIHRleHQgbm9kZXMsIHRoaXMgaXMgdGhlXG4gICAgYW1vdW50IG9mIGNoYXJhY3RlcnMuIEZvciBvdGhlciBsZWFmIG5vZGVzLCBpdCBpcyBvbmUuIEZvclxuICAgIG5vbi1sZWFmIG5vZGVzLCBpdCBpcyB0aGUgc2l6ZSBvZiB0aGUgY29udGVudCBwbHVzIHR3byAodGhlXG4gICAgc3RhcnQgYW5kIGVuZCB0b2tlbikuXG4gICAgKi9cbiAgICBnZXQgbm9kZVNpemUoKSB7IHJldHVybiB0aGlzLmlzTGVhZiA/IDEgOiAyICsgdGhpcy5jb250ZW50LnNpemU7IH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgdGhlIG5vZGUgaGFzLlxuICAgICovXG4gICAgZ2V0IGNoaWxkQ291bnQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGRDb3VudDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlcyBhbiBlcnJvciB3aGVuIHRoZVxuICAgIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICAqL1xuICAgIGNoaWxkKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgaXQgZXhpc3RzLlxuICAgICovXG4gICAgbWF5YmVDaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpOyB9XG4gICAgLyoqXG4gICAgQ2FsbCBgZmAgZm9yIGV2ZXJ5IGNoaWxkIG5vZGUsIHBhc3NpbmcgdGhlIG5vZGUsIGl0cyBvZmZzZXRcbiAgICBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHsgdGhpcy5jb250ZW50LmZvckVhY2goZik7IH1cbiAgICAvKipcbiAgICBJbnZva2UgYSBjYWxsYmFjayBmb3IgYWxsIGRlc2NlbmRhbnQgbm9kZXMgcmVjdXJzaXZlbHkgYmV0d2VlblxuICAgIHRoZSBnaXZlbiB0d28gcG9zaXRpb25zIHRoYXQgYXJlIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXNcbiAgICBub2RlJ3MgY29udGVudC4gVGhlIGNhbGxiYWNrIGlzIGludm9rZWQgd2l0aCB0aGUgbm9kZSwgaXRzXG4gICAgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIG5vZGUgKG1ldGhvZCByZWNlaXZlciksXG4gICAgaXRzIHBhcmVudCBub2RlLCBhbmQgaXRzIGNoaWxkIGluZGV4LiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAgZmFsc2UgZm9yIGEgZ2l2ZW4gbm9kZSwgdGhhdCBub2RlJ3MgY2hpbGRyZW4gd2lsbCBub3QgYmVcbiAgICByZWN1cnNlZCBvdmVyLiBUaGUgbGFzdCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhXG4gICAgc3RhcnRpbmcgcG9zaXRpb24gdG8gY291bnQgZnJvbS5cbiAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgc3RhcnRQb3MgPSAwKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gRG9lc24ndFxuICAgIGRlc2NlbmQgaW50byBhIG5vZGUgd2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLlxuICAgICovXG4gICAgZGVzY2VuZGFudHMoZikge1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbmNhdGVuYXRlcyBhbGwgdGhlIHRleHQgbm9kZXMgZm91bmQgaW4gdGhpcyBmcmFnbWVudCBhbmQgaXRzXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc0xlYWYgJiYgdGhpcy50eXBlLnNwZWMubGVhZlRleHQpXG4gICAgICAgICAgICA/IHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KHRoaXMpXG4gICAgICAgICAgICA6IHRoaXMudGV4dEJldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYWxsIHRleHQgYmV0d2VlbiBwb3NpdGlvbnMgYGZyb21gIGFuZCBgdG9gLiBXaGVuXG4gICAgYGJsb2NrU2VwYXJhdG9yYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBpbnNlcnRlZCB0byBzZXBhcmF0ZSB0ZXh0XG4gICAgZnJvbSBkaWZmZXJlbnQgYmxvY2sgbm9kZXMuIElmIGBsZWFmVGV4dGAgaXMgZ2l2ZW4sIGl0J2xsIGJlXG4gICAgaW5zZXJ0ZWQgZm9yIGV2ZXJ5IG5vbi10ZXh0IGxlYWYgbm9kZSBlbmNvdW50ZXJlZCwgb3RoZXJ3aXNlXG4gICAgW2BsZWFmVGV4dGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlY15sZWFmVGV4dCkgd2lsbCBiZSB1c2VkLlxuICAgICovXG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoaXMgbm9kZSdzIGZpcnN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5maXJzdENoaWxkOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBsYXN0IGNoaWxkLCBvciBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vXG4gICAgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxhc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0d28gbm9kZXMgcmVwcmVzZW50IHRoZSBzYW1lIHBpZWNlIG9mIGRvY3VtZW50LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgKHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgbWFya3VwICh0eXBlLCBhdHRyaWJ1dGVzLCBhbmQgbWFya3MpIG9mIHRoaXMgbm9kZSB0b1xuICAgIHRob3NlIG9mIGFub3RoZXIuIFJldHVybnMgYHRydWVgIGlmIGJvdGggaGF2ZSB0aGUgc2FtZSBtYXJrdXAuXG4gICAgKi9cbiAgICBzYW1lTWFya3VwKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcmt1cChvdGhlci50eXBlLCBvdGhlci5hdHRycywgb3RoZXIubWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSdzIG1hcmt1cCBjb3JyZXNwb25kIHRvIHRoZSBnaXZlbiB0eXBlLFxuICAgIGF0dHJpYnV0ZXMsIGFuZCBtYXJrcy5cbiAgICAqL1xuICAgIGhhc01hcmt1cCh0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlICYmXG4gICAgICAgICAgICBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBhdHRycyB8fCB0eXBlLmRlZmF1bHRBdHRycyB8fCBlbXB0eUF0dHJzKSAmJlxuICAgICAgICAgICAgTWFyay5zYW1lU2V0KHRoaXMubWFya3MsIG1hcmtzIHx8IE1hcmsubm9uZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBub2RlIHdpdGggdGhlIHNhbWUgbWFya3VwIGFzIHRoaXMgbm9kZSwgY29udGFpbmluZ1xuICAgIHRoZSBnaXZlbiBjb250ZW50IChvciBlbXB0eSwgaWYgbm8gY29udGVudCBpcyBnaXZlbikuXG4gICAgKi9cbiAgICBjb3B5KGNvbnRlbnQgPSBudWxsKSB7XG4gICAgICAgIGlmIChjb250ZW50ID09IHRoaXMuY29udGVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUsIHdpdGggdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBpbnN0ZWFkXG4gICAgb2YgdGhlIG5vZGUncyBvd24gbWFya3MuXG4gICAgKi9cbiAgICBtYXJrKG1hcmtzKSB7XG4gICAgICAgIHJldHVybiBtYXJrcyA9PSB0aGlzLm1hcmtzID8gdGhpcyA6IG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy5jb250ZW50LCBtYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlIHdpdGggb25seSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9ucy4gSWYgYHRvYCBpcyBub3QgZ2l2ZW4sIGl0IGRlZmF1bHRzIHRvIHRoZSBlbmQgb2ZcbiAgICB0aGUgbm9kZS5cbiAgICAqL1xuICAgIGN1dChmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSh0aGlzLmNvbnRlbnQuY3V0KGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEN1dCBvdXQgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucywgYW5kXG4gICAgcmV0dXJuIGl0IGFzIGEgYFNsaWNlYCBvYmplY3QuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMuY29udGVudC5zaXplLCBpbmNsdWRlUGFyZW50cyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChmcm9tID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgJGZyb20gPSB0aGlzLnJlc29sdmUoZnJvbSksICR0byA9IHRoaXMucmVzb2x2ZSh0byk7XG4gICAgICAgIGxldCBkZXB0aCA9IGluY2x1ZGVQYXJlbnRzID8gMCA6ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uc3RhcnQoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBjb250ZW50ID0gbm9kZS5jb250ZW50LmN1dCgkZnJvbS5wb3MgLSBzdGFydCwgJHRvLnBvcyAtIHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShjb250ZW50LCAkZnJvbS5kZXB0aCAtIGRlcHRoLCAkdG8uZGVwdGggLSBkZXB0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucyB3aXRoXG4gICAgdGhlIGdpdmVuIHNsaWNlLiBUaGUgc2xpY2UgbXVzdCAnZml0JywgbWVhbmluZyBpdHMgb3BlbiBzaWRlc1xuICAgIG11c3QgYmUgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzdXJyb3VuZGluZyBjb250ZW50LCBhbmQgaXRzXG4gICAgY29udGVudCBub2RlcyBtdXN0IGJlIHZhbGlkIGNoaWxkcmVuIGZvciB0aGUgbm9kZSB0aGV5IGFyZSBwbGFjZWRcbiAgICBpbnRvLiBJZiBhbnkgb2YgdGhpcyBpcyB2aW9sYXRlZCwgYW4gZXJyb3Igb2YgdHlwZVxuICAgIFtgUmVwbGFjZUVycm9yYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlcGxhY2VFcnJvcikgaXMgdGhyb3duLlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2UodGhpcy5yZXNvbHZlKGZyb20pLCB0aGlzLnJlc29sdmUodG8pLCBzbGljZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbm9kZUF0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gcG9zIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcG9zIC09IG9mZnNldCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBhZnRlciB0aGUgZ2l2ZW4gb2Zmc2V0LCBpZiBhbnksXG4gICAgYW5kIHJldHVybiBpdCBhbG9uZyB3aXRoIGl0cyBpbmRleCBhbmQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoaXNcbiAgICBub2RlLlxuICAgICovXG4gICAgY2hpbGRBZnRlcihwb3MpIHtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQubWF5YmVDaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgKGRpcmVjdCkgY2hpbGQgbm9kZSBiZWZvcmUgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQmVmb3JlKHBvcykge1xuICAgICAgICBpZiAocG9zID09IDApXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBudWxsLCBpbmRleDogMCwgb2Zmc2V0OiAwIH07XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IHBvcylcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudC5jaGlsZChpbmRleCksIGluZGV4LCBvZmZzZXQgfTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgaW5kZXg6IGluZGV4IC0gMSwgb2Zmc2V0OiBvZmZzZXQgLSBub2RlLm5vZGVTaXplIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc29sdmUgdGhlIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcmV0dXJuaW5nIGFuXG4gICAgW29iamVjdF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlJlc29sdmVkUG9zKSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGl0cyBjb250ZXh0LlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MpIHsgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmVDYWNoZWQodGhpcywgcG9zKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZU5vQ2FjaGUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgYSBnaXZlbiBtYXJrIG9yIG1hcmsgdHlwZSBvY2N1cnMgaW4gdGhpcyBkb2N1bWVudFxuICAgIGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICByYW5nZUhhc01hcmsoZnJvbSwgdG8sIHR5cGUpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAhZm91bmQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIGJsb2NrIChub24taW5saW5lIG5vZGUpXG4gICAgKi9cbiAgICBnZXQgaXNCbG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0Jsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0YmxvY2sgbm9kZSwgYSBibG9jayBub2RlIHdpdGggaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMudHlwZS5pc1RleHRibG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgYWxsb3dzIGlubGluZSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7IHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGlubGluZSBub2RlIChhIHRleHQgbm9kZSBvciBhIG5vZGUgdGhhdCBjYW5cbiAgICBhcHBlYXIgYW1vbmcgdGV4dCkuXG4gICAgKi9cbiAgICBnZXQgaXNJbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNJbmxpbmU7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIHRleHQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc1RleHQoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBsZWFmIG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNMZWFmKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzTGVhZjsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlIGRpcmVjdGx5XG4gICAgZWRpdGFibGUgY29udGVudC4gVGhpcyBpcyB1c3VhbGx5IHRoZSBzYW1lIGFzIGBpc0xlYWZgLCBidXQgY2FuXG4gICAgYmUgY29uZmlndXJlZCB3aXRoIHRoZSBbYGF0b21gIHByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXRvbSlcbiAgICBvbiBhIG5vZGUncyBzcGVjICh0eXBpY2FsbHkgdXNlZCB3aGVuIHRoZSBub2RlIGlzIGRpc3BsYXllZCBhc1xuICAgIGFuIHVuZWRpdGFibGUgW25vZGUgdmlld10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuTm9kZVZpZXcpKS5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLnR5cGUuaXNBdG9tOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSBmb3IgZGVidWdnaW5nXG4gICAgcHVycG9zZXMuXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLnR5cGUubmFtZTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgbmFtZSArPSBcIihcIiArIHRoaXMuY29udGVudC50b1N0cmluZ0lubmVyKCkgKyBcIilcIjtcbiAgICAgICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZW50IG1hdGNoIGluIHRoaXMgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgKi9cbiAgICBjb250ZW50TWF0Y2hBdChpbmRleCkge1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCAwLCBpbmRleCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgY29udGVudE1hdGNoQXQgb24gYSBub2RlIHdpdGggaW52YWxpZCBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIChieVxuICAgIGNoaWxkIGluZGV4KSB3aXRoIHRoZSBnaXZlbiByZXBsYWNlbWVudCBmcmFnbWVudCAod2hpY2ggZGVmYXVsdHNcbiAgICB0byB0aGUgZW1wdHkgZnJhZ21lbnQpIHdvdWxkIGxlYXZlIHRoZSBub2RlJ3MgY29udGVudCB2YWxpZC4gWW91XG4gICAgY2FuIG9wdGlvbmFsbHkgcGFzcyBgc3RhcnRgIGFuZCBgZW5kYCBpbmRpY2VzIGludG8gdGhlXG4gICAgcmVwbGFjZW1lbnQgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlKGZyb20sIHRvLCByZXBsYWNlbWVudCA9IEZyYWdtZW50LmVtcHR5LCBzdGFydCA9IDAsIGVuZCA9IHJlcGxhY2VtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgbGV0IG9uZSA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hGcmFnbWVudChyZXBsYWNlbWVudCwgc3RhcnQsIGVuZCk7XG4gICAgICAgIGxldCB0d28gPSBvbmUgJiYgb25lLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIGlmICghdHdvIHx8ICF0d28udmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUuYWxsb3dzTWFya3MocmVwbGFjZW1lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciByZXBsYWNpbmcgdGhlIHJhbmdlIGBmcm9tYCB0byBgdG9gIChieSBpbmRleCkgd2l0aFxuICAgIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuXG4gICAgKi9cbiAgICBjYW5SZXBsYWNlV2l0aChmcm9tLCB0bywgdHlwZSwgbWFya3MpIHtcbiAgICAgICAgaWYgKG1hcmtzICYmICF0aGlzLnR5cGUuYWxsb3dzTWFya3MobWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICYmIHN0YXJ0Lm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCB0byk7XG4gICAgICAgIHJldHVybiBlbmQgPyBlbmQudmFsaWRFbmQgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBub2RlJ3MgY29udGVudCBjb3VsZCBiZSBhcHBlbmRlZCB0byB0aGlzXG4gICAgbm9kZS4gSWYgdGhhdCBub2RlIGlzIGVtcHR5LCB0aGlzIHdpbGwgb25seSByZXR1cm4gdHJ1ZSBpZiB0aGVyZVxuICAgIGlzIGF0IGxlYXN0IG9uZSBub2RlIHR5cGUgdGhhdCBjYW4gYXBwZWFyIGluIGJvdGggbm9kZXMgKHRvIGF2b2lkXG4gICAgbWVyZ2luZyBjb21wbGV0ZWx5IGluY29tcGF0aWJsZSBub2RlcykuXG4gICAgKi9cbiAgICBjYW5BcHBlbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhblJlcGxhY2UodGhpcy5jaGlsZENvdW50LCB0aGlzLmNoaWxkQ291bnQsIG90aGVyLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmNvbXBhdGlibGVDb250ZW50KG90aGVyLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoaXMgbm9kZSBhbmQgaXRzIGRlc2NlbmRhbnRzIGNvbmZvcm0gdG8gdGhlXG4gICAgc2NoZW1hLCBhbmQgcmFpc2UgYW4gZXhjZXB0aW9uIHdoZW4gdGhleSBkbyBub3QuXG4gICAgKi9cbiAgICBjaGVjaygpIHtcbiAgICAgICAgdGhpcy50eXBlLmNoZWNrQ29udGVudCh0aGlzLmNvbnRlbnQpO1xuICAgICAgICB0aGlzLnR5cGUuY2hlY2tBdHRycyh0aGlzLmF0dHJzKTtcbiAgICAgICAgbGV0IGNvcHkgPSBNYXJrLm5vbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcmsgPSB0aGlzLm1hcmtzW2ldO1xuICAgICAgICAgICAgbWFyay50eXBlLmNoZWNrQXR0cnMobWFyay5hdHRycyk7XG4gICAgICAgICAgICBjb3B5ID0gbWFyay5hZGRUb1NldChjb3B5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU1hcmsuc2FtZVNldChjb3B5LCB0aGlzLm1hcmtzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNvbGxlY3Rpb24gb2YgbWFya3MgZm9yIG5vZGUgJHt0aGlzLnR5cGUubmFtZX06ICR7dGhpcy5tYXJrcy5tYXAobSA9PiBtLnR5cGUubmFtZSl9YCk7XG4gICAgICAgIHRoaXMuY29udGVudC5mb3JFYWNoKG5vZGUgPT4gbm9kZS5jaGVjaygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG9iaiA9IHsgdHlwZTogdGhpcy50eXBlLm5hbWUgfTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgb2JqLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLm1hcmtzLmxlbmd0aClcbiAgICAgICAgICAgIG9iai5tYXJrcyA9IHRoaXMubWFya3MubWFwKG4gPT4gbi50b0pTT04oKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbm9kZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCBtYXJrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGpzb24ubWFya3MpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uLm1hcmtzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbWFyayBkYXRhIGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICAgICAgbWFya3MgPSBqc29uLm1hcmtzLm1hcChzY2hlbWEubWFya0Zyb21KU09OKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoanNvbi50eXBlID09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24udGV4dCAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0ZXh0IG5vZGUgaW4gSlNPTlwiKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEudGV4dChqc29uLnRleHQsIG1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KTtcbiAgICAgICAgbGV0IG5vZGUgPSBzY2hlbWEubm9kZVR5cGUoanNvbi50eXBlKS5jcmVhdGUoanNvbi5hdHRycywgY29udGVudCwgbWFya3MpO1xuICAgICAgICBub2RlLnR5cGUuY2hlY2tBdHRycyhub2RlLmF0dHJzKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufVxuTm9kZS5wcm90b3R5cGUudGV4dCA9IHVuZGVmaW5lZDtcbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgTm9kZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhdHRycywgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgYXR0cnMsIG51bGwsIG1hcmtzKTtcbiAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFbXB0eSB0ZXh0IG5vZGVzIGFyZSBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gY29udGVudDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgSlNPTi5zdHJpbmdpZnkodGhpcy50ZXh0KSk7XG4gICAgfVxuICAgIGdldCB0ZXh0Q29udGVudCgpIHsgcmV0dXJuIHRoaXMudGV4dDsgfVxuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pOyB9XG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIG1hcmsobWFya3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy50ZXh0LCBtYXJrcyk7XG4gICAgfVxuICAgIHdpdGhUZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gdGhpcy50ZXh0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0ZXh0LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gICAgY3V0KGZyb20gPSAwLCB0byA9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhUZXh0KHRoaXMudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW1lTWFya3VwKG90aGVyKSAmJiB0aGlzLnRleHQgPT0gb3RoZXIudGV4dDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgYmFzZSA9IHN1cGVyLnRvSlNPTigpO1xuICAgICAgICBiYXNlLnRleHQgPSB0aGlzLnRleHQ7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBNYXJrcyhtYXJrcywgc3RyKSB7XG4gICAgZm9yIChsZXQgaSA9IG1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBzdHIgPSBtYXJrc1tpXS50eXBlLm5hbWUgKyBcIihcIiArIHN0ciArIFwiKVwiO1xuICAgIHJldHVybiBzdHI7XG59XG5cbi8qKlxuSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IGEgbWF0Y2ggc3RhdGUgb2YgYSBub2RlIHR5cGUnc1xuW2NvbnRlbnQgZXhwcmVzc2lvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvbnRlbnQpLCBhbmQgY2FuIGJlIHVzZWQgdG9cbmZpbmQgb3V0IHdoZXRoZXIgZnVydGhlciBjb250ZW50IG1hdGNoZXMgaGVyZSwgYW5kIHdoZXRoZXIgYSBnaXZlblxucG9zaXRpb24gaXMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4qL1xuY2xhc3MgQ29udGVudE1hdGNoIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG1hdGNoIHN0YXRlIHJlcHJlc2VudHMgYSB2YWxpZCBlbmQgb2YgdGhlIG5vZGUuXG4gICAgKi9cbiAgICB2YWxpZEVuZCkge1xuICAgICAgICB0aGlzLnZhbGlkRW5kID0gdmFsaWRFbmQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwQ2FjaGUgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcGFyc2Uoc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcyk7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRNYXRjaC5lbXB0eTtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0KVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdHJhaWxpbmcgdGV4dFwiKTtcbiAgICAgICAgbGV0IG1hdGNoID0gZGZhKG5mYShleHByKSk7XG4gICAgICAgIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgTWF0Y2ggYSBub2RlIHR5cGUsIHJldHVybmluZyBhIG1hdGNoIGFmdGVyIHRoYXQgbm9kZSBpZlxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaFR5cGUodHlwZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHRbaV0ubmV4dDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtYXRjaCBhIGZyYWdtZW50LiBSZXR1cm5zIHRoZSByZXN1bHRpbmcgbWF0Y2ggd2hlblxuICAgIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBtYXRjaEZyYWdtZW50KGZyYWcsIHN0YXJ0ID0gMCwgZW5kID0gZnJhZy5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBjdXIgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGN1ciAmJiBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICBjdXIgPSBjdXIubWF0Y2hUeXBlKGZyYWcuY2hpbGQoaSkudHlwZSk7XG4gICAgICAgIHJldHVybiBjdXI7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGlubGluZUNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoICE9IDAgJiYgdGhpcy5uZXh0WzBdLnR5cGUuaXNJbmxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZmlyc3QgbWF0Y2hpbmcgbm9kZSB0eXBlIGF0IHRoaXMgbWF0Y2ggcG9zaXRpb24gdGhhdCBjYW5cbiAgICBiZSBnZW5lcmF0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdFR5cGUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyB0eXBlIH0gPSB0aGlzLm5leHRbaV07XG4gICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGF0aWJsZShvdGhlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3RoZXIubmV4dC5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gb3RoZXIubmV4dFtqXS50eXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWF0Y2ggdGhlIGdpdmVuIGZyYWdtZW50LCBhbmQgaWYgdGhhdCBmYWlscywgc2VlIGlmIGl0IGNhblxuICAgIGJlIG1hZGUgdG8gbWF0Y2ggYnkgaW5zZXJ0aW5nIG5vZGVzIGluIGZyb250IG9mIGl0LiBXaGVuXG4gICAgc3VjY2Vzc2Z1bCwgcmV0dXJuIGEgZnJhZ21lbnQgb2YgaW5zZXJ0ZWQgbm9kZXMgKHdoaWNoIG1heSBiZVxuICAgIGVtcHR5IGlmIG5vdGhpbmcgaGFkIHRvIGJlIGluc2VydGVkKS4gV2hlbiBgdG9FbmRgIGlzIHRydWUsIG9ubHlcbiAgICByZXR1cm4gYSBmcmFnbWVudCBpZiB0aGUgcmVzdWx0aW5nIG1hdGNoIGdvZXMgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBmaWxsQmVmb3JlKGFmdGVyLCB0b0VuZCA9IGZhbHNlLCBzdGFydEluZGV4ID0gMCkge1xuICAgICAgICBsZXQgc2VlbiA9IFt0aGlzXTtcbiAgICAgICAgZnVuY3Rpb24gc2VhcmNoKG1hdGNoLCB0eXBlcykge1xuICAgICAgICAgICAgbGV0IGZpbmlzaGVkID0gbWF0Y2gubWF0Y2hGcmFnbWVudChhZnRlciwgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQgJiYgKCF0b0VuZCB8fCBmaW5pc2hlZC52YWxpZEVuZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20odHlwZXMubWFwKHRwID0+IHRwLmNyZWF0ZUFuZEZpbGwoKSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgJiYgc2Vlbi5pbmRleE9mKG5leHQpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gc2VhcmNoKG5leHQsIHR5cGVzLmNvbmNhdCh0eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoKHRoaXMsIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBhIHNldCBvZiB3cmFwcGluZyBub2RlIHR5cGVzIHRoYXQgd291bGQgYWxsb3cgYSBub2RlIG9mIHRoZVxuICAgIGdpdmVuIHR5cGUgdG8gYXBwZWFyIGF0IHRoaXMgcG9zaXRpb24uIFRoZSByZXN1bHQgbWF5IGJlIGVtcHR5XG4gICAgKHdoZW4gaXQgZml0cyBkaXJlY3RseSkgYW5kIHdpbGwgYmUgbnVsbCB3aGVuIG5vIHN1Y2ggd3JhcHBpbmdcbiAgICBleGlzdHMuXG4gICAgKi9cbiAgICBmaW5kV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy53cmFwQ2FjaGUubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAodGhpcy53cmFwQ2FjaGVbaV0gPT0gdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndyYXBDYWNoZVtpICsgMV07XG4gICAgICAgIGxldCBjb21wdXRlZCA9IHRoaXMuY29tcHV0ZVdyYXBwaW5nKHRhcmdldCk7XG4gICAgICAgIHRoaXMud3JhcENhY2hlLnB1c2godGFyZ2V0LCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wdXRlV3JhcHBpbmcodGFyZ2V0KSB7XG4gICAgICAgIGxldCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgYWN0aXZlID0gW3sgbWF0Y2g6IHRoaXMsIHR5cGU6IG51bGwsIHZpYTogbnVsbCB9XTtcbiAgICAgICAgd2hpbGUgKGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gYWN0aXZlLnNoaWZ0KCksIG1hdGNoID0gY3VycmVudC5tYXRjaDtcbiAgICAgICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvYmogPSBjdXJyZW50OyBvYmoudHlwZTsgb2JqID0gb2JqLnZpYSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqLnR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2gubmV4dFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuaXNMZWFmICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSAmJiAhKHR5cGUubmFtZSBpbiBzZWVuKSAmJiAoIWN1cnJlbnQudHlwZSB8fCBuZXh0LnZhbGlkRW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmUucHVzaCh7IG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaCwgdHlwZSwgdmlhOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWVuW3R5cGUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBvdXRnb2luZyBlZGdlcyB0aGlzIG5vZGUgaGFzIGluIHRoZSBmaW5pdGVcbiAgICBhdXRvbWF0b24gdGhhdCBkZXNjcmliZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGdldCBlZGdlQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIF9uX1x1MjAwQnRoIG91dGdvaW5nIGVkZ2UgZnJvbSB0aGlzIG5vZGUgaW4gdGhlIGZpbml0ZVxuICAgIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZWRnZShuKSB7XG4gICAgICAgIGlmIChuID49IHRoaXMubmV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlcmUncyBubyAke259dGggZWRnZSBpbiB0aGlzIGNvbnRlbnQgbWF0Y2hgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFtuXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHNlZW4gPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gc2NhbihtKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2gobSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2NhbihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Nhbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNlZW4ubWFwKChtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgb3V0ID0gaSArIChtLnZhbGlkRW5kID8gXCIqXCIgOiBcIiBcIikgKyBcIiBcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIG91dCArPSAoaSA/IFwiLCBcIiA6IFwiXCIpICsgbS5uZXh0W2ldLnR5cGUubmFtZSArIFwiLT5cIiArIHNlZW4uaW5kZXhPZihtLm5leHRbaV0ubmV4dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH1cbn1cbi8qKlxuQGludGVybmFsXG4qL1xuQ29udGVudE1hdGNoLmVtcHR5ID0gbmV3IENvbnRlbnRNYXRjaCh0cnVlKTtcbmNsYXNzIFRva2VuU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy5ub2RlVHlwZXMgPSBub2RlVHlwZXM7XG4gICAgICAgIHRoaXMuaW5saW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnRva2VucyA9IHN0cmluZy5zcGxpdCgvXFxzKig/PVxcYnxcXFd8JCkvKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zW3RoaXMudG9rZW5zLmxlbmd0aCAtIDFdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5wb3AoKTtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zWzBdID09IFwiXCIpXG4gICAgICAgICAgICB0aGlzLnRva2Vucy5zaGlmdCgpO1xuICAgIH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMucG9zXTsgfVxuICAgIGVhdCh0b2spIHsgcmV0dXJuIHRoaXMubmV4dCA9PSB0b2sgJiYgKHRoaXMucG9zKysgfHwgdHJ1ZSk7IH1cbiAgICBlcnIoc3RyKSB7IHRocm93IG5ldyBTeW50YXhFcnJvcihzdHIgKyBcIiAoaW4gY29udGVudCBleHByZXNzaW9uICdcIiArIHRoaXMuc3RyaW5nICsgXCInKVwiKTsgfVxufVxuZnVuY3Rpb24gcGFyc2VFeHByKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTZXEoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLmVhdChcInxcIikpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU2VxKHN0cmVhbSkge1xuICAgIGxldCBleHBycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgZXhwcnMucHVzaChwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSk7XG4gICAgfSB3aGlsZSAoc3RyZWFtLm5leHQgJiYgc3RyZWFtLm5leHQgIT0gXCIpXCIgJiYgc3RyZWFtLm5leHQgIT0gXCJ8XCIpO1xuICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcInNlcVwiLCBleHBycyB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkge1xuICAgIGxldCBleHByID0gcGFyc2VFeHByQXRvbShzdHJlYW0pO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIrXCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJwbHVzXCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIipcIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcInN0YXJcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiP1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwib3B0XCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIntcIikpXG4gICAgICAgICAgICBleHByID0gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xufVxuZnVuY3Rpb24gcGFyc2VOdW0oc3RyZWFtKSB7XG4gICAgaWYgKC9cXEQvLnRlc3Qoc3RyZWFtLm5leHQpKVxuICAgICAgICBzdHJlYW0uZXJyKFwiRXhwZWN0ZWQgbnVtYmVyLCBnb3QgJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgbGV0IHJlc3VsdCA9IE51bWJlcihzdHJlYW0ubmV4dCk7XG4gICAgc3RyZWFtLnBvcysrO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpIHtcbiAgICBsZXQgbWluID0gcGFyc2VOdW0oc3RyZWFtKSwgbWF4ID0gbWluO1xuICAgIGlmIChzdHJlYW0uZWF0KFwiLFwiKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQgIT0gXCJ9XCIpXG4gICAgICAgICAgICBtYXggPSBwYXJzZU51bShzdHJlYW0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXggPSAtMTtcbiAgICB9XG4gICAgaWYgKCFzdHJlYW0uZWF0KFwifVwiKSlcbiAgICAgICAgc3RyZWFtLmVycihcIlVuY2xvc2VkIGJyYWNlZCByYW5nZVwiKTtcbiAgICByZXR1cm4geyB0eXBlOiBcInJhbmdlXCIsIG1pbiwgbWF4LCBleHByIH07XG59XG5mdW5jdGlvbiByZXNvbHZlTmFtZShzdHJlYW0sIG5hbWUpIHtcbiAgICBsZXQgdHlwZXMgPSBzdHJlYW0ubm9kZVR5cGVzLCB0eXBlID0gdHlwZXNbbmFtZV07XG4gICAgaWYgKHR5cGUpXG4gICAgICAgIHJldHVybiBbdHlwZV07XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbdHlwZU5hbWVdO1xuICAgICAgICBpZiAodHlwZS5pc0luR3JvdXAobmFtZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0eXBlKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT0gMClcbiAgICAgICAgc3RyZWFtLmVycihcIk5vIG5vZGUgdHlwZSBvciBncm91cCAnXCIgKyBuYW1lICsgXCInIGZvdW5kXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJBdG9tKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiKFwiKSkge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgICAgICBpZiAoIXN0cmVhbS5lYXQoXCIpXCIpKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk1pc3NpbmcgY2xvc2luZyBwYXJlblwiKTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEvXFxXLy50ZXN0KHN0cmVhbS5uZXh0KSkge1xuICAgICAgICBsZXQgZXhwcnMgPSByZXNvbHZlTmFtZShzdHJlYW0sIHN0cmVhbS5uZXh0KS5tYXAodHlwZSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmlubGluZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5pbmxpbmUgPSB0eXBlLmlzSW5saW5lO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmlubGluZSAhPSB0eXBlLmlzSW5saW5lKVxuICAgICAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXhpbmcgaW5saW5lIGFuZCBibG9jayBjb250ZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJuYW1lXCIsIHZhbHVlOiB0eXBlIH07XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW0ucG9zKys7XG4gICAgICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogeyB0eXBlOiBcImNob2ljZVwiLCBleHBycyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyZWFtLmVycihcIlVuZXhwZWN0ZWQgdG9rZW4gJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gICAgfVxufVxuLy8gQ29uc3RydWN0IGFuIE5GQSBmcm9tIGFuIGV4cHJlc3Npb24gYXMgcmV0dXJuZWQgYnkgdGhlIHBhcnNlci4gVGhlXG4vLyBORkEgaXMgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2Ygc3RhdGVzLCB3aGljaCBhcmUgdGhlbXNlbHZlc1xuLy8gYXJyYXlzIG9mIGVkZ2VzLCB3aGljaCBhcmUgYHt0ZXJtLCB0b31gIG9iamVjdHMuIFRoZSBmaXJzdCBzdGF0ZSBpc1xuLy8gdGhlIGVudHJ5IHN0YXRlIGFuZCB0aGUgbGFzdCBub2RlIGlzIHRoZSBzdWNjZXNzIHN0YXRlLlxuLy9cbi8vIE5vdGUgdGhhdCB1bmxpa2UgdHlwaWNhbCBORkFzLCB0aGUgZWRnZSBvcmRlcmluZyBpbiB0aGlzIG9uZSBpc1xuLy8gc2lnbmlmaWNhbnQsIGluIHRoYXQgaXQgaXMgdXNlZCB0byBjb250cnVjdCBmaWxsZXIgY29udGVudCB3aGVuXG4vLyBuZWNlc3NhcnkuXG5mdW5jdGlvbiBuZmEoZXhwcikge1xuICAgIGxldCBuZmEgPSBbW11dO1xuICAgIGNvbm5lY3QoY29tcGlsZShleHByLCAwKSwgbm9kZSgpKTtcbiAgICByZXR1cm4gbmZhO1xuICAgIGZ1bmN0aW9uIG5vZGUoKSB7IHJldHVybiBuZmEucHVzaChbXSkgLSAxOyB9XG4gICAgZnVuY3Rpb24gZWRnZShmcm9tLCB0bywgdGVybSkge1xuICAgICAgICBsZXQgZWRnZSA9IHsgdGVybSwgdG8gfTtcbiAgICAgICAgbmZhW2Zyb21dLnB1c2goZWRnZSk7XG4gICAgICAgIHJldHVybiBlZGdlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25uZWN0KGVkZ2VzLCB0bykge1xuICAgICAgICBlZGdlcy5mb3JFYWNoKGVkZ2UgPT4gZWRnZS50byA9IHRvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGlsZShleHByLCBmcm9tKSB7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT0gXCJjaG9pY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHIuZXhwcnMucmVkdWNlKChvdXQsIGV4cHIpID0+IG91dC5jb25jYXQoY29tcGlsZShleHByLCBmcm9tKSksIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzZXFcIikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNvbXBpbGUoZXhwci5leHByc1tpXSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gZXhwci5leHBycy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICBjb25uZWN0KG5leHQsIGZyb20gPSBub2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInN0YXJcIikge1xuICAgICAgICAgICAgbGV0IGxvb3AgPSBub2RlKCk7XG4gICAgICAgICAgICBlZGdlKGZyb20sIGxvb3ApO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJwbHVzXCIpIHtcbiAgICAgICAgICAgIGxldCBsb29wID0gbm9kZSgpO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSksIGxvb3ApO1xuICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJvcHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGZyb20pXS5jb25jYXQoY29tcGlsZShleHByLmV4cHIsIGZyb20pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJyYW5nZVwiKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwci5taW47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZSgpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIG5leHQpO1xuICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5tYXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGV4cHIubWluOyBpIDwgZXhwci5tYXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZShjdXIsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoY3VyKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoZnJvbSwgdW5kZWZpbmVkLCBleHByLnZhbHVlKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV4cHIgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNtcChhLCBiKSB7IHJldHVybiBiIC0gYTsgfVxuLy8gR2V0IHRoZSBzZXQgb2Ygbm9kZXMgcmVhY2hhYmxlIGJ5IG51bGwgZWRnZXMgZnJvbSBgbm9kZWAuIE9taXRcbi8vIG5vZGVzIHdpdGggb25seSBhIHNpbmdsZSBudWxsLW91dC1lZGdlLCBzaW5jZSB0aGV5IG1heSBsZWFkIHRvXG4vLyBuZWVkbGVzcyBkdXBsaWNhdGVkIG5vZGVzLlxuZnVuY3Rpb24gbnVsbEZyb20obmZhLCBub2RlKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIHNjYW4obm9kZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCk7XG4gICAgZnVuY3Rpb24gc2Nhbihub2RlKSB7XG4gICAgICAgIGxldCBlZGdlcyA9IG5mYVtub2RlXTtcbiAgICAgICAgaWYgKGVkZ2VzLmxlbmd0aCA9PSAxICYmICFlZGdlc1swXS50ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIHNjYW4oZWRnZXNbMF0udG8pO1xuICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgdGVybSwgdG8gfSA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKCF0ZXJtICYmIHJlc3VsdC5pbmRleE9mKHRvKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBzY2FuKHRvKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIENvbXBpbGVzIGFuIE5GQSBhcyBwcm9kdWNlZCBieSBgbmZhYCBpbnRvIGEgREZBLCBtb2RlbGVkIGFzIGEgc2V0XG4vLyBvZiBzdGF0ZSBvYmplY3RzIChgQ29udGVudE1hdGNoYCBpbnN0YW5jZXMpIHdpdGggdHJhbnNpdGlvbnNcbi8vIGJldHdlZW4gdGhlbS5cbmZ1bmN0aW9uIGRmYShuZmEpIHtcbiAgICBsZXQgbGFiZWxlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIGV4cGxvcmUobnVsbEZyb20obmZhLCAwKSk7XG4gICAgZnVuY3Rpb24gZXhwbG9yZShzdGF0ZXMpIHtcbiAgICAgICAgbGV0IG91dCA9IFtdO1xuICAgICAgICBzdGF0ZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIG5mYVtub2RlXS5mb3JFYWNoKCh7IHRlcm0sIHRvIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRlcm0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBsZXQgc2V0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0W2ldWzBdID09IHRlcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQgPSBvdXRbaV1bMV07XG4gICAgICAgICAgICAgICAgbnVsbEZyb20obmZhLCB0bykuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChbdGVybSwgc2V0ID0gW11dKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldC5pbmRleE9mKG5vZGUpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBzdGF0ZSA9IGxhYmVsZWRbc3RhdGVzLmpvaW4oXCIsXCIpXSA9IG5ldyBDb250ZW50TWF0Y2goc3RhdGVzLmluZGV4T2YobmZhLmxlbmd0aCAtIDEpID4gLTEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXRlcyA9IG91dFtpXVsxXS5zb3J0KGNtcCk7XG4gICAgICAgICAgICBzdGF0ZS5uZXh0LnB1c2goeyB0eXBlOiBvdXRbaV1bMF0sIG5leHQ6IGxhYmVsZWRbc3RhdGVzLmpvaW4oXCIsXCIpXSB8fCBleHBsb3JlKHN0YXRlcykgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSkge1xuICAgIGZvciAobGV0IGkgPSAwLCB3b3JrID0gW21hdGNoXTsgaSA8IHdvcmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXRlID0gd29ya1tpXSwgZGVhZCA9ICFzdGF0ZS52YWxpZEVuZCwgbm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZS5uZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBzdGF0ZS5uZXh0W2pdO1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0eXBlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGRlYWQgJiYgISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpXG4gICAgICAgICAgICAgICAgZGVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHdvcmsuaW5kZXhPZihuZXh0KSA9PSAtMSlcbiAgICAgICAgICAgICAgICB3b3JrLnB1c2gobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlYWQpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiT25seSBub24tZ2VuZXJhdGFibGUgbm9kZXMgKFwiICsgbm9kZXMuam9pbihcIiwgXCIpICsgXCIpIGluIGEgcmVxdWlyZWQgcG9zaXRpb24gKHNlZSBodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL2d1aWRlLyNnZW5lcmF0YWJsZSlcIik7XG4gICAgfVxufVxuXG4vLyBGb3Igbm9kZSB0eXBlcyB3aGVyZSBhbGwgYXR0cnMgaGF2ZSBhIGRlZmF1bHQgdmFsdWUgKG9yIHdoaWNoIGRvbid0XG4vLyBoYXZlIGFueSBhdHRyaWJ1dGVzKSwgYnVpbGQgdXAgYSBzaW5nbGUgcmV1c2FibGUgZGVmYXVsdCBhdHRyaWJ1dGVcbi8vIG9iamVjdCwgYW5kIHVzZSBpdCBmb3IgYWxsIG5vZGVzIHRoYXQgZG9uJ3Qgc3BlY2lmeSBzcGVjaWZpY1xuLy8gYXR0cmlidXRlcy5cbmZ1bmN0aW9uIGRlZmF1bHRBdHRycyhhdHRycykge1xuICAgIGxldCBkZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgYXR0ck5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHIgPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgIGlmICghYXR0ci5oYXNEZWZhdWx0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGRlZmF1bHRzW2F0dHJOYW1lXSA9IGF0dHIuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xufVxuZnVuY3Rpb24gY29tcHV0ZUF0dHJzKGF0dHJzLCB2YWx1ZSkge1xuICAgIGxldCBidWlsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgZ2l2ZW4gPSB2YWx1ZSAmJiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgaWYgKGdpdmVuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBhdHRyID0gYXR0cnNbbmFtZV07XG4gICAgICAgICAgICBpZiAoYXR0ci5oYXNEZWZhdWx0KVxuICAgICAgICAgICAgICAgIGdpdmVuID0gYXR0ci5kZWZhdWx0O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gdmFsdWUgc3VwcGxpZWQgZm9yIGF0dHJpYnV0ZSBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWx0W25hbWVdID0gZ2l2ZW47XG4gICAgfVxuICAgIHJldHVybiBidWlsdDtcbn1cbmZ1bmN0aW9uIGNoZWNrQXR0cnMoYXR0cnMsIHZhbHVlcywgdHlwZSwgbmFtZSkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gdmFsdWVzKVxuICAgICAgICBpZiAoIShuYW1lIGluIGF0dHJzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnN1cHBvcnRlZCBhdHRyaWJ1dGUgJHtuYW1lfSBmb3IgJHt0eXBlfSBvZiB0eXBlICR7bmFtZX1gKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyID0gYXR0cnNbbmFtZV07XG4gICAgICAgIGlmIChhdHRyLnZhbGlkYXRlKVxuICAgICAgICAgICAgYXR0ci52YWxpZGF0ZSh2YWx1ZXNbbmFtZV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRBdHRycyh0eXBlTmFtZSwgYXR0cnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSBuZXcgQXR0cmlidXRlKHR5cGVOYW1lLCBuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuTm9kZSB0eXBlcyBhcmUgb2JqZWN0cyBhbGxvY2F0ZWQgb25jZSBwZXIgYFNjaGVtYWAgYW5kIHVzZWQgdG9cblt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnR5cGUpIGBOb2RlYCBpbnN0YW5jZXMuIFRoZXkgY29udGFpbiBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIG5vZGUgdHlwZSwgc3VjaCBhcyBpdHMgbmFtZSBhbmQgd2hhdCBraW5kIG9mIG5vZGUgaXRcbnJlcHJlc2VudHMuXG4qL1xuY2xhc3MgTm9kZVR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgdGhlIG5vZGUgdHlwZSBoYXMgaW4gdGhpcyBzY2hlbWEuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBBIGxpbmsgYmFjayB0byB0aGUgYFNjaGVtYWAgdGhlIG5vZGUgdHlwZSBiZWxvbmdzIHRvLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc3BlYyB0aGF0IHRoaXMgdHlwZSBpcyBiYXNlZCBvblxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzZXQgb2YgbWFya3MgYWxsb3dlZCBpbiB0aGlzIG5vZGUuIGBudWxsYCBtZWFucyBhbGwgbWFya3NcbiAgICAgICAgYXJlIGFsbG93ZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFya1NldCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ3JvdXBzID0gc3BlYy5ncm91cCA/IHNwZWMuZ3JvdXAuc3BsaXQoXCIgXCIpIDogW107XG4gICAgICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMobmFtZSwgc3BlYy5hdHRycyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdEF0dHJzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmNvbnRlbnRNYXRjaCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5saW5lQ29udGVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNCbG9jayA9ICEoc3BlYy5pbmxpbmUgfHwgbmFtZSA9PSBcInRleHRcIik7XG4gICAgICAgIHRoaXMuaXNUZXh0ID0gbmFtZSA9PSBcInRleHRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB0aGlzIGlzIGFuIGlubGluZSB0eXBlLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gIXRoaXMuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgdGhpcyBpcyBhIHRleHRibG9jayB0eXBlLCBhIGJsb2NrIHRoYXQgY29udGFpbnMgaW5saW5lXG4gICAgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc1RleHRibG9jaygpIHsgcmV0dXJuIHRoaXMuaXNCbG9jayAmJiB0aGlzLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIGZvciBub2RlIHR5cGVzIHRoYXQgYWxsb3cgbm8gY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0xlYWYoKSB7IHJldHVybiB0aGlzLmNvbnRlbnRNYXRjaCA9PSBDb250ZW50TWF0Y2guZW1wdHk7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGlzIGFuIGF0b20sIGkuZS4gd2hlbiBpdCBkb2VzIG5vdCBoYXZlXG4gICAgZGlyZWN0bHkgZWRpdGFibGUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpc0F0b20oKSB7IHJldHVybiB0aGlzLmlzTGVhZiB8fCAhIXRoaXMuc3BlYy5hdG9tOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRydWUgd2hlbiB0aGlzIG5vZGUgdHlwZSBpcyBwYXJ0IG9mIHRoZSBnaXZlblxuICAgIFtncm91cF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmdyb3VwKS5cbiAgICAqL1xuICAgIGlzSW5Hcm91cChncm91cCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cHMuaW5kZXhPZihncm91cCkgPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5vZGUgdHlwZSdzIFt3aGl0ZXNwYWNlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMud2hpdGVzcGFjZSkgb3B0aW9uLlxuICAgICovXG4gICAgZ2V0IHdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMud2hpdGVzcGFjZSB8fCAodGhpcy5zcGVjLmNvZGUgPyBcInByZVwiIDogXCJub3JtYWxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoaXMgbm9kZSB0eXBlIGhhcyBhbnkgcmVxdWlyZWQgYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIGhhc1JlcXVpcmVkQXR0cnMoKSB7XG4gICAgICAgIGZvciAobGV0IG4gaW4gdGhpcy5hdHRycylcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dHJzW25dLmlzUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBub2RlIGFsbG93cyBzb21lIG9mIHRoZSBzYW1lIGNvbnRlbnQgYXNcbiAgICB0aGUgZ2l2ZW4gbm9kZSB0eXBlLlxuICAgICovXG4gICAgY29tcGF0aWJsZUNvbnRlbnQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy5jb250ZW50TWF0Y2guY29tcGF0aWJsZShvdGhlci5jb250ZW50TWF0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXB1dGVBdHRycyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzICYmIHRoaXMuZGVmYXVsdEF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEF0dHJzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYE5vZGVgIG9mIHRoaXMgdHlwZS4gVGhlIGdpdmVuIGF0dHJpYnV0ZXMgYXJlXG4gICAgY2hlY2tlZCBhbmQgZGVmYXVsdGVkICh5b3UgY2FuIHBhc3MgYG51bGxgIHRvIHVzZSB0aGUgdHlwZSdzXG4gICAgZGVmYXVsdHMgZW50aXJlbHksIGlmIG5vIHJlcXVpcmVkIGF0dHJpYnV0ZXMgZXhpc3QpLiBgY29udGVudGBcbiAgICBtYXkgYmUgYSBgRnJhZ21lbnRgLCBhIG5vZGUsIGFuIGFycmF5IG9mIG5vZGVzLCBvclxuICAgIGBudWxsYC4gU2ltaWxhcmx5IGBtYXJrc2AgbWF5IGJlIGBudWxsYCB0byBkZWZhdWx0IHRvIHRoZSBlbXB0eVxuICAgIHNldCBvZiBtYXJrcy5cbiAgICAqL1xuICAgIGNyZWF0ZShhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGVUeXBlLmNyZWF0ZSBjYW4ndCBjb25zdHJ1Y3QgdGV4dCBub2Rlc1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgRnJhZ21lbnQuZnJvbShjb250ZW50KSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2BjcmVhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IGNoZWNrIHRoZSBnaXZlbiBjb250ZW50XG4gICAgYWdhaW5zdCB0aGUgbm9kZSB0eXBlJ3MgY29udGVudCByZXN0cmljdGlvbnMsIGFuZCB0aHJvdyBhbiBlcnJvclxuICAgIGlmIGl0IGRvZXNuJ3QgbWF0Y2guXG4gICAgKi9cbiAgICBjcmVhdGVDaGVja2VkKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICAgIHRoaXMuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBjb250ZW50LCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYGNyZWF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgc2VlIGlmIGl0IGlzXG4gICAgbmVjZXNzYXJ5IHRvIGFkZCBub2RlcyB0byB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBnaXZlbiBmcmFnbWVudFxuICAgIHRvIG1ha2UgaXQgZml0IHRoZSBub2RlLiBJZiBubyBmaXR0aW5nIHdyYXBwaW5nIGNhbiBiZSBmb3VuZCxcbiAgICByZXR1cm4gbnVsbC4gTm90ZSB0aGF0LCBkdWUgdG8gdGhlIGZhY3QgdGhhdCByZXF1aXJlZCBub2RlcyBjYW5cbiAgICBhbHdheXMgYmUgY3JlYXRlZCwgdGhpcyB3aWxsIGFsd2F5cyBzdWNjZWVkIGlmIHlvdSBwYXNzIG51bGwgb3JcbiAgICBgRnJhZ21lbnQuZW1wdHlgIGFzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBjcmVhdGVBbmRGaWxsKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgYXR0cnMgPSB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyk7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gdGhpcy5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29udGVudCA9IGJlZm9yZS5hcHBlbmQoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoZWQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSBtYXRjaGVkICYmIG1hdGNoZWQuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIGlmICghYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGF0dHJzLCBjb250ZW50LmFwcGVuZChhZnRlciksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIHZhbGlkIGNvbnRlbnQgZm9yIHRoaXMgbm9kZVxuICAgIHR5cGUuXG4gICAgKi9cbiAgICB2YWxpZENvbnRlbnQoY29udGVudCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC52YWxpZEVuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrcyhjb250ZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaHJvd3MgYSBSYW5nZUVycm9yIGlmIHRoZSBnaXZlbiBmcmFnbWVudCBpcyBub3QgdmFsaWQgY29udGVudCBmb3IgdGhpc1xuICAgIG5vZGUgdHlwZS5cbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoZWNrQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZENvbnRlbnQoY29udGVudCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjb250ZW50IGZvciBub2RlICR7dGhpcy5uYW1lfTogJHtjb250ZW50LnRvU3RyaW5nKCkuc2xpY2UoMCwgNTApfWApO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoZWNrQXR0cnMoYXR0cnMpIHtcbiAgICAgICAgY2hlY2tBdHRycyh0aGlzLmF0dHJzLCBhdHRycywgXCJub2RlXCIsIHRoaXMubmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIG1hcmsgdHlwZSBpcyBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIGFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtTZXQgPT0gbnVsbCB8fCB0aGlzLm1hcmtTZXQuaW5kZXhPZihtYXJrVHlwZSkgPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgYXJlIGFsbG93ZWQgaW4gdGhpcyBub2RlLlxuICAgICovXG4gICAgYWxsb3dzTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgbWFya3MgdGhhdCBhcmUgbm90IGFsbG93ZWQgaW4gdGhpcyBub2RlIGZyb20gdGhlIGdpdmVuIHNldC5cbiAgICAqL1xuICAgIGFsbG93ZWRNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgICAgIGxldCBjb3B5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya1R5cGUobWFya3NbaV0udHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBtYXJrcy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LnB1c2gobWFya3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhY29weSA/IG1hcmtzIDogY29weS5sZW5ndGggPyBjb3B5IDogTWFyay5ub25lO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKG5vZGVzLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIG5vZGVzLmZvckVhY2goKG5hbWUsIHNwZWMpID0+IHJlc3VsdFtuYW1lXSA9IG5ldyBOb2RlVHlwZShuYW1lLCBzY2hlbWEsIHNwZWMpKTtcbiAgICAgICAgbGV0IHRvcFR5cGUgPSBzY2hlbWEuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCI7XG4gICAgICAgIGlmICghcmVzdWx0W3RvcFR5cGVdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTY2hlbWEgaXMgbWlzc2luZyBpdHMgdG9wIG5vZGUgdHlwZSAoJ1wiICsgdG9wVHlwZSArIFwiJylcIik7XG4gICAgICAgIGlmICghcmVzdWx0LnRleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV2ZXJ5IHNjaGVtYSBuZWVkcyBhICd0ZXh0JyB0eXBlXCIpO1xuICAgICAgICBmb3IgKGxldCBfIGluIHJlc3VsdC50ZXh0LmF0dHJzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdGV4dCBub2RlIHR5cGUgc2hvdWxkIG5vdCBoYXZlIGF0dHJpYnV0ZXNcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlKHR5cGVOYW1lLCBhdHRyTmFtZSwgdHlwZSkge1xuICAgIGxldCB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpO1xuICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgbGV0IG5hbWUgPSB2YWx1ZSA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHZhbHVlO1xuICAgICAgICBpZiAodHlwZXMuaW5kZXhPZihuYW1lKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRXhwZWN0ZWQgdmFsdWUgb2YgdHlwZSAke3R5cGVzfSBmb3IgYXR0cmlidXRlICR7YXR0ck5hbWV9IG9uIHR5cGUgJHt0eXBlTmFtZX0sIGdvdCAke25hbWV9YCk7XG4gICAgfTtcbn1cbi8vIEF0dHJpYnV0ZSBkZXNjcmlwdG9yc1xuY2xhc3MgQXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlTmFtZSwgYXR0ck5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5oYXNEZWZhdWx0ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwiZGVmYXVsdFwiKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gb3B0aW9ucy5kZWZhdWx0O1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdHlwZW9mIG9wdGlvbnMudmFsaWRhdGUgPT0gXCJzdHJpbmdcIiA/IHZhbGlkYXRlVHlwZSh0eXBlTmFtZSwgYXR0ck5hbWUsIG9wdGlvbnMudmFsaWRhdGUpIDogb3B0aW9ucy52YWxpZGF0ZTtcbiAgICB9XG4gICAgZ2V0IGlzUmVxdWlyZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5oYXNEZWZhdWx0O1xuICAgIH1cbn1cbi8vIE1hcmtzXG4vKipcbkxpa2Ugbm9kZXMsIG1hcmtzICh3aGljaCBhcmUgYXNzb2NpYXRlZCB3aXRoIG5vZGVzIHRvIHNpZ25pZnlcbnRoaW5ncyBsaWtlIGVtcGhhc2lzIG9yIGJlaW5nIHBhcnQgb2YgYSBsaW5rKSBhcmVcblt0YWdnZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrLnR5cGUpIHdpdGggdHlwZSBvYmplY3RzLCB3aGljaCBhcmVcbmluc3RhbnRpYXRlZCBvbmNlIHBlciBgU2NoZW1hYC5cbiovXG5jbGFzcyBNYXJrVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGUgbWFyayB0eXBlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5rLCBcbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIHRoYXQgdGhpcyBtYXJrIHR5cGUgaW5zdGFuY2UgaXMgcGFydCBvZi5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNwZWMgb24gd2hpY2ggdGhlIHR5cGUgaXMgYmFzZWQuXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICB0aGlzLmF0dHJzID0gaW5pdEF0dHJzKG5hbWUsIHNwZWMuYXR0cnMpO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVkID0gbnVsbDtcbiAgICAgICAgbGV0IGRlZmF1bHRzID0gZGVmYXVsdEF0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gZGVmYXVsdHMgPyBuZXcgTWFyayh0aGlzLCBkZWZhdWx0cykgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIG9mIHRoaXMgdHlwZS4gYGF0dHJzYCBtYXkgYmUgYG51bGxgIG9yIGFuIG9iamVjdFxuICAgIGNvbnRhaW5pbmcgb25seSBzb21lIG9mIHRoZSBtYXJrJ3MgYXR0cmlidXRlcy4gVGhlIG90aGVycywgaWZcbiAgICB0aGV5IGhhdmUgZGVmYXVsdHMsIHdpbGwgYmUgYWRkZWQuXG4gICAgKi9cbiAgICBjcmVhdGUoYXR0cnMgPSBudWxsKSB7XG4gICAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3IE1hcmsodGhpcywgY29tcHV0ZUF0dHJzKHRoaXMuYXR0cnMsIGF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNvbXBpbGUobWFya3MsIHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmFuayA9IDA7XG4gICAgICAgIG1hcmtzLmZvckVhY2goKG5hbWUsIHNwZWMpID0+IHJlc3VsdFtuYW1lXSA9IG5ldyBNYXJrVHlwZShuYW1lLCByYW5rKyssIHNjaGVtYSwgc3BlYykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldCwgYSBuZXcgc2V0XG4gICAgd2l0aG91dCBpdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCB0aGUgaW5wdXQgc2V0IGlzIHJldHVybmVkLlxuICAgICovXG4gICAgcmVtb3ZlRnJvbVNldChzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHNldCA9IHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0cyB3aGV0aGVyIHRoZXJlIGlzIGEgbWFyayBvZiB0aGlzIHR5cGUgaW4gdGhlIGdpdmVuIHNldC5cbiAgICAqL1xuICAgIGlzSW5TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldFtpXS50eXBlID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFtpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGVja0F0dHJzKGF0dHJzKSB7XG4gICAgICAgIGNoZWNrQXR0cnModGhpcy5hdHRycywgYXR0cnMsIFwibWFya1wiLCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyaWVzIHdoZXRoZXIgYSBnaXZlbiBtYXJrIHR5cGUgaXNcbiAgICBbZXhjbHVkZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrU3BlYy5leGNsdWRlcykgYnkgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBleGNsdWRlcyhvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leGNsdWRlZC5pbmRleE9mKG90aGVyKSA+IC0xO1xuICAgIH1cbn1cbi8qKlxuQSBkb2N1bWVudCBzY2hlbWEuIEhvbGRzIFtub2RlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUpIGFuZCBbbWFya1xudHlwZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtUeXBlKSBvYmplY3RzIGZvciB0aGUgbm9kZXMgYW5kIG1hcmtzIHRoYXQgbWF5XG5vY2N1ciBpbiBjb25mb3JtaW5nIGRvY3VtZW50cywgYW5kIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yXG5jcmVhdGluZyBhbmQgZGVzZXJpYWxpemluZyBzdWNoIGRvY3VtZW50cy5cblxuV2hlbiBnaXZlbiwgdGhlIHR5cGUgcGFyYW1ldGVycyBwcm92aWRlIHRoZSBuYW1lcyBvZiB0aGUgbm9kZXMgYW5kXG5tYXJrcyBpbiB0aGlzIHNjaGVtYS5cbiovXG5jbGFzcyBTY2hlbWEge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHNjaGVtYSBmcm9tIGEgc2NoZW1hIFtzcGVjaWZpY2F0aW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuU2NoZW1hU3BlYykuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgW2xpbmVicmVha1xuICAgICAgICByZXBsYWNlbWVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmxpbmVicmVha1JlcGxhY2VtZW50KSBub2RlIGRlZmluZWRcbiAgICAgICAgaW4gdGhpcyBzY2hlbWEsIGlmIGFueS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lYnJlYWtSZXBsYWNlbWVudCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBBbiBvYmplY3QgZm9yIHN0b3Jpbmcgd2hhdGV2ZXIgdmFsdWVzIG1vZHVsZXMgbWF5IHdhbnQgdG9cbiAgICAgICAgY29tcHV0ZSBhbmQgY2FjaGUgcGVyIHNjaGVtYS4gKElmIHlvdSB3YW50IHRvIHN0b3JlIHNvbWV0aGluZ1xuICAgICAgICBpbiBpdCwgdHJ5IHRvIHVzZSBwcm9wZXJ0eSBuYW1lcyB1bmxpa2VseSB0byBjbGFzaC4pXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGluc3RhbmNlU3BlYyA9IHRoaXMuc3BlYyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWNbcHJvcF0gPSBzcGVjW3Byb3BdO1xuICAgICAgICBpbnN0YW5jZVNwZWMubm9kZXMgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5ub2RlcyksXG4gICAgICAgICAgICBpbnN0YW5jZVNwZWMubWFya3MgPSBPcmRlcmVkTWFwLmZyb20oc3BlYy5tYXJrcyB8fCB7fSksXG4gICAgICAgICAgICB0aGlzLm5vZGVzID0gTm9kZVR5cGUuY29tcGlsZSh0aGlzLnNwZWMubm9kZXMsIHRoaXMpO1xuICAgICAgICB0aGlzLm1hcmtzID0gTWFya1R5cGUuY29tcGlsZSh0aGlzLnNwZWMubWFya3MsIHRoaXMpO1xuICAgICAgICBsZXQgY29udGVudEV4cHJDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKHByb3AgaW4gdGhpcy5tYXJrcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihwcm9wICsgXCIgY2FuIG5vdCBiZSBib3RoIGEgbm9kZSBhbmQgYSBtYXJrXCIpO1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzW3Byb3BdLCBjb250ZW50RXhwciA9IHR5cGUuc3BlYy5jb250ZW50IHx8IFwiXCIsIG1hcmtFeHByID0gdHlwZS5zcGVjLm1hcmtzO1xuICAgICAgICAgICAgdHlwZS5jb250ZW50TWF0Y2ggPSBjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSB8fFxuICAgICAgICAgICAgICAgIChjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSA9IENvbnRlbnRNYXRjaC5wYXJzZShjb250ZW50RXhwciwgdGhpcy5ub2RlcykpO1xuICAgICAgICAgICAgdHlwZS5pbmxpbmVDb250ZW50ID0gdHlwZS5jb250ZW50TWF0Y2guaW5saW5lQ29udGVudDtcbiAgICAgICAgICAgIGlmICh0eXBlLnNwZWMubGluZWJyZWFrUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lYnJlYWtSZXBsYWNlbWVudClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdWx0aXBsZSBsaW5lYnJlYWsgbm9kZXMgZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuaXNJbmxpbmUgfHwgIXR5cGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkxpbmVicmVhayByZXBsYWNlbWVudCBub2RlcyBtdXN0IGJlIGlubGluZSBsZWFmIG5vZGVzXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHlwZS5tYXJrU2V0ID0gbWFya0V4cHIgPT0gXCJfXCIgPyBudWxsIDpcbiAgICAgICAgICAgICAgICBtYXJrRXhwciA/IGdhdGhlck1hcmtzKHRoaXMsIG1hcmtFeHByLnNwbGl0KFwiIFwiKSkgOlxuICAgICAgICAgICAgICAgICAgICBtYXJrRXhwciA9PSBcIlwiIHx8ICF0eXBlLmlubGluZUNvbnRlbnQgPyBbXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLm1hcmtzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMubWFya3NbcHJvcF0sIGV4Y2wgPSB0eXBlLnNwZWMuZXhjbHVkZXM7XG4gICAgICAgICAgICB0eXBlLmV4Y2x1ZGVkID0gZXhjbCA9PSBudWxsID8gW3R5cGVdIDogZXhjbCA9PSBcIlwiID8gW10gOiBnYXRoZXJNYXJrcyh0aGlzLCBleGNsLnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlRnJvbUpTT04gPSB0aGlzLm5vZGVGcm9tSlNPTi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm1hcmtGcm9tSlNPTiA9IHRoaXMubWFya0Zyb21KU09OLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudG9wTm9kZVR5cGUgPSB0aGlzLm5vZGVzW3RoaXMuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCJdO1xuICAgICAgICB0aGlzLmNhY2hlZC53cmFwcGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIGluIHRoaXMgc2NoZW1hLiBUaGUgYHR5cGVgIG1heSBiZSBhIHN0cmluZyBvciBhXG4gICAgYE5vZGVUeXBlYCBpbnN0YW5jZS4gQXR0cmlidXRlcyB3aWxsIGJlIGV4dGVuZGVkIHdpdGggZGVmYXVsdHMsXG4gICAgYGNvbnRlbnRgIG1heSBiZSBhIGBGcmFnbWVudGAsIGBudWxsYCwgYSBgTm9kZWAsIG9yIGFuIGFycmF5IG9mXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBub2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5ub2RlVHlwZSh0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAoISh0eXBlIGluc3RhbmNlb2YgTm9kZVR5cGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG5vZGUgdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZS5zY2hlbWEgIT0gdGhpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGZyb20gZGlmZmVyZW50IHNjaGVtYSB1c2VkIChcIiArIHR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlQ2hlY2tlZChhdHRycywgY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IG5vZGUgaW4gdGhlIHNjaGVtYS4gRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90XG4gICAgYWxsb3dlZC5cbiAgICAqL1xuICAgIHRleHQodGV4dCwgbWFya3MpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzLnRleHQ7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodHlwZSwgdHlwZS5kZWZhdWx0QXR0cnMsIHRleHQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBtYXJrKHR5cGUsIGF0dHJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubWFya3NbdHlwZV07XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShhdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbm9kZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuICAgIGJvdW5kLlxuICAgICovXG4gICAgbm9kZUZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIE5vZGUuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgbWFyayBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBUaGlzIG1ldGhvZCBpc1xuICAgIGJvdW5kLlxuICAgICovXG4gICAgbWFya0Zyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIE1hcmsuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbm9kZVR5cGUobmFtZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBuYW1lKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlck1hcmtzKHNjaGVtYSwgbWFya3MpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuYW1lID0gbWFya3NbaV0sIG1hcmsgPSBzY2hlbWEubWFya3NbbmFtZV0sIG9rID0gbWFyaztcbiAgICAgICAgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2gobWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrID0gc2NoZW1hLm1hcmtzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiX1wiIHx8IChtYXJrLnNwZWMuZ3JvdXAgJiYgbWFyay5zcGVjLmdyb3VwLnNwbGl0KFwiIFwiKS5pbmRleE9mKG5hbWUpID4gLTEpKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKG9rID0gbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvaylcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVua25vd24gbWFyayB0eXBlOiAnXCIgKyBtYXJrc1tpXSArIFwiJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiBpc1RhZ1J1bGUocnVsZSkgeyByZXR1cm4gcnVsZS50YWcgIT0gbnVsbDsgfVxuZnVuY3Rpb24gaXNTdHlsZVJ1bGUocnVsZSkgeyByZXR1cm4gcnVsZS5zdHlsZSAhPSBudWxsOyB9XG4vKipcbkEgRE9NIHBhcnNlciByZXByZXNlbnRzIGEgc3RyYXRlZ3kgZm9yIHBhcnNpbmcgRE9NIGNvbnRlbnQgaW50byBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudCBjb25mb3JtaW5nIHRvIGEgZ2l2ZW4gc2NoZW1hLiBJdHMgYmVoYXZpb3IgaXNcbmRlZmluZWQgYnkgYW4gYXJyYXkgb2YgW3J1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKS5cbiovXG5jbGFzcyBET01QYXJzZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBhcnNlciB0aGF0IHRhcmdldHMgdGhlIGdpdmVuIHNjaGVtYSwgdXNpbmcgdGhlIGdpdmVuXG4gICAgcGFyc2luZyBydWxlcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgaW50byB3aGljaCB0aGUgcGFyc2VyIHBhcnNlcy5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNldCBvZiBbcGFyc2UgcnVsZXNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUpIHRoYXQgdGhlIHBhcnNlclxuICAgIHVzZXMsIGluIG9yZGVyIG9mIHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBydWxlcykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGFncyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgICAgIGxldCBtYXRjaGVkU3R5bGVzID0gdGhpcy5tYXRjaGVkU3R5bGVzID0gW107XG4gICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNUYWdSdWxlKHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0eWxlUnVsZShydWxlKSkge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gL1tePV0qLy5leGVjKHJ1bGUuc3R5bGUpWzBdO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkU3R5bGVzLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkU3R5bGVzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZXMucHVzaChydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9ubHkgbm9ybWFsaXplIGxpc3QgZWxlbWVudHMgd2hlbiBsaXN0cyBpbiB0aGUgc2NoZW1hIGNhbid0IGRpcmVjdGx5IGNvbnRhaW4gdGhlbXNlbHZlc1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUxpc3RzID0gIXRoaXMudGFncy5zb21lKHIgPT4ge1xuICAgICAgICAgICAgaWYgKCEvXih1bHxvbClcXGIvLnRlc3Qoci50YWcpIHx8ICFyLm5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBzY2hlbWEubm9kZXNbci5ub2RlXTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUobm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBQYXJzZSBhIGRvY3VtZW50IGZyb20gdGhlIGNvbnRlbnQgb2YgYSBET00gbm9kZS5cbiAgICAqL1xuICAgIHBhcnNlKGRvbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgTWFyay5ub25lLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgICByZXR1cm4gY29udGV4dC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2VzIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiBET00gbm9kZSwgbGlrZVxuICAgIFtgcGFyc2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NUGFyc2VyLnBhcnNlKSwgYW5kIHRha2VzIHRoZSBzYW1lIHNldCBvZlxuICAgIG9wdGlvbnMuIEJ1dCB1bmxpa2UgdGhhdCBtZXRob2QsIHdoaWNoIHByb2R1Y2VzIGEgd2hvbGUgbm9kZSxcbiAgICB0aGlzIG9uZSByZXR1cm5zIGEgc2xpY2UgdGhhdCBpcyBvcGVuIGF0IHRoZSBzaWRlcywgbWVhbmluZyB0aGF0XG4gICAgdGhlIHNjaGVtYSBjb25zdHJhaW50cyBhcmVuJ3QgYXBwbGllZCB0byB0aGUgc3RhcnQgb2Ygbm9kZXMgdG9cbiAgICB0aGUgbGVmdCBvZiB0aGUgaW5wdXQgYW5kIHRoZSBlbmQgb2Ygbm9kZXMgYXQgdGhlIGVuZC5cbiAgICAqL1xuICAgIHBhcnNlU2xpY2UoZG9tLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgICBjb250ZXh0LmFkZEFsbChkb20sIE1hcmsubm9uZSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgICAgcmV0dXJuIFNsaWNlLm1heE9wZW4oY29udGV4dC5maW5pc2goKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF0Y2hUYWcoZG9tLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gYWZ0ZXIgPyB0aGlzLnRhZ3MuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnRhZ3NbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlcyhkb20sIHJ1bGUudGFnKSAmJlxuICAgICAgICAgICAgICAgIChydWxlLm5hbWVzcGFjZSA9PT0gdW5kZWZpbmVkIHx8IGRvbS5uYW1lc3BhY2VVUkkgPT0gcnVsZS5uYW1lc3BhY2UpICYmXG4gICAgICAgICAgICAgICAgKCFydWxlLmNvbnRleHQgfHwgY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBydWxlLmdldEF0dHJzKGRvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hdGNoU3R5bGUocHJvcCwgdmFsdWUsIGNvbnRleHQsIGFmdGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZnRlciA/IHRoaXMuc3R5bGVzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnN0eWxlc1tpXSwgc3R5bGUgPSBydWxlLnN0eWxlO1xuICAgICAgICAgICAgaWYgKHN0eWxlLmluZGV4T2YocHJvcCkgIT0gMCB8fFxuICAgICAgICAgICAgICAgIHJ1bGUuY29udGV4dCAmJiAhY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpIHx8XG4gICAgICAgICAgICAgICAgLy8gVGVzdCB0aGF0IHRoZSBzdHlsZSBzdHJpbmcgZWl0aGVyIHByZWNpc2VseSBtYXRjaGVzIHRoZSBwcm9wLFxuICAgICAgICAgICAgICAgIC8vIG9yIGhhcyBhbiAnPScgc2lnbiBhZnRlciB0aGUgcHJvcCwgZm9sbG93ZWQgYnkgdGhlIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgc3R5bGUubGVuZ3RoID4gcHJvcC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0eWxlLmNoYXJDb2RlQXQocHJvcC5sZW5ndGgpICE9IDYxIHx8IHN0eWxlLnNsaWNlKHByb3AubGVuZ3RoICsgMSkgIT0gdmFsdWUpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgc2NoZW1hUnVsZXMoc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAgICAgICAgIGxldCBwcmlvcml0eSA9IHJ1bGUucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogcnVsZS5wcmlvcml0eSwgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcmVzdWx0W2ldLCBuZXh0UHJpb3JpdHkgPSBuZXh0LnByaW9yaXR5ID09IG51bGwgPyA1MCA6IG5leHQucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRQcmlvcml0eSA8IHByaW9yaXR5KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgIGxldCBydWxlcyA9IHNjaGVtYS5tYXJrc1tuYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICAgICAgaWYgKHJ1bGVzKVxuICAgICAgICAgICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJ1bGUubWFyayB8fCBydWxlLmlnbm9yZSB8fCBydWxlLmNsZWFyTWFyaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm1hcmsgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBzY2hlbWEubm9kZXNbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgICAgIGlmIChydWxlcylcbiAgICAgICAgICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShydWxlLm5vZGUgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5tYXJrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubm9kZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgRE9NIHBhcnNlciB1c2luZyB0aGUgcGFyc2luZyBydWxlcyBsaXN0ZWQgaW4gYVxuICAgIHNjaGVtYSdzIFtub2RlIHNwZWNzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMucGFyc2VET00pLCByZW9yZGVyZWQgYnlcbiAgICBbcHJpb3JpdHldKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUucHJpb3JpdHkpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciB8fFxuICAgICAgICAgICAgKHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyID0gbmV3IERPTVBhcnNlcihzY2hlbWEsIERPTVBhcnNlci5zY2hlbWFSdWxlcyhzY2hlbWEpKSk7XG4gICAgfVxufVxuY29uc3QgYmxvY2tUYWdzID0ge1xuICAgIGFkZHJlc3M6IHRydWUsIGFydGljbGU6IHRydWUsIGFzaWRlOiB0cnVlLCBibG9ja3F1b3RlOiB0cnVlLCBjYW52YXM6IHRydWUsXG4gICAgZGQ6IHRydWUsIGRpdjogdHJ1ZSwgZGw6IHRydWUsIGZpZWxkc2V0OiB0cnVlLCBmaWdjYXB0aW9uOiB0cnVlLCBmaWd1cmU6IHRydWUsXG4gICAgZm9vdGVyOiB0cnVlLCBmb3JtOiB0cnVlLCBoMTogdHJ1ZSwgaDI6IHRydWUsIGgzOiB0cnVlLCBoNDogdHJ1ZSwgaDU6IHRydWUsXG4gICAgaDY6IHRydWUsIGhlYWRlcjogdHJ1ZSwgaGdyb3VwOiB0cnVlLCBocjogdHJ1ZSwgbGk6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvbDogdHJ1ZSxcbiAgICBvdXRwdXQ6IHRydWUsIHA6IHRydWUsIHByZTogdHJ1ZSwgc2VjdGlvbjogdHJ1ZSwgdGFibGU6IHRydWUsIHRmb290OiB0cnVlLCB1bDogdHJ1ZVxufTtcbmNvbnN0IGlnbm9yZVRhZ3MgPSB7XG4gICAgaGVhZDogdHJ1ZSwgbm9zY3JpcHQ6IHRydWUsIG9iamVjdDogdHJ1ZSwgc2NyaXB0OiB0cnVlLCBzdHlsZTogdHJ1ZSwgdGl0bGU6IHRydWVcbn07XG5jb25zdCBsaXN0VGFncyA9IHsgb2w6IHRydWUsIHVsOiB0cnVlIH07XG4vLyBVc2luZyBhIGJpdGZpZWxkIGZvciBub2RlIGNvbnRleHQgb3B0aW9uc1xuY29uc3QgT1BUX1BSRVNFUlZFX1dTID0gMSwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgPSAyLCBPUFRfT1BFTl9MRUZUID0gNDtcbmZ1bmN0aW9uIHdzT3B0aW9uc0Zvcih0eXBlLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIGJhc2UpIHtcbiAgICBpZiAocHJlc2VydmVXaGl0ZXNwYWNlICE9IG51bGwpXG4gICAgICAgIHJldHVybiAocHJlc2VydmVXaGl0ZXNwYWNlID8gT1BUX1BSRVNFUlZFX1dTIDogMCkgfFxuICAgICAgICAgICAgKHByZXNlcnZlV2hpdGVzcGFjZSA9PT0gXCJmdWxsXCIgPyBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IDApO1xuICAgIHJldHVybiB0eXBlICYmIHR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiID8gT1BUX1BSRVNFUlZFX1dTIHwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiBiYXNlICYgfk9QVF9PUEVOX0xFRlQ7XG59XG5jbGFzcyBOb2RlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYXR0cnMsIG1hcmtzLCBzb2xpZCwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMuc29saWQgPSBzb2xpZDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIC8vIE1hcmtzIGFwcGxpZWQgdG8gdGhlIG5vZGUncyBjaGlsZHJlblxuICAgICAgICB0aGlzLmFjdGl2ZU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2ggfHwgKG9wdGlvbnMgJiBPUFRfT1BFTl9MRUZUID8gbnVsbCA6IHR5cGUuY29udGVudE1hdGNoKTtcbiAgICB9XG4gICAgZmluZFdyYXBwaW5nKG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICBsZXQgZmlsbCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmaWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gsIHdyYXA7XG4gICAgICAgICAgICAgICAgaWYgKHdyYXAgPSBzdGFydC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpO1xuICAgIH1cbiAgICBmaW5pc2gob3BlbkVuZCkge1xuICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7IC8vIFN0cmlwIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSwgbTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QuaXNUZXh0ICYmIChtID0gL1sgXFx0XFxyXFxuXFx1MDAwY10rJC8uZXhlYyhsYXN0LnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdC50ZXh0Lmxlbmd0aCA9PSBtWzBdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSA9IHRleHQud2l0aFRleHQodGV4dC50ZXh0LnNsaWNlKDAsIHRleHQudGV4dC5sZW5ndGggLSBtWzBdLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIW9wZW5FbmQgJiYgdGhpcy5tYXRjaClcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmFwcGVuZCh0aGlzLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA/IHRoaXMudHlwZS5jcmVhdGUodGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcykgOiBjb250ZW50O1xuICAgIH1cbiAgICBpbmxpbmVDb250ZXh0KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50WzBdLmlzSW5saW5lO1xuICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICYmICFibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbn1cbmNsYXNzIFBhcnNlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIHBhcnNlciB3ZSBhcmUgdXNpbmcuXG4gICAgcGFyc2VyLCBcbiAgICAvLyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhpcyBwYXJzZS5cbiAgICBvcHRpb25zLCBpc09wZW4pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gaXNPcGVuO1xuICAgICAgICB0aGlzLm9wZW4gPSAwO1xuICAgICAgICB0aGlzLmxvY2FsUHJlc2VydmVXUyA9IGZhbHNlO1xuICAgICAgICBsZXQgdG9wTm9kZSA9IG9wdGlvbnMudG9wTm9kZSwgdG9wQ29udGV4dDtcbiAgICAgICAgbGV0IHRvcE9wdGlvbnMgPSB3c09wdGlvbnNGb3IobnVsbCwgb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsIDApIHwgKGlzT3BlbiA/IE9QVF9PUEVOX0xFRlQgOiAwKTtcbiAgICAgICAgaWYgKHRvcE5vZGUpXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHRvcE5vZGUudHlwZSwgdG9wTm9kZS5hdHRycywgTWFyay5ub25lLCB0cnVlLCBvcHRpb25zLnRvcE1hdGNoIHx8IHRvcE5vZGUudHlwZS5jb250ZW50TWF0Y2gsIHRvcE9wdGlvbnMpO1xuICAgICAgICBlbHNlIGlmIChpc09wZW4pXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KG51bGwsIG51bGwsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQocGFyc2VyLnNjaGVtYS50b3BOb2RlVHlwZSwgbnVsbCwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0b3BDb250ZXh0XTtcbiAgICAgICAgdGhpcy5maW5kID0gb3B0aW9ucy5maW5kUG9zaXRpb25zO1xuICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbdGhpcy5vcGVuXTtcbiAgICB9XG4gICAgLy8gQWRkIGEgRE9NIG5vZGUgdG8gdGhlIGNvbnRlbnQuIFRleHQgaXMgaW5zZXJ0ZWQgYXMgdGV4dCBub2RlLFxuICAgIC8vIG90aGVyd2lzZSwgdGhlIG5vZGUgaXMgcGFzc2VkIHRvIGBhZGRFbGVtZW50YCBvciwgaWYgaXQgaGFzIGFcbiAgICAvLyBgc3R5bGVgIGF0dHJpYnV0ZSwgYGFkZEVsZW1lbnRXaXRoU3R5bGVzYC5cbiAgICBhZGRET00oZG9tLCBtYXJrcykge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0aGlzLmFkZFRleHROb2RlKGRvbSwgbWFya3MpO1xuICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20sIG1hcmtzKTtcbiAgICB9XG4gICAgYWRkVGV4dE5vZGUoZG9tLCBtYXJrcykge1xuICAgICAgICBsZXQgdmFsdWUgPSBkb20ubm9kZVZhbHVlO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy50b3AsIHByZXNlcnZlV1MgPSAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCkgPyBcImZ1bGxcIlxuICAgICAgICAgICAgOiB0aGlzLmxvY2FsUHJlc2VydmVXUyB8fCAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpID4gMDtcbiAgICAgICAgaWYgKHByZXNlcnZlV1MgPT09IFwiZnVsbFwiIHx8XG4gICAgICAgICAgICB0b3AuaW5saW5lQ29udGV4dChkb20pIHx8XG4gICAgICAgICAgICAvW14gXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlV1MpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1sgXFx0XFxyXFxuXFx1MDAwY10rL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGFuZCB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSBpdCwgb3JcbiAgICAgICAgICAgICAgICAvLyBhIGhhcmQgYnJlYWssIG9yIGEgdGV4dCBub2RlIHRoYXQgZW5kcyB3aXRoIHdoaXRlc3BhY2UsIHN0cmlwIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxlYWRpbmcgc3BhY2UuXG4gICAgICAgICAgICAgICAgaWYgKC9eWyBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkgJiYgdGhpcy5vcGVuID09IHRoaXMubm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZUJlZm9yZSA9IHRvcC5jb250ZW50W3RvcC5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9tTm9kZUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZUJlZm9yZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvbU5vZGVCZWZvcmUgJiYgZG9tTm9kZUJlZm9yZS5ub2RlTmFtZSA9PSAnQlInKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVCZWZvcmUuaXNUZXh0ICYmIC9bIFxcdFxcclxcblxcdTAwMGNdJC8udGVzdChub2RlQmVmb3JlLnRleHQpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlc2VydmVXUyAhPT0gXCJmdWxsXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csIFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydE5vZGUodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQodmFsdWUpLCBtYXJrcywgIS9cXFMvLnRlc3QodmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMuZmluZEluVGV4dChkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gdGFnIGFuZCB1c2UgdGhhdCB0byBwYXJzZS4gSWZcbiAgICAvLyBub25lIGlzIGZvdW5kLCB0aGUgZWxlbWVudCdzIGNvbnRlbnQgbm9kZXMgYXJlIGFkZGVkIGRpcmVjdGx5LlxuICAgIGFkZEVsZW1lbnQoZG9tLCBtYXJrcywgbWF0Y2hBZnRlcikge1xuICAgICAgICBsZXQgb3V0ZXJXUyA9IHRoaXMubG9jYWxQcmVzZXJ2ZVdTLCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKGRvbS50YWdOYW1lID09IFwiUFJFXCIgfHwgL3ByZS8udGVzdChkb20uc3R5bGUgJiYgZG9tLnN0eWxlLndoaXRlU3BhY2UpKVxuICAgICAgICAgICAgdGhpcy5sb2NhbFByZXNlcnZlV1MgPSB0cnVlO1xuICAgICAgICBsZXQgbmFtZSA9IGRvbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBydWxlSUQ7XG4gICAgICAgIGlmIChsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB0aGlzLnBhcnNlci5ub3JtYWxpemVMaXN0cylcbiAgICAgICAgICAgIG5vcm1hbGl6ZUxpc3QoZG9tKTtcbiAgICAgICAgbGV0IHJ1bGUgPSAodGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZSAmJiB0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlKGRvbSkpIHx8XG4gICAgICAgICAgICAocnVsZUlEID0gdGhpcy5wYXJzZXIubWF0Y2hUYWcoZG9tLCB0aGlzLCBtYXRjaEFmdGVyKSk7XG4gICAgICAgIG91dDogaWYgKHJ1bGUgPyBydWxlLmlnbm9yZSA6IGlnbm9yZVRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVGYWxsYmFjayhkb20sIG1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcnVsZSB8fCBydWxlLnNraXAgfHwgcnVsZS5jbG9zZVBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHJ1bGUgJiYgcnVsZS5jbG9zZVBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSBNYXRoLm1heCgwLCB0aGlzLm9wZW4gLSAxKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUgJiYgcnVsZS5za2lwLm5vZGVUeXBlKVxuICAgICAgICAgICAgICAgIGRvbSA9IHJ1bGUuc2tpcDtcbiAgICAgICAgICAgIGxldCBzeW5jLCBvbGROZWVkc0Jsb2NrID0gdGhpcy5uZWVkc0Jsb2NrO1xuICAgICAgICAgICAgaWYgKGJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3AuY29udGVudC5sZW5ndGggJiYgdG9wLmNvbnRlbnRbMF0uaXNJbmxpbmUgJiYgdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3Blbi0tO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0b3AudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSwgbWFya3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbm5lck1hcmtzID0gcnVsZSAmJiBydWxlLnNraXAgPyBtYXJrcyA6IHRoaXMucmVhZFN0eWxlcyhkb20sIG1hcmtzKTtcbiAgICAgICAgICAgIGlmIChpbm5lck1hcmtzKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQWxsKGRvbSwgaW5uZXJNYXJrcyk7XG4gICAgICAgICAgICBpZiAoc3luYylcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNCbG9jayA9IG9sZE5lZWRzQmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgaW5uZXJNYXJrcyA9IHRoaXMucmVhZFN0eWxlcyhkb20sIG1hcmtzKTtcbiAgICAgICAgICAgIGlmIChpbm5lck1hcmtzKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIGlubmVyTWFya3MsIHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSA/IHJ1bGVJRCA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2NhbFByZXNlcnZlV1MgPSBvdXRlcldTO1xuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGxlYWYgRE9NIG5vZGVzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGJlIGlnbm9yZWRcbiAgICBsZWFmRmFsbGJhY2soZG9tLCBtYXJrcykge1xuICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiB0aGlzLnRvcC50eXBlICYmIHRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIiksIG1hcmtzKTtcbiAgICB9XG4gICAgLy8gQ2FsbGVkIGZvciBpZ25vcmVkIG5vZGVzXG4gICAgaWdub3JlRmFsbGJhY2soZG9tLCBtYXJrcykge1xuICAgICAgICAvLyBJZ25vcmVkIEJSIG5vZGVzIHNob3VsZCBhdCBsZWFzdCBjcmVhdGUgYW4gaW5saW5lIGNvbnRleHRcbiAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgKCF0aGlzLnRvcC50eXBlIHx8ICF0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpKVxuICAgICAgICAgICAgdGhpcy5maW5kUGxhY2UodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQoXCItXCIpLCBtYXJrcywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIFJ1biBhbnkgc3R5bGUgcGFyc2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZSdzIHN0eWxlcy4gRWl0aGVyXG4gICAgLy8gcmV0dXJuIGFuIHVwZGF0ZWQgYXJyYXkgb2YgbWFya3MsIG9yIG51bGwgdG8gaW5kaWNhdGUgc29tZSBvZiB0aGVcbiAgICAvLyBzdHlsZXMgaGFkIGEgcnVsZSB3aXRoIGBpZ25vcmVgIHNldC5cbiAgICByZWFkU3R5bGVzKGRvbSwgbWFya3MpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IGRvbS5zdHlsZTtcbiAgICAgICAgLy8gQmVjYXVzZSBtYW55IHByb3BlcnRpZXMgd2lsbCBvbmx5IHNob3cgdXAgaW4gJ25vcm1hbGl6ZWQnIGZvcm1cbiAgICAgICAgLy8gaW4gYHN0eWxlLml0ZW1gIChpLmUuIHRleHQtZGVjb3JhdGlvbiBiZWNvbWVzXG4gICAgICAgIC8vIHRleHQtZGVjb3JhdGlvbi1saW5lLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGV0YyksIHdlIGRpcmVjdGx5XG4gICAgICAgIC8vIHF1ZXJ5IHRoZSBzdHlsZXMgbWVudGlvbmVkIGluIG91ciBydWxlcyBpbnN0ZWFkIG9mIGl0ZXJhdGluZ1xuICAgICAgICAvLyBvdmVyIHRoZSBpdGVtcy5cbiAgICAgICAgaWYgKHN0eWxlcyAmJiBzdHlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnNlci5tYXRjaGVkU3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSB0aGlzLnBhcnNlci5tYXRjaGVkU3R5bGVzW2ldLCB2YWx1ZSA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYWZ0ZXIgPSB1bmRlZmluZWQ7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnBhcnNlci5tYXRjaFN0eWxlKG5hbWUsIHZhbHVlLCB0aGlzLCBhZnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5pZ25vcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5jbGVhck1hcmspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5maWx0ZXIobSA9PiAhcnVsZS5jbGVhck1hcmsobSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdLmNyZWF0ZShydWxlLmF0dHJzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5jb25zdW1pbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gcnVsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8vIExvb2sgdXAgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gbm9kZS4gSWYgbm9uZSBhcmUgZm91bmQsIHJldHVyblxuICAgIC8vIGZhbHNlLiBPdGhlcndpc2UsIGFwcGx5IGl0LCB1c2UgaXRzIHJldHVybiB2YWx1ZSB0byBkcml2ZSB0aGUgd2F5XG4gICAgLy8gdGhlIG5vZGUncyBjb250ZW50IGlzIHdyYXBwZWQsIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICBhZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgbWFya3MsIGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgbGV0IHN5bmMsIG5vZGVUeXBlO1xuICAgICAgICBpZiAocnVsZS5ub2RlKSB7XG4gICAgICAgICAgICBub2RlVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tydWxlLm5vZGVdO1xuICAgICAgICAgICAgaWYgKCFub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmVudGVyKG5vZGVUeXBlLCBydWxlLmF0dHJzIHx8IG51bGwsIG1hcmtzLCBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IGlubmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmluc2VydE5vZGUobm9kZVR5cGUuY3JlYXRlKHJ1bGUuYXR0cnMpLCBtYXJrcywgZG9tLm5vZGVOYW1lID09IFwiQlJcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20sIG1hcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQobWFya1R5cGUuY3JlYXRlKHJ1bGUuYXR0cnMpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRJbiA9IHRoaXMudG9wO1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250aW51ZUFmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tLCBtYXJrcywgY29udGludWVBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVsZS5nZXRDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudChkb20sIHRoaXMucGFyc2VyLnNjaGVtYSkuZm9yRWFjaChub2RlID0+IHRoaXMuaW5zZXJ0Tm9kZShub2RlLCBtYXJrcywgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50RE9NID0gZG9tO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IGRvbS5xdWVyeVNlbGVjdG9yKHJ1bGUuY29udGVudEVsZW1lbnQpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50KGRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLmNvbnRlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmFkZEFsbChjb250ZW50RE9NLCBtYXJrcyk7XG4gICAgICAgICAgICB0aGlzLmZpbmRBcm91bmQoZG9tLCBjb250ZW50RE9NLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5bmMgJiYgdGhpcy5zeW5jKHN0YXJ0SW4pKVxuICAgICAgICAgICAgdGhpcy5vcGVuLS07XG4gICAgfVxuICAgIC8vIEFkZCBhbGwgY2hpbGQgbm9kZXMgYmV0d2VlbiBgc3RhcnRJbmRleGAgYW5kIGBlbmRJbmRleGAgKG9yIHRoZVxuICAgIC8vIHdob2xlIG5vZGUsIGlmIG5vdCBnaXZlbikuIElmIGBzeW5jYCBpcyBwYXNzZWQsIHVzZSBpdCB0b1xuICAgIC8vIHN5bmNocm9uaXplIGFmdGVyIGV2ZXJ5IGJsb2NrIGVsZW1lbnQuXG4gICAgYWRkQWxsKHBhcmVudCwgbWFya3MsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgICAgICAgZm9yIChsZXQgZG9tID0gc3RhcnRJbmRleCA/IHBhcmVudC5jaGlsZE5vZGVzW3N0YXJ0SW5kZXhdIDogcGFyZW50LmZpcnN0Q2hpbGQsIGVuZCA9IGVuZEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50LmNoaWxkTm9kZXNbZW5kSW5kZXhdOyBkb20gIT0gZW5kOyBkb20gPSBkb20ubmV4dFNpYmxpbmcsICsraW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmFkZERPTShkb20sIG1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIHdheSB0byBmaXQgdGhlIGdpdmVuIG5vZGUgdHlwZSBpbnRvIHRoZSBjdXJyZW50XG4gICAgLy8gY29udGV4dC4gTWF5IGFkZCBpbnRlcm1lZGlhdGUgd3JhcHBlcnMgYW5kL29yIGxlYXZlIG5vbi1zb2xpZFxuICAgIC8vIG5vZGVzIHRoYXQgd2UncmUgaW4uXG4gICAgZmluZFBsYWNlKG5vZGUsIG1hcmtzLCBjYXV0aW91cykge1xuICAgICAgICBsZXQgcm91dGUsIHN5bmM7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5vcGVuLCBwZW5hbHR5ID0gMDsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGN4ID0gdGhpcy5ub2Rlc1tkZXB0aF07XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjeC5maW5kV3JhcHBpbmcobm9kZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgJiYgKCFyb3V0ZSB8fCByb3V0ZS5sZW5ndGggPiBmb3VuZC5sZW5ndGggKyBwZW5hbHR5KSkge1xuICAgICAgICAgICAgICAgIHJvdXRlID0gZm91bmQ7XG4gICAgICAgICAgICAgICAgc3luYyA9IGN4O1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjeC5zb2xpZCkge1xuICAgICAgICAgICAgICAgIGlmIChjYXV0aW91cylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcGVuYWx0eSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcm91dGUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jKHN5bmMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbWFya3MgPSB0aGlzLmVudGVySW5uZXIocm91dGVbaV0sIG51bGwsIG1hcmtzLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGluc2VydCB0aGUgZ2l2ZW4gbm9kZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW4gbmVlZGVkLlxuICAgIGluc2VydE5vZGUobm9kZSwgbWFya3MsIGNhdXRpb3VzKSB7XG4gICAgICAgIGlmIChub2RlLmlzSW5saW5lICYmIHRoaXMubmVlZHNCbG9jayAmJiAhdGhpcy50b3AudHlwZSkge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdGhpcy50ZXh0YmxvY2tGcm9tQ29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgICAgICAgIG1hcmtzID0gdGhpcy5lbnRlcklubmVyKGJsb2NrLCBudWxsLCBtYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlubmVyTWFya3MgPSB0aGlzLmZpbmRQbGFjZShub2RlLCBtYXJrcywgY2F1dGlvdXMpO1xuICAgICAgICBpZiAoaW5uZXJNYXJrcykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgICAgICBpZiAodG9wLm1hdGNoKVxuICAgICAgICAgICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgIGxldCBub2RlTWFya3MgPSBNYXJrLm5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBtIG9mIGlubmVyTWFya3MuY29uY2F0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgIGlmICh0b3AudHlwZSA/IHRvcC50eXBlLmFsbG93c01hcmtUeXBlKG0udHlwZSkgOiBtYXJrTWF5QXBwbHkobS50eXBlLCBub2RlLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBub2RlTWFya3MgPSBtLmFkZFRvU2V0KG5vZGVNYXJrcyk7XG4gICAgICAgICAgICB0b3AuY29udGVudC5wdXNoKG5vZGUubWFyayhub2RlTWFya3MpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHN0YXJ0IGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW5cbiAgICAvLyBuZWNlc3NhcnkuXG4gICAgZW50ZXIodHlwZSwgYXR0cnMsIG1hcmtzLCBwcmVzZXJ2ZVdTKSB7XG4gICAgICAgIGxldCBpbm5lck1hcmtzID0gdGhpcy5maW5kUGxhY2UodHlwZS5jcmVhdGUoYXR0cnMpLCBtYXJrcywgZmFsc2UpO1xuICAgICAgICBpZiAoaW5uZXJNYXJrcylcbiAgICAgICAgICAgIGlubmVyTWFya3MgPSB0aGlzLmVudGVySW5uZXIodHlwZSwgYXR0cnMsIG1hcmtzLCB0cnVlLCBwcmVzZXJ2ZVdTKTtcbiAgICAgICAgcmV0dXJuIGlubmVyTWFya3M7XG4gICAgfVxuICAgIC8vIE9wZW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlXG4gICAgZW50ZXJJbm5lcih0eXBlLCBhdHRycywgbWFya3MsIHNvbGlkID0gZmFsc2UsIHByZXNlcnZlV1MpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoICYmIHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGxldCBvcHRpb25zID0gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV1MsIHRvcC5vcHRpb25zKTtcbiAgICAgICAgaWYgKCh0b3Aub3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQpICYmIHRvcC5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgb3B0aW9ucyB8PSBPUFRfT1BFTl9MRUZUO1xuICAgICAgICBsZXQgYXBwbHlNYXJrcyA9IE1hcmsubm9uZTtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5maWx0ZXIobSA9PiB7XG4gICAgICAgICAgICBpZiAodG9wLnR5cGUgPyB0b3AudHlwZS5hbGxvd3NNYXJrVHlwZShtLnR5cGUpIDogbWFya01heUFwcGx5KG0udHlwZSwgdHlwZSkpIHtcbiAgICAgICAgICAgICAgICBhcHBseU1hcmtzID0gbS5hZGRUb1NldChhcHBseU1hcmtzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgTm9kZUNvbnRleHQodHlwZSwgYXR0cnMsIGFwcGx5TWFya3MsIHNvbGlkLCBudWxsLCBvcHRpb25zKSk7XG4gICAgICAgIHRoaXMub3BlbisrO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhbGwgbm9kZXMgYWJvdmUgdGhpcy5vcGVuIGFyZSBmaW5pc2hlZCBhbmQgYWRkZWQgdG9cbiAgICAvLyB0aGVpciBwYXJlbnRzXG4gICAgY2xvc2VFeHRyYShvcGVuRW5kID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpID4gdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+IHRoaXMub3BlbjsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbaSAtIDFdLmNvbnRlbnQucHVzaCh0aGlzLm5vZGVzW2ldLmZpbmlzaChvcGVuRW5kKSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmxlbmd0aCA9IHRoaXMub3BlbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLm9wZW4gPSAwO1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEodGhpcy5pc09wZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5maW5pc2goISEodGhpcy5pc09wZW4gfHwgdGhpcy5vcHRpb25zLnRvcE9wZW4pKTtcbiAgICB9XG4gICAgc3luYyh0bykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbaV0gPT0gdG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sb2NhbFByZXNlcnZlV1MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW2ldLm9wdGlvbnMgfD0gT1BUX1BSRVNFUlZFX1dTO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRQb3MoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub3BlbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5ub2Rlc1tpXS5jb250ZW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGNvbnRlbnQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICAgICAgcG9zICs9IGNvbnRlbnRbal0ubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBmaW5kQXRQb2ludChwYXJlbnQsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gcGFyZW50ICYmIHRoaXMuZmluZFtpXS5vZmZzZXQgPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5zaWRlKHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRBcm91bmQocGFyZW50LCBjb250ZW50LCBiZWZvcmUpIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBjb250ZW50ICYmIHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBjb250ZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuZmluZFtpXS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyAmIChiZWZvcmUgPyAyIDogNCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEluVGV4dCh0ZXh0Tm9kZSkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gdGV4dE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3MgLSAodGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIHRoaXMuZmluZFtpXS5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGNvbnRleHQgc3RyaW5nIG1hdGNoZXMgdGhpcyBjb250ZXh0LlxuICAgIG1hdGNoZXNDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuaW5kZXhPZihcInxcIikgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnNwbGl0KC9cXHMqXFx8XFxzKi8pLnNvbWUodGhpcy5tYXRjaGVzQ29udGV4dCwgdGhpcyk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGNvbnRleHQuc3BsaXQoXCIvXCIpO1xuICAgICAgICBsZXQgb3B0aW9uID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gICAgICAgIGxldCB1c2VSb290ID0gIXRoaXMuaXNPcGVuICYmICghb3B0aW9uIHx8IG9wdGlvbi5wYXJlbnQudHlwZSA9PSB0aGlzLm5vZGVzWzBdLnR5cGUpO1xuICAgICAgICBsZXQgbWluRGVwdGggPSAtKG9wdGlvbiA/IG9wdGlvbi5kZXB0aCArIDEgOiAwKSArICh1c2VSb290ID8gMCA6IDEpO1xuICAgICAgICBsZXQgbWF0Y2ggPSAoaSwgZGVwdGgpID0+IHtcbiAgICAgICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBwYXJ0cy5sZW5ndGggLSAxIHx8IGkgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZGVwdGggPj0gbWluRGVwdGg7IGRlcHRoLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2goaSAtIDEsIGRlcHRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBkZXB0aCA+IDAgfHwgKGRlcHRoID09IDAgJiYgdXNlUm9vdCkgPyB0aGlzLm5vZGVzW2RlcHRoXS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbiAmJiBkZXB0aCA+PSBtaW5EZXB0aCA/IG9wdGlvbi5ub2RlKGRlcHRoIC0gbWluRGVwdGgpLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dCB8fCAobmV4dC5uYW1lICE9IHBhcnQgJiYgIW5leHQuaXNJbkdyb3VwKHBhcnQpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1hdGNoKHBhcnRzLmxlbmd0aCAtIDEsIHRoaXMub3Blbik7XG4gICAgfVxuICAgIHRleHRibG9ja0Zyb21Db250ZXh0KCkge1xuICAgICAgICBsZXQgJGNvbnRleHQgPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgaWYgKCRjb250ZXh0KVxuICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCBkZWZsdCA9ICRjb250ZXh0Lm5vZGUoZCkuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXhBZnRlcihkKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrICYmIGRlZmx0LmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmx0O1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlcykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiB0eXBlLmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBkaXJlY3RseSBuZXN0ZWQgbGlzdCBub2RlcyBwcm9kdWNlZCBieSBzb21lXG4vLyB0b29scyBhbmQgYWxsb3dlZCBieSBicm93c2VycyB0byBtZWFuIHRoYXQgdGhlIG5lc3RlZCBsaXN0IGlzXG4vLyBhY3R1YWxseSBwYXJ0IG9mIHRoZSBsaXN0IGl0ZW0gYWJvdmUgaXQuXG5mdW5jdGlvbiBub3JtYWxpemVMaXN0KGRvbSkge1xuICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQsIHByZXZJdGVtID0gbnVsbDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBjaGlsZC5ub2RlVHlwZSA9PSAxID8gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICAgIGlmIChuYW1lICYmIGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHByZXZJdGVtKSB7XG4gICAgICAgICAgICBwcmV2SXRlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICBjaGlsZCA9IHByZXZJdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJsaVwiKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEFwcGx5IGEgQ1NTIHNlbGVjdG9yLlxuZnVuY3Rpb24gbWF0Y2hlcyhkb20sIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIChkb20ubWF0Y2hlcyB8fCBkb20ubXNNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBkb20ubW96TWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGRvbSwgc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuLy8gVXNlZCB3aGVuIGZpbmRpbmcgYSBtYXJrIGF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmcmFnbWVudCBwYXJzZS5cbi8vIENoZWNrcyB3aGV0aGVyIGl0IHdvdWxkIGJlIHJlYXNvbmFibGUgdG8gYXBwbHkgYSBnaXZlbiBtYXJrIHR5cGUgdG9cbi8vIGEgZ2l2ZW4gbm9kZSwgYnkgbG9va2luZyBhdCB0aGUgd2F5IHRoZSBtYXJrIG9jY3VycyBpbiB0aGUgc2NoZW1hLlxuZnVuY3Rpb24gbWFya01heUFwcGx5KG1hcmtUeXBlLCBub2RlVHlwZSkge1xuICAgIGxldCBub2RlcyA9IG5vZGVUeXBlLnNjaGVtYS5ub2RlcztcbiAgICBmb3IgKGxldCBuYW1lIGluIG5vZGVzKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFwYXJlbnQuYWxsb3dzTWFya1R5cGUobWFya1R5cGUpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBzZWVuID0gW10sIHNjYW4gPSAobWF0Y2gpID0+IHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChtYXRjaCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBub2RlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihuZXh0KSA8IDAgJiYgc2NhbihuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzY2FuKHBhcmVudC5jb250ZW50TWF0Y2gpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vKipcbkEgRE9NIHNlcmlhbGl6ZXIga25vd3MgaG93IHRvIGNvbnZlcnQgUHJvc2VNaXJyb3Igbm9kZXMgYW5kXG5tYXJrcyBvZiB2YXJpb3VzIHR5cGVzIHRvIERPTSBub2Rlcy5cbiovXG5jbGFzcyBET01TZXJpYWxpemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXJpYWxpemVyLiBgbm9kZXNgIHNob3VsZCBtYXAgbm9kZSBuYW1lcyB0byBmdW5jdGlvbnNcbiAgICB0aGF0IHRha2UgYSBub2RlIGFuZCByZXR1cm4gYSBkZXNjcmlwdGlvbiBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICAgIERPTS4gYG1hcmtzYCBkb2VzIHRoZSBzYW1lIGZvciBtYXJrIG5hbWVzLCBidXQgYWxzbyBnZXRzIGFuXG4gICAgYXJndW1lbnQgdGhhdCB0ZWxscyBpdCB3aGV0aGVyIHRoZSBtYXJrJ3MgY29udGVudCBpcyBibG9jayBvclxuICAgIGlubGluZSBjb250ZW50IChmb3IgdHlwaWNhbCB1c2UsIGl0J2xsIGFsd2F5cyBiZSBpbmxpbmUpLiBBIG1hcmtcbiAgICBzZXJpYWxpemVyIG1heSBiZSBgbnVsbGAgdG8gaW5kaWNhdGUgdGhhdCBtYXJrcyBvZiB0aGF0IHR5cGVcbiAgICBzaG91bGQgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbm9kZSBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG5vZGVzLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG1hcmtzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhlIGNvbnRlbnQgb2YgdGhpcyBmcmFnbWVudCB0byBhIERPTSBmcmFnbWVudC4gV2hlblxuICAgIG5vdCBpbiB0aGUgYnJvd3NlciwgdGhlIGBkb2N1bWVudGAgb3B0aW9uLCBjb250YWluaW5nIGEgRE9NXG4gICAgZG9jdW1lbnQsIHNob3VsZCBiZSBwYXNzZWQgc28gdGhhdCB0aGUgc2VyaWFsaXplciBjYW4gY3JlYXRlXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBzZXJpYWxpemVGcmFnbWVudChmcmFnbWVudCwgb3B0aW9ucyA9IHt9LCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSBkb2Mob3B0aW9ucykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgdG9wID0gdGFyZ2V0LCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoIHx8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtlZXAgPSAwLCByZW5kZXJlZCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoICYmIHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLm1hcmtzW3JlbmRlcmVkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hcmtzW25leHQudHlwZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5lcShhY3RpdmVba2VlcF1bMF0pIHx8IG5leHQudHlwZS5zcGVjLnNwYW5uaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwKys7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gYWN0aXZlLnBvcCgpWzFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGQgPSBub2RlLm1hcmtzW3JlbmRlcmVkKytdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFya0RPTSA9IHRoaXMuc2VyaWFsaXplTWFyayhhZGQsIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFya0RPTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2goW2FkZCwgdG9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQobWFya0RPTS5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gbWFya0RPTS5jb250ZW50RE9NIHx8IG1hcmtET00uZG9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wLmFwcGVuZENoaWxkKHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHsgZG9tLCBjb250ZW50RE9NIH0gPSByZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdGhpcy5ub2Rlc1tub2RlLnR5cGUubmFtZV0obm9kZSksIG51bGwsIG5vZGUuYXR0cnMpO1xuICAgICAgICBpZiAoY29udGVudERPTSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG5vdCBhbGxvd2VkIGluIGEgbGVhZiBub2RlIHNwZWNcIik7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZUZyYWdtZW50KG5vZGUuY29udGVudCwgb3B0aW9ucywgY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgbm9kZSB0byBhIERPTSBub2RlLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3VcbiAgICBuZWVkIHRvIHNlcmlhbGl6ZSBhIHBhcnQgb2YgYSBkb2N1bWVudCwgYXMgb3Bwb3NlZCB0byB0aGUgd2hvbGVcbiAgICBkb2N1bWVudC4gVG8gc2VyaWFsaXplIGEgd2hvbGUgZG9jdW1lbnQsIHVzZVxuICAgIFtgc2VyaWFsaXplRnJhZ21lbnRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NU2VyaWFsaXplci5zZXJpYWxpemVGcmFnbWVudCkgb25cbiAgICBpdHMgW2NvbnRlbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLmNvbnRlbnQpLlxuICAgICovXG4gICAgc2VyaWFsaXplTm9kZShub2RlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gbm9kZS5tYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHdyYXAgPSB0aGlzLnNlcmlhbGl6ZU1hcmsobm9kZS5tYXJrc1tpXSwgbm9kZS5pc0lubGluZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAod3JhcCkge1xuICAgICAgICAgICAgICAgICh3cmFwLmNvbnRlbnRET00gfHwgd3JhcC5kb20pLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gd3JhcC5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXJpYWxpemVNYXJrKG1hcmssIGlubGluZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB0b0RPTSA9IHRoaXMubWFya3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgICByZXR1cm4gdG9ET00gJiYgcmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRvRE9NKG1hcmssIGlubGluZSksIG51bGwsIG1hcmsuYXR0cnMpO1xuICAgIH1cbiAgICBzdGF0aWMgcmVuZGVyU3BlYyhkb2MsIHN0cnVjdHVyZSwgeG1sTlMgPSBudWxsLCBibG9ja0FycmF5c0luKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUywgYmxvY2tBcnJheXNJbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgc2VyaWFsaXplciB1c2luZyB0aGUgW2B0b0RPTWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy50b0RPTSlcbiAgICBwcm9wZXJ0aWVzIGluIGEgc2NoZW1hJ3Mgbm9kZSBhbmQgbWFyayBzcGVjcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyIHx8XG4gICAgICAgICAgICAoc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyID0gbmV3IERPTVNlcmlhbGl6ZXIodGhpcy5ub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSwgdGhpcy5tYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3Mgbm9kZSBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbiAgICBUaGlzIGNhbiBiZSB1c2VmdWwgYXMgYSBiYXNlIHRvIGJ1aWxkIGEgY3VzdG9tIHNlcmlhbGl6ZXIgZnJvbS5cbiAgICAqL1xuICAgIHN0YXRpYyBub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBnYXRoZXJUb0RPTShzY2hlbWEubm9kZXMpO1xuICAgICAgICBpZiAoIXJlc3VsdC50ZXh0KVxuICAgICAgICAgICAgcmVzdWx0LnRleHQgPSBub2RlID0+IG5vZGUudGV4dDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2F0aGVyIHRoZSBzZXJpYWxpemVycyBpbiBhIHNjaGVtYSdzIG1hcmsgc3BlY3MgaW50byBhbiBvYmplY3QuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFya3NGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gZ2F0aGVyVG9ET00oc2NoZW1hLm1hcmtzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJUb0RPTShvYmopIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvYmopIHtcbiAgICAgICAgbGV0IHRvRE9NID0gb2JqW25hbWVdLnNwZWMudG9ET007XG4gICAgICAgIGlmICh0b0RPTSlcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHRvRE9NO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZG9jKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQ7XG59XG5jb25zdCBzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc3VzcGljaW91c0F0dHJpYnV0ZXMoYXR0cnMpIHtcbiAgICBsZXQgdmFsdWUgPSBzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUuZ2V0KGF0dHJzKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc3VzcGljaW91c0F0dHJpYnV0ZUNhY2hlLnNldChhdHRycywgdmFsdWUgPSBzdXNwaWNpb3VzQXR0cmlidXRlc0lubmVyKGF0dHJzKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gc3VzcGljaW91c0F0dHJpYnV0ZXNJbm5lcihhdHRycykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHNjYW4odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlWzBdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW4odmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHNjYW4odmFsdWVbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW4oYXR0cnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUywgYmxvY2tBcnJheXNJbikge1xuICAgIGlmICh0eXBlb2Ygc3RydWN0dXJlID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB7IGRvbTogZG9jLmNyZWF0ZVRleHROb2RlKHN0cnVjdHVyZSkgfTtcbiAgICBpZiAoc3RydWN0dXJlLm5vZGVUeXBlICE9IG51bGwpXG4gICAgICAgIHJldHVybiB7IGRvbTogc3RydWN0dXJlIH07XG4gICAgaWYgKHN0cnVjdHVyZS5kb20gJiYgc3RydWN0dXJlLmRvbS5ub2RlVHlwZSAhPSBudWxsKVxuICAgICAgICByZXR1cm4gc3RydWN0dXJlO1xuICAgIGxldCB0YWdOYW1lID0gc3RydWN0dXJlWzBdLCBzdXNwaWNpb3VzO1xuICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgYXJyYXkgcGFzc2VkIHRvIHJlbmRlclNwZWNcIik7XG4gICAgaWYgKGJsb2NrQXJyYXlzSW4gJiYgKHN1c3BpY2lvdXMgPSBzdXNwaWNpb3VzQXR0cmlidXRlcyhibG9ja0FycmF5c0luKSkgJiZcbiAgICAgICAgc3VzcGljaW91cy5pbmRleE9mKHN0cnVjdHVyZSkgPiAtMSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVc2luZyBhbiBhcnJheSBmcm9tIGFuIGF0dHJpYnV0ZSBvYmplY3QgYXMgYSBET00gc3BlYy4gVGhpcyBtYXkgYmUgYW4gYXR0ZW1wdGVkIGNyb3NzIHNpdGUgc2NyaXB0aW5nIGF0dGFjay5cIik7XG4gICAgbGV0IHNwYWNlID0gdGFnTmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgICBpZiAoc3BhY2UgPiAwKSB7XG4gICAgICAgIHhtbE5TID0gdGFnTmFtZS5zbGljZSgwLCBzcGFjZSk7XG4gICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnNsaWNlKHNwYWNlICsgMSk7XG4gICAgfVxuICAgIGxldCBjb250ZW50RE9NO1xuICAgIGxldCBkb20gPSAoeG1sTlMgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHhtbE5TLCB0YWdOYW1lKSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpKTtcbiAgICBsZXQgYXR0cnMgPSBzdHJ1Y3R1cmVbMV0sIHN0YXJ0ID0gMTtcbiAgICBpZiAoYXR0cnMgJiYgdHlwZW9mIGF0dHJzID09IFwib2JqZWN0XCIgJiYgYXR0cnMubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShhdHRycykpIHtcbiAgICAgICAgc3RhcnQgPSAyO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgaWYgKGF0dHJzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3BhY2UgPSBuYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzcGFjZSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNsaWNlKDAsIHNwYWNlKSwgbmFtZS5zbGljZShzcGFjZSArIDEpLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RydWN0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHN0cnVjdHVyZVtpXTtcbiAgICAgICAgaWYgKGNoaWxkID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaSA8IHN0cnVjdHVyZS5sZW5ndGggLSAxIHx8IGkgPiBzdGFydClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBtdXN0IGJlIHRoZSBvbmx5IGNoaWxkIG9mIGl0cyBwYXJlbnQgbm9kZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbSwgY29udGVudERPTTogZG9tIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgeyBkb206IGlubmVyLCBjb250ZW50RE9NOiBpbm5lckNvbnRlbnQgfSA9IHJlbmRlclNwZWMoZG9jLCBjaGlsZCwgeG1sTlMsIGJsb2NrQXJyYXlzSW4pO1xuICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICAgICAgICAgIGlmIChpbm5lckNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdWx0aXBsZSBjb250ZW50IGhvbGVzXCIpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBpbm5lckNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tLCBjb250ZW50RE9NIH07XG59XG5cbmV4cG9ydCB7IENvbnRlbnRNYXRjaCwgRE9NUGFyc2VyLCBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgTWFyaywgTWFya1R5cGUsIE5vZGUsIE5vZGVSYW5nZSwgTm9kZVR5cGUsIFJlcGxhY2VFcnJvciwgUmVzb2x2ZWRQb3MsIFNjaGVtYSwgU2xpY2UgfTtcbiIsICJpbXBvcnQgeyBSZXBsYWNlRXJyb3IsIFNsaWNlLCBGcmFnbWVudCwgTWFya1R5cGUsIE1hcmsgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5cbi8vIFJlY292ZXJ5IHZhbHVlcyBlbmNvZGUgYSByYW5nZSBpbmRleCBhbmQgYW4gb2Zmc2V0LiBUaGV5IGFyZVxuLy8gcmVwcmVzZW50ZWQgYXMgbnVtYmVycywgYmVjYXVzZSB0b25zIG9mIHRoZW0gd2lsbCBiZSBjcmVhdGVkIHdoZW5cbi8vIG1hcHBpbmcsIGZvciBleGFtcGxlLCBhIGxhcmdlIG51bWJlciBvZiBkZWNvcmF0aW9ucy4gVGhlIG51bWJlcidzXG4vLyBsb3dlciAxNiBiaXRzIHByb3ZpZGUgdGhlIGluZGV4LCB0aGUgcmVtYWluaW5nIGJpdHMgdGhlIG9mZnNldC5cbi8vXG4vLyBOb3RlOiBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBiaXQgc2hpZnQgb3BlcmF0b3JzIHRvIGVuLSBhbmRcbi8vIGRlY29kZSB0aGVzZSwgc2luY2UgdGhvc2UgY2xpcCB0byAzMiBiaXRzLCB3aGljaCB3ZSBtaWdodCBpbiByYXJlXG4vLyBjYXNlcyB3YW50IHRvIG92ZXJmbG93LiBBIDY0LWJpdCBmbG9hdCBjYW4gcmVwcmVzZW50IDQ4LWJpdFxuLy8gaW50ZWdlcnMgcHJlY2lzZWx5LlxuY29uc3QgbG93ZXIxNiA9IDB4ZmZmZjtcbmNvbnN0IGZhY3RvcjE2ID0gTWF0aC5wb3coMiwgMTYpO1xuZnVuY3Rpb24gbWFrZVJlY292ZXIoaW5kZXgsIG9mZnNldCkgeyByZXR1cm4gaW5kZXggKyBvZmZzZXQgKiBmYWN0b3IxNjsgfVxuZnVuY3Rpb24gcmVjb3ZlckluZGV4KHZhbHVlKSB7IHJldHVybiB2YWx1ZSAmIGxvd2VyMTY7IH1cbmZ1bmN0aW9uIHJlY292ZXJPZmZzZXQodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSAtICh2YWx1ZSAmIGxvd2VyMTYpKSAvIGZhY3RvcjE2OyB9XG5jb25zdCBERUxfQkVGT1JFID0gMSwgREVMX0FGVEVSID0gMiwgREVMX0FDUk9TUyA9IDQsIERFTF9TSURFID0gODtcbi8qKlxuQW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIG1hcHBlZCBwb3NpdGlvbiB3aXRoIGV4dHJhXG5pbmZvcm1hdGlvbi5cbiovXG5jbGFzcyBNYXBSZXN1bHQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG1hcHBlZCB2ZXJzaW9uIG9mIHRoZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkZWxJbmZvLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXIpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZGVsSW5mbyA9IGRlbEluZm87XG4gICAgICAgIHRoaXMucmVjb3ZlciA9IHJlY292ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSBwb3NpdGlvbiB3YXMgZGVsZXRlZCwgdGhhdCBpcywgd2hldGhlciB0aGVcbiAgICBzdGVwIHJlbW92ZWQgdGhlIHRva2VuIG9uIHRoZSBzaWRlIHF1ZXJpZWQgKHZpYSB0aGUgYGFzc29jYClcbiAgICBhcmd1bWVudCBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIERFTF9TSURFKSA+IDA7IH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgdG9rZW4gYmVmb3JlIHRoZSBtYXBwZWQgcG9zaXRpb24gd2FzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZEJlZm9yZSgpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0JFRk9SRSB8IERFTF9BQ1JPU1MpKSA+IDA7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhlIHRva2VuIGFmdGVyIHRoZSBtYXBwZWQgcG9zaXRpb24gd2FzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZEFmdGVyKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIChERUxfQUZURVIgfCBERUxfQUNST1NTKSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVGVsbHMgd2hldGhlciBhbnkgb2YgdGhlIHN0ZXBzIG1hcHBlZCB0aHJvdWdoIGRlbGV0ZXMgYWNyb3NzIHRoZVxuICAgIHBvc2l0aW9uIChpbmNsdWRpbmcgYm90aCB0aGUgdG9rZW4gYmVmb3JlIGFuZCBhZnRlciB0aGVcbiAgICBwb3NpdGlvbikuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZEFjcm9zcygpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfQUNST1NTKSA+IDA7IH1cbn1cbi8qKlxuQSBtYXAgZGVzY3JpYmluZyB0aGUgZGVsZXRpb25zIGFuZCBpbnNlcnRpb25zIG1hZGUgYnkgYSBzdGVwLCB3aGljaFxuY2FuIGJlIHVzZWQgdG8gZmluZCB0aGUgY29ycmVzcG9uZGVuY2UgYmV0d2VlbiBwb3NpdGlvbnMgaW4gdGhlXG5wcmUtc3RlcCB2ZXJzaW9uIG9mIGEgZG9jdW1lbnQgYW5kIHRoZSBzYW1lIHBvc2l0aW9uIGluIHRoZVxucG9zdC1zdGVwIHZlcnNpb24uXG4qL1xuY2xhc3MgU3RlcE1hcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcG9zaXRpb24gbWFwLiBUaGUgbW9kaWZpY2F0aW9ucyB0byB0aGUgZG9jdW1lbnQgYXJlXG4gICAgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgbnVtYmVycywgaW4gd2hpY2ggZWFjaCBncm91cCBvZiB0aHJlZVxuICAgIHJlcHJlc2VudHMgYSBtb2RpZmllZCBjaHVuayBhcyBgW3N0YXJ0LCBvbGRTaXplLCBuZXdTaXplXWAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmdlcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnZlcnRlZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmludmVydGVkID0gaW52ZXJ0ZWQ7XG4gICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aCAmJiBTdGVwTWFwLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3Zlcih2YWx1ZSkge1xuICAgICAgICBsZXQgZGlmZiA9IDAsIGluZGV4ID0gcmVjb3ZlckluZGV4KHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLmludmVydGVkKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgICAgICAgICAgIGRpZmYgKz0gdGhpcy5yYW5nZXNbaSAqIDMgKyAyXSAtIHRoaXMucmFuZ2VzW2kgKiAzICsgMV07XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1tpbmRleCAqIDNdICsgZGlmZiArIHJlY292ZXJPZmZzZXQodmFsdWUpO1xuICAgIH1cbiAgICBtYXBSZXN1bHQocG9zLCBhc3NvYyA9IDEpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSk7IH1cbiAgICBtYXAocG9zLCBhc3NvYyA9IDEpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCB0cnVlKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgX21hcChwb3MsIGFzc29jLCBzaW1wbGUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdLCBlbmQgPSBzdGFydCArIG9sZFNpemU7XG4gICAgICAgICAgICBpZiAocG9zIDw9IGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBzaWRlID0gIW9sZFNpemUgPyBhc3NvYyA6IHBvcyA9PSBzdGFydCA/IC0xIDogcG9zID09IGVuZCA/IDEgOiBhc3NvYztcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gc3RhcnQgKyBkaWZmICsgKHNpZGUgPCAwID8gMCA6IG5ld1NpemUpO1xuICAgICAgICAgICAgICAgIGlmIChzaW1wbGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgbGV0IHJlY292ZXIgPSBwb3MgPT0gKGFzc29jIDwgMCA/IHN0YXJ0IDogZW5kKSA/IG51bGwgOiBtYWtlUmVjb3ZlcihpIC8gMywgcG9zIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgIGxldCBkZWwgPSBwb3MgPT0gc3RhcnQgPyBERUxfQUZURVIgOiBwb3MgPT0gZW5kID8gREVMX0JFRk9SRSA6IERFTF9BQ1JPU1M7XG4gICAgICAgICAgICAgICAgaWYgKGFzc29jIDwgMCA/IHBvcyAhPSBzdGFydCA6IHBvcyAhPSBlbmQpXG4gICAgICAgICAgICAgICAgICAgIGRlbCB8PSBERUxfU0lERTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hcFJlc3VsdChyZXN1bHQsIGRlbCwgcmVjb3Zlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaWZmICs9IG5ld1NpemUgLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGUgPyBwb3MgKyBkaWZmIDogbmV3IE1hcFJlc3VsdChwb3MgKyBkaWZmLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b3VjaGVzKHBvcywgcmVjb3Zlcikge1xuICAgICAgICBsZXQgZGlmZiA9IDAsIGluZGV4ID0gcmVjb3ZlckluZGV4KHJlY292ZXIpO1xuICAgICAgICBsZXQgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBlbmQgPSBzdGFydCArIG9sZFNpemU7XG4gICAgICAgICAgICBpZiAocG9zIDw9IGVuZCAmJiBpID09IGluZGV4ICogMylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGRpZmYgKz0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBDYWxscyB0aGUgZ2l2ZW4gZnVuY3Rpb24gb24gZWFjaCBvZiB0aGUgY2hhbmdlZCByYW5nZXMgaW5jbHVkZWQgaW5cbiAgICB0aGlzIG1hcC5cbiAgICAqL1xuICAgIGZvckVhY2goZikge1xuICAgICAgICBsZXQgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgZGlmZiA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0sIG9sZFN0YXJ0ID0gc3RhcnQgLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKSwgbmV3U3RhcnQgPSBzdGFydCArICh0aGlzLmludmVydGVkID8gMCA6IGRpZmYpO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XTtcbiAgICAgICAgICAgIGYob2xkU3RhcnQsIG9sZFN0YXJ0ICsgb2xkU2l6ZSwgbmV3U3RhcnQsIG5ld1N0YXJ0ICsgbmV3U2l6ZSk7XG4gICAgICAgICAgICBkaWZmICs9IG5ld1NpemUgLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgbWFwLiBUaGUgcmVzdWx0IGNhbiBiZSB1c2VkIHRvXG4gICAgbWFwIHBvc2l0aW9ucyBpbiB0aGUgcG9zdC1zdGVwIGRvY3VtZW50IHRvIHRoZSBwcmUtc3RlcCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKHRoaXMucmFuZ2VzLCAhdGhpcy5pbnZlcnRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pbnZlcnRlZCA/IFwiLVwiIDogXCJcIikgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnJhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcCB0aGF0IG1vdmVzIGFsbCBwb3NpdGlvbnMgYnkgb2Zmc2V0IGBuYCAod2hpY2ggbWF5IGJlXG4gICAgbmVnYXRpdmUpLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBhcHBseWluZyBzdGVwcyBtZWFudCBmb3IgYVxuICAgIHN1Yi1kb2N1bWVudCB0byBhIGxhcmdlciBkb2N1bWVudCwgb3IgdmljZS12ZXJzYS5cbiAgICAqL1xuICAgIHN0YXRpYyBvZmZzZXQobikge1xuICAgICAgICByZXR1cm4gbiA9PSAwID8gU3RlcE1hcC5lbXB0eSA6IG5ldyBTdGVwTWFwKG4gPCAwID8gWzAsIC1uLCAwXSA6IFswLCAwLCBuXSk7XG4gICAgfVxufVxuLyoqXG5BIFN0ZXBNYXAgdGhhdCBjb250YWlucyBubyBjaGFuZ2VkIHJhbmdlcy5cbiovXG5TdGVwTWFwLmVtcHR5ID0gbmV3IFN0ZXBNYXAoW10pO1xuLyoqXG5BIG1hcHBpbmcgcmVwcmVzZW50cyBhIHBpcGVsaW5lIG9mIHplcm8gb3IgbW9yZSBbc3RlcFxubWFwc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwTWFwKS4gSXQgaGFzIHNwZWNpYWwgcHJvdmlzaW9ucyBmb3IgbG9zc2xlc3NseVxuaGFuZGxpbmcgbWFwcGluZyBwb3NpdGlvbnMgdGhyb3VnaCBhIHNlcmllcyBvZiBzdGVwcyBpbiB3aGljaCBzb21lXG5zdGVwcyBhcmUgaW52ZXJ0ZWQgdmVyc2lvbnMgb2YgZWFybGllciBzdGVwcy4gKFRoaXMgY29tZXMgdXAgd2hlblxuXHUyMDE4W3JlYmFzaW5nXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL2d1aWRlLyN0cmFuc2Zvcm0ucmViYXNpbmcpXHUyMDE5IHN0ZXBzIGZvclxuY29sbGFib3JhdGlvbiBvciBoaXN0b3J5IG1hbmFnZW1lbnQuKVxuKi9cbmNsYXNzIE1hcHBpbmcge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBtYXBwaW5nIHdpdGggdGhlIGdpdmVuIHBvc2l0aW9uIG1hcHMuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXBzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1pcnJvciwgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXksIHVzZWQgd2hlbiBgbWFwYCBvclxuICAgIGBtYXBSZXN1bHRgIGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIGZyb20gPSAwLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIGluIHRoZSBgbWFwc2AgYXJyYXkuXG4gICAgKi9cbiAgICB0byA9IG1hcHMgPyBtYXBzLmxlbmd0aCA6IDApIHtcbiAgICAgICAgdGhpcy5taXJyb3IgPSBtaXJyb3I7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5fbWFwcyA9IG1hcHMgfHwgW107XG4gICAgICAgIHRoaXMub3duRGF0YSA9ICEobWFwcyB8fCBtaXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RlcCBtYXBzIGluIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIGdldCBtYXBzKCkgeyByZXR1cm4gdGhpcy5fbWFwczsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcHBpbmcgdGhhdCBtYXBzIG9ubHkgdGhyb3VnaCBhIHBhcnQgb2YgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBzbGljZShmcm9tID0gMCwgdG8gPSB0aGlzLm1hcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwcGluZyh0aGlzLl9tYXBzLCB0aGlzLm1pcnJvciwgZnJvbSwgdG8pO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBzdGVwIG1hcCB0byB0aGUgZW5kIG9mIHRoaXMgbWFwcGluZy4gSWYgYG1pcnJvcnNgIGlzXG4gICAgZ2l2ZW4sIGl0IHNob3VsZCBiZSB0aGUgaW5kZXggb2YgdGhlIHN0ZXAgbWFwIHRoYXQgaXMgdGhlIG1pcnJvclxuICAgIGltYWdlIG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgYXBwZW5kTWFwKG1hcCwgbWlycm9ycykge1xuICAgICAgICBpZiAoIXRoaXMub3duRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fbWFwcyA9IHRoaXMuX21hcHMuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMubWlycm9yID0gdGhpcy5taXJyb3IgJiYgdGhpcy5taXJyb3Iuc2xpY2UoKTtcbiAgICAgICAgICAgIHRoaXMub3duRGF0YSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50byA9IHRoaXMuX21hcHMucHVzaChtYXApO1xuICAgICAgICBpZiAobWlycm9ycyAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZXRNaXJyb3IodGhpcy5fbWFwcy5sZW5ndGggLSAxLCBtaXJyb3JzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGFsbCB0aGUgc3RlcCBtYXBzIGluIGEgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZSAocHJlc2VydmluZ1xuICAgIG1pcnJvcmluZyBpbmZvcm1hdGlvbikuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0U2l6ZSA9IHRoaXMuX21hcHMubGVuZ3RoOyBpIDwgbWFwcGluZy5fbWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWFwKG1hcHBpbmcuX21hcHNbaV0sIG1pcnIgIT0gbnVsbCAmJiBtaXJyIDwgaSA/IHN0YXJ0U2l6ZSArIG1pcnIgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmRzIHRoZSBvZmZzZXQgb2YgdGhlIHN0ZXAgbWFwIHRoYXQgbWlycm9ycyB0aGUgbWFwIGF0IHRoZVxuICAgIGdpdmVuIG9mZnNldCwgaW4gdGhpcyBtYXBwaW5nIChhcyBwZXIgdGhlIHNlY29uZCBhcmd1bWVudCB0b1xuICAgIGBhcHBlbmRNYXBgKS5cbiAgICAqL1xuICAgIGdldE1pcnJvcihuKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5taXJyb3IubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yW2ldID09IG4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pcnJvcltpICsgKGkgJSAyID8gLTEgOiAxKV07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2V0TWlycm9yKG4sIG0pIHtcbiAgICAgICAgaWYgKCF0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHRoaXMubWlycm9yID0gW107XG4gICAgICAgIHRoaXMubWlycm9yLnB1c2gobiwgbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGVuZCB0aGUgaW52ZXJzZSBvZiB0aGUgZ2l2ZW4gbWFwcGluZyB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcHBpbmdJbnZlcnRlZChtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBtYXBwaW5nLm1hcHMubGVuZ3RoIC0gMSwgdG90YWxTaXplID0gdGhpcy5fbWFwcy5sZW5ndGggKyBtYXBwaW5nLl9tYXBzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLl9tYXBzW2ldLmludmVydCgpLCBtaXJyICE9IG51bGwgJiYgbWlyciA+IGkgPyB0b3RhbFNpemUgLSBtaXJyIC0gMSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICBsZXQgaW52ZXJzZSA9IG5ldyBNYXBwaW5nO1xuICAgICAgICBpbnZlcnNlLmFwcGVuZE1hcHBpbmdJbnZlcnRlZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGludmVyc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm1pcnJvcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspXG4gICAgICAgICAgICBwb3MgPSB0aGlzLl9tYXBzW2ldLm1hcChwb3MsIGFzc29jKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdGhyb3VnaCB0aGlzIG1hcHBpbmcsIHJldHVybmluZyBhIG1hcHBpbmdcbiAgICByZXN1bHQuXG4gICAgKi9cbiAgICBtYXBSZXN1bHQocG9zLCBhc3NvYyA9IDEpIHsgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCBmYWxzZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkZWxJbmZvID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcCA9IHRoaXMuX21hcHNbaV0sIHJlc3VsdCA9IG1hcC5tYXBSZXN1bHQocG9zLCBhc3NvYyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlY292ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb3JyID0gdGhpcy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvcnIgIT0gbnVsbCAmJiBjb3JyID4gaSAmJiBjb3JyIDwgdGhpcy50bykge1xuICAgICAgICAgICAgICAgICAgICBpID0gY29ycjtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5fbWFwc1tjb3JyXS5yZWNvdmVyKHJlc3VsdC5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsSW5mbyB8PSByZXN1bHQuZGVsSW5mbztcbiAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyA6IG5ldyBNYXBSZXN1bHQocG9zLCBkZWxJbmZvLCBudWxsKTtcbiAgICB9XG59XG5cbmNvbnN0IHN0ZXBzQnlJRCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcbkEgc3RlcCBvYmplY3QgcmVwcmVzZW50cyBhbiBhdG9taWMgY2hhbmdlLiBJdCBnZW5lcmFsbHkgYXBwbGllc1xub25seSB0byB0aGUgZG9jdW1lbnQgaXQgd2FzIGNyZWF0ZWQgZm9yLCBzaW5jZSB0aGUgcG9zaXRpb25zXG5zdG9yZWQgaW4gaXQgd2lsbCBvbmx5IG1ha2Ugc2Vuc2UgZm9yIHRoYXQgZG9jdW1lbnQuXG5cbk5ldyBzdGVwcyBhcmUgZGVmaW5lZCBieSBjcmVhdGluZyBjbGFzc2VzIHRoYXQgZXh0ZW5kIGBTdGVwYCxcbm92ZXJyaWRpbmcgdGhlIGBhcHBseWAsIGBpbnZlcnRgLCBgbWFwYCwgYGdldE1hcGAgYW5kIGBmcm9tSlNPTmBcbm1ldGhvZHMsIGFuZCByZWdpc3RlcmluZyB5b3VyIGNsYXNzIHdpdGggYSB1bmlxdWVcbkpTT04tc2VyaWFsaXphdGlvbiBpZGVudGlmaWVyIHVzaW5nXG5bYFN0ZXAuanNvbklEYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwXmpzb25JRCkuXG4qL1xuY2xhc3MgU3RlcCB7XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzdGVwIG1hcCB0aGF0IHJlcHJlc2VudHMgdGhlIGNoYW5nZXMgbWFkZSBieSB0aGlzIHN0ZXAsXG4gICAgYW5kIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGUgb2xkXG4gICAgYW5kIHRoZSBuZXcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXRNYXAoKSB7IHJldHVybiBTdGVwTWFwLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1lcmdlIHRoaXMgc3RlcCB3aXRoIGFub3RoZXIgb25lLCB0byBiZSBhcHBsaWVkIGRpcmVjdGx5XG4gICAgYWZ0ZXIgaXQuIFJldHVybnMgdGhlIG1lcmdlZCBzdGVwIHdoZW4gcG9zc2libGUsIG51bGwgaWYgdGhlXG4gICAgc3RlcHMgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICovXG4gICAgbWVyZ2Uob3RoZXIpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIHN0ZXAgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2lsbCBjYWxsXG4gICAgdGhyb3VnaCB0byB0aGUgc3RlcCBjbGFzcycgb3duIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24uc3RlcFR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc3RlcHNCeUlEW2pzb24uc3RlcFR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc3RlcCB0eXBlICR7anNvbi5zdGVwVHlwZX0gZGVmaW5lZGApO1xuICAgICAgICByZXR1cm4gdHlwZS5mcm9tSlNPTihzY2hlbWEsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIHNlcmlhbGl6ZSBzdGVwcyB0byBKU09OLCBlYWNoIHN0ZXAgbmVlZHMgYSBzdHJpbmdcbiAgICBJRCB0byBhdHRhY2ggdG8gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFVzZSB0aGlzIG1ldGhvZCB0b1xuICAgIHJlZ2lzdGVyIGFuIElEIGZvciB5b3VyIHN0ZXAgY2xhc3Nlcy4gVHJ5IHRvIHBpY2sgc29tZXRoaW5nXG4gICAgdGhhdCdzIHVubGlrZWx5IHRvIGNsYXNoIHdpdGggc3RlcHMgZnJvbSBvdGhlciBtb2R1bGVzLlxuICAgICovXG4gICAgc3RhdGljIGpzb25JRChpZCwgc3RlcENsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBzdGVwc0J5SUQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkR1cGxpY2F0ZSB1c2Ugb2Ygc3RlcCBKU09OIElEIFwiICsgaWQpO1xuICAgICAgICBzdGVwc0J5SURbaWRdID0gc3RlcENsYXNzO1xuICAgICAgICBzdGVwQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICAgICAgICByZXR1cm4gc3RlcENsYXNzO1xuICAgIH1cbn1cbi8qKlxuVGhlIHJlc3VsdCBvZiBbYXBwbHlpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcC5hcHBseSkgYSBzdGVwLiBDb250YWlucyBlaXRoZXIgYVxubmV3IGRvY3VtZW50IG9yIGEgZmFpbHVyZSB2YWx1ZS5cbiovXG5jbGFzcyBTdGVwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2Zvcm1lZCBkb2N1bWVudCwgaWYgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGZhaWx1cmUgbWVzc2FnZSwgaWYgdW5zdWNjZXNzZnVsLlxuICAgICovXG4gICAgZmFpbGVkKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLmZhaWxlZCA9IGZhaWxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc3VjY2Vzc2Z1bCBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIHN0YXRpYyBvayhkb2MpIHsgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KGRvYywgbnVsbCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmYWlsZWQgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmFpbChtZXNzYWdlKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChudWxsLCBtZXNzYWdlKTsgfVxuICAgIC8qKlxuICAgIENhbGwgW2BOb2RlLnJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXBsYWNlKSB3aXRoIHRoZSBnaXZlblxuICAgIGFyZ3VtZW50cy4gQ3JlYXRlIGEgc3VjY2Vzc2Z1bCByZXN1bHQgaWYgaXQgc3VjY2VlZHMsIGFuZCBhXG4gICAgZmFpbGVkIG9uZSBpZiBpdCB0aHJvd3MgYSBgUmVwbGFjZUVycm9yYC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmVwbGFjZShkb2MsIGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQub2soZG9jLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmVwbGFjZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1hcEZyYWdtZW50KGZyYWdtZW50LCBmLCBwYXJlbnQpIHtcbiAgICBsZXQgbWFwcGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZnJhZ21lbnQuY2hpbGQoaSk7XG4gICAgICAgIGlmIChjaGlsZC5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmNvcHkobWFwRnJhZ21lbnQoY2hpbGQuY29udGVudCwgZiwgY2hpbGQpKTtcbiAgICAgICAgaWYgKGNoaWxkLmlzSW5saW5lKVxuICAgICAgICAgICAgY2hpbGQgPSBmKGNoaWxkLCBwYXJlbnQsIGkpO1xuICAgICAgICBtYXBwZWQucHVzaChjaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkobWFwcGVkKTtcbn1cbi8qKlxuQWRkIGEgbWFyayB0byBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIEFkZE1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBtYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSwgJGZyb20gPSBkb2MucmVzb2x2ZSh0aGlzLmZyb20pO1xuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ubm9kZSgkZnJvbS5zaGFyZWREZXB0aCh0aGlzLnRvKSk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCAobm9kZSwgcGFyZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuaXNBdG9tIHx8ICFwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZSh0aGlzLm1hcmsudHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5tYXJrKHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIHBhcmVudCksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBBZGRNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGRNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhZGRNYXJrXCIsIEFkZE1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGFsbCBpbmxpbmUgY29udGVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgUmVtb3ZlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgdW5tYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgb2xkU2xpY2UgPSBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIG5vZGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIH0sIGRvYyksIG9sZFNsaWNlLm9wZW5TdGFydCwgb2xkU2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBzbGljZSk7XG4gICAgfVxuICAgIGludmVydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGRNYXJrU3RlcCh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQgJiYgdG8uZGVsZXRlZCB8fCBmcm9tLnBvcyA+PSB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChmcm9tLnBvcywgdG8ucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBSZW1vdmVNYXJrU3RlcCAmJlxuICAgICAgICAgICAgb3RoZXIubWFyay5lcSh0aGlzLm1hcmspICYmXG4gICAgICAgICAgICB0aGlzLmZyb20gPD0gb3RoZXIudG8gJiYgdGhpcy50byA+PSBvdGhlci5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChNYXRoLm1pbih0aGlzLmZyb20sIG90aGVyLmZyb20pLCBNYXRoLm1heCh0aGlzLnRvLCBvdGhlci50byksIHRoaXMubWFyayk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU1hcmtcIiwgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpLFxuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVNYXJrU3RlcChqc29uLmZyb20sIGpzb24udG8sIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVNYXJrXCIsIFJlbW92ZU1hcmtTdGVwKTtcbi8qKlxuQWRkIGEgbWFyayB0byBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgQWRkTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBtYXJrIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byBhZGQuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGxldCBuZXdTZXQgPSB0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcyk7XG4gICAgICAgICAgICBpZiAobmV3U2V0Lmxlbmd0aCA9PSBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5tYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLm1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCBub2RlLm1hcmtzW2ldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IEFkZE5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImFkZE5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBZGROb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTm9kZU1hcmtcIiwgQWRkTm9kZU1hcmtTdGVwKTtcbi8qKlxuUmVtb3ZlIGEgbWFyayBmcm9tIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBSZW1vdmVOb2RlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrLXJlbW92aW5nIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byByZW1vdmUuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgbWFyayBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShub2RlLmF0dHJzLCBudWxsLCB0aGlzLm1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIXRoaXMubWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwicmVtb3ZlTm9kZU1hcmtcIiwgcG9zOiB0aGlzLnBvcywgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlbW92ZU5vZGVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAoanNvbi5wb3MsIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZW1vdmVOb2RlTWFya1wiLCBSZW1vdmVOb2RlTWFya1N0ZXApO1xuXG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgbmV3IGNvbnRlbnQuXG4qL1xuY2xhc3MgUmVwbGFjZVN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBUaGUgZ2l2ZW4gYHNsaWNlYCBzaG91bGQgZml0IHRoZSAnZ2FwJyBiZXR3ZWVuIGBmcm9tYCBhbmRcbiAgICBgdG9gXHUyMDE0dGhlIGRlcHRocyBtdXN0IGxpbmUgdXAsIGFuZCB0aGUgc3Vycm91bmRpbmcgbm9kZXMgbXVzdCBiZVxuICAgIGFibGUgdG8gYmUgam9pbmVkIHdpdGggdGhlIG9wZW4gc2lkZXMgb2YgdGhlIHNsaWNlLiBXaGVuXG4gICAgYHN0cnVjdHVyZWAgaXMgdHJ1ZSwgdGhlIHN0ZXAgd2lsbCBmYWlsIGlmIHRoZSBjb250ZW50IGJldHdlZW5cbiAgICBmcm9tIGFuZCB0byBpcyBub3QganVzdCBhIHNlcXVlbmNlIG9mIGNsb3NpbmcgYW5kIHRoZW4gb3BlbmluZ1xuICAgIHRva2VucyAodGhpcyBpcyB0byBndWFyZCBhZ2FpbnN0IHJlYmFzZWQgcmVwbGFjZSBzdGVwc1xuICAgIG92ZXJ3cml0aW5nIHNvbWV0aGluZyB0aGV5IHdlcmVuJ3Qgc3VwcG9zZWQgdG8pLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMudG8pKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSByZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5zbGljZSk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMudG8gLSB0aGlzLmZyb20sIHRoaXMuc2xpY2Uuc2l6ZV0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbS5wb3MsIE1hdGgubWF4KGZyb20ucG9zLCB0by5wb3MpLCB0aGlzLnNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXApIHx8IG90aGVyLnN0cnVjdHVyZSB8fCB0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplID09IG90aGVyLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlbkVuZCAmJiAhb3RoZXIuc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKHRoaXMuc2xpY2UuY29udGVudC5hcHBlbmQob3RoZXIuc2xpY2UuY29udGVudCksIHRoaXMuc2xpY2Uub3BlblN0YXJ0LCBvdGhlci5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAodGhpcy5mcm9tLCB0aGlzLnRvICsgKG90aGVyLnRvIC0gb3RoZXIuZnJvbSksIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIudG8gPT0gdGhpcy5mcm9tICYmICF0aGlzLnNsaWNlLm9wZW5TdGFydCAmJiAhb3RoZXIuc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShvdGhlci5zbGljZS5jb250ZW50LmFwcGVuZCh0aGlzLnNsaWNlLmNvbnRlbnQpLCBvdGhlci5zbGljZS5vcGVuU3RhcnQsIHRoaXMuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKG90aGVyLmZyb20sIHRoaXMudG8sIHNsaWNlLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICAgICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSlcbiAgICAgICAgICAgIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChqc29uLmZyb20sIGpzb24udG8sIFNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVwbGFjZVwiLCBSZXBsYWNlU3RlcCk7XG4vKipcblJlcGxhY2UgYSBwYXJ0IG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgc2xpY2Ugb2YgY29udGVudCwgYnV0XG5wcmVzZXJ2ZSBhIHJhbmdlIG9mIHRoZSByZXBsYWNlZCBjb250ZW50IGJ5IG1vdmluZyBpdCBpbnRvIHRoZVxuc2xpY2UuXG4qL1xuY2xhc3MgUmVwbGFjZUFyb3VuZFN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSByZXBsYWNlLWFyb3VuZCBzdGVwIHdpdGggdGhlIGdpdmVuIHJhbmdlIGFuZCBnYXAuXG4gICAgYGluc2VydGAgc2hvdWxkIGJlIHRoZSBwb2ludCBpbiB0aGUgc2xpY2UgaW50byB3aGljaCB0aGUgY29udGVudFxuICAgIG9mIHRoZSBnYXAgc2hvdWxkIGJlIG1vdmVkLiBgc3RydWN0dXJlYCBoYXMgdGhlIHNhbWUgbWVhbmluZyBhc1xuICAgIGl0IGhhcyBpbiB0aGUgW2BSZXBsYWNlU3RlcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uUmVwbGFjZVN0ZXApIGNsYXNzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiBwcmVzZXJ2ZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBnYXBGcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcFRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBpbiB0aGUgc2xpY2Ugd2hlcmUgdGhlIHByZXNlcnZlZCByYW5nZSBzaG91bGQgYmVcbiAgICBpbnNlcnRlZC5cbiAgICAqL1xuICAgIGluc2VydCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdHJ1Y3R1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZ2FwRnJvbSA9IGdhcEZyb207XG4gICAgICAgIHRoaXMuZ2FwVG8gPSBnYXBUbztcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgICAgICB0aGlzLmluc2VydCA9IGluc2VydDtcbiAgICAgICAgdGhpcy5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUgJiYgKGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20pIHx8XG4gICAgICAgICAgICBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZ2FwVG8sIHRoaXMudG8pKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgZ2FwLXJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIik7XG4gICAgICAgIGxldCBnYXAgPSBkb2Muc2xpY2UodGhpcy5nYXBGcm9tLCB0aGlzLmdhcFRvKTtcbiAgICAgICAgaWYgKGdhcC5vcGVuU3RhcnQgfHwgZ2FwLm9wZW5FbmQpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiR2FwIGlzIG5vdCBhIGZsYXQgcmFuZ2VcIik7XG4gICAgICAgIGxldCBpbnNlcnRlZCA9IHRoaXMuc2xpY2UuaW5zZXJ0QXQodGhpcy5pbnNlcnQsIGdhcC5jb250ZW50KTtcbiAgICAgICAgaWYgKCFpbnNlcnRlZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJDb250ZW50IGRvZXMgbm90IGZpdCBpbiBnYXBcIik7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCBpbnNlcnRlZCk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwTWFwKFt0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5pbnNlcnQsXG4gICAgICAgICAgICB0aGlzLmdhcFRvLCB0aGlzLnRvIC0gdGhpcy5nYXBUbywgdGhpcy5zbGljZS5zaXplIC0gdGhpcy5pbnNlcnRdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgZ2FwID0gdGhpcy5nYXBUbyAtIHRoaXMuZ2FwRnJvbTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSArIGdhcCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0ICsgZ2FwLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKS5yZW1vdmVCZXR3ZWVuKHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5nYXBUbyAtIHRoaXMuZnJvbSksIHRoaXMuZ2FwRnJvbSAtIHRoaXMuZnJvbSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IHRoaXMuZnJvbSA9PSB0aGlzLmdhcEZyb20gPyBmcm9tLnBvcyA6IG1hcHBpbmcubWFwKHRoaXMuZ2FwRnJvbSwgLTEpO1xuICAgICAgICBsZXQgZ2FwVG8gPSB0aGlzLnRvID09IHRoaXMuZ2FwVG8gPyB0by5wb3MgOiBtYXBwaW5nLm1hcCh0aGlzLmdhcFRvLCAxKTtcbiAgICAgICAgaWYgKChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcykgfHwgZ2FwRnJvbSA8IGZyb20ucG9zIHx8IGdhcFRvID4gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoZnJvbS5wb3MsIHRvLnBvcywgZ2FwRnJvbSwgZ2FwVG8sIHRoaXMuc2xpY2UsIHRoaXMuaW5zZXJ0LCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGpzb24gPSB7IHN0ZXBUeXBlOiBcInJlcGxhY2VBcm91bmRcIiwgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byxcbiAgICAgICAgICAgIGdhcEZyb206IHRoaXMuZ2FwRnJvbSwgZ2FwVG86IHRoaXMuZ2FwVG8sIGluc2VydDogdGhpcy5pbnNlcnQgfTtcbiAgICAgICAgaWYgKHRoaXMuc2xpY2Uuc2l6ZSlcbiAgICAgICAgICAgIGpzb24uc2xpY2UgPSB0aGlzLnNsaWNlLnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICBqc29uLnN0cnVjdHVyZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi50byAhPSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICB0eXBlb2YganNvbi5nYXBGcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uZ2FwVG8gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5pbnNlcnQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVwbGFjZUFyb3VuZFN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBqc29uLmdhcEZyb20sIGpzb24uZ2FwVG8sIFNsaWNlLmZyb21KU09OKHNjaGVtYSwganNvbi5zbGljZSksIGpzb24uaW5zZXJ0LCAhIWpzb24uc3RydWN0dXJlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlcGxhY2VBcm91bmRcIiwgUmVwbGFjZUFyb3VuZFN0ZXApO1xuZnVuY3Rpb24gY29udGVudEJldHdlZW4oZG9jLCBmcm9tLCB0bykge1xuICAgIGxldCAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLCBkaXN0ID0gdG8gLSBmcm9tLCBkZXB0aCA9ICRmcm9tLmRlcHRoO1xuICAgIHdoaWxlIChkaXN0ID4gMCAmJiBkZXB0aCA+IDAgJiYgJGZyb20uaW5kZXhBZnRlcihkZXB0aCkgPT0gJGZyb20ubm9kZShkZXB0aCkuY2hpbGRDb3VudCkge1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgICBkaXN0LS07XG4gICAgfVxuICAgIGlmIChkaXN0ID4gMCkge1xuICAgICAgICBsZXQgbmV4dCA9ICRmcm9tLm5vZGUoZGVwdGgpLm1heWJlQ2hpbGQoJGZyb20uaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAoZGlzdCA+IDApIHtcbiAgICAgICAgICAgIGlmICghbmV4dCB8fCBuZXh0LmlzTGVhZilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBkaXN0LS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICAgIGxldCByZW1vdmVkID0gW10sIGFkZGVkID0gW107XG4gICAgbGV0IHJlbW92aW5nLCBhZGRpbmc7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50KSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG1hcmtzID0gbm9kZS5tYXJrcztcbiAgICAgICAgaWYgKCFtYXJrLmlzSW5TZXQobWFya3MpICYmIHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG1hcmsudHlwZSkpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHBvcywgZnJvbSksIGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgIGxldCBuZXdTZXQgPSBtYXJrLmFkZFRvU2V0KG1hcmtzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcmtzW2ldLmlzSW5TZXQobmV3U2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZpbmcgJiYgcmVtb3ZpbmcudG8gPT0gc3RhcnQgJiYgcmVtb3ZpbmcubWFyay5lcShtYXJrc1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmluZy50byA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKHJlbW92aW5nID0gbmV3IFJlbW92ZU1hcmtTdGVwKHN0YXJ0LCBlbmQsIG1hcmtzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZGluZyAmJiBhZGRpbmcudG8gPT0gc3RhcnQpXG4gICAgICAgICAgICAgICAgYWRkaW5nLnRvID0gZW5kO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFkZGVkLnB1c2goYWRkaW5nID0gbmV3IEFkZE1hcmtTdGVwKHN0YXJ0LCBlbmQsIG1hcmspKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJlbW92ZWQuZm9yRWFjaChzID0+IHRyLnN0ZXAocykpO1xuICAgIGFkZGVkLmZvckVhY2gocyA9PiB0ci5zdGVwKHMpKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU1hcmsodHIsIGZyb20sIHRvLCBtYXJrKSB7XG4gICAgbGV0IG1hdGNoZWQgPSBbXSwgc3RlcCA9IDA7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAoIW5vZGUuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0ZXArKztcbiAgICAgICAgbGV0IHRvUmVtb3ZlID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcmsgaW5zdGFuY2VvZiBNYXJrVHlwZSkge1xuICAgICAgICAgICAgbGV0IHNldCA9IG5vZGUubWFya3MsIGZvdW5kO1xuICAgICAgICAgICAgd2hpbGUgKGZvdW5kID0gbWFyay5pc0luU2V0KHNldCkpIHtcbiAgICAgICAgICAgICAgICAodG9SZW1vdmUgfHwgKHRvUmVtb3ZlID0gW10pKS5wdXNoKGZvdW5kKTtcbiAgICAgICAgICAgICAgICBzZXQgPSBmb3VuZC5yZW1vdmVGcm9tU2V0KHNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFyaykge1xuICAgICAgICAgICAgaWYgKG1hcmsuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICB0b1JlbW92ZSA9IFttYXJrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvUmVtb3ZlID0gbm9kZS5tYXJrcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9SZW1vdmUgJiYgdG9SZW1vdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdHlsZSA9IHRvUmVtb3ZlW2ldLCBmb3VuZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoZWQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBtYXRjaGVkW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobS5zdGVwID09IHN0ZXAgLSAxICYmIHN0eWxlLmVxKG1hdGNoZWRbal0uc3R5bGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQudG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnN0ZXAgPSBzdGVwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKHsgc3R5bGUsIGZyb206IE1hdGgubWF4KHBvcywgZnJvbSksIHRvOiBlbmQsIHN0ZXAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgbWF0Y2hlZC5mb3JFYWNoKG0gPT4gdHIuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAobS5mcm9tLCBtLnRvLCBtLnN0eWxlKSkpO1xufVxuZnVuY3Rpb24gY2xlYXJJbmNvbXBhdGlibGUodHIsIHBvcywgcGFyZW50VHlwZSwgbWF0Y2ggPSBwYXJlbnRUeXBlLmNvbnRlbnRNYXRjaCwgY2xlYXJOZXdsaW5lcyA9IHRydWUpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBsZXQgcmVwbFN0ZXBzID0gW10sIGN1ciA9IHBvcyArIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpLCBlbmQgPSBjdXIgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgbGV0IGFsbG93ZWQgPSBtYXRjaC5tYXRjaFR5cGUoY2hpbGQudHlwZSk7XG4gICAgICAgIGlmICghYWxsb3dlZCkge1xuICAgICAgICAgICAgcmVwbFN0ZXBzLnB1c2gobmV3IFJlcGxhY2VTdGVwKGN1ciwgZW5kLCBTbGljZS5lbXB0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWF0Y2ggPSBhbGxvd2VkO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZC5tYXJrcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFR5cGUuYWxsb3dzTWFya1R5cGUoY2hpbGQubWFya3Nbal0udHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKGN1ciwgZW5kLCBjaGlsZC5tYXJrc1tqXSkpO1xuICAgICAgICAgICAgaWYgKGNsZWFyTmV3bGluZXMgJiYgY2hpbGQuaXNUZXh0ICYmIHBhcmVudFR5cGUud2hpdGVzcGFjZSAhPSBcInByZVwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IG0sIG5ld2xpbmUgPSAvXFxyP1xcbnxcXHIvZywgc2xpY2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG0gPSBuZXdsaW5lLmV4ZWMoY2hpbGQudGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzbGljZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20ocGFyZW50VHlwZS5zY2hlbWEudGV4dChcIiBcIiwgcGFyZW50VHlwZS5hbGxvd2VkTWFya3MoY2hpbGQubWFya3MpKSksIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICByZXBsU3RlcHMucHVzaChuZXcgUmVwbGFjZVN0ZXAoY3VyICsgbS5pbmRleCwgY3VyICsgbS5pbmRleCArIG1bMF0ubGVuZ3RoLCBzbGljZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBlbmQ7XG4gICAgfVxuICAgIGlmICghbWF0Y2gudmFsaWRFbmQpIHtcbiAgICAgICAgbGV0IGZpbGwgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgdHIucmVwbGFjZShjdXIsIGN1ciwgbmV3IFNsaWNlKGZpbGwsIDAsIDApKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHJlcGxTdGVwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgdHIuc3RlcChyZXBsU3RlcHNbaV0pO1xufVxuXG5mdW5jdGlvbiBjYW5DdXQobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoc3RhcnQgPT0gMCB8fCBub2RlLmNhblJlcGxhY2Uoc3RhcnQsIG5vZGUuY2hpbGRDb3VudCkpICYmXG4gICAgICAgIChlbmQgPT0gbm9kZS5jaGlsZENvdW50IHx8IG5vZGUuY2FuUmVwbGFjZSgwLCBlbmQpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB0YXJnZXQgZGVwdGggdG8gd2hpY2ggdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlXG5jYW4gYmUgbGlmdGVkLiBXaWxsIG5vdCBnbyBhY3Jvc3Ncbltpc29sYXRpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5pc29sYXRpbmcpIHBhcmVudCBub2Rlcy5cbiovXG5mdW5jdGlvbiBsaWZ0VGFyZ2V0KHJhbmdlKSB7XG4gICAgbGV0IHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgICBsZXQgY29udGVudCA9IHBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgocmFuZ2Uuc3RhcnRJbmRleCwgcmFuZ2UuZW5kSW5kZXgpO1xuICAgIGZvciAobGV0IGRlcHRoID0gcmFuZ2UuZGVwdGg7OyAtLWRlcHRoKSB7XG4gICAgICAgIGxldCBub2RlID0gcmFuZ2UuJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBpbmRleCA9IHJhbmdlLiRmcm9tLmluZGV4KGRlcHRoKSwgZW5kSW5kZXggPSByYW5nZS4kdG8uaW5kZXhBZnRlcihkZXB0aCk7XG4gICAgICAgIGlmIChkZXB0aCA8IHJhbmdlLmRlcHRoICYmIG5vZGUuY2FuUmVwbGFjZShpbmRleCwgZW5kSW5kZXgsIGNvbnRlbnQpKVxuICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCB8fCBub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgIWNhbkN1dChub2RlLCBpbmRleCwgZW5kSW5kZXgpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbGlmdCh0ciwgcmFuZ2UsIHRhcmdldCkge1xuICAgIGxldCB7ICRmcm9tLCAkdG8sIGRlcHRoIH0gPSByYW5nZTtcbiAgICBsZXQgZ2FwU3RhcnQgPSAkZnJvbS5iZWZvcmUoZGVwdGggKyAxKSwgZ2FwRW5kID0gJHRvLmFmdGVyKGRlcHRoICsgMSk7XG4gICAgbGV0IHN0YXJ0ID0gZ2FwU3RhcnQsIGVuZCA9IGdhcEVuZDtcbiAgICBsZXQgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIG9wZW5TdGFydCA9IDA7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKVxuICAgICAgICBpZiAoc3BsaXR0aW5nIHx8ICRmcm9tLmluZGV4KGQpID4gMCkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICB9XG4gICAgbGV0IGFmdGVyID0gRnJhZ21lbnQuZW1wdHksIG9wZW5FbmQgPSAwO1xuICAgIGZvciAobGV0IGQgPSBkZXB0aCwgc3BsaXR0aW5nID0gZmFsc2U7IGQgPiB0YXJnZXQ7IGQtLSlcbiAgICAgICAgaWYgKHNwbGl0dGluZyB8fCAkdG8uYWZ0ZXIoZCArIDEpIDwgJHRvLmVuZChkKSkge1xuICAgICAgICAgICAgc3BsaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSgkdG8ubm9kZShkKS5jb3B5KGFmdGVyKSk7XG4gICAgICAgICAgICBvcGVuRW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIGdhcFN0YXJ0LCBnYXBFbmQsIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgb3BlblN0YXJ0LCBvcGVuRW5kKSwgYmVmb3JlLnNpemUgLSBvcGVuU3RhcnQsIHRydWUpKTtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSB2YWxpZCB3YXkgdG8gd3JhcCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UgaW4gYVxubm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZS4gTWF5IGludHJvZHVjZSBleHRyYSBub2RlcyBhcm91bmQgYW5kIGluc2lkZVxudGhlIHdyYXBwZXIgbm9kZSwgaWYgbmVjZXNzYXJ5LiBSZXR1cm5zIG51bGwgaWYgbm8gdmFsaWQgd3JhcHBpbmdcbmNvdWxkIGJlIGZvdW5kLiBXaGVuIGBpbm5lclJhbmdlYCBpcyBnaXZlbiwgdGhhdCByYW5nZSdzIGNvbnRlbnQgaXNcbnVzZWQgYXMgdGhlIGNvbnRlbnQgdG8gZml0IGludG8gdGhlIHdyYXBwaW5nLCBpbnN0ZWFkIG9mIHRoZVxuY29udGVudCBvZiBgcmFuZ2VgLlxuKi9cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzID0gbnVsbCwgaW5uZXJSYW5nZSA9IHJhbmdlKSB7XG4gICAgbGV0IGFyb3VuZCA9IGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBsZXQgaW5uZXIgPSBhcm91bmQgJiYgZmluZFdyYXBwaW5nSW5zaWRlKGlubmVyUmFuZ2UsIG5vZGVUeXBlKTtcbiAgICBpZiAoIWlubmVyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gYXJvdW5kLm1hcCh3aXRoQXR0cnMpXG4gICAgICAgIC5jb25jYXQoeyB0eXBlOiBub2RlVHlwZSwgYXR0cnMgfSkuY29uY2F0KGlubmVyLm1hcCh3aXRoQXR0cnMpKTtcbn1cbmZ1bmN0aW9uIHdpdGhBdHRycyh0eXBlKSB7IHJldHVybiB7IHR5cGUsIGF0dHJzOiBudWxsIH07IH1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ091dHNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICBsZXQgeyBwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBsZXQgYXJvdW5kID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KHN0YXJ0SW5kZXgpLmZpbmRXcmFwcGluZyh0eXBlKTtcbiAgICBpZiAoIWFyb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG91dGVyID0gYXJvdW5kLmxlbmd0aCA/IGFyb3VuZFswXSA6IHR5cGU7XG4gICAgcmV0dXJuIHBhcmVudC5jYW5SZXBsYWNlV2l0aChzdGFydEluZGV4LCBlbmRJbmRleCwgb3V0ZXIpID8gYXJvdW5kIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRXcmFwcGluZ0luc2lkZShyYW5nZSwgdHlwZSkge1xuICAgIGxldCB7IHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIGxldCBpbm5lciA9IHBhcmVudC5jaGlsZChzdGFydEluZGV4KTtcbiAgICBsZXQgaW5zaWRlID0gdHlwZS5jb250ZW50TWF0Y2guZmluZFdyYXBwaW5nKGlubmVyLnR5cGUpO1xuICAgIGlmICghaW5zaWRlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbGFzdFR5cGUgPSBpbnNpZGUubGVuZ3RoID8gaW5zaWRlW2luc2lkZS5sZW5ndGggLSAxXSA6IHR5cGU7XG4gICAgbGV0IGlubmVyTWF0Y2ggPSBsYXN0VHlwZS5jb250ZW50TWF0Y2g7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGlubmVyTWF0Y2ggJiYgaSA8IGVuZEluZGV4OyBpKyspXG4gICAgICAgIGlubmVyTWF0Y2ggPSBpbm5lck1hdGNoLm1hdGNoVHlwZShwYXJlbnQuY2hpbGQoaSkudHlwZSk7XG4gICAgaWYgKCFpbm5lck1hdGNoIHx8ICFpbm5lck1hdGNoLnZhbGlkRW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaW5zaWRlO1xufVxuZnVuY3Rpb24gd3JhcCh0ciwgcmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gd3JhcHBlcnNbaV0udHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoLnZhbGlkRW5kKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV3JhcHBlciB0eXBlIGdpdmVuIHRvIFRyYW5zZm9ybS53cmFwIGRvZXMgbm90IGZvcm0gdmFsaWQgY29udGVudCBvZiBpdHMgcGFyZW50IHdyYXBwZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20od3JhcHBlcnNbaV0udHlwZS5jcmVhdGUod3JhcHBlcnNbaV0uYXR0cnMsIGNvbnRlbnQpKTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsIGVuZCA9IHJhbmdlLmVuZDtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBzdGFydCwgZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xufVxuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKHRyLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpIHtcbiAgICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHlwZSBnaXZlbiB0byBzZXRCbG9ja1R5cGUgc2hvdWxkIGJlIGEgdGV4dGJsb2NrXCIpO1xuICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgbGV0IGF0dHJzSGVyZSA9IHR5cGVvZiBhdHRycyA9PSBcImZ1bmN0aW9uXCIgPyBhdHRycyhub2RlKSA6IGF0dHJzO1xuICAgICAgICBpZiAobm9kZS5pc1RleHRibG9jayAmJiAhbm9kZS5oYXNNYXJrdXAodHlwZSwgYXR0cnNIZXJlKSAmJlxuICAgICAgICAgICAgY2FuQ2hhbmdlVHlwZSh0ci5kb2MsIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyksIHR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgY29udmVydE5ld2xpbmVzID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlLnNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIGxldCBwcmUgPSB0eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiwgc3VwcG9ydExpbmVicmVhayA9ICEhdHlwZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKHR5cGUuc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlICYmICFzdXBwb3J0TGluZWJyZWFrKVxuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0TmV3bGluZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcHJlICYmIHN1cHBvcnRMaW5lYnJlYWspXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnROZXdsaW5lcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbnN1cmUgYWxsIG1hcmt1cCB0aGF0IGlzbid0IGFsbG93ZWQgaW4gdGhlIG5ldyBub2RlIHR5cGUgaXMgY2xlYXJlZFxuICAgICAgICAgICAgaWYgKGNvbnZlcnROZXdsaW5lcyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmVwbGFjZUxpbmVicmVha3ModHIsIG5vZGUsIHBvcywgbWFwRnJvbSk7XG4gICAgICAgICAgICBjbGVhckluY29tcGF0aWJsZSh0ciwgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zLCAxKSwgdHlwZSwgdW5kZWZpbmVkLCBjb252ZXJ0TmV3bGluZXMgPT09IG51bGwpO1xuICAgICAgICAgICAgbGV0IG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgbGV0IHN0YXJ0TSA9IG1hcHBpbmcubWFwKHBvcywgMSksIGVuZE0gPSBtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplLCAxKTtcbiAgICAgICAgICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0TSwgZW5kTSwgc3RhcnRNICsgMSwgZW5kTSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzSGVyZSwgbnVsbCwgbm9kZS5tYXJrcykpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICAgICAgaWYgKGNvbnZlcnROZXdsaW5lcyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXBsYWNlTmV3bGluZXModHIsIG5vZGUsIHBvcywgbWFwRnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VOZXdsaW5lcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKSB7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZCwgb2Zmc2V0KSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgICAgIGxldCBtLCBuZXdsaW5lID0gL1xccj9cXG58XFxyL2c7XG4gICAgICAgICAgICB3aGlsZSAobSA9IG5ld2xpbmUuZXhlYyhjaGlsZC50ZXh0KSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyArIDEgKyBvZmZzZXQgKyBtLmluZGV4KTtcbiAgICAgICAgICAgICAgICB0ci5yZXBsYWNlV2l0aChzdGFydCwgc3RhcnQgKyAxLCBub2RlLnR5cGUuc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50LmNyZWF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVwbGFjZUxpbmVicmVha3ModHIsIG5vZGUsIHBvcywgbWFwRnJvbSkge1xuICAgIG5vZGUuZm9yRWFjaCgoY2hpbGQsIG9mZnNldCkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PSBjaGlsZC50eXBlLnNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgMSArIG9mZnNldCk7XG4gICAgICAgICAgICB0ci5yZXBsYWNlV2l0aChzdGFydCwgc3RhcnQgKyAxLCBub2RlLnR5cGUuc2NoZW1hLnRleHQoXCJcXG5cIikpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBjYW5DaGFuZ2VUeXBlKGRvYywgcG9zLCB0eXBlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICByZXR1cm4gJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgdHlwZSk7XG59XG4vKipcbkNoYW5nZSB0aGUgdHlwZSwgYXR0cmlidXRlcywgYW5kL29yIG1hcmtzIG9mIHRoZSBub2RlIGF0IGBwb3NgLlxuV2hlbiBgdHlwZWAgaXNuJ3QgZ2l2ZW4sIHRoZSBleGlzdGluZyBub2RlIHR5cGUgaXMgcHJlc2VydmVkLFxuKi9cbmZ1bmN0aW9uIHNldE5vZGVNYXJrdXAodHIsIHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gICAgbGV0IG5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvcyk7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cIik7XG4gICAgaWYgKCF0eXBlKVxuICAgICAgICB0eXBlID0gbm9kZS50eXBlO1xuICAgIGxldCBuZXdOb2RlID0gdHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG1hcmtzIHx8IG5vZGUubWFya3MpO1xuICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2VXaXRoKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgbmV3Tm9kZSk7XG4gICAgaWYgKCF0eXBlLnZhbGlkQ29udGVudChub2RlLmNvbnRlbnQpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSB0eXBlIFwiICsgdHlwZS5uYW1lKTtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHBvcyArIDEsIHBvcyArIG5vZGUubm9kZVNpemUgLSAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShuZXdOb2RlKSwgMCwgMCksIDEsIHRydWUpKTtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciBzcGxpdHRpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIGFsbG93ZWQuXG4qL1xuZnVuY3Rpb24gY2FuU3BsaXQoZG9jLCBwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgYmFzZSA9ICRwb3MuZGVwdGggLSBkZXB0aDtcbiAgICBsZXQgaW5uZXJUeXBlID0gKHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclt0eXBlc0FmdGVyLmxlbmd0aCAtIDFdKSB8fCAkcG9zLnBhcmVudDtcbiAgICBpZiAoYmFzZSA8IDAgfHwgJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZyB8fFxuICAgICAgICAhJHBvcy5wYXJlbnQuY2FuUmVwbGFjZSgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpIHx8XG4gICAgICAgICFpbm5lclR5cGUudHlwZS52YWxpZENvbnRlbnQoJHBvcy5wYXJlbnQuY29udGVudC5jdXRCeUluZGV4KCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxLCBpID0gZGVwdGggLSAyOyBkID4gYmFzZTsgZC0tLCBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSAkcG9zLm5vZGUoZCksIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHJlc3QgPSBub2RlLmNvbnRlbnQuY3V0QnlJbmRleChpbmRleCwgbm9kZS5jaGlsZENvdW50KTtcbiAgICAgICAgbGV0IG92ZXJyaWRlQ2hpbGQgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaSArIDFdO1xuICAgICAgICBpZiAob3ZlcnJpZGVDaGlsZClcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnJlcGxhY2VDaGlsZCgwLCBvdmVycmlkZUNoaWxkLnR5cGUuY3JlYXRlKG92ZXJyaWRlQ2hpbGQuYXR0cnMpKTtcbiAgICAgICAgbGV0IGFmdGVyID0gKHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpXSkgfHwgbm9kZTtcbiAgICAgICAgaWYgKCFub2RlLmNhblJlcGxhY2UoaW5kZXggKyAxLCBub2RlLmNoaWxkQ291bnQpIHx8ICFhZnRlci50eXBlLnZhbGlkQ29udGVudChyZXN0KSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGJhc2UpO1xuICAgIGxldCBiYXNlVHlwZSA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlclswXTtcbiAgICByZXR1cm4gJHBvcy5ub2RlKGJhc2UpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgYmFzZVR5cGUgPyBiYXNlVHlwZS50eXBlIDogJHBvcy5ub2RlKGJhc2UgKyAxKS50eXBlKTtcbn1cbmZ1bmN0aW9uIHNwbGl0KHRyLCBwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgIGxldCAkcG9zID0gdHIuZG9jLnJlc29sdmUocG9zKSwgYmVmb3JlID0gRnJhZ21lbnQuZW1wdHksIGFmdGVyID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGgsIGUgPSAkcG9zLmRlcHRoIC0gZGVwdGgsIGkgPSBkZXB0aCAtIDE7IGQgPiBlOyBkLS0sIGktLSkge1xuICAgICAgICBiZWZvcmUgPSBGcmFnbWVudC5mcm9tKCRwb3Mubm9kZShkKS5jb3B5KGJlZm9yZSkpO1xuICAgICAgICBsZXQgdHlwZUFmdGVyID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldO1xuICAgICAgICBhZnRlciA9IEZyYWdtZW50LmZyb20odHlwZUFmdGVyID8gdHlwZUFmdGVyLnR5cGUuY3JlYXRlKHR5cGVBZnRlci5hdHRycywgYWZ0ZXIpIDogJHBvcy5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAocG9zLCBwb3MsIG5ldyBTbGljZShiZWZvcmUuYXBwZW5kKGFmdGVyKSwgZGVwdGgsIGRlcHRoKSwgdHJ1ZSkpO1xufVxuLyoqXG5UZXN0IHdoZXRoZXIgdGhlIGJsb2NrcyBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gcG9zaXRpb24gY2FuIGJlXG5qb2luZWQuXG4qL1xuZnVuY3Rpb24gY2FuSm9pbihkb2MsIHBvcykge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgcmV0dXJuIGpvaW5hYmxlKCRwb3Mubm9kZUJlZm9yZSwgJHBvcy5ub2RlQWZ0ZXIpICYmXG4gICAgICAgICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSk7XG59XG5mdW5jdGlvbiBjYW5BcHBlbmRXaXRoU3Vic3RpdHV0ZWRMaW5lYnJlYWtzKGEsIGIpIHtcbiAgICBpZiAoIWIuY29udGVudC5zaXplKVxuICAgICAgICBhLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQoYi50eXBlKTtcbiAgICBsZXQgbWF0Y2ggPSBhLmNvbnRlbnRNYXRjaEF0KGEuY2hpbGRDb3VudCk7XG4gICAgbGV0IHsgbGluZWJyZWFrUmVwbGFjZW1lbnQgfSA9IGEudHlwZS5zY2hlbWE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiLmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBiLmNoaWxkKGkpO1xuICAgICAgICBsZXQgdHlwZSA9IGNoaWxkLnR5cGUgPT0gbGluZWJyZWFrUmVwbGFjZW1lbnQgPyBhLnR5cGUuc2NoZW1hLm5vZGVzLnRleHQgOiBjaGlsZC50eXBlO1xuICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFhLnR5cGUuYWxsb3dzTWFya3MoY2hpbGQubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2gudmFsaWRFbmQ7XG59XG5mdW5jdGlvbiBqb2luYWJsZShhLCBiKSB7XG4gICAgcmV0dXJuICEhKGEgJiYgYiAmJiAhYS5pc0xlYWYgJiYgY2FuQXBwZW5kV2l0aFN1YnN0aXR1dGVkTGluZWJyZWFrcyhhLCBiKSk7XG59XG4vKipcbkZpbmQgYW4gYW5jZXN0b3Igb2YgdGhlIGdpdmVuIHBvc2l0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCB0byB0aGVcbmJsb2NrIGJlZm9yZSAob3IgYWZ0ZXIgaWYgYGRpcmAgaXMgcG9zaXRpdmUpLiBSZXR1cm5zIHRoZSBqb2luYWJsZVxucG9pbnQsIGlmIGFueS5cbiovXG5mdW5jdGlvbiBqb2luUG9pbnQoZG9jLCBwb3MsIGRpciA9IC0xKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgIGxldCBiZWZvcmUsIGFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgIGlmIChkID09ICRwb3MuZGVwdGgpIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZTtcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyID4gMCkge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkKS5tYXliZUNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZm9yZSAmJiAhYmVmb3JlLmlzVGV4dGJsb2NrICYmIGpvaW5hYmxlKGJlZm9yZSwgYWZ0ZXIpICYmXG4gICAgICAgICAgICAkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGlmIChkID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcG9zID0gZGlyIDwgMCA/ICRwb3MuYmVmb3JlKGQpIDogJHBvcy5hZnRlcihkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBqb2luKHRyLCBwb3MsIGRlcHRoKSB7XG4gICAgbGV0IGNvbnZlcnROZXdsaW5lcyA9IG51bGw7XG4gICAgbGV0IHsgbGluZWJyZWFrUmVwbGFjZW1lbnQgfSA9IHRyLmRvYy50eXBlLnNjaGVtYTtcbiAgICBsZXQgJGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKHBvcyAtIGRlcHRoKSwgYmVmb3JlVHlwZSA9ICRiZWZvcmUubm9kZSgpLnR5cGU7XG4gICAgaWYgKGxpbmVicmVha1JlcGxhY2VtZW50ICYmIGJlZm9yZVR5cGUuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgcHJlID0gYmVmb3JlVHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCI7XG4gICAgICAgIGxldCBzdXBwb3J0TGluZWJyZWFrID0gISFiZWZvcmVUeXBlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUobGluZWJyZWFrUmVwbGFjZW1lbnQpO1xuICAgICAgICBpZiAocHJlICYmICFzdXBwb3J0TGluZWJyZWFrKVxuICAgICAgICAgICAgY29udmVydE5ld2xpbmVzID0gZmFsc2U7XG4gICAgICAgIGVsc2UgaWYgKCFwcmUgJiYgc3VwcG9ydExpbmVicmVhaylcbiAgICAgICAgICAgIGNvbnZlcnROZXdsaW5lcyA9IHRydWU7XG4gICAgfVxuICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIGlmIChjb252ZXJ0TmV3bGluZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxldCAkYWZ0ZXIgPSB0ci5kb2MucmVzb2x2ZShwb3MgKyBkZXB0aCk7XG4gICAgICAgIHJlcGxhY2VMaW5lYnJlYWtzKHRyLCAkYWZ0ZXIubm9kZSgpLCAkYWZ0ZXIuYmVmb3JlKCksIG1hcEZyb20pO1xuICAgIH1cbiAgICBpZiAoYmVmb3JlVHlwZS5pbmxpbmVDb250ZW50KVxuICAgICAgICBjbGVhckluY29tcGF0aWJsZSh0ciwgcG9zICsgZGVwdGggLSAxLCBiZWZvcmVUeXBlLCAkYmVmb3JlLm5vZGUoKS5jb250ZW50TWF0Y2hBdCgkYmVmb3JlLmluZGV4KCkpLCBjb252ZXJ0TmV3bGluZXMgPT0gbnVsbCk7XG4gICAgbGV0IG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLCBzdGFydCA9IG1hcHBpbmcubWFwKHBvcyAtIGRlcHRoKTtcbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChzdGFydCwgbWFwcGluZy5tYXAocG9zICsgZGVwdGgsIC0xKSwgU2xpY2UuZW1wdHksIHRydWUpKTtcbiAgICBpZiAoY29udmVydE5ld2xpbmVzID09PSB0cnVlKSB7XG4gICAgICAgIGxldCAkZnVsbCA9IHRyLmRvYy5yZXNvbHZlKHN0YXJ0KTtcbiAgICAgICAgcmVwbGFjZU5ld2xpbmVzKHRyLCAkZnVsbC5ub2RlKCksICRmdWxsLmJlZm9yZSgpLCB0ci5zdGVwcy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG4vKipcblRyeSB0byBmaW5kIGEgcG9pbnQgd2hlcmUgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIGNhbiBiZSBpbnNlcnRlZFxubmVhciBgcG9zYCwgYnkgc2VhcmNoaW5nIHVwIHRoZSBub2RlIGhpZXJhcmNoeSB3aGVuIGBwb3NgIGl0c2VsZlxuaXNuJ3QgYSB2YWxpZCBwbGFjZSBidXQgaXMgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIG5vZGUuIFJldHVyblxubnVsbCBpZiBubyBwb3NpdGlvbiB3YXMgZm91bmQuXG4qL1xuZnVuY3Rpb24gaW5zZXJ0UG9pbnQoZG9jLCBwb3MsIG5vZGVUeXBlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICgkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aCgkcG9zLmluZGV4KCksICRwb3MuaW5kZXgoKSwgbm9kZVR5cGUpKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAwKVxuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5iZWZvcmUoZCArIDEpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIGlmICgkcG9zLnBhcmVudE9mZnNldCA9PSAkcG9zLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihkKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuYWZ0ZXIoZCArIDEpO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgJHBvcy5ub2RlKGQpLmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuRmluZHMgYSBwb3NpdGlvbiBhdCBvciBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uIHdoZXJlIHRoZSBnaXZlblxuc2xpY2UgY2FuIGJlIGluc2VydGVkLiBXaWxsIGxvb2sgYXQgcGFyZW50IG5vZGVzJyBuZWFyZXN0IGJvdW5kYXJ5XG5hbmQgdHJ5IHRoZXJlLCBldmVuIGlmIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiB3YXNuJ3QgZGlyZWN0bHkgYXQgdGhlXG5zdGFydCBvciBlbmQgb2YgdGhhdCBub2RlLiBSZXR1cm5zIG51bGwgd2hlbiBubyBwb3NpdGlvbiB3YXMgZm91bmQuXG4qL1xuZnVuY3Rpb24gZHJvcFBvaW50KGRvYywgcG9zLCBzbGljZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBsZXQgY29udGVudCA9IHNsaWNlLmNvbnRlbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZS5vcGVuU3RhcnQ7IGkrKylcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgIGZvciAobGV0IHBhc3MgPSAxOyBwYXNzIDw9IChzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5zaXplID8gMiA6IDEpOyBwYXNzKyspIHtcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgYmlhcyA9IGQgPT0gJHBvcy5kZXB0aCA/IDAgOiAkcG9zLnBvcyA8PSAoJHBvcy5zdGFydChkICsgMSkgKyAkcG9zLmVuZChkICsgMSkpIC8gMiA/IC0xIDogMTtcbiAgICAgICAgICAgIGxldCBpbnNlcnRQb3MgPSAkcG9zLmluZGV4KGQpICsgKGJpYXMgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShkKSwgZml0cyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSkge1xuICAgICAgICAgICAgICAgIGZpdHMgPSBwYXJlbnQuY2FuUmVwbGFjZShpbnNlcnRQb3MsIGluc2VydFBvcywgY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcHBpbmcgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoaW5zZXJ0UG9zKS5maW5kV3JhcHBpbmcoY29udGVudC5maXJzdENoaWxkLnR5cGUpO1xuICAgICAgICAgICAgICAgIGZpdHMgPSB3cmFwcGluZyAmJiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIHdyYXBwaW5nWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXRzKVxuICAgICAgICAgICAgICAgIHJldHVybiBiaWFzID09IDAgPyAkcG9zLnBvcyA6IGJpYXMgPCAwID8gJHBvcy5iZWZvcmUoZCArIDEpIDogJHBvcy5hZnRlcihkICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuXHUyMDE4Rml0XHUyMDE5IGEgc2xpY2UgaW50byBhIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCwgcHJvZHVjaW5nIGFcbltzdGVwXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXApIHRoYXQgaW5zZXJ0cyBpdC4gV2lsbCByZXR1cm4gbnVsbCBpZlxudGhlcmUncyBubyBtZWFuaW5nZnVsIHdheSB0byBpbnNlcnQgdGhlIHNsaWNlIGhlcmUsIG9yIGluc2VydGluZyBpdFxud291bGQgYmUgYSBuby1vcCAoYW4gZW1wdHkgc2xpY2Ugb3ZlciBhbiBlbXB0eSByYW5nZSkuXG4qL1xuZnVuY3Rpb24gcmVwbGFjZVN0ZXAoZG9jLCBmcm9tLCB0byA9IGZyb20sIHNsaWNlID0gU2xpY2UuZW1wdHkpIHtcbiAgICBpZiAoZnJvbSA9PSB0byAmJiAhc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0ICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksICR0byA9IGRvYy5yZXNvbHZlKHRvKTtcbiAgICAvLyBPcHRpbWl6YXRpb24gLS0gYXZvaWQgd29yayBpZiBpdCdzIG9idmlvdXMgdGhhdCBpdCdzIG5vdCBuZWVkZWQuXG4gICAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSk7XG4gICAgcmV0dXJuIG5ldyBGaXR0ZXIoJGZyb20sICR0bywgc2xpY2UpLmZpdCgpO1xufVxuZnVuY3Rpb24gZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICAgIHJldHVybiAhc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLnN0YXJ0KCkgPT0gJHRvLnN0YXJ0KCkgJiZcbiAgICAgICAgJGZyb20ucGFyZW50LmNhblJlcGxhY2UoJGZyb20uaW5kZXgoKSwgJHRvLmluZGV4KCksIHNsaWNlLmNvbnRlbnQpO1xufVxuLy8gQWxnb3JpdGhtIGZvciAncGxhY2luZycgdGhlIGVsZW1lbnRzIG9mIGEgc2xpY2UgaW50byBhIGdhcDpcbi8vXG4vLyBXZSBjb25zaWRlciB0aGUgY29udGVudCBvZiBlYWNoIG5vZGUgdGhhdCBpcyBvcGVuIHRvIHRoZSBsZWZ0IHRvIGJlXG4vLyBpbmRlcGVuZGVudGx5IHBsYWNlYWJsZS4gSS5lLiBpbiA8cChcImZvb1wiKSwgcChcImJhclwiKT4sIHdoZW4gdGhlXG4vLyBwYXJhZ3JhcGggb24gdGhlIGxlZnQgaXMgb3BlbiwgXCJmb29cIiBjYW4gYmUgcGxhY2VkIChzb21ld2hlcmUgb25cbi8vIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50IGdhcCkgaW5kZXBlbmRlbnRseSBmcm9tIHAoXCJiYXJcIikuXG4vL1xuLy8gVGhpcyBjbGFzcyB0cmFja3MgdGhlIHN0YXRlIG9mIHRoZSBwbGFjZW1lbnQgcHJvZ3Jlc3MgaW4gdGhlXG4vLyBmb2xsb3dpbmcgcHJvcGVydGllczpcbi8vXG4vLyAgLSBgZnJvbnRpZXJgIGhvbGRzIGEgc3RhY2sgb2YgYHt0eXBlLCBtYXRjaH1gIG9iamVjdHMgdGhhdFxuLy8gICAgcmVwcmVzZW50IHRoZSBvcGVuIHNpZGUgb2YgdGhlIHJlcGxhY2VtZW50LiBJdCBzdGFydHMgYXRcbi8vICAgIGAkZnJvbWAsIHRoZW4gbW92ZXMgZm9yd2FyZCBhcyBjb250ZW50IGlzIHBsYWNlZCwgYW5kIGlzIGZpbmFsbHlcbi8vICAgIHJlY29uY2lsZWQgd2l0aCBgJHRvYC5cbi8vXG4vLyAgLSBgdW5wbGFjZWRgIGlzIGEgc2xpY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IHRoYXQgaGFzbid0XG4vLyAgICBiZWVuIHBsYWNlZCB5ZXQuXG4vL1xuLy8gIC0gYHBsYWNlZGAgaXMgYSBmcmFnbWVudCBvZiBwbGFjZWQgY29udGVudC4gSXRzIG9wZW4tc3RhcnQgdmFsdWVcbi8vICAgIGlzIGltcGxpY2l0IGluIGAkZnJvbWAsIGFuZCBpdHMgb3Blbi1lbmQgdmFsdWUgaW4gYGZyb250aWVyYC5cbmNsYXNzIEZpdHRlciB7XG4gICAgY29uc3RydWN0b3IoJGZyb20sICR0bywgdW5wbGFjZWQpIHtcbiAgICAgICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgICAgICB0aGlzLiR0byA9ICR0bztcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IHVucGxhY2VkO1xuICAgICAgICB0aGlzLmZyb250aWVyID0gW107XG4gICAgICAgIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9ICRmcm9tLmRlcHRoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gJGZyb20ubm9kZShpKTtcbiAgICAgICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4QWZ0ZXIoaSkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gJGZyb20uZGVwdGg7IGkgPiAwOyBpLS0pXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShpKS5jb3B5KHRoaXMucGxhY2VkKSk7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHsgcmV0dXJuIHRoaXMuZnJvbnRpZXIubGVuZ3RoIC0gMTsgfVxuICAgIGZpdCgpIHtcbiAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGVyZSdzIHVucGxhY2VkIGNvbnRlbnQsIHRyeSB0byBwbGFjZSBzb21lIG9mIGl0LlxuICAgICAgICAvLyBJZiB0aGF0IGZhaWxzLCBlaXRoZXIgaW5jcmVhc2UgdGhlIG9wZW4gc2NvcmUgb2YgdGhlIHVucGxhY2VkXG4gICAgICAgIC8vIHNsaWNlLCBvciBkcm9wIG5vZGVzIGZyb20gaXQsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICAgICAgd2hpbGUgKHRoaXMudW5wbGFjZWQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGZpdCA9IHRoaXMuZmluZEZpdHRhYmxlKCk7XG4gICAgICAgICAgICBpZiAoZml0KVxuICAgICAgICAgICAgICAgIHRoaXMucGxhY2VOb2RlcyhmaXQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMub3Blbk1vcmUoKSB8fCB0aGlzLmRyb3BOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGVyZSdzIGlubGluZSBjb250ZW50IGRpcmVjdGx5IGFmdGVyIHRoZSBmcm9udGllciBfYW5kX1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciBgdGhpcy4kdG9gLCB3ZSBtdXN0IGdlbmVyYXRlIGEgYFJlcGxhY2VBcm91bmRgXG4gICAgICAgIC8vIHN0ZXAgdGhhdCBwdWxscyB0aGF0IGNvbnRlbnQgaW50byB0aGUgbm9kZSBhZnRlciB0aGUgZnJvbnRpZXIuXG4gICAgICAgIC8vIFRoYXQgbWVhbnMgdGhlIGZpdHRpbmcgbXVzdCBiZSBkb25lIHRvIHRoZSBlbmQgb2YgdGhlIHRleHRibG9ja1xuICAgICAgICAvLyBub2RlIGFmdGVyIGB0aGlzLiR0b2AsIG5vdCBgdGhpcy4kdG9gIGl0c2VsZi5cbiAgICAgICAgbGV0IG1vdmVJbmxpbmUgPSB0aGlzLm11c3RNb3ZlSW5saW5lKCksIHBsYWNlZFNpemUgPSB0aGlzLnBsYWNlZC5zaXplIC0gdGhpcy5kZXB0aCAtIHRoaXMuJGZyb20uZGVwdGg7XG4gICAgICAgIGxldCAkZnJvbSA9IHRoaXMuJGZyb20sICR0byA9IHRoaXMuY2xvc2UobW92ZUlubGluZSA8IDAgPyB0aGlzLiR0byA6ICRmcm9tLmRvYy5yZXNvbHZlKG1vdmVJbmxpbmUpKTtcbiAgICAgICAgaWYgKCEkdG8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gSWYgY2xvc2luZyB0byBgJHRvYCBzdWNjZWVkZWQsIGNyZWF0ZSBhIHN0ZXBcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLnBsYWNlZCwgb3BlblN0YXJ0ID0gJGZyb20uZGVwdGgsIG9wZW5FbmQgPSAkdG8uZGVwdGg7XG4gICAgICAgIHdoaWxlIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSkgeyAvLyBOb3JtYWxpemUgYnkgZHJvcHBpbmcgb3BlbiBwYXJlbnQgbm9kZXNcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICAgICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICAgICAgb3BlbkVuZC0tO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICBpZiAobW92ZUlubGluZSA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkZnJvbS5wb3MsIG1vdmVJbmxpbmUsIHRoaXMuJHRvLnBvcywgdGhpcy4kdG8uZW5kKCksIHNsaWNlLCBwbGFjZWRTaXplKTtcbiAgICAgICAgaWYgKHNsaWNlLnNpemUgfHwgJGZyb20ucG9zICE9IHRoaXMuJHRvLnBvcykgLy8gRG9uJ3QgZ2VuZXJhdGUgbm8tb3Agc3RlcHNcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoJGZyb20ucG9zLCAkdG8ucG9zLCBzbGljZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBGaW5kIGEgcG9zaXRpb24gb24gdGhlIHN0YXJ0IHNwaW5lIG9mIGB0aGlzLnVucGxhY2VkYCB0aGF0IGhhc1xuICAgIC8vIGNvbnRlbnQgdGhhdCBjYW4gYmUgbW92ZWQgc29tZXdoZXJlIG9uIHRoZSBmcm9udGllci4gUmV0dXJucyB0d29cbiAgICAvLyBkZXB0aHMsIG9uZSBmb3IgdGhlIHNsaWNlIGFuZCBvbmUgZm9yIHRoZSBmcm9udGllci5cbiAgICBmaW5kRml0dGFibGUoKSB7XG4gICAgICAgIGxldCBzdGFydERlcHRoID0gdGhpcy51bnBsYWNlZC5vcGVuU3RhcnQ7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHRoaXMudW5wbGFjZWQuY29udGVudCwgZCA9IDAsIG9wZW5FbmQgPSB0aGlzLnVucGxhY2VkLm9wZW5FbmQ7IGQgPCBzdGFydERlcHRoOyBkKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gY3VyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoY3VyLmNoaWxkQ291bnQgPiAxKVxuICAgICAgICAgICAgICAgIG9wZW5FbmQgPSAwO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmlzb2xhdGluZyAmJiBvcGVuRW5kIDw9IGQpIHtcbiAgICAgICAgICAgICAgICBzdGFydERlcHRoID0gZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHRyeSB3cmFwcGluZyBub2RlcyAocGFzcyAyKSBhZnRlciBmaW5kaW5nIGEgcGxhY2Ugd2l0aG91dFxuICAgICAgICAvLyB3cmFwcGluZyBmYWlsZWQuXG4gICAgICAgIGZvciAobGV0IHBhc3MgPSAxOyBwYXNzIDw9IDI7IHBhc3MrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgc2xpY2VEZXB0aCA9IHBhc3MgPT0gMSA/IHN0YXJ0RGVwdGggOiB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDsgc2xpY2VEZXB0aCA+PSAwOyBzbGljZURlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhZ21lbnQsIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlRGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gY29udGVudEF0KHRoaXMudW5wbGFjZWQuY29udGVudCwgc2xpY2VEZXB0aCAtIDEpLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMudW5wbGFjZWQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBmcm9udGllckRlcHRoID0gdGhpcy5kZXB0aDsgZnJvbnRpZXJEZXB0aCA+PSAwOyBmcm9udGllckRlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbWF0Y2ggfSA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0sIHdyYXAsIGluamVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhc3MgMSwgaWYgdGhlIG5leHQgbm9kZSBtYXRjaGVzLCBvciB0aGVyZSBpcyBubyBuZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgYnV0IHRoZSBwYXJlbnRzIGxvb2sgY29tcGF0aWJsZSwgd2UndmUgZm91bmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3MgPT0gMSAmJiAoZmlyc3QgPyBtYXRjaC5tYXRjaFR5cGUoZmlyc3QudHlwZSkgfHwgKGluamVjdCA9IG1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShmaXJzdCksIGZhbHNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyZW50ICYmIHR5cGUuY29tcGF0aWJsZUNvbnRlbnQocGFyZW50LnR5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgaW5qZWN0IH07XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHBhc3MgMiwgbG9vayBmb3IgYSBzZXQgb2Ygd3JhcHBpbmcgbm9kZXMgdGhhdCBtYWtlXG4gICAgICAgICAgICAgICAgICAgIC8vIGBmaXJzdGAgZml0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhc3MgPT0gMiAmJiBmaXJzdCAmJiAod3JhcCA9IG1hdGNoLmZpbmRXcmFwcGluZyhmaXJzdC50eXBlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIHdyYXAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29udGludWUgbG9va2luZyBmdXJ0aGVyIHVwIGlmIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAvLyB3b3VsZCBmaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBtYXRjaC5tYXRjaFR5cGUocGFyZW50LnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG9wZW5Nb3JlKCkge1xuICAgICAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHRoaXMudW5wbGFjZWQ7XG4gICAgICAgIGxldCBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgICBpZiAoIWlubmVyLmNoaWxkQ291bnQgfHwgaW5uZXIuZmlyc3RDaGlsZC5pc0xlYWYpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0ICsgMSwgTWF0aC5tYXgob3BlbkVuZCwgaW5uZXIuc2l6ZSArIG9wZW5TdGFydCA+PSBjb250ZW50LnNpemUgLSBvcGVuRW5kID8gb3BlblN0YXJ0ICsgMSA6IDApKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyb3BOb2RlKCkge1xuICAgICAgICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHRoaXMudW5wbGFjZWQ7XG4gICAgICAgIGxldCBpbm5lciA9IGNvbnRlbnRBdChjb250ZW50LCBvcGVuU3RhcnQpO1xuICAgICAgICBpZiAoaW5uZXIuY2hpbGRDb3VudCA8PSAxICYmIG9wZW5TdGFydCA+IDApIHtcbiAgICAgICAgICAgIGxldCBvcGVuQXRFbmQgPSBjb250ZW50LnNpemUgLSBvcGVuU3RhcnQgPD0gb3BlblN0YXJ0ICsgaW5uZXIuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQgLSAxLCAxKSwgb3BlblN0YXJ0IC0gMSwgb3BlbkF0RW5kID8gb3BlblN0YXJ0IC0gMSA6IG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCwgMSksIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTW92ZSBjb250ZW50IGZyb20gdGhlIHVucGxhY2VkIHNsaWNlIGF0IGBzbGljZURlcHRoYCB0byB0aGVcbiAgICAvLyBmcm9udGllciBub2RlIGF0IGBmcm9udGllckRlcHRoYC4gQ2xvc2UgdGhhdCBmcm9udGllciBub2RlIHdoZW5cbiAgICAvLyBhcHBsaWNhYmxlLlxuICAgIHBsYWNlTm9kZXMoeyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIGluamVjdCwgd3JhcCB9KSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmRlcHRoID4gZnJvbnRpZXJEZXB0aClcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgaWYgKHdyYXApXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKHdyYXBbaV0pO1xuICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnVucGxhY2VkLCBmcmFnbWVudCA9IHBhcmVudCA/IHBhcmVudC5jb250ZW50IDogc2xpY2UuY29udGVudDtcbiAgICAgICAgbGV0IG9wZW5TdGFydCA9IHNsaWNlLm9wZW5TdGFydCAtIHNsaWNlRGVwdGg7XG4gICAgICAgIGxldCB0YWtlbiA9IDAsIGFkZCA9IFtdO1xuICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXTtcbiAgICAgICAgaWYgKGluamVjdCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmplY3QuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgICAgIGFkZC5wdXNoKGluamVjdC5jaGlsZChpKSk7XG4gICAgICAgICAgICBtYXRjaCA9IG1hdGNoLm1hdGNoRnJhZ21lbnQoaW5qZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlcyB0aGUgYW1vdW50IG9mIChlbmQpIG9wZW4gbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgLy8gZnJhZ21lbnQuIFdoZW4gMCwgdGhlIHBhcmVudCBpcyBvcGVuLCBidXQgbm8gbW9yZS4gV2hlblxuICAgICAgICAvLyBuZWdhdGl2ZSwgbm90aGluZyBpcyBvcGVuLlxuICAgICAgICBsZXQgb3BlbkVuZENvdW50ID0gKGZyYWdtZW50LnNpemUgKyBzbGljZURlcHRoKSAtIChzbGljZS5jb250ZW50LnNpemUgLSBzbGljZS5vcGVuRW5kKTtcbiAgICAgICAgLy8gU2NhbiBvdmVyIHRoZSBmcmFnbWVudCwgZml0dGluZyBhcyBtYW55IGNoaWxkIG5vZGVzIGFzXG4gICAgICAgIC8vIHBvc3NpYmxlLlxuICAgICAgICB3aGlsZSAodGFrZW4gPCBmcmFnbWVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGZyYWdtZW50LmNoaWxkKHRha2VuKSwgbWF0Y2hlcyA9IG1hdGNoLm1hdGNoVHlwZShuZXh0LnR5cGUpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGFrZW4rKztcbiAgICAgICAgICAgIGlmICh0YWtlbiA+IDEgfHwgb3BlblN0YXJ0ID09IDAgfHwgbmV4dC5jb250ZW50LnNpemUpIHsgLy8gRHJvcCBlbXB0eSBvcGVuIG5vZGVzXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIGFkZC5wdXNoKGNsb3NlTm9kZVN0YXJ0KG5leHQubWFyayh0eXBlLmFsbG93ZWRNYXJrcyhuZXh0Lm1hcmtzKSksIHRha2VuID09IDEgPyBvcGVuU3RhcnQgOiAwLCB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50ID8gb3BlbkVuZENvdW50IDogLTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9FbmQgPSB0YWtlbiA9PSBmcmFnbWVudC5jaGlsZENvdW50O1xuICAgICAgICBpZiAoIXRvRW5kKVxuICAgICAgICAgICAgb3BlbkVuZENvdW50ID0gLTE7XG4gICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgZnJvbnRpZXJEZXB0aCwgRnJhZ21lbnQuZnJvbShhZGQpKTtcbiAgICAgICAgdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXS5tYXRjaCA9IG1hdGNoO1xuICAgICAgICAvLyBJZiB0aGUgcGFyZW50IHR5cGVzIG1hdGNoLCBhbmQgdGhlIGVudGlyZSBub2RlIHdhcyBtb3ZlZCwgYW5kXG4gICAgICAgIC8vIGl0J3Mgbm90IG9wZW4sIGNsb3NlIHRoaXMgZnJvbnRpZXIgbm9kZSByaWdodCBhd2F5LlxuICAgICAgICBpZiAodG9FbmQgJiYgb3BlbkVuZENvdW50IDwgMCAmJiBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXS50eXBlICYmIHRoaXMuZnJvbnRpZXIubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgLy8gQWRkIG5ldyBmcm9udGllciBub2RlcyBmb3IgYW55IG9wZW4gbm9kZXMgYXQgdGhlIGVuZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGN1ciA9IGZyYWdtZW50OyBpIDwgb3BlbkVuZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gY3VyLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7IHR5cGU6IG5vZGUudHlwZSwgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQobm9kZS5jaGlsZENvdW50KSB9KTtcbiAgICAgICAgICAgIGN1ciA9IG5vZGUuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgYHRoaXMudW5wbGFjZWRgLiBEcm9wIHRoZSBlbnRpcmUgbm9kZSBmcm9tIHdoaWNoIHdlXG4gICAgICAgIC8vIHBsYWNlZCBpdCB3ZSBnb3QgdG8gaXRzIGVuZCwgb3RoZXJ3aXNlIGp1c3QgZHJvcCB0aGUgcGxhY2VkXG4gICAgICAgIC8vIG5vZGVzLlxuICAgICAgICB0aGlzLnVucGxhY2VkID0gIXRvRW5kID8gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoc2xpY2UuY29udGVudCwgc2xpY2VEZXB0aCwgdGFrZW4pLCBzbGljZS5vcGVuU3RhcnQsIHNsaWNlLm9wZW5FbmQpXG4gICAgICAgICAgICA6IHNsaWNlRGVwdGggPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoIC0gMSwgMSksIHNsaWNlRGVwdGggLSAxLCBvcGVuRW5kQ291bnQgPCAwID8gc2xpY2Uub3BlbkVuZCA6IHNsaWNlRGVwdGggLSAxKTtcbiAgICB9XG4gICAgbXVzdE1vdmVJbmxpbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy4kdG8ucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXSwgbGV2ZWw7XG4gICAgICAgIGlmICghdG9wLnR5cGUuaXNUZXh0YmxvY2sgfHwgIWNvbnRlbnRBZnRlckZpdHModGhpcy4kdG8sIHRoaXMuJHRvLmRlcHRoLCB0b3AudHlwZSwgdG9wLm1hdGNoLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICh0aGlzLiR0by5kZXB0aCA9PSB0aGlzLmRlcHRoICYmIChsZXZlbCA9IHRoaXMuZmluZENsb3NlTGV2ZWwodGhpcy4kdG8pKSAmJiBsZXZlbC5kZXB0aCA9PSB0aGlzLmRlcHRoKSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IHsgZGVwdGggfSA9IHRoaXMuJHRvLCBhZnRlciA9IHRoaXMuJHRvLmFmdGVyKGRlcHRoKTtcbiAgICAgICAgd2hpbGUgKGRlcHRoID4gMSAmJiBhZnRlciA9PSB0aGlzLiR0by5lbmQoLS1kZXB0aCkpXG4gICAgICAgICAgICArK2FmdGVyO1xuICAgICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgfVxuICAgIGZpbmRDbG9zZUxldmVsKCR0bykge1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBpID0gTWF0aC5taW4odGhpcy5kZXB0aCwgJHRvLmRlcHRoKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2ldO1xuICAgICAgICAgICAgbGV0IGRyb3BJbm5lciA9IGkgPCAkdG8uZGVwdGggJiYgJHRvLmVuZChpICsgMSkgPT0gJHRvLnBvcyArICgkdG8uZGVwdGggLSAoaSArIDEpKTtcbiAgICAgICAgICAgIGxldCBmaXQgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgaSwgdHlwZSwgbWF0Y2gsIGRyb3BJbm5lcik7XG4gICAgICAgICAgICBpZiAoIWZpdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSBpIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltkXTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkLCB0eXBlLCBtYXRjaCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgc2NhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRlcHRoOiBpLCBmaXQsIG1vdmU6IGRyb3BJbm5lciA/ICR0by5kb2MucmVzb2x2ZSgkdG8uYWZ0ZXIoaSArIDEpKSA6ICR0byB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCR0bykge1xuICAgICAgICBsZXQgY2xvc2UgPSB0aGlzLmZpbmRDbG9zZUxldmVsKCR0byk7XG4gICAgICAgIGlmICghY2xvc2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBjbG9zZS5kZXB0aClcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGcm9udGllck5vZGUoKTtcbiAgICAgICAgaWYgKGNsb3NlLmZpdC5jaGlsZENvdW50KVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBjbG9zZS5kZXB0aCwgY2xvc2UuZml0KTtcbiAgICAgICAgJHRvID0gY2xvc2UubW92ZTtcbiAgICAgICAgZm9yIChsZXQgZCA9IGNsb3NlLmRlcHRoICsgMTsgZCA8PSAkdG8uZGVwdGg7IGQrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkdG8ubm9kZShkKSwgYWRkID0gbm9kZS50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgJHRvLmluZGV4KGQpKTtcbiAgICAgICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZShub2RlLnR5cGUsIG5vZGUuYXR0cnMsIGFkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICR0bztcbiAgICB9XG4gICAgb3BlbkZyb250aWVyTm9kZSh0eXBlLCBhdHRycyA9IG51bGwsIGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF07XG4gICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5kZXB0aCwgRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRycywgY29udGVudCkpKTtcbiAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHsgdHlwZSwgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoIH0pO1xuICAgIH1cbiAgICBjbG9zZUZyb250aWVyTm9kZSgpIHtcbiAgICAgICAgbGV0IG9wZW4gPSB0aGlzLmZyb250aWVyLnBvcCgpO1xuICAgICAgICBsZXQgYWRkID0gb3Blbi5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgaWYgKGFkZC5jaGlsZENvdW50KVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmZyb250aWVyLmxlbmd0aCwgYWRkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkcm9wRnJvbUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY291bnQpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LmN1dEJ5SW5kZXgoY291bnQsIGZyYWdtZW50LmNoaWxkQ291bnQpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZnJhZ21lbnQuZmlyc3RDaGlsZC5jb3B5KGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvdW50KSkpO1xufVxuZnVuY3Rpb24gYWRkVG9GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvbnRlbnQpIHtcbiAgICBpZiAoZGVwdGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50LmFwcGVuZChjb250ZW50KTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBmcmFnbWVudC5sYXN0Q2hpbGQuY29weShhZGRUb0ZyYWdtZW50KGZyYWdtZW50Lmxhc3RDaGlsZC5jb250ZW50LCBkZXB0aCAtIDEsIGNvbnRlbnQpKSk7XG59XG5mdW5jdGlvbiBjb250ZW50QXQoZnJhZ21lbnQsIGRlcHRoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXB0aDsgaSsrKVxuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiBjbG9zZU5vZGVTdGFydChub2RlLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBpZiAob3BlblN0YXJ0IDw9IDApXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIGxldCBmcmFnID0gbm9kZS5jb250ZW50O1xuICAgIGlmIChvcGVuU3RhcnQgPiAxKVxuICAgICAgICBmcmFnID0gZnJhZy5yZXBsYWNlQ2hpbGQoMCwgY2xvc2VOb2RlU3RhcnQoZnJhZy5maXJzdENoaWxkLCBvcGVuU3RhcnQgLSAxLCBmcmFnLmNoaWxkQ291bnQgPT0gMSA/IG9wZW5FbmQgLSAxIDogMCkpO1xuICAgIGlmIChvcGVuU3RhcnQgPiAwKSB7XG4gICAgICAgIGZyYWcgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoZnJhZykuYXBwZW5kKGZyYWcpO1xuICAgICAgICBpZiAob3BlbkVuZCA8PSAwKVxuICAgICAgICAgICAgZnJhZyA9IGZyYWcuYXBwZW5kKG5vZGUudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmcmFnKS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmNvcHkoZnJhZyk7XG59XG5mdW5jdGlvbiBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZGVwdGgsIHR5cGUsIG1hdGNoLCBvcGVuKSB7XG4gICAgbGV0IG5vZGUgPSAkdG8ubm9kZShkZXB0aCksIGluZGV4ID0gb3BlbiA/ICR0by5pbmRleEFmdGVyKGRlcHRoKSA6ICR0by5pbmRleChkZXB0aCk7XG4gICAgaWYgKGluZGV4ID09IG5vZGUuY2hpbGRDb3VudCAmJiAhdHlwZS5jb21wYXRpYmxlQ29udGVudChub2RlLnR5cGUpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZml0ID0gbWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsIGluZGV4KTtcbiAgICByZXR1cm4gZml0ICYmICFpbnZhbGlkTWFya3ModHlwZSwgbm9kZS5jb250ZW50LCBpbmRleCkgPyBmaXQgOiBudWxsO1xufVxuZnVuY3Rpb24gaW52YWxpZE1hcmtzKHR5cGUsIGZyYWdtZW50LCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgaWYgKCF0eXBlLmFsbG93c01hcmtzKGZyYWdtZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlZmluZXNDb250ZW50KHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5zcGVjLmRlZmluaW5nIHx8IHR5cGUuc3BlYy5kZWZpbmluZ0ZvckNvbnRlbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2UodHIsIGZyb20sIHRvLCBzbGljZSkge1xuICAgIGlmICghc2xpY2Uuc2l6ZSlcbiAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGlmIChmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSlcbiAgICAgICAgcmV0dXJuIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKGZyb20sIHRvLCBzbGljZSkpO1xuICAgIGxldCB0YXJnZXREZXB0aHMgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCB0ci5kb2MucmVzb2x2ZSh0bykpO1xuICAgIC8vIENhbid0IHJlcGxhY2UgdGhlIHdob2xlIGRvY3VtZW50LCBzbyByZW1vdmUgMCBpZiBpdCdzIHByZXNlbnRcbiAgICBpZiAodGFyZ2V0RGVwdGhzW3RhcmdldERlcHRocy5sZW5ndGggLSAxXSA9PSAwKVxuICAgICAgICB0YXJnZXREZXB0aHMucG9wKCk7XG4gICAgLy8gTmVnYXRpdmUgbnVtYmVycyByZXByZXNlbnQgbm90IGV4cGFuc2lvbiBvdmVyIHRoZSB3aG9sZSBub2RlIGF0XG4gICAgLy8gdGhhdCBkZXB0aCwgYnV0IHJlcGxhY2luZyBmcm9tICRmcm9tLmJlZm9yZSgtRCkgdG8gJHRvLnBvcy5cbiAgICBsZXQgcHJlZmVycmVkVGFyZ2V0ID0gLSgkZnJvbS5kZXB0aCArIDEpO1xuICAgIHRhcmdldERlcHRocy51bnNoaWZ0KHByZWZlcnJlZFRhcmdldCk7XG4gICAgLy8gVGhpcyBsb29wIHBpY2tzIGEgcHJlZmVycmVkIHRhcmdldCBkZXB0aCwgaWYgb25lIG9mIHRoZSBjb3ZlcmluZ1xuICAgIC8vIGRlcHRocyBpcyBub3Qgb3V0c2lkZSBvZiBhIGRlZmluaW5nIG5vZGUsIGFuZCBhZGRzIG5lZ2F0aXZlXG4gICAgLy8gZGVwdGhzIGZvciBhbnkgZGVwdGggdGhhdCBoYXMgJGZyb20gYXQgaXRzIHN0YXJ0IGFuZCBkb2VzIG5vdFxuICAgIC8vIGNyb3NzIGEgZGVmaW5pbmcgbm9kZS5cbiAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGgsIHBvcyA9ICRmcm9tLnBvcyAtIDE7IGQgPiAwOyBkLS0sIHBvcy0tKSB7XG4gICAgICAgIGxldCBzcGVjID0gJGZyb20ubm9kZShkKS50eXBlLnNwZWM7XG4gICAgICAgIGlmIChzcGVjLmRlZmluaW5nIHx8IHNwZWMuZGVmaW5pbmdBc0NvbnRleHQgfHwgc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHRhcmdldERlcHRocy5pbmRleE9mKGQpID4gLTEpXG4gICAgICAgICAgICBwcmVmZXJyZWRUYXJnZXQgPSBkO1xuICAgICAgICBlbHNlIGlmICgkZnJvbS5iZWZvcmUoZCkgPT0gcG9zKVxuICAgICAgICAgICAgdGFyZ2V0RGVwdGhzLnNwbGljZSgxLCAwLCAtZCk7XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaXQgZWFjaCBwb3NzaWJsZSBkZXB0aCBvZiB0aGUgc2xpY2UgaW50byBlYWNoIHBvc3NpYmxlXG4gICAgLy8gdGFyZ2V0IGRlcHRoLCBzdGFydGluZyB3aXRoIHRoZSBwcmVmZXJyZWQgZGVwdGhzLlxuICAgIGxldCBwcmVmZXJyZWRUYXJnZXRJbmRleCA9IHRhcmdldERlcHRocy5pbmRleE9mKHByZWZlcnJlZFRhcmdldCk7XG4gICAgbGV0IGxlZnROb2RlcyA9IFtdLCBwcmVmZXJyZWREZXB0aCA9IHNsaWNlLm9wZW5TdGFydDtcbiAgICBmb3IgKGxldCBjb250ZW50ID0gc2xpY2UuY29udGVudCwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGxlZnROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoaSA9PSBzbGljZS5vcGVuU3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgLy8gQmFjayB1cCBwcmVmZXJyZWREZXB0aCB0byBjb3ZlciBkZWZpbmluZyB0ZXh0YmxvY2tzIGRpcmVjdGx5XG4gICAgLy8gYWJvdmUgaXQsIHBvc3NpYmx5IHNraXBwaW5nIGEgbm9uLWRlZmluaW5nIHRleHRibG9jay5cbiAgICBmb3IgKGxldCBkID0gcHJlZmVycmVkRGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgbGVmdE5vZGUgPSBsZWZ0Tm9kZXNbZF0sIGRlZiA9IGRlZmluZXNDb250ZW50KGxlZnROb2RlLnR5cGUpO1xuICAgICAgICBpZiAoZGVmICYmICFsZWZ0Tm9kZS5zYW1lTWFya3VwKCRmcm9tLm5vZGUoTWF0aC5hYnMocHJlZmVycmVkVGFyZ2V0KSAtIDEpKSlcbiAgICAgICAgICAgIHByZWZlcnJlZERlcHRoID0gZDtcbiAgICAgICAgZWxzZSBpZiAoZGVmIHx8ICFsZWZ0Tm9kZS50eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBzbGljZS5vcGVuU3RhcnQ7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGxldCBvcGVuRGVwdGggPSAoaiArIHByZWZlcnJlZERlcHRoICsgMSkgJSAoc2xpY2Uub3BlblN0YXJ0ICsgMSk7XG4gICAgICAgIGxldCBpbnNlcnQgPSBsZWZ0Tm9kZXNbb3BlbkRlcHRoXTtcbiAgICAgICAgaWYgKCFpbnNlcnQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXREZXB0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBwb3NzaWJsZSBleHBhbnNpb24gbGV2ZWxzLCBzdGFydGluZyB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gcHJlZmVycmVkIG9uZVxuICAgICAgICAgICAgbGV0IHRhcmdldERlcHRoID0gdGFyZ2V0RGVwdGhzWyhpICsgcHJlZmVycmVkVGFyZ2V0SW5kZXgpICUgdGFyZ2V0RGVwdGhzLmxlbmd0aF0sIGV4cGFuZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RGVwdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGVwdGggPSAtdGFyZ2V0RGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ubm9kZSh0YXJnZXREZXB0aCAtIDEpLCBpbmRleCA9ICRmcm9tLmluZGV4KHRhcmdldERlcHRoIC0gMSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgaW5zZXJ0LnR5cGUsIGluc2VydC5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyLnJlcGxhY2UoJGZyb20uYmVmb3JlKHRhcmdldERlcHRoKSwgZXhwYW5kID8gJHRvLmFmdGVyKHRhcmdldERlcHRoKSA6IHRvLCBuZXcgU2xpY2UoY2xvc2VGcmFnbWVudChzbGljZS5jb250ZW50LCAwLCBzbGljZS5vcGVuU3RhcnQsIG9wZW5EZXB0aCksIG9wZW5EZXB0aCwgc2xpY2Uub3BlbkVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdGFydFN0ZXBzID0gdHIuc3RlcHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSB0YXJnZXREZXB0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdHIucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICBpZiAodHIuc3RlcHMubGVuZ3RoID4gc3RhcnRTdGVwcylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgZGVwdGggPSB0YXJnZXREZXB0aHNbaV07XG4gICAgICAgIGlmIChkZXB0aCA8IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZnJvbSA9ICRmcm9tLmJlZm9yZShkZXB0aCk7XG4gICAgICAgIHRvID0gJHRvLmFmdGVyKGRlcHRoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZUZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgb2xkT3BlbiwgbmV3T3BlbiwgcGFyZW50KSB7XG4gICAgaWYgKGRlcHRoIDwgb2xkT3Blbikge1xuICAgICAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICBmcmFnbWVudCA9IGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmaXJzdC5jb3B5KGNsb3NlRnJhZ21lbnQoZmlyc3QuY29udGVudCwgZGVwdGggKyAxLCBvbGRPcGVuLCBuZXdPcGVuLCBmaXJzdCkpKTtcbiAgICB9XG4gICAgaWYgKGRlcHRoID4gbmV3T3Blbikge1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoMCk7XG4gICAgICAgIGxldCBzdGFydCA9IG1hdGNoLmZpbGxCZWZvcmUoZnJhZ21lbnQpLmFwcGVuZChmcmFnbWVudCk7XG4gICAgICAgIGZyYWdtZW50ID0gc3RhcnQuYXBwZW5kKG1hdGNoLm1hdGNoRnJhZ21lbnQoc3RhcnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlV2l0aCh0ciwgZnJvbSwgdG8sIG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuaXNJbmxpbmUgJiYgZnJvbSA9PSB0byAmJiB0ci5kb2MucmVzb2x2ZShmcm9tKS5wYXJlbnQuY29udGVudC5zaXplKSB7XG4gICAgICAgIGxldCBwb2ludCA9IGluc2VydFBvaW50KHRyLmRvYywgZnJvbSwgbm9kZS50eXBlKTtcbiAgICAgICAgaWYgKHBvaW50ICE9IG51bGwpXG4gICAgICAgICAgICBmcm9tID0gdG8gPSBwb2ludDtcbiAgICB9XG4gICAgdHIucmVwbGFjZVJhbmdlKGZyb20sIHRvLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShub2RlKSwgMCwgMCkpO1xufVxuZnVuY3Rpb24gZGVsZXRlUmFuZ2UodHIsIGZyb20sIHRvKSB7XG4gICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgICBsZXQgY292ZXJlZCA9IGNvdmVyZWREZXB0aHMoJGZyb20sICR0byk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3ZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZXB0aCA9IGNvdmVyZWRbaV0sIGxhc3QgPSBpID09IGNvdmVyZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKChsYXN0ICYmIGRlcHRoID09IDApIHx8ICRmcm9tLm5vZGUoZGVwdGgpLnR5cGUuY29udGVudE1hdGNoLnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5zdGFydChkZXB0aCksICR0by5lbmQoZGVwdGgpKTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiAobGFzdCB8fCAkZnJvbS5ub2RlKGRlcHRoIC0gMSkuY2FuUmVwbGFjZSgkZnJvbS5pbmRleChkZXB0aCAtIDEpLCAkdG8uaW5kZXhBZnRlcihkZXB0aCAtIDEpKSkpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkZXB0aCksICR0by5hZnRlcihkZXB0aCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBkID0gMTsgZCA8PSAkZnJvbS5kZXB0aCAmJiBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgIGlmIChmcm9tIC0gJGZyb20uc3RhcnQoZCkgPT0gJGZyb20uZGVwdGggLSBkICYmIHRvID4gJGZyb20uZW5kKGQpICYmICR0by5lbmQoZCkgLSB0byAhPSAkdG8uZGVwdGggLSBkICYmXG4gICAgICAgICAgICAkZnJvbS5zdGFydChkIC0gMSkgPT0gJHRvLnN0YXJ0KGQgLSAxKSAmJiAkZnJvbS5ub2RlKGQgLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGQgLSAxKSwgJHRvLmluZGV4KGQgLSAxKSkpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLmJlZm9yZShkKSwgdG8pO1xuICAgIH1cbiAgICB0ci5kZWxldGUoZnJvbSwgdG8pO1xufVxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGVwdGhzIGZvciB3aGljaCAkZnJvbSAtICR0byBzcGFucyB0aGVcbi8vIHdob2xlIGNvbnRlbnQgb2YgdGhlIG5vZGVzIGF0IHRoYXQgZGVwdGguXG5mdW5jdGlvbiBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pIHtcbiAgICBsZXQgcmVzdWx0ID0gW10sIG1pbkRlcHRoID0gTWF0aC5taW4oJGZyb20uZGVwdGgsICR0by5kZXB0aCk7XG4gICAgZm9yIChsZXQgZCA9IG1pbkRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5zdGFydChkKTtcbiAgICAgICAgaWYgKHN0YXJ0IDwgJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCkgfHxcbiAgICAgICAgICAgICR0by5lbmQoZCkgPiAkdG8ucG9zICsgKCR0by5kZXB0aCAtIGQpIHx8XG4gICAgICAgICAgICAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgICAgICR0by5ub2RlKGQpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHN0YXJ0ID09ICR0by5zdGFydChkKSB8fFxuICAgICAgICAgICAgKGQgPT0gJGZyb20uZGVwdGggJiYgZCA9PSAkdG8uZGVwdGggJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50ICYmXG4gICAgICAgICAgICAgICAgZCAmJiAkdG8uc3RhcnQoZCAtIDEpID09IHN0YXJ0IC0gMSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5VcGRhdGUgYW4gYXR0cmlidXRlIGluIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBBdHRyU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhbiBhdHRyaWJ1dGUgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICovXG4gICAgYXR0ciwgXG4gICAgLy8gVGhlIGF0dHJpYnV0ZSdzIG5ldyB2YWx1ZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIk5vIG5vZGUgYXQgYXR0cmlidXRlIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBub2RlLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBub2RlLmF0dHJzW25hbWVdO1xuICAgICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBub2RlLm1hcmtzKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAodGhpcy5wb3MsIHRoaXMuYXR0ciwgZG9jLm5vZGVBdCh0aGlzLnBvcykuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBdHRyU3RlcChwb3MucG9zLCB0aGlzLmF0dHIsIHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImF0dHJcIiwgcG9zOiB0aGlzLnBvcywgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEF0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTdGVwKGpzb24ucG9zLCBqc29uLmF0dHIsIGpzb24udmFsdWUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYXR0clwiLCBBdHRyU3RlcCk7XG4vKipcblVwZGF0ZSBhbiBhdHRyaWJ1dGUgaW4gdGhlIGRvYyBub2RlLlxuKi9cbmNsYXNzIERvY0F0dHJTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGFuIGF0dHJpYnV0ZSBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgKi9cbiAgICBhdHRyLCBcbiAgICAvLyBUaGUgYXR0cmlidXRlJ3MgbmV3IHZhbHVlLlxuICAgIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gZG9jLmF0dHJzKVxuICAgICAgICAgICAgYXR0cnNbbmFtZV0gPSBkb2MuYXR0cnNbbmFtZV07XG4gICAgICAgIGF0dHJzW3RoaXMuYXR0cl0gPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IGRvYy50eXBlLmNyZWF0ZShhdHRycywgZG9jLmNvbnRlbnQsIGRvYy5tYXJrcyk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKHVwZGF0ZWQpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgRG9jQXR0clN0ZXAodGhpcy5hdHRyLCBkb2MuYXR0cnNbdGhpcy5hdHRyXSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcImRvY0F0dHJcIiwgYXR0cjogdGhpcy5hdHRyLCB2YWx1ZTogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5hdHRyICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIERvY0F0dHJTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IERvY0F0dHJTdGVwKGpzb24uYXR0ciwganNvbi52YWx1ZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJkb2NBdHRyXCIsIERvY0F0dHJTdGVwKTtcblxuLyoqXG5AaW50ZXJuYWxcbiovXG5sZXQgVHJhbnNmb3JtRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbn07XG5UcmFuc2Zvcm1FcnJvciA9IGZ1bmN0aW9uIFRyYW5zZm9ybUVycm9yKG1lc3NhZ2UpIHtcbiAgICBsZXQgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBlcnIuX19wcm90b19fID0gVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlO1xuICAgIHJldHVybiBlcnI7XG59O1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJhbnNmb3JtRXJyb3I7XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUubmFtZSA9IFwiVHJhbnNmb3JtRXJyb3JcIjtcbi8qKlxuQWJzdHJhY3Rpb24gdG8gYnVpbGQgdXAgYW5kIHRyYWNrIGFuIGFycmF5IG9mXG5bc3RlcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcCkgcmVwcmVzZW50aW5nIGEgZG9jdW1lbnQgdHJhbnNmb3JtYXRpb24uXG5cbk1vc3QgdHJhbnNmb3JtaW5nIG1ldGhvZHMgcmV0dXJuIHRoZSBgVHJhbnNmb3JtYCBvYmplY3QgaXRzZWxmLCBzb1xudGhhdCB0aGV5IGNhbiBiZSBjaGFpbmVkLlxuKi9cbmNsYXNzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdHJhbnNmb3JtIHRoYXQgc3RhcnRzIHdpdGggdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZG9jdW1lbnQgKHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIHN0ZXBzIGluIHRoZVxuICAgIHRyYW5zZm9ybSkuXG4gICAgKi9cbiAgICBkb2MpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RlcHMgaW4gdGhpcyB0cmFuc2Zvcm0uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RlcHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBkb2N1bWVudHMgYmVmb3JlIGVhY2ggb2YgdGhlIHN0ZXBzLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvY3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEEgbWFwcGluZyB3aXRoIHRoZSBtYXBzIGZvciBlYWNoIG9mIHRoZSBzdGVwcyBpbiB0aGlzIHRyYW5zZm9ybS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBiZWZvcmUoKSB7IHJldHVybiB0aGlzLmRvY3MubGVuZ3RoID8gdGhpcy5kb2NzWzBdIDogdGhpcy5kb2M7IH1cbiAgICAvKipcbiAgICBBcHBseSBhIG5ldyBzdGVwIGluIHRoaXMgdHJhbnNmb3JtLCBzYXZpbmcgdGhlIHJlc3VsdC4gVGhyb3dzIGFuXG4gICAgZXJyb3Igd2hlbiB0aGUgc3RlcCBmYWlscy5cbiAgICAqL1xuICAgIHN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5tYXliZVN0ZXAoc3RlcCk7XG4gICAgICAgIGlmIChyZXN1bHQuZmFpbGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zZm9ybUVycm9yKHJlc3VsdC5mYWlsZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIGFwcGx5IGEgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybWF0aW9uLCBpZ25vcmluZyBpdCBpZiBpdFxuICAgIGZhaWxzLiBSZXR1cm5zIHRoZSBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIG1heWJlU3RlcChzdGVwKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzdGVwLmFwcGx5KHRoaXMuZG9jKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuZmFpbGVkKVxuICAgICAgICAgICAgdGhpcy5hZGRTdGVwKHN0ZXAsIHJlc3VsdC5kb2MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhlIGRvY3VtZW50IGhhcyBiZWVuIGNoYW5nZWQgKHdoZW4gdGhlcmUgYXJlIGFueVxuICAgIHN0ZXBzKS5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZFN0ZXAoc3RlcCwgZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jcy5wdXNoKHRoaXMuZG9jKTtcbiAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHN0ZXApO1xuICAgICAgICB0aGlzLm1hcHBpbmcuYXBwZW5kTWFwKHN0ZXAuZ2V0TWFwKCkpO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2Agd2l0aCB0aGVcbiAgICBnaXZlbiBgc2xpY2VgLlxuICAgICovXG4gICAgcmVwbGFjZShmcm9tLCB0byA9IGZyb20sIHNsaWNlID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgbGV0IHN0ZXAgPSByZXBsYWNlU3RlcCh0aGlzLmRvYywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgaWYgKHN0ZXApXG4gICAgICAgICAgICB0aGlzLnN0ZXAoc3RlcCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSB3aXRoIHRoZSBnaXZlbiBjb250ZW50LCB3aGljaCBtYXkgYmUgYVxuICAgIGZyYWdtZW50LCBub2RlLCBvciBhcnJheSBvZiBub2Rlcy5cbiAgICAqL1xuICAgIHJlcGxhY2VXaXRoKGZyb20sIHRvLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCAwLCAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBkZWxldGUoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgU2xpY2UuZW1wdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICBJbnNlcnQgdGhlIGdpdmVuIGNvbnRlbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaW5zZXJ0KHBvcywgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aChwb3MsIHBvcywgY29udGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIGdpdmVuIHNsaWNlLCB1c2luZ1xuICAgIGBmcm9tYCwgYHRvYCwgYW5kIHRoZSBzbGljZSdzXG4gICAgW2BvcGVuU3RhcnRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuU2xpY2Uub3BlblN0YXJ0KSBwcm9wZXJ0eSBhcyBoaW50cywgcmF0aGVyXG4gICAgdGhhbiBmaXhlZCBzdGFydCBhbmQgZW5kIHBvaW50cy4gVGhpcyBtZXRob2QgbWF5IGdyb3cgdGhlXG4gICAgcmVwbGFjZWQgYXJlYSBvciBjbG9zZSBvcGVuIG5vZGVzIGluIHRoZSBzbGljZSBpbiBvcmRlciB0byBnZXQgYVxuICAgIGZpdCB0aGF0IGlzIG1vcmUgaW4gbGluZSB3aXRoIFdZU0lXWUcgZXhwZWN0YXRpb25zLCBieSBkcm9wcGluZ1xuICAgIGZ1bGx5IGNvdmVyZWQgcGFyZW50IG5vZGVzIG9mIHRoZSByZXBsYWNlZCByZWdpb24gd2hlbiB0aGV5IGFyZVxuICAgIG1hcmtlZCBbbm9uLWRlZmluaW5nIGFzXG4gICAgY29udGV4dF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nQXNDb250ZXh0KSwgb3IgaW5jbHVkaW5nIGFuXG4gICAgb3BlbiBwYXJlbnQgbm9kZSBmcm9tIHRoZSBzbGljZSB0aGF0IF9pc18gbWFya2VkIGFzIFtkZWZpbmluZ1xuICAgIGl0cyBjb250ZW50XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmdGb3JDb250ZW50KS5cbiAgICBcbiAgICBUaGlzIGlzIHRoZSBtZXRob2QsIGZvciBleGFtcGxlLCB0byBoYW5kbGUgcGFzdGUuIFRoZSBzaW1pbGFyXG4gICAgW2ByZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5UcmFuc2Zvcm0ucmVwbGFjZSkgbWV0aG9kIGlzIGEgbW9yZVxuICAgIHByaW1pdGl2ZSB0b29sIHdoaWNoIHdpbGwgX25vdF8gbW92ZSB0aGUgc3RhcnQgYW5kIGVuZCBvZiBpdHMgZ2l2ZW5cbiAgICByYW5nZSwgYW5kIGlzIHVzZWZ1bCBpbiBzaXR1YXRpb25zIHdoZXJlIHlvdSBuZWVkIG1vcmUgcHJlY2lzZVxuICAgIGNvbnRyb2wgb3ZlciB3aGF0IGhhcHBlbnMuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCBhIG5vZGUsIGJ1dCB1c2UgYGZyb21gIGFuZCBgdG9gIGFzXG4gICAgaGludHMsIHJhdGhlciB0aGFuIHByZWNpc2UgcG9zaXRpb25zLiBXaGVuIGZyb20gYW5kIHRvIGFyZSB0aGUgc2FtZVxuICAgIGFuZCBhcmUgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIHBhcmVudCBub2RlIGluIHdoaWNoIHRoZSBnaXZlblxuICAgIG5vZGUgZG9lc24ndCBmaXQsIHRoaXMgbWV0aG9kIG1heSBfbW92ZV8gdGhlbSBvdXQgdG93YXJkcyBhIHBhcmVudFxuICAgIHRoYXQgZG9lcyBhbGxvdyB0aGUgZ2l2ZW4gbm9kZSB0byBiZSBwbGFjZWQuIFdoZW4gdGhlIGdpdmVuIHJhbmdlXG4gICAgY29tcGxldGVseSBjb3ZlcnMgYSBwYXJlbnQgbm9kZSwgdGhpcyBtZXRob2QgbWF5IGNvbXBsZXRlbHkgcmVwbGFjZVxuICAgIHRoYXQgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBub2RlKSB7XG4gICAgICAgIHJlcGxhY2VSYW5nZVdpdGgodGhpcywgZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBnaXZlbiByYW5nZSwgZXhwYW5kaW5nIGl0IHRvIGNvdmVyIGZ1bGx5IGNvdmVyZWRcbiAgICBwYXJlbnQgbm9kZXMgdW50aWwgYSB2YWxpZCByZXBsYWNlIGlzIGZvdW5kLlxuICAgICovXG4gICAgZGVsZXRlUmFuZ2UoZnJvbSwgdG8pIHtcbiAgICAgICAgZGVsZXRlUmFuZ2UodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU3BsaXQgdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlIG9mZiBmcm9tIGl0cyBwYXJlbnQsIGlmIHRoZXJlXG4gICAgaXMgc2libGluZyBjb250ZW50IGJlZm9yZSBvciBhZnRlciBpdCwgYW5kIG1vdmUgaXQgdXAgdGhlIHRyZWUgdG9cbiAgICB0aGUgZGVwdGggc3BlY2lmaWVkIGJ5IGB0YXJnZXRgLiBZb3UnbGwgcHJvYmFibHkgd2FudCB0byB1c2VcbiAgICBbYGxpZnRUYXJnZXRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLmxpZnRUYXJnZXQpIHRvIGNvbXB1dGUgYHRhcmdldGAsIHRvIG1ha2VcbiAgICBzdXJlIHRoZSBsaWZ0IGlzIHZhbGlkLlxuICAgICovXG4gICAgbGlmdChyYW5nZSwgdGFyZ2V0KSB7XG4gICAgICAgIGxpZnQodGhpcywgcmFuZ2UsIHRhcmdldCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBKb2luIHRoZSBibG9ja3MgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbi4gSWYgZGVwdGggaXMgMiwgdGhlaXJcbiAgICBsYXN0IGFuZCBmaXJzdCBzaWJsaW5ncyBhcmUgYWxzbyBqb2luZWQsIGFuZCBzbyBvbi5cbiAgICAqL1xuICAgIGpvaW4ocG9zLCBkZXB0aCA9IDEpIHtcbiAgICAgICAgam9pbih0aGlzLCBwb3MsIGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFdyYXAgdGhlIGdpdmVuIFtyYW5nZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZSkgaW4gdGhlIGdpdmVuIHNldCBvZiB3cmFwcGVycy5cbiAgICBUaGUgd3JhcHBlcnMgYXJlIGFzc3VtZWQgdG8gYmUgdmFsaWQgaW4gdGhpcyBwb3NpdGlvbiwgYW5kIHNob3VsZFxuICAgIHByb2JhYmx5IGJlIGNvbXB1dGVkIHdpdGggW2BmaW5kV3JhcHBpbmdgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLmZpbmRXcmFwcGluZykuXG4gICAgKi9cbiAgICB3cmFwKHJhbmdlLCB3cmFwcGVycykge1xuICAgICAgICB3cmFwKHRoaXMsIHJhbmdlLCB3cmFwcGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHR5cGUgb2YgYWxsIHRleHRibG9ja3MgKHBhcnRseSkgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AgdG9cbiAgICB0aGUgZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBzZXRCbG9ja1R5cGUoZnJvbSwgdG8gPSBmcm9tLCB0eXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICAgICAgc2V0QmxvY2tUeXBlKHRoaXMsIGZyb20sIHRvLCB0eXBlLCBhdHRycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGFuZ2UgdGhlIHR5cGUsIGF0dHJpYnV0ZXMsIGFuZC9vciBtYXJrcyBvZiB0aGUgbm9kZSBhdCBgcG9zYC5cbiAgICBXaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG4gICAgKi9cbiAgICBzZXROb2RlTWFya3VwKHBvcywgdHlwZSwgYXR0cnMgPSBudWxsLCBtYXJrcykge1xuICAgICAgICBzZXROb2RlTWFya3VwKHRoaXMsIHBvcywgdHlwZSwgYXR0cnMsIG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gYSBnaXZlbiBub2RlIHRvIGEgbmV3IHZhbHVlLlxuICAgIFRoZSBgcG9zYCBhZGRyZXNzZXMgdGhlIGRvY3VtZW50IGNvbnRlbnQuIFVzZSBgc2V0RG9jQXR0cmlidXRlYFxuICAgIHRvIHNldCBhdHRyaWJ1dGVzIG9uIHRoZSBkb2N1bWVudCBpdHNlbGYuXG4gICAgKi9cbiAgICBzZXROb2RlQXR0cmlidXRlKHBvcywgYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBBdHRyU3RlcChwb3MsIGF0dHIsIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgYSBzaW5nbGUgYXR0cmlidXRlIG9uIHRoZSBkb2N1bWVudCB0byBhIG5ldyB2YWx1ZS5cbiAgICAqL1xuICAgIHNldERvY0F0dHJpYnV0ZShhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IERvY0F0dHJTdGVwKGF0dHIsIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYSBtYXJrIHRvIHRoZSBub2RlIGF0IHBvc2l0aW9uIGBwb3NgLlxuICAgICovXG4gICAgYWRkTm9kZU1hcmsocG9zLCBtYXJrKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgQWRkTm9kZU1hcmtTdGVwKHBvcywgbWFyaykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIGEgbWFyayAob3IgYWxsIG1hcmtzIG9mIHRoZSBnaXZlbiB0eXBlKSBmcm9tIHRoZSBub2RlIGF0XG4gICAgcG9zaXRpb24gYHBvc2AuXG4gICAgKi9cbiAgICByZW1vdmVOb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRvYy5ub2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IHBvc2l0aW9uIFwiICsgcG9zKTtcbiAgICAgICAgaWYgKG1hcmsgaW5zdGFuY2VvZiBNYXJrKSB7XG4gICAgICAgICAgICBpZiAobWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RlcChuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcywgbWFyaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNldCA9IG5vZGUubWFya3MsIGZvdW5kLCBzdGVwcyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKGZvdW5kID0gbWFyay5pc0luU2V0KHNldCkpIHtcbiAgICAgICAgICAgICAgICBzdGVwcy5wdXNoKG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLCBmb3VuZCkpO1xuICAgICAgICAgICAgICAgIHNldCA9IGZvdW5kLnJlbW92ZUZyb21TZXQoc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGVwcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXAoc3RlcHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTcGxpdCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFuZCBvcHRpb25hbGx5LCBpZiBgZGVwdGhgIGlzXG4gICAgZ3JlYXRlciB0aGFuIG9uZSwgYW55IG51bWJlciBvZiBub2RlcyBhYm92ZSB0aGF0LiBCeSBkZWZhdWx0LCB0aGVcbiAgICBwYXJ0cyBzcGxpdCBvZmYgd2lsbCBpbmhlcml0IHRoZSBub2RlIHR5cGUgb2YgdGhlIG9yaWdpbmFsIG5vZGUuXG4gICAgVGhpcyBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFuIGFycmF5IG9mIHR5cGVzIGFuZCBhdHRyaWJ1dGVzIHRvXG4gICAgdXNlIGFmdGVyIHRoZSBzcGxpdCAod2l0aCB0aGUgb3V0ZXJtb3N0IG5vZGVzIGNvbWluZyBmaXJzdCkuXG4gICAgKi9cbiAgICBzcGxpdChwb3MsIGRlcHRoID0gMSwgdHlwZXNBZnRlcikge1xuICAgICAgICBzcGxpdCh0aGlzLCBwb3MsIGRlcHRoLCB0eXBlc0FmdGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCB0aGUgZ2l2ZW4gbWFyayB0byB0aGUgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuXG4gICAgKi9cbiAgICBhZGRNYXJrKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgICAgIGFkZE1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIG1hcmtzIGZyb20gaW5saW5lIG5vZGVzIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLiBXaGVuXG4gICAgYG1hcmtgIGlzIGEgc2luZ2xlIG1hcmssIHJlbW92ZSBwcmVjaXNlbHkgdGhhdCBtYXJrLiBXaGVuIGl0IGlzXG4gICAgYSBtYXJrIHR5cGUsIHJlbW92ZSBhbGwgbWFya3Mgb2YgdGhhdCB0eXBlLiBXaGVuIGl0IGlzIG51bGwsXG4gICAgcmVtb3ZlIGFsbCBtYXJrcyBvZiBhbnkgdHlwZS5cbiAgICAqL1xuICAgIHJlbW92ZU1hcmsoZnJvbSwgdG8sIG1hcmspIHtcbiAgICAgICAgcmVtb3ZlTWFyayh0aGlzLCBmcm9tLCB0bywgbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIGFsbCBtYXJrcyBhbmQgbm9kZXMgZnJvbSB0aGUgY29udGVudCBvZiB0aGUgbm9kZSBhdFxuICAgIGBwb3NgIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIGdpdmVuIG5ldyBwYXJlbnQgbm9kZSB0eXBlLiBBY2NlcHRzXG4gICAgYW4gb3B0aW9uYWwgc3RhcnRpbmcgW2NvbnRlbnQgbWF0Y2hdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Db250ZW50TWF0Y2gpIGFzXG4gICAgdGhpcmQgYXJndW1lbnQuXG4gICAgKi9cbiAgICBjbGVhckluY29tcGF0aWJsZShwb3MsIHBhcmVudFR5cGUsIG1hdGNoKSB7XG4gICAgICAgIGNsZWFySW5jb21wYXRpYmxlKHRoaXMsIHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFkZE1hcmtTdGVwLCBBZGROb2RlTWFya1N0ZXAsIEF0dHJTdGVwLCBEb2NBdHRyU3RlcCwgTWFwUmVzdWx0LCBNYXBwaW5nLCBSZW1vdmVNYXJrU3RlcCwgUmVtb3ZlTm9kZU1hcmtTdGVwLCBSZXBsYWNlQXJvdW5kU3RlcCwgUmVwbGFjZVN0ZXAsIFN0ZXAsIFN0ZXBNYXAsIFN0ZXBSZXN1bHQsIFRyYW5zZm9ybSwgVHJhbnNmb3JtRXJyb3IsIGNhbkpvaW4sIGNhblNwbGl0LCBkcm9wUG9pbnQsIGZpbmRXcmFwcGluZywgaW5zZXJ0UG9pbnQsIGpvaW5Qb2ludCwgbGlmdFRhcmdldCwgcmVwbGFjZVN0ZXAgfTtcbiIsICJpbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQsIE1hcmssIE5vZGUgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFRyYW5zZm9ybSB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbmNvbnN0IGNsYXNzZXNCeUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuU3VwZXJjbGFzcyBmb3IgZWRpdG9yIHNlbGVjdGlvbnMuIEV2ZXJ5IHNlbGVjdGlvbiB0eXBlIHNob3VsZFxuZXh0ZW5kIHRoaXMuIFNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LlxuKi9cbmNsYXNzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgSW5pdGlhbGl6ZSBhIHNlbGVjdGlvbiB3aXRoIHRoZSBoZWFkIGFuZCBhbmNob3IgYW5kIHJhbmdlcy4gSWYgbm9cbiAgICByYW5nZXMgYXJlIGdpdmVuLCBjb25zdHJ1Y3RzIGEgc2luZ2xlIHJhbmdlIGFjcm9zcyBgJGFuY2hvcmAgYW5kXG4gICAgYCRoZWFkYC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBhbmNob3Igb2YgdGhlIHNlbGVjdGlvbiAodGhlIHNpZGUgdGhhdCBzdGF5cyBpblxuICAgIHBsYWNlIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBtb2RpZmllZCkuXG4gICAgKi9cbiAgICAkYW5jaG9yLCBcbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgaGVhZCBvZiB0aGUgc2VsZWN0aW9uICh0aGUgc2lkZSB0aGF0IG1vdmVzIHdoZW5cbiAgICB0aGUgc2VsZWN0aW9uIGlzIG1vZGlmaWVkKS5cbiAgICAqL1xuICAgICRoZWFkLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy4kYW5jaG9yID0gJGFuY2hvcjtcbiAgICAgICAgdGhpcy4kaGVhZCA9ICRoZWFkO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcyB8fCBbbmV3IFNlbGVjdGlvblJhbmdlKCRhbmNob3IubWluKCRoZWFkKSwgJGFuY2hvci5tYXgoJGhlYWQpKV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBhbmNob3IsIGFzIGFuIHVucmVzb2x2ZWQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgYW5jaG9yKCkgeyByZXR1cm4gdGhpcy4kYW5jaG9yLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24ncyBoZWFkLlxuICAgICovXG4gICAgZ2V0IGhlYWQoKSB7IHJldHVybiB0aGlzLiRoZWFkLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy4kZnJvbS5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLiR0by5wb3M7IH1cbiAgICAvKipcbiAgICBUaGUgcmVzb2x2ZWQgbG93ZXIgIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0ICRmcm9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbMF0uJGZyb207XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCB1cHBlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCAkdG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS4kdG87XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gY29udGFpbnMgYW55IGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAocmFuZ2VzW2ldLiRmcm9tLnBvcyAhPSByYW5nZXNbaV0uJHRvLnBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRlbnQgb2YgdGhpcyBzZWxlY3Rpb24gYXMgYSBzbGljZS5cbiAgICAqL1xuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRmcm9tLmRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8sIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIHNsaWNlIG9yLCBpZiBubyBzbGljZSBpcyBnaXZlbixcbiAgICBkZWxldGUgdGhlIHNlbGVjdGlvbi4gV2lsbCBhcHBlbmQgdG8gdGhlIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgcmVwbGFjZSh0ciwgY29udGVudCA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIC8vIFB1dCB0aGUgbmV3IHNlbGVjdGlvbiBhdCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIGluc2VydGVkXG4gICAgICAgIC8vIGNvbnRlbnQuIFdoZW4gdGhhdCBlbmRlZCBpbiBhbiBpbmxpbmUgbm9kZSwgc2VhcmNoIGJhY2t3YXJkcyxcbiAgICAgICAgLy8gdG8gZ2V0IHRoZSBwb3NpdGlvbiBhZnRlciB0aGF0IG5vZGUuIElmIG5vdCwgc2VhcmNoIGZvcndhcmQuXG4gICAgICAgIGxldCBsYXN0Tm9kZSA9IGNvbnRlbnQuY29udGVudC5sYXN0Q2hpbGQsIGxhc3RQYXJlbnQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQub3BlbkVuZDsgaSsrKSB7XG4gICAgICAgICAgICBsYXN0UGFyZW50ID0gbGFzdE5vZGU7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aCwgcmFuZ2VzID0gdGhpcy5yYW5nZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgICAgICAgdHIucmVwbGFjZVJhbmdlKG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIG1hcHBpbmcubWFwKCR0by5wb3MpLCBpID8gU2xpY2UuZW1wdHkgOiBjb250ZW50KTtcbiAgICAgICAgICAgIGlmIChpID09IDApXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIChsYXN0Tm9kZSA/IGxhc3ROb2RlLmlzSW5saW5lIDogbGFzdFBhcmVudCAmJiBsYXN0UGFyZW50LmlzVGV4dGJsb2NrKSA/IC0xIDogMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUsIGFwcGVuZGluZyB0aGUgY2hhbmdlc1xuICAgIHRvIHRoZSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHJlcGxhY2VXaXRoKHRyLCBub2RlKSB7XG4gICAgICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXSwgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKCRmcm9tLnBvcyksIHRvID0gbWFwcGluZy5tYXAoJHRvLnBvcyk7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBtYXBGcm9tLCBub2RlLmlzSW5saW5lID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gc3RhcnRpbmcgYXQgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24gYW5kIHNlYXJjaGluZyBiYWNrIGlmIGBkaXJgIGlzIG5lZ2F0aXZlLCBhbmQgZm9yd2FyZCBpZlxuICAgIHBvc2l0aXZlLiBXaGVuIGB0ZXh0T25seWAgaXMgdHJ1ZSwgb25seSBjb25zaWRlciBjdXJzb3JcbiAgICBzZWxlY3Rpb25zLiBXaWxsIHJldHVybiBudWxsIHdoZW4gbm8gdmFsaWQgc2VsZWN0aW9uIHBvc2l0aW9uIGlzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb20oJHBvcywgZGlyLCB0ZXh0T25seSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpbm5lciA9ICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQgPyBuZXcgVGV4dFNlbGVjdGlvbigkcG9zKVxuICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLnBhcmVudCwgJHBvcy5wb3MsICRwb3MuaW5kZXgoKSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoIC0gMTsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZGlyIDwgMFxuICAgICAgICAgICAgICAgID8gZmluZFNlbGVjdGlvbkluKCRwb3Mubm9kZSgwKSwgJHBvcy5ub2RlKGRlcHRoKSwgJHBvcy5iZWZvcmUoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCksIGRpciwgdGV4dE9ubHkpXG4gICAgICAgICAgICAgICAgOiBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLm5vZGUoZGVwdGgpLCAkcG9zLmFmdGVyKGRlcHRoICsgMSksICRwb3MuaW5kZXgoZGVwdGgpICsgMSwgZGlyLCB0ZXh0T25seSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgdmFsaWQgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gbmVhciB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbi4gU2VhcmNoZXMgZm9yd2FyZCBmaXJzdCBieSBkZWZhdWx0LCBidXQgaWYgYGJpYXNgIGlzXG4gICAgbmVnYXRpdmUsIGl0IHdpbGwgc2VhcmNoIGJhY2t3YXJkcyBmaXJzdC5cbiAgICAqL1xuICAgIHN0YXRpYyBuZWFyKCRwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRGcm9tKCRwb3MsIGJpYXMpIHx8IHRoaXMuZmluZEZyb20oJHBvcywgLWJpYXMpIHx8IG5ldyBBbGxTZWxlY3Rpb24oJHBvcy5ub2RlKDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gY2xvc2VzdCB0byB0aGUgc3RhcnQgb2ZcbiAgICB0aGUgZ2l2ZW4gZG9jdW1lbnQuIFdpbGwgcmV0dXJuIGFuXG4gICAgW2BBbGxTZWxlY3Rpb25gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuQWxsU2VsZWN0aW9uKSBpZiBubyB2YWxpZCBwb3NpdGlvblxuICAgIGV4aXN0cy5cbiAgICAqL1xuICAgIHN0YXRpYyBhdFN0YXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gZmluZFNlbGVjdGlvbkluKGRvYywgZG9jLCAwLCAwLCAxKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGN1cnNvciBvciBsZWFmIG5vZGUgc2VsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBhdEVuZChkb2MpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRTZWxlY3Rpb25Jbihkb2MsIGRvYywgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jLmNoaWxkQ291bnQsIC0xKSB8fCBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc2VsZWN0aW9uLiBNdXN0IGJlXG4gICAgaW1wbGVtZW50ZWQgZm9yIGN1c3RvbSBjbGFzc2VzIChhcyBhIHN0YXRpYyBjbGFzcyBtZXRob2QpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIWpzb24udHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgY2xzID0gY2xhc3Nlc0J5SWRbanNvbi50eXBlXTtcbiAgICAgICAgaWYgKCFjbHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gc2VsZWN0aW9uIHR5cGUgJHtqc29uLnR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIGNscy5mcm9tSlNPTihkb2MsIGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIGRlc2VyaWFsaXplIHNlbGVjdGlvbnMgZnJvbSBKU09OLCBjdXN0b20gc2VsZWN0aW9uXG4gICAgY2xhc3NlcyBtdXN0IHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCBhbiBJRCBzdHJpbmcsIHNvIHRoYXQgdGhleVxuICAgIGNhbiBiZSBkaXNhbWJpZ3VhdGVkLiBUcnkgdG8gcGljayBzb21ldGhpbmcgdGhhdCdzIHVubGlrZWx5IHRvXG4gICAgY2xhc2ggd2l0aCBjbGFzc2VzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHNlbGVjdGlvbkNsYXNzKSB7XG4gICAgICAgIGlmIChpZCBpbiBjbGFzc2VzQnlJZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzZWxlY3Rpb24gSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgY2xhc3Nlc0J5SWRbaWRdID0gc2VsZWN0aW9uQ2xhc3M7XG4gICAgICAgIHNlbGVjdGlvbkNsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbkNsYXNzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbYm9va21hcmtdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25Cb29rbWFyaykgZm9yIHRoaXMgc2VsZWN0aW9uLFxuICAgIHdoaWNoIGlzIGEgdmFsdWUgdGhhdCBjYW4gYmUgbWFwcGVkIHdpdGhvdXQgaGF2aW5nIGFjY2VzcyB0byBhXG4gICAgY3VycmVudCBkb2N1bWVudCwgYW5kIGxhdGVyIHJlc29sdmVkIHRvIGEgcmVhbCBzZWxlY3Rpb24gZm9yIGFcbiAgICBnaXZlbiBkb2N1bWVudCBhZ2Fpbi4gKFRoaXMgaXMgdXNlZCBtb3N0bHkgYnkgdGhlIGhpc3RvcnkgdG9cbiAgICB0cmFjayBhbmQgcmVzdG9yZSBvbGQgc2VsZWN0aW9ucy4pIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mXG4gICAgdGhpcyBtZXRob2QganVzdCBjb252ZXJ0cyB0aGUgc2VsZWN0aW9uIHRvIGEgdGV4dCBzZWxlY3Rpb24gYW5kXG4gICAgcmV0dXJucyB0aGUgYm9va21hcmsgZm9yIHRoYXQuXG4gICAgKi9cbiAgICBnZXRCb29rbWFyaygpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbih0aGlzLiRhbmNob3IsIHRoaXMuJGhlYWQpLmdldEJvb2ttYXJrKCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gdHJ1ZTtcbi8qKlxuUmVwcmVzZW50cyBhIHNlbGVjdGVkIHJhbmdlIGluIGEgZG9jdW1lbnQuXG4qL1xuY2xhc3MgU2VsZWN0aW9uUmFuZ2Uge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgICRmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgJHRvKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgfVxufVxubGV0IHdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gY2hlY2tUZXh0U2VsZWN0aW9uKCRwb3MpIHtcbiAgICBpZiAoIXdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiAmJiAhJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICB3YXJuZWRBYm91dFRleHRTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlRleHRTZWxlY3Rpb24gZW5kcG9pbnQgbm90IHBvaW50aW5nIGludG8gYSBub2RlIHdpdGggaW5saW5lIGNvbnRlbnQgKFwiICsgJHBvcy5wYXJlbnQudHlwZS5uYW1lICsgXCIpXCIpO1xuICAgIH1cbn1cbi8qKlxuQSB0ZXh0IHNlbGVjdGlvbiByZXByZXNlbnRzIGEgY2xhc3NpY2FsIGVkaXRvciBzZWxlY3Rpb24sIHdpdGggYVxuaGVhZCAodGhlIG1vdmluZyBzaWRlKSBhbmQgYW5jaG9yIChpbW1vYmlsZSBzaWRlKSwgYm90aCBvZiB3aGljaFxucG9pbnQgaW50byB0ZXh0YmxvY2sgbm9kZXMuIEl0IGNhbiBiZSBlbXB0eSAoYSByZWd1bGFyIGN1cnNvclxucG9zaXRpb24pLlxuKi9cbmNsYXNzIFRleHRTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHRleHQgc2VsZWN0aW9uIGJldHdlZW4gdGhlIGdpdmVuIHBvaW50cy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRhbmNob3IsICRoZWFkID0gJGFuY2hvcikge1xuICAgICAgICBjaGVja1RleHRTZWxlY3Rpb24oJGFuY2hvcik7XG4gICAgICAgIGNoZWNrVGV4dFNlbGVjdGlvbigkaGVhZCk7XG4gICAgICAgIHN1cGVyKCRhbmNob3IsICRoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJlc29sdmVkIHBvc2l0aW9uIGlmIHRoaXMgaXMgYSBjdXJzb3Igc2VsZWN0aW9uIChhblxuICAgIGVtcHR5IHRleHQgc2VsZWN0aW9uKSwgYW5kIG51bGwgb3RoZXJ3aXNlLlxuICAgICovXG4gICAgZ2V0ICRjdXJzb3IoKSB7IHJldHVybiB0aGlzLiRhbmNob3IucG9zID09IHRoaXMuJGhlYWQucG9zID8gdGhpcy4kaGVhZCA6IG51bGw7IH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICBpZiAoISRoZWFkLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkKTtcbiAgICAgICAgbGV0ICRhbmNob3IgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmFuY2hvcikpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCA/ICRhbmNob3IgOiAkaGVhZCwgJGhlYWQpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgc3VwZXIucmVwbGFjZSh0ciwgY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50ID09IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSB0aGlzLiRmcm9tLm1hcmtzQWNyb3NzKHRoaXMuJHRvKTtcbiAgICAgICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRCb29rbWFyayh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgYW5jaG9yOiB0aGlzLmFuY2hvciwgaGVhZDogdGhpcy5oZWFkIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBUZXh0U2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpLCBkb2MucmVzb2x2ZShqc29uLmhlYWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGFuY2hvciwgaGVhZCA9IGFuY2hvcikge1xuICAgICAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcygkYW5jaG9yLCBoZWFkID09IGFuY2hvciA/ICRhbmNob3IgOiBkb2MucmVzb2x2ZShoZWFkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHRleHQgc2VsZWN0aW9uIHRoYXQgc3BhbnMgdGhlIGdpdmVuIHBvc2l0aW9ucyBvciwgaWZcbiAgICB0aGV5IGFyZW4ndCB0ZXh0IHBvc2l0aW9ucywgZmluZCBhIHRleHQgc2VsZWN0aW9uIG5lYXIgdGhlbS5cbiAgICBgYmlhc2AgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtZXRob2Qgc2VhcmNoZXMgZm9yd2FyZCAoZGVmYXVsdClcbiAgICBvciBiYWNrd2FyZHMgKG5lZ2F0aXZlIG51bWJlcikgZmlyc3QuIFdpbGwgZmFsbCBiYWNrIHRvIGNhbGxpbmdcbiAgICBbYFNlbGVjdGlvbi5uZWFyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbl5uZWFyKSB3aGVuIHRoZSBkb2N1bWVudFxuICAgIGRvZXNuJ3QgY29udGFpbiBhIHZhbGlkIHRleHQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgYmV0d2VlbigkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICAgICAgICBsZXQgZFBvcyA9ICRhbmNob3IucG9zIC0gJGhlYWQucG9zO1xuICAgICAgICBpZiAoIWJpYXMgfHwgZFBvcylcbiAgICAgICAgICAgIGJpYXMgPSBkUG9zID49IDAgPyAxIDogLTE7XG4gICAgICAgIGlmICghJGhlYWQucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IFNlbGVjdGlvbi5maW5kRnJvbSgkaGVhZCwgYmlhcywgdHJ1ZSkgfHwgU2VsZWN0aW9uLmZpbmRGcm9tKCRoZWFkLCAtYmlhcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgJGhlYWQgPSBmb3VuZC4kaGVhZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQsIGJpYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJGFuY2hvci5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgaWYgKGRQb3MgPT0gMCkge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAkaGVhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICRhbmNob3IgPSAoU2VsZWN0aW9uLmZpbmRGcm9tKCRhbmNob3IsIC1iaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGFuY2hvciwgYmlhcywgdHJ1ZSkpLiRhbmNob3I7XG4gICAgICAgICAgICAgICAgaWYgKCgkYW5jaG9yLnBvcyA8ICRoZWFkLnBvcykgIT0gKGRQb3MgPCAwKSlcbiAgICAgICAgICAgICAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLCAkaGVhZCk7XG4gICAgfVxufVxuU2VsZWN0aW9uLmpzb25JRChcInRleHRcIiwgVGV4dFNlbGVjdGlvbik7XG5jbGFzcyBUZXh0Qm9va21hcmsge1xuICAgIGNvbnN0cnVjdG9yKGFuY2hvciwgaGVhZCkge1xuICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Qm9va21hcmsobWFwcGluZy5tYXAodGhpcy5hbmNob3IpLCBtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uYmV0d2Vlbihkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIGRvYy5yZXNvbHZlKHRoaXMuaGVhZCkpO1xuICAgIH1cbn1cbi8qKlxuQSBub2RlIHNlbGVjdGlvbiBpcyBhIHNlbGVjdGlvbiB0aGF0IHBvaW50cyBhdCBhIHNpbmdsZSBub2RlLiBBbGxcbm5vZGVzIG1hcmtlZCBbc2VsZWN0YWJsZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLnNlbGVjdGFibGUpIGNhbiBiZSB0aGVcbnRhcmdldCBvZiBhIG5vZGUgc2VsZWN0aW9uLiBJbiBzdWNoIGEgc2VsZWN0aW9uLCBgZnJvbWAgYW5kIGB0b2BcbnBvaW50IGRpcmVjdGx5IGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHNlbGVjdGVkIG5vZGUsIGBhbmNob3JgIGVxdWFsc1xuYGZyb21gLCBhbmQgYGhlYWRgIGVxdWFscyBgdG9gLi5cbiovXG5jbGFzcyBOb2RlU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIHNlbGVjdGlvbi4gRG9lcyBub3QgdmVyaWZ5IHRoZSB2YWxpZGl0eSBvZiBpdHNcbiAgICBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCRwb3MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgbGV0ICRlbmQgPSAkcG9zLm5vZGUoMCkucmVzb2x2ZSgkcG9zLnBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgICBzdXBlcigkcG9zLCAkZW5kKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICBpZiAoZGVsZXRlZClcbiAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odGhpcy5ub2RlKSwgMCwgMCk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgb3RoZXIuYW5jaG9yID09IHRoaXMuYW5jaG9yO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibm9kZVwiLCBhbmNob3I6IHRoaXMuYW5jaG9yIH07XG4gICAgfVxuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IE5vZGVCb29rbWFyayh0aGlzLmFuY2hvcik7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmFuY2hvciAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlU2VsZWN0aW9uLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oZG9jLnJlc29sdmUoanNvbi5hbmNob3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbm9kZSBzZWxlY3Rpb24gZnJvbSBub24tcmVzb2x2ZWQgcG9zaXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGZyb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGZyb20pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIG1heSBiZSBzZWxlY3RlZCBhcyBhIG5vZGVcbiAgICBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgaXNTZWxlY3RhYmxlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFub2RlLmlzVGV4dCAmJiBub2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZTtcbiAgICB9XG59XG5Ob2RlU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5TZWxlY3Rpb24uanNvbklEKFwibm9kZVwiLCBOb2RlU2VsZWN0aW9uKTtcbmNsYXNzIE5vZGVCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgeyBkZWxldGVkLCBwb3MgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuYW5jaG9yKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQgPyBuZXcgVGV4dEJvb2ttYXJrKHBvcywgcG9zKSA6IG5ldyBOb2RlQm9va21hcmsocG9zKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksIG5vZGUgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyk7XG4gICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG59XG4vKipcbkEgc2VsZWN0aW9uIHR5cGUgdGhhdCByZXByZXNlbnRzIHNlbGVjdGluZyB0aGUgd2hvbGUgZG9jdW1lbnRcbih3aGljaCBjYW4gbm90IG5lY2Vzc2FyaWx5IGJlIGV4cHJlc3NlZCB3aXRoIGEgdGV4dCBzZWxlY3Rpb24sIHdoZW5cbnRoZXJlIGFyZSBmb3IgZXhhbXBsZSBsZWFmIGJsb2NrIG5vZGVzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgdGhlXG5kb2N1bWVudCkuXG4qL1xuY2xhc3MgQWxsU2VsZWN0aW9uIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gYWxsLXNlbGVjdGlvbiBvdmVyIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICBzdXBlcihkb2MucmVzb2x2ZSgwKSwgZG9jLnJlc29sdmUoZG9jLmNvbnRlbnQuc2l6ZSkpO1xuICAgIH1cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgwLCB0ci5kb2MuY29udGVudC5zaXplKTtcbiAgICAgICAgICAgIGxldCBzZWwgPSBTZWxlY3Rpb24uYXRTdGFydCh0ci5kb2MpO1xuICAgICAgICAgICAgaWYgKCFzZWwuZXEodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLnJlcGxhY2UodHIsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHsgcmV0dXJuIHsgdHlwZTogXCJhbGxcIiB9OyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBtYXAoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb247IH1cbiAgICBnZXRCb29rbWFyaygpIHsgcmV0dXJuIEFsbEJvb2ttYXJrOyB9XG59XG5TZWxlY3Rpb24uanNvbklEKFwiYWxsXCIsIEFsbFNlbGVjdGlvbik7XG5jb25zdCBBbGxCb29rbWFyayA9IHtcbiAgICBtYXAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgIHJlc29sdmUoZG9jKSB7IHJldHVybiBuZXcgQWxsU2VsZWN0aW9uKGRvYyk7IH1cbn07XG4vLyBGSVhNRSB3ZSdsbCBuZWVkIHNvbWUgYXdhcmVuZXNzIG9mIHRleHQgZGlyZWN0aW9uIHdoZW4gc2Nhbm5pbmcgZm9yIHNlbGVjdGlvbnNcbi8vIFRyeSB0byBmaW5kIGEgc2VsZWN0aW9uIGluc2lkZSB0aGUgZ2l2ZW4gbm9kZS4gYHBvc2AgcG9pbnRzIGF0IHRoZVxuLy8gcG9zaXRpb24gd2hlcmUgdGhlIHNlYXJjaCBzdGFydHMuIFdoZW4gYHRleHRgIGlzIHRydWUsIG9ubHkgcmV0dXJuXG4vLyB0ZXh0IHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBub2RlLCBwb3MsIGluZGV4LCBkaXIsIHRleHQgPSBmYWxzZSkge1xuICAgIGlmIChub2RlLmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyk7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gKGRpciA+IDAgPyAwIDogMSk7IGRpciA+IDAgPyBpIDwgbm9kZS5jaGlsZENvdW50IDogaSA+PSAwOyBpICs9IGRpcikge1xuICAgICAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkKGkpO1xuICAgICAgICBpZiAoIWNoaWxkLmlzQXRvbSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZFNlbGVjdGlvbkluKGRvYywgY2hpbGQsIHBvcyArIGRpciwgZGlyIDwgMCA/IGNoaWxkLmNoaWxkQ291bnQgOiAwLCBkaXIsIHRleHQpO1xuICAgICAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbm5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGV4dCAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHBvcyAtIChkaXIgPCAwID8gY2hpbGQubm9kZVNpemUgOiAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplICogZGlyO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCBzdGFydExlbiwgYmlhcykge1xuICAgIGxldCBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA8IHN0YXJ0TGVuKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcbiAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbbGFzdF0sIGVuZDtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiB7IGlmIChlbmQgPT0gbnVsbClcbiAgICAgICAgZW5kID0gbmV3VG87IH0pO1xuICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSk7XG59XG5cbmNvbnN0IFVQREFURURfU0VMID0gMSwgVVBEQVRFRF9NQVJLUyA9IDIsIFVQREFURURfU0NST0xMID0gNDtcbi8qKlxuQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uLCB3aGljaCBjYW4gYmUgYXBwbGllZCB0byBhIHN0YXRlIHRvXG5jcmVhdGUgYW4gdXBkYXRlZCBzdGF0ZS4gVXNlXG5bYEVkaXRvclN0YXRlLnRyYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRyKSB0byBjcmVhdGUgYW4gaW5zdGFuY2UuXG5cblRyYW5zYWN0aW9ucyB0cmFjayBjaGFuZ2VzIHRvIHRoZSBkb2N1bWVudCAodGhleSBhcmUgYSBzdWJjbGFzcyBvZlxuW2BUcmFuc2Zvcm1gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlRyYW5zZm9ybSkpLCBidXQgYWxzbyBvdGhlciBzdGF0ZSBjaGFuZ2VzLFxubGlrZSBzZWxlY3Rpb24gdXBkYXRlcyBhbmQgYWRqdXN0bWVudHMgb2YgdGhlIHNldCBvZiBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKS4gSW4gYWRkaXRpb24sIHlvdSBjYW4gc3RvcmVcbm1ldGFkYXRhIHByb3BlcnRpZXMgaW4gYSB0cmFuc2FjdGlvbiwgd2hpY2ggYXJlIGV4dHJhIHBpZWNlcyBvZlxuaW5mb3JtYXRpb24gdGhhdCBjbGllbnQgY29kZSBvciBwbHVnaW5zIGNhbiB1c2UgdG8gZGVzY3JpYmUgd2hhdCBhXG50cmFuc2FjdGlvbiByZXByZXNlbnRzLCBzbyB0aGF0IHRoZXkgY2FuIHVwZGF0ZSB0aGVpciBbb3duXG5zdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQpIGFjY29yZGluZ2x5LlxuXG5UaGUgW2VkaXRvciB2aWV3XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3KSB1c2VzIGEgZmV3IG1ldGFkYXRhXG5wcm9wZXJ0aWVzOiBpdCB3aWxsIGF0dGFjaCBhIHByb3BlcnR5IGBcInBvaW50ZXJcImAgd2l0aCB0aGUgdmFsdWVcbmB0cnVlYCB0byBzZWxlY3Rpb24gdHJhbnNhY3Rpb25zIGRpcmVjdGx5IGNhdXNlZCBieSBtb3VzZSBvciB0b3VjaFxuaW5wdXQsIGEgYFwiY29tcG9zaXRpb25cImAgcHJvcGVydHkgaG9sZGluZyBhbiBJRCBpZGVudGlmeWluZyB0aGVcbmNvbXBvc2l0aW9uIHRoYXQgY2F1c2VkIGl0IHRvIHRyYW5zYWN0aW9ucyBjYXVzZWQgYnkgY29tcG9zZWQgRE9NXG5pbnB1dCwgYW5kIGEgYFwidWlFdmVudFwiYCBwcm9wZXJ0eSBvZiB0aGF0IG1heSBiZSBgXCJwYXN0ZVwiYCxcbmBcImN1dFwiYCwgb3IgYFwiZHJvcFwiYC5cbiovXG5jbGFzcyBUcmFuc2FjdGlvbiBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICBzdXBlcihzdGF0ZS5kb2MpO1xuICAgICAgICAvLyBUaGUgc3RlcCBjb3VudCBmb3Igd2hpY2ggdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIHZhbGlkLlxuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbkZvciA9IDA7XG4gICAgICAgIC8vIEJpdGZpZWxkIHRvIHRyYWNrIHdoaWNoIGFzcGVjdHMgb2YgdGhlIHN0YXRlIHdlcmUgdXBkYXRlZCBieVxuICAgICAgICAvLyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAgICB0aGlzLnVwZGF0ZWQgPSAwO1xuICAgICAgICAvLyBPYmplY3QgdXNlZCB0byBzdG9yZSBtZXRhZGF0YSBwcm9wZXJ0aWVzIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMubWV0YSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbidzIGN1cnJlbnQgc2VsZWN0aW9uLiBUaGlzIGRlZmF1bHRzIHRvIHRoZSBlZGl0b3JcbiAgICBzZWxlY3Rpb24gW21hcHBlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbi5tYXApIHRocm91Z2ggdGhlIHN0ZXBzIGluIHRoZVxuICAgIHRyYW5zYWN0aW9uLCBidXQgY2FuIGJlIG92ZXJ3cml0dGVuIHdpdGhcbiAgICBbYHNldFNlbGVjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZXRTZWxlY3Rpb24pLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyU2VsZWN0aW9uRm9yIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uID0gdGhpcy5jdXJTZWxlY3Rpb24ubWFwKHRoaXMuZG9jLCB0aGlzLm1hcHBpbmcuc2xpY2UodGhpcy5jdXJTZWxlY3Rpb25Gb3IpKTtcbiAgICAgICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyU2VsZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHRyYW5zYWN0aW9uJ3MgY3VycmVudCBzZWxlY3Rpb24uIFdpbGwgZGV0ZXJtaW5lIHRoZVxuICAgIHNlbGVjdGlvbiB0aGF0IHRoZSBlZGl0b3IgZ2V0cyB3aGVuIHRoZSB0cmFuc2FjdGlvbiBpcyBhcHBsaWVkLlxuICAgICovXG4gICAgc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLmRvYyAhPSB0aGlzLmRvYylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBhc3NlZCB0byBzZXRTZWxlY3Rpb24gbXVzdCBwb2ludCBhdCB0aGUgY3VycmVudCBkb2N1bWVudFwiKTtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gdGhpcy5zdGVwcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9ICh0aGlzLnVwZGF0ZWQgfCBVUERBVEVEX1NFTCkgJiB+VVBEQVRFRF9NQVJLUztcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgdXBkYXRlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX1NFTCkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIGN1cnJlbnQgc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgc2V0U3RvcmVkTWFya3MobWFya3MpIHtcbiAgICAgICAgdGhpcy5zdG9yZWRNYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9NQVJLUztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIE1ha2Ugc3VyZSB0aGUgY3VycmVudCBzdG9yZWQgbWFya3Mgb3IsIGlmIHRoYXQgaXMgbnVsbCwgdGhlIG1hcmtzXG4gICAgYXQgdGhlIHNlbGVjdGlvbiwgbWF0Y2ggdGhlIGdpdmVuIHNldCBvZiBtYXJrcy4gRG9lcyBub3RoaW5nIGlmXG4gICAgdGhpcyBpcyBhbHJlYWR5IHRoZSBjYXNlLlxuICAgICovXG4gICAgZW5zdXJlTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpLCBtYXJrcykpXG4gICAgICAgICAgICB0aGlzLnNldFN0b3JlZE1hcmtzKG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIHNldCBvZiBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICBhZGRTdG9yZWRNYXJrKG1hcmspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlTWFya3MobWFyay5hZGRUb1NldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIGEgbWFyayBvciBtYXJrIHR5cGUgZnJvbSB0aGUgc2V0IG9mIHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIHJlbW92ZVN0b3JlZE1hcmsobWFyaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVNYXJrcyhtYXJrLnJlbW92ZUZyb21TZXQodGhpcy5zdG9yZWRNYXJrcyB8fCB0aGlzLnNlbGVjdGlvbi4kaGVhZC5tYXJrcygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHN0b3JlZCBtYXJrcyB3ZXJlIGV4cGxpY2l0bHkgc2V0IGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgZ2V0IHN0b3JlZE1hcmtzU2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfTUFSS1MpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICBzdXBlci5hZGRTdGVwKHN0ZXAsIGRvYyk7XG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHRoaXMudXBkYXRlZCAmIH5VUERBVEVEX01BUktTO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB0aW1lc3RhbXAgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNldFRpbWUodGltZSkge1xuICAgICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gc2xpY2UuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uKHNsaWNlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5vZGUuIFdoZW4gYGluaGVyaXRNYXJrc2AgaXNcbiAgICB0cnVlIGFuZCB0aGUgY29udGVudCBpcyBpbmxpbmUsIGl0IGluaGVyaXRzIHRoZSBtYXJrcyBmcm9tIHRoZVxuICAgIHBsYWNlIHdoZXJlIGl0IGlzIGluc2VydGVkLlxuICAgICovXG4gICAgcmVwbGFjZVNlbGVjdGlvbldpdGgobm9kZSwgaW5oZXJpdE1hcmtzID0gdHJ1ZSkge1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGlmIChpbmhlcml0TWFya3MpXG4gICAgICAgICAgICBub2RlID0gbm9kZS5tYXJrKHRoaXMuc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi5lbXB0eSA/IHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpIDogKHNlbGVjdGlvbi4kZnJvbS5tYXJrc0Fjcm9zcyhzZWxlY3Rpb24uJHRvKSB8fCBNYXJrLm5vbmUpKSk7XG4gICAgICAgIHNlbGVjdGlvbi5yZXBsYWNlV2l0aCh0aGlzLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICovXG4gICAgZGVsZXRlU2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbi5yZXBsYWNlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2UsIG9yIHRoZSBzZWxlY3Rpb24gaWYgbm8gcmFuZ2UgaXMgZ2l2ZW4sXG4gICAgd2l0aCBhIHRleHQgbm9kZSBjb250YWluaW5nIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBpbnNlcnRUZXh0KHRleHQsIGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmRvYy50eXBlLnNjaGVtYTtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVNlbGVjdGlvbldpdGgoc2NoZW1hLnRleHQodGV4dCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tO1xuICAgICAgICAgICAgdG8gPSB0byA9PSBudWxsID8gZnJvbSA6IHRvO1xuICAgICAgICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZVJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRoaXMuc3RvcmVkTWFya3M7XG4gICAgICAgICAgICBpZiAoIW1hcmtzKSB7XG4gICAgICAgICAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IHRvID09IGZyb20gPyAkZnJvbS5tYXJrcygpIDogJGZyb20ubWFya3NBY3Jvc3ModGhpcy5kb2MucmVzb2x2ZSh0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUmFuZ2VXaXRoKGZyb20sIHRvLCBzY2hlbWEudGV4dCh0ZXh0LCBtYXJrcykpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5lbXB0eSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0aGlzLnNlbGVjdGlvbi4kdG8pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFN0b3JlIGEgbWV0YWRhdGEgcHJvcGVydHkgaW4gdGhpcyB0cmFuc2FjdGlvbiwga2V5ZWQgZWl0aGVyIGJ5XG4gICAgbmFtZSBvciBieSBwbHVnaW4uXG4gICAgKi9cbiAgICBzZXRNZXRhKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhIG1ldGFkYXRhIHByb3BlcnR5IGZvciBhIGdpdmVuIG5hbWUgb3IgcGx1Z2luLlxuICAgICovXG4gICAgZ2V0TWV0YShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YVt0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgPyBrZXkgOiBrZXkua2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoaXMgdHJhbnNhY3Rpb24gZG9lc24ndCBjb250YWluIGFueSBtZXRhZGF0YSxcbiAgICBhbmQgY2FuIHRodXMgc2FmZWx5IGJlIGV4dGVuZGVkLlxuICAgICovXG4gICAgZ2V0IGlzR2VuZXJpYygpIHtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLm1ldGEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkIHNjcm9sbCB0aGUgc2VsZWN0aW9uIGludG8gdmlld1xuICAgIHdoZW4gdXBkYXRlZCB0byB0aGUgc3RhdGUgcHJvZHVjZWQgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZWQgfD0gVVBEQVRFRF9TQ1JPTEw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyB0cmFuc2FjdGlvbiBoYXMgaGFkIGBzY3JvbGxJbnRvVmlld2AgY2FsbGVkIG9uIGl0LlxuICAgICovXG4gICAgZ2V0IHNjcm9sbGVkSW50b1ZpZXcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9TQ1JPTEwpID4gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmQoZiwgc2VsZikge1xuICAgIHJldHVybiAhc2VsZiB8fCAhZiA/IGYgOiBmLmJpbmQoc2VsZik7XG59XG5jbGFzcyBGaWVsZERlc2Mge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGRlc2MsIHNlbGYpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbml0ID0gYmluZChkZXNjLmluaXQsIHNlbGYpO1xuICAgICAgICB0aGlzLmFwcGx5ID0gYmluZChkZXNjLmFwcGx5LCBzZWxmKTtcbiAgICB9XG59XG5jb25zdCBiYXNlRmllbGRzID0gW1xuICAgIG5ldyBGaWVsZERlc2MoXCJkb2NcIiwge1xuICAgICAgICBpbml0KGNvbmZpZykgeyByZXR1cm4gY29uZmlnLmRvYyB8fCBjb25maWcuc2NoZW1hLnRvcE5vZGVUeXBlLmNyZWF0ZUFuZEZpbGwoKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLmRvYzsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzZWxlY3Rpb25cIiwge1xuICAgICAgICBpbml0KGNvbmZpZywgaW5zdGFuY2UpIHsgcmV0dXJuIGNvbmZpZy5zZWxlY3Rpb24gfHwgU2VsZWN0aW9uLmF0U3RhcnQoaW5zdGFuY2UuZG9jKTsgfSxcbiAgICAgICAgYXBwbHkodHIpIHsgcmV0dXJuIHRyLnNlbGVjdGlvbjsgfVxuICAgIH0pLFxuICAgIG5ldyBGaWVsZERlc2MoXCJzdG9yZWRNYXJrc1wiLCB7XG4gICAgICAgIGluaXQoY29uZmlnKSB7IHJldHVybiBjb25maWcuc3RvcmVkTWFya3MgfHwgbnVsbDsgfSxcbiAgICAgICAgYXBwbHkodHIsIF9tYXJrcywgX29sZCwgc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yID8gdHIuc3RvcmVkTWFya3MgOiBudWxsOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInNjcm9sbFRvU2VsZWN0aW9uXCIsIHtcbiAgICAgICAgaW5pdCgpIHsgcmV0dXJuIDA7IH0sXG4gICAgICAgIGFwcGx5KHRyLCBwcmV2KSB7IHJldHVybiB0ci5zY3JvbGxlZEludG9WaWV3ID8gcHJldiArIDEgOiBwcmV2OyB9XG4gICAgfSlcbl07XG4vLyBPYmplY3Qgd3JhcHBpbmcgdGhlIHBhcnQgb2YgYSBzdGF0ZSBvYmplY3QgdGhhdCBzdGF5cyB0aGUgc2FtZVxuLy8gYWNyb3NzIHRyYW5zYWN0aW9ucy4gU3RvcmVkIGluIHRoZSBzdGF0ZSdzIGBjb25maWdgIHByb3BlcnR5LlxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBwbHVnaW5zKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5zQnlLZXkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGJhc2VGaWVsZHMuc2xpY2UoKTtcbiAgICAgICAgaWYgKHBsdWdpbnMpXG4gICAgICAgICAgICBwbHVnaW5zLmZvckVhY2gocGx1Z2luID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wbHVnaW5zQnlLZXlbcGx1Z2luLmtleV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQWRkaW5nIGRpZmZlcmVudCBpbnN0YW5jZXMgb2YgYSBrZXllZCBwbHVnaW4gKFwiICsgcGx1Z2luLmtleSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luc0J5S2V5W3BsdWdpbi5rZXldID0gcGx1Z2luO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5zdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWVsZHMucHVzaChuZXcgRmllbGREZXNjKHBsdWdpbi5rZXksIHBsdWdpbi5zcGVjLnN0YXRlLCBwbHVnaW4pKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuVGhlIHN0YXRlIG9mIGEgUHJvc2VNaXJyb3IgZWRpdG9yIGlzIHJlcHJlc2VudGVkIGJ5IGFuIG9iamVjdCBvZlxudGhpcyB0eXBlLiBBIHN0YXRlIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZVx1MjAxNGl0IGlzbid0XG51cGRhdGVkLCBidXQgcmF0aGVyIGEgbmV3IHN0YXRlIHZhbHVlIGlzIGNvbXB1dGVkIGZyb20gYW4gb2xkIG9uZVxudXNpbmcgdGhlIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIG1ldGhvZC5cblxuQSBzdGF0ZSBob2xkcyBhIG51bWJlciBvZiBidWlsdC1pbiBmaWVsZHMsIGFuZCBwbHVnaW5zIGNhblxuW2RlZmluZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuc3RhdGUpIGFkZGl0aW9uYWwgZmllbGRzLlxuKi9cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2NoZW1hIG9mIHRoZSBzdGF0ZSdzIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBsdWdpbnMgdGhhdCBhcmUgYWN0aXZlIGluIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgcGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsdWdpbnM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0byBwcm9kdWNlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHkodHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUcmFuc2FjdGlvbih0cikuc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmlsdGVyVHJhbnNhY3Rpb24odHIsIGlnbm9yZSA9IC0xKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChpICE9IGlnbm9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbiAmJiAhcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIHRyLCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVmVyYm9zZSB2YXJpYW50IG9mIFtgYXBwbHlgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuYXBwbHkpIHRoYXRcbiAgICByZXR1cm5zIHRoZSBwcmVjaXNlIHRyYW5zYWN0aW9ucyB0aGF0IHdlcmUgYXBwbGllZCAod2hpY2ggbWlnaHRcbiAgICBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBbdHJhbnNhY3Rpb25cbiAgICBob29rc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMuZmlsdGVyVHJhbnNhY3Rpb24pIG9mXG4gICAgcGx1Z2lucykgYWxvbmcgd2l0aCB0aGUgbmV3IHN0YXRlLlxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbihyb290VHIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlclRyYW5zYWN0aW9uKHJvb3RUcikpXG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogdGhpcywgdHJhbnNhY3Rpb25zOiBbXSB9O1xuICAgICAgICBsZXQgdHJzID0gW3Jvb3RUcl0sIG5ld1N0YXRlID0gdGhpcy5hcHBseUlubmVyKHJvb3RUciksIHNlZW4gPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGxvb3AgcmVwZWF0ZWRseSBnaXZlcyBwbHVnaW5zIGEgY2hhbmNlIHRvIHJlc3BvbmQgdG9cbiAgICAgICAgLy8gdHJhbnNhY3Rpb25zIGFzIG5ldyB0cmFuc2FjdGlvbnMgYXJlIGFkZGVkLCBtYWtpbmcgc3VyZSB0byBvbmx5XG4gICAgICAgIC8vIHBhc3MgdGhlIHRyYW5zYWN0aW9ucyB0aGUgcGx1Z2luIGRpZCBub3Qgc2VlIGJlZm9yZS5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGhhdmVOZXcgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmNvbmZpZy5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy5hcHBlbmRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IHNlZW4gPyBzZWVuW2ldLm4gOiAwLCBvbGRTdGF0ZSA9IHNlZW4gPyBzZWVuW2ldLnN0YXRlIDogdGhpcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyID0gbiA8IHRycy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uLmNhbGwocGx1Z2luLCBuID8gdHJzLnNsaWNlKG4pIDogdHJzLCBvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHIgJiYgbmV3U3RhdGUuZmlsdGVyVHJhbnNhY3Rpb24odHIsIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiLCByb290VHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb25maWcucGx1Z2lucy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGogPCBpID8geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfSA6IHsgc3RhdGU6IHRoaXMsIG46IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnMucHVzaCh0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IG5ld1N0YXRlLmFwcGx5SW5uZXIodHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZU5ldyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2ldID0geyBzdGF0ZTogbmV3U3RhdGUsIG46IHRycy5sZW5ndGggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhdmVOZXcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IG5ld1N0YXRlLCB0cmFuc2FjdGlvbnM6IHRycyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlJbm5lcih0cikge1xuICAgICAgICBpZiAoIXRyLmJlZm9yZS5lcSh0aGlzLmRvYykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFwcGx5aW5nIGEgbWlzbWF0Y2hlZCB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0luc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKHRoaXMuY29uZmlnKSwgZmllbGRzID0gdGhpcy5jb25maWcuZmllbGRzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgbmV3SW5zdGFuY2VbZmllbGQubmFtZV0gPSBmaWVsZC5hcHBseSh0ciwgdGhpc1tmaWVsZC5uYW1lXSwgdGhpcywgbmV3SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdJbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhcnQgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgZnJvbSB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHRyKCkgeyByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHRoaXMpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcpIHtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbihjb25maWcuZG9jID8gY29uZmlnLmRvYy50eXBlLnNjaGVtYSA6IGNvbmZpZy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRjb25maWcuZmllbGRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaW5zdGFuY2VbJGNvbmZpZy5maWVsZHNbaV0ubmFtZV0gPSAkY29uZmlnLmZpZWxkc1tpXS5pbml0KGNvbmZpZywgaW5zdGFuY2UpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBzdGF0ZSBiYXNlZCBvbiB0aGlzIG9uZSwgYnV0IHdpdGggYW4gYWRqdXN0ZWQgc2V0XG4gICAgb2YgYWN0aXZlIHBsdWdpbnMuIFN0YXRlIGZpZWxkcyB0aGF0IGV4aXN0IGluIGJvdGggc2V0cyBvZlxuICAgIHBsdWdpbnMgYXJlIGtlcHQgdW5jaGFuZ2VkLiBUaG9zZSB0aGF0IG5vIGxvbmdlciBleGlzdCBhcmVcbiAgICBkcm9wcGVkLCBhbmQgdGhvc2UgdGhhdCBhcmUgbmV3IGFyZSBpbml0aWFsaXplZCB1c2luZyB0aGVpclxuICAgIFtgaW5pdGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkLmluaXQpIG1ldGhvZCwgcGFzc2luZyBpbiB0aGUgbmV3XG4gICAgY29uZmlndXJhdGlvbiBvYmplY3QuLlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24odGhpcy5zY2hlbWEsIGNvbmZpZy5wbHVnaW5zKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9ICRjb25maWcuZmllbGRzLCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gZmllbGRzW2ldLm5hbWU7XG4gICAgICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB0aGlzW25hbWVdIDogZmllbGRzW2ldLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBzdGF0ZSB0byBKU09OLiBJZiB5b3Ugd2FudCB0byBzZXJpYWxpemUgdGhlIHN0YXRlXG4gICAgb2YgcGx1Z2lucywgcGFzcyBhbiBvYmplY3QgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyB0byB1c2UgaW4gdGhlXG4gICAgcmVzdWx0aW5nIEpTT04gb2JqZWN0IHRvIHBsdWdpbiBvYmplY3RzLiBUaGUgYXJndW1lbnQgbWF5IGFsc28gYmVcbiAgICBhIHN0cmluZyBvciBudW1iZXIsIGluIHdoaWNoIGNhc2UgaXQgaXMgaWdub3JlZCwgdG8gc3VwcG9ydCB0aGVcbiAgICB3YXkgYEpTT04uc3RyaW5naWZ5YCBjYWxscyBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gICAgKi9cbiAgICB0b0pTT04ocGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IGRvYzogdGhpcy5kb2MudG9KU09OKCksIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKCkgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcmVkTWFya3MpXG4gICAgICAgICAgICByZXN1bHQuc3RvcmVkTWFya3MgPSB0aGlzLnN0b3JlZE1hcmtzLm1hcChtID0+IG0udG9KU09OKCkpO1xuICAgICAgICBpZiAocGx1Z2luRmllbGRzICYmIHR5cGVvZiBwbHVnaW5GaWVsZHMgPT0gJ29iamVjdCcpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09IFwiZG9jXCIgfHwgcHJvcCA9PSBcInNlbGVjdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBKU09OIGZpZWxkcyBgZG9jYCBhbmQgYHNlbGVjdGlvbmAgYXJlIHJlc2VydmVkXCIpO1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSBwbHVnaW5GaWVsZHNbcHJvcF0sIHN0YXRlID0gcGx1Z2luLnNwZWMuc3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvSlNPTilcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gc3RhdGUudG9KU09OLmNhbGwocGx1Z2luLCB0aGlzW3BsdWdpbi5rZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgc3RhdGUuIGBjb25maWdgIHNob3VsZFxuICAgIGhhdmUgYXQgbGVhc3QgYSBgc2NoZW1hYCBmaWVsZCwgYW5kIHNob3VsZCBjb250YWluIGFycmF5IG9mXG4gICAgcGx1Z2lucyB0byBpbml0aWFsaXplIHRoZSBzdGF0ZSB3aXRoLiBgcGx1Z2luRmllbGRzYCBjYW4gYmUgdXNlZFxuICAgIHRvIGRlc2VyaWFsaXplIHRoZSBzdGF0ZSBvZiBwbHVnaW5zLCBieSBhc3NvY2lhdGluZyBwbHVnaW5cbiAgICBpbnN0YW5jZXMgd2l0aCB0aGUgcHJvcGVydHkgbmFtZXMgdGhleSB1c2UgaW4gdGhlIEpTT04gb2JqZWN0LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGNvbmZpZywganNvbiwgcGx1Z2luRmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRWRpdG9yU3RhdGUuZnJvbUpTT05cIik7XG4gICAgICAgIGlmICghY29uZmlnLnNjaGVtYSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVxdWlyZWQgY29uZmlnIGZpZWxkICdzY2hlbWEnIG1pc3NpbmdcIik7XG4gICAgICAgIGxldCAkY29uZmlnID0gbmV3IENvbmZpZ3VyYXRpb24oY29uZmlnLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgICRjb25maWcuZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT0gXCJkb2NcIikge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRvYyA9IE5vZGUuZnJvbUpTT04oY29uZmlnLnNjaGVtYSwganNvbi5kb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInNlbGVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uID0gU2VsZWN0aW9uLmZyb21KU09OKGluc3RhbmNlLmRvYywganNvbi5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQubmFtZSA9PSBcInN0b3JlZE1hcmtzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5zdG9yZWRNYXJrcylcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RvcmVkTWFya3MgPSBqc29uLnN0b3JlZE1hcmtzLm1hcChjb25maWcuc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luRmllbGRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHBsdWdpbkZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHBsdWdpbkZpZWxkc1twcm9wXSwgc3RhdGUgPSBwbHVnaW4uc3BlYy5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4ua2V5ID09IGZpZWxkLm5hbWUgJiYgc3RhdGUgJiYgc3RhdGUuZnJvbUpTT04gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbiwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IHN0YXRlLmZyb21KU09OLmNhbGwocGx1Z2luLCBjb25maWcsIGpzb25bcHJvcF0sIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZVtmaWVsZC5uYW1lXSA9IGZpZWxkLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBiaW5kUHJvcHMob2JqLCBzZWxmLCB0YXJnZXQpIHtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iaikge1xuICAgICAgICBsZXQgdmFsID0gb2JqW3Byb3BdO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICAgICAgICB2YWwgPSB2YWwuYmluZChzZWxmKTtcbiAgICAgICAgZWxzZSBpZiAocHJvcCA9PSBcImhhbmRsZURPTUV2ZW50c1wiKVxuICAgICAgICAgICAgdmFsID0gYmluZFByb3BzKHZhbCwgc2VsZiwge30pO1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG4vKipcblBsdWdpbnMgYnVuZGxlIGZ1bmN0aW9uYWxpdHkgdGhhdCBjYW4gYmUgYWRkZWQgdG8gYW4gZWRpdG9yLlxuVGhleSBhcmUgcGFydCBvZiB0aGUgW2VkaXRvciBzdGF0ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlKSBhbmRcbm1heSBpbmZsdWVuY2UgdGhhdCBzdGF0ZSBhbmQgdGhlIHZpZXcgdGhhdCBjb250YWlucyBpdC5cbiovXG5jbGFzcyBQbHVnaW4ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBsdWdpbi5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwbHVnaW4ncyBbc3BlYyBvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjKS5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBbcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzKSBleHBvcnRlZCBieSB0aGlzIHBsdWdpbi5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wcyA9IHt9O1xuICAgICAgICBpZiAoc3BlYy5wcm9wcylcbiAgICAgICAgICAgIGJpbmRQcm9wcyhzcGVjLnByb3BzLCB0aGlzLCB0aGlzLnByb3BzKTtcbiAgICAgICAgdGhpcy5rZXkgPSBzcGVjLmtleSA/IHNwZWMua2V5LmtleSA6IGNyZWF0ZUtleShcInBsdWdpblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0cmFjdCB0aGUgcGx1Z2luJ3Mgc3RhdGUgZmllbGQgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXRTdGF0ZShzdGF0ZSkgeyByZXR1cm4gc3RhdGVbdGhpcy5rZXldOyB9XG59XG5jb25zdCBrZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGNyZWF0ZUtleShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4ga2V5cylcbiAgICAgICAgcmV0dXJuIG5hbWUgKyBcIiRcIiArICsra2V5c1tuYW1lXTtcbiAgICBrZXlzW25hbWVdID0gMDtcbiAgICByZXR1cm4gbmFtZSArIFwiJFwiO1xufVxuLyoqXG5BIGtleSBpcyB1c2VkIHRvIFt0YWddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5QbHVnaW5TcGVjLmtleSkgcGx1Z2lucyBpbiBhIHdheVxudGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0byBmaW5kIHRoZW0sIGdpdmVuIGFuIGVkaXRvciBzdGF0ZS5cbkFzc2lnbmluZyBhIGtleSBkb2VzIG1lYW4gb25seSBvbmUgcGx1Z2luIG9mIHRoYXQgdHlwZSBjYW4gYmVcbmFjdGl2ZSBpbiBhIHN0YXRlLlxuKi9cbmNsYXNzIFBsdWdpbktleSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luIGtleS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUgPSBcImtleVwiKSB7IHRoaXMua2V5ID0gY3JlYXRlS2V5KG5hbWUpOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBhY3RpdmUgcGx1Z2luIHdpdGggdGhpcyBrZXksIGlmIGFueSwgZnJvbSBhbiBlZGl0b3JcbiAgICBzdGF0ZS5cbiAgICAqL1xuICAgIGdldChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY29uZmlnLnBsdWdpbnNCeUtleVt0aGlzLmtleV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBsdWdpbidzIHN0YXRlIGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0U3RhdGUoc3RhdGUpIHsgcmV0dXJuIHN0YXRlW3RoaXMua2V5XTsgfVxufVxuXG5leHBvcnQgeyBBbGxTZWxlY3Rpb24sIEVkaXRvclN0YXRlLCBOb2RlU2VsZWN0aW9uLCBQbHVnaW4sIFBsdWdpbktleSwgU2VsZWN0aW9uLCBTZWxlY3Rpb25SYW5nZSwgVGV4dFNlbGVjdGlvbiwgVHJhbnNhY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBTbGljZSwgRE9NUGFyc2VyIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgZHJvcFBvaW50IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuY29uc3QgZG9tSW5kZXggPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufTtcbmNvbnN0IHBhcmVudE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGxldCBwYXJlbnQgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMTEgPyBwYXJlbnQuaG9zdCA6IHBhcmVudDtcbn07XG5sZXQgcmV1c2VkUmFuZ2UgPSBudWxsO1xuLy8gTm90ZSB0aGF0IHRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHJhbmdlLCBiZWNhdXNlIERPTSByYW5nZVxuLy8gb2JqZWN0cyBhcmUgZXZlcnkgZXhwZW5zaXZlLCBhbmQga2VlcCBzbG93aW5nIGRvd24gc3Vic2VxdWVudCBET01cbi8vIHVwZGF0ZXMsIGZvciBzb21lIHJlYXNvbi5cbmNvbnN0IHRleHRSYW5nZSA9IGZ1bmN0aW9uIChub2RlLCBmcm9tLCB0bykge1xuICAgIGxldCByYW5nZSA9IHJldXNlZFJhbmdlIHx8IChyZXVzZWRSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkpO1xuICAgIHJhbmdlLnNldEVuZChub2RlLCB0byA9PSBudWxsID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20gfHwgMCk7XG4gICAgcmV0dXJuIHJhbmdlO1xufTtcbmNvbnN0IGNsZWFyUmV1c2VkUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV1c2VkUmFuZ2UgPSBudWxsO1xufTtcbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmNvbnN0IGlzRXF1aXZhbGVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgJiYgKHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIC0xKSB8fFxuICAgICAgICBzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAxKSk7XG59O1xuY29uc3QgYXRvbUVsZW1lbnRzID0gL14oaW1nfGJyfGlucHV0fHRleHRhcmVhfGhyKSQvaTtcbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIHZhciBfYTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlID09IHRhcmdldE5vZGUgJiYgb2ZmID09IHRhcmdldE9mZilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob2ZmID09IChkaXIgPCAwID8gMCA6IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPSAxIHx8IGhhc0Jsb2NrRGVzYyhub2RlKSB8fCBhdG9tRWxlbWVudHMudGVzdChub2RlLm5vZGVOYW1lKSB8fFxuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGROb2Rlc1tvZmYgKyAoZGlyIDwgMCA/IC0xIDogMCldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEgJiYgY2hpbGQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIGlmICgoX2EgPSBjaGlsZC5wbVZpZXdEZXNjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWdub3JlRm9yU2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBvZmYgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIG9mZiA9IGRpciA8IDAgPyBub2RlU2l6ZShub2RlKSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBub2RlU2l6ZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUJlZm9yZSQxKG5vZGUsIG9mZnNldCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIG9mZnNldCA9IG5vZGVTaXplKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHROb2RlQWZ0ZXIkMShub2RlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgJiYgb2Zmc2V0IDwgbm9kZS5ub2RlVmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzT25FZGdlKG5vZGUsIG9mZnNldCwgcGFyZW50KSB7XG4gICAgZm9yIChsZXQgYXRTdGFydCA9IG9mZnNldCA9PSAwLCBhdEVuZCA9IG9mZnNldCA9PSBub2RlU2l6ZShub2RlKTsgYXRTdGFydCB8fCBhdEVuZDspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBpbmRleCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGF0U3RhcnQgPSBhdFN0YXJ0ICYmIGluZGV4ID09IDA7XG4gICAgICAgIGF0RW5kID0gYXRFbmQgJiYgaW5kZXggPT0gbm9kZVNpemUobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFzQmxvY2tEZXNjKGRvbSkge1xuICAgIGxldCBkZXNjO1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSlcbiAgICAgICAgaWYgKGRlc2MgPSBjdXIucG1WaWV3RGVzYylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Mubm9kZSAmJiBkZXNjLm5vZGUuaXNCbG9jayAmJiAoZGVzYy5kb20gPT0gZG9tIHx8IGRlc2MuY29udGVudERPTSA9PSBkb20pO1xufVxuLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzUyM1xuLy8gKGlzQ29sbGFwc2VkIGluYXBwcm9wcmlhdGVseSByZXR1cm5zIHRydWUgaW4gc2hhZG93IGRvbSlcbmNvbnN0IHNlbGVjdGlvbkNvbGxhcHNlZCA9IGZ1bmN0aW9uIChkb21TZWwpIHtcbiAgICByZXR1cm4gZG9tU2VsLmZvY3VzTm9kZSAmJiBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbn07XG5mdW5jdGlvbiBrZXlFdmVudChrZXlDb2RlLCBrZXkpIHtcbiAgICBsZXQgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChcImtleWRvd25cIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZlbnQua2V5Q29kZSA9IGtleUNvZGU7XG4gICAgZXZlbnQua2V5ID0gZXZlbnQuY29kZSA9IGtleTtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBkZWVwQWN0aXZlRWxlbWVudChkb2MpIHtcbiAgICBsZXQgZWx0ID0gZG9jLmFjdGl2ZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsdCAmJiBlbHQuc2hhZG93Um9vdClcbiAgICAgICAgZWx0ID0gZWx0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgICByZXR1cm4gZWx0O1xufVxuZnVuY3Rpb24gY2FyZXRGcm9tUG9pbnQoZG9jLCB4LCB5KSB7XG4gICAgaWYgKGRvYy5jYXJldFBvc2l0aW9uRnJvbVBvaW50KSB7XG4gICAgICAgIHRyeSB7IC8vIEZpcmVmb3ggdGhyb3dzIGZvciB0aGlzIGNhbGwgaW4gaGFyZC10by1wcmVkaWN0IGNpcmN1bXN0YW5jZXMgKCM5OTQpXG4gICAgICAgICAgICBsZXQgcG9zID0gZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAvLyBDbGlwIHRoZSBvZmZzZXQsIGJlY2F1c2UgQ2hyb21lIHdpbGwgcmV0dXJuIGEgdGV4dCBvZmZzZXRcbiAgICAgICAgICAgIC8vIGludG8gPGlucHV0PiBub2Rlcywgd2hpY2ggY2FuJ3QgYmUgdHJlYXRlZCBhcyBhIHJlZ3VsYXIgRE9NXG4gICAgICAgICAgICAvLyBvZmZzZXRcbiAgICAgICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogcG9zLm9mZnNldE5vZGUsIG9mZnNldDogTWF0aC5taW4obm9kZVNpemUocG9zLm9mZnNldE5vZGUpLCBwb3Mub2Zmc2V0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICB9XG4gICAgaWYgKGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICAgIGxldCByYW5nZSA9IGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiByYW5nZS5zdGFydENvbnRhaW5lciwgb2Zmc2V0OiBNYXRoLm1pbihub2RlU2l6ZShyYW5nZS5zdGFydENvbnRhaW5lciksIHJhbmdlLnN0YXJ0T2Zmc2V0KSB9O1xuICAgIH1cbn1cblxuY29uc3QgbmF2ID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yIDogbnVsbDtcbmNvbnN0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgYWdlbnQgPSAobmF2ICYmIG5hdi51c2VyQWdlbnQpIHx8IFwiXCI7XG5jb25zdCBpZV9lZGdlID0gL0VkZ2VcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWVfdXB0bzEwID0gL01TSUUgXFxkLy5leGVjKGFnZW50KTtcbmNvbnN0IGllXzExdXAgPSAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWUgPSAhIShpZV91cHRvMTAgfHwgaWVfMTF1cCB8fCBpZV9lZGdlKTtcbmNvbnN0IGllX3ZlcnNpb24gPSBpZV91cHRvMTAgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBpZV8xMXVwID8gK2llXzExdXBbMV0gOiBpZV9lZGdlID8gK2llX2VkZ2VbMV0gOiAwO1xuY29uc3QgZ2Vja28gPSAhaWUgJiYgL2dlY2tvXFwvKFxcZCspL2kudGVzdChhZ2VudCk7XG5nZWNrbyAmJiArKC9GaXJlZm94XFwvKFxcZCspLy5leGVjKGFnZW50KSB8fCBbMCwgMF0pWzFdO1xuY29uc3QgX2Nocm9tZSA9ICFpZSAmJiAvQ2hyb21lXFwvKFxcZCspLy5leGVjKGFnZW50KTtcbmNvbnN0IGNocm9tZSA9ICEhX2Nocm9tZTtcbmNvbnN0IGNocm9tZV92ZXJzaW9uID0gX2Nocm9tZSA/ICtfY2hyb21lWzFdIDogMDtcbmNvbnN0IHNhZmFyaSA9ICFpZSAmJiAhIW5hdiAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2LnZlbmRvcik7XG4vLyBJcyB0cnVlIGZvciBib3RoIGlPUyBhbmQgaVBhZE9TIGZvciBjb252ZW5pZW5jZVxuY29uc3QgaW9zID0gc2FmYXJpICYmICgvTW9iaWxlXFwvXFx3Ky8udGVzdChhZ2VudCkgfHwgISFuYXYgJiYgbmF2Lm1heFRvdWNoUG9pbnRzID4gMik7XG5jb25zdCBtYWMgPSBpb3MgfHwgKG5hdiA/IC9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlKTtcbmNvbnN0IHdpbmRvd3MgPSBuYXYgPyAvV2luLy50ZXN0KG5hdi5wbGF0Zm9ybSkgOiBmYWxzZTtcbmNvbnN0IGFuZHJvaWQgPSAvQW5kcm9pZCBcXGQvLnRlc3QoYWdlbnQpO1xuY29uc3Qgd2Via2l0ID0gISFkb2MgJiYgXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZTtcbmNvbnN0IHdlYmtpdF92ZXJzaW9uID0gd2Via2l0ID8gKygvXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDA7XG5cbmZ1bmN0aW9uIHdpbmRvd1JlY3QoZG9jKSB7XG4gICAgbGV0IHZwID0gZG9jLmRlZmF1bHRWaWV3ICYmIGRvYy5kZWZhdWx0Vmlldy52aXN1YWxWaWV3cG9ydDtcbiAgICBpZiAodnApXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAwLCByaWdodDogdnAud2lkdGgsXG4gICAgICAgICAgICB0b3A6IDAsIGJvdHRvbTogdnAuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgIHRvcDogMCwgYm90dG9tOiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB9O1xufVxuZnVuY3Rpb24gZ2V0U2lkZSh2YWx1ZSwgc2lkZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IHZhbHVlIDogdmFsdWVbc2lkZV07XG59XG5mdW5jdGlvbiBjbGllbnRSZWN0KG5vZGUpIHtcbiAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gQWRqdXN0IGZvciBlbGVtZW50cyB3aXRoIHN0eWxlIFwidHJhbnNmb3JtOiBzY2FsZSgpXCJcbiAgICBsZXQgc2NhbGVYID0gKHJlY3Qud2lkdGggLyBub2RlLm9mZnNldFdpZHRoKSB8fCAxO1xuICAgIGxldCBzY2FsZVkgPSAocmVjdC5oZWlnaHQgLyBub2RlLm9mZnNldEhlaWdodCkgfHwgMTtcbiAgICAvLyBNYWtlIHN1cmUgc2Nyb2xsYmFyIHdpZHRoIGlzbid0IGluY2x1ZGVkIGluIHRoZSByZWN0YW5nbGVcbiAgICByZXR1cm4geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBub2RlLmNsaWVudFdpZHRoICogc2NhbGVYLFxuICAgICAgICB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QudG9wICsgbm9kZS5jbGllbnRIZWlnaHQgKiBzY2FsZVkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFJlY3RJbnRvVmlldyh2aWV3LCByZWN0LCBzdGFydERPTSkge1xuICAgIGxldCBzY3JvbGxUaHJlc2hvbGQgPSB2aWV3LnNvbWVQcm9wKFwic2Nyb2xsVGhyZXNob2xkXCIpIHx8IDAsIHNjcm9sbE1hcmdpbiA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxNYXJnaW5cIikgfHwgNTtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBzdGFydERPTSB8fCB2aWV3LmRvbTs7KSB7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Tm9kZShwYXJlbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgbGV0IGF0VG9wID0gZWx0ID09IGRvYy5ib2R5O1xuICAgICAgICBsZXQgYm91bmRpbmcgPSBhdFRvcCA/IHdpbmRvd1JlY3QoZG9jKSA6IGNsaWVudFJlY3QoZWx0KTtcbiAgICAgICAgbGV0IG1vdmVYID0gMCwgbW92ZVkgPSAwO1xuICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3AgKyBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJ0b3BcIikpXG4gICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImJvdHRvbVwiKSlcbiAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcFxuICAgICAgICAgICAgICAgID8gcmVjdC50b3AgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJ0b3BcIikgLSBib3VuZGluZy50b3BcbiAgICAgICAgICAgICAgICA6IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwiYm90dG9tXCIpO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcImxlZnRcIikpXG4gICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcImxlZnRcIikpO1xuICAgICAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgLSBnZXRTaWRlKHNjcm9sbFRocmVzaG9sZCwgXCJyaWdodFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwicmlnaHRcIik7XG4gICAgICAgIGlmIChtb3ZlWCB8fCBtb3ZlWSkge1xuICAgICAgICAgICAgaWYgKGF0VG9wKSB7XG4gICAgICAgICAgICAgICAgZG9jLmRlZmF1bHRWaWV3LnNjcm9sbEJ5KG1vdmVYLCBtb3ZlWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRYID0gZWx0LnNjcm9sbExlZnQsIHN0YXJ0WSA9IGVsdC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVZKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsVG9wICs9IG1vdmVZO1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgZWx0LnNjcm9sbExlZnQgKz0gbW92ZVg7XG4gICAgICAgICAgICAgICAgbGV0IGRYID0gZWx0LnNjcm9sbExlZnQgLSBzdGFydFgsIGRZID0gZWx0LnNjcm9sbFRvcCAtIHN0YXJ0WTtcbiAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiByZWN0LmxlZnQgLSBkWCwgdG9wOiByZWN0LnRvcCAtIGRZLCByaWdodDogcmVjdC5yaWdodCAtIGRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gZFkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9zID0gYXRUb3AgPyBcImZpeGVkXCIgOiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb247XG4gICAgICAgIGlmICgvXihmaXhlZHxzdGlja3kpJC8udGVzdChwb3MpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBhcmVudCA9IHBvcyA9PSBcImFic29sdXRlXCIgPyBwYXJlbnQub2Zmc2V0UGFyZW50IDogcGFyZW50Tm9kZShwYXJlbnQpO1xuICAgIH1cbn1cbi8vIFN0b3JlIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGVkaXRvcidzIHBhcmVudCBub2RlcywgYWxvbmcgd2l0aFxuLy8gdGhlIHRvcCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IG5lYXIgdGhlIHRvcCBvZiB0aGUgZWRpdG9yLCB3aGljaFxuLy8gd2lsbCBiZSB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgdmlzaWJsZSB2aWV3cG9ydCByZW1haW5zIHN0YWJsZSBldmVuXG4vLyB3aGVuIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IGFib3ZlIGNoYW5nZXMuXG5mdW5jdGlvbiBzdG9yZVNjcm9sbFBvcyh2aWV3KSB7XG4gICAgbGV0IHJlY3QgPSB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRZID0gTWF0aC5tYXgoMCwgcmVjdC50b3ApO1xuICAgIGxldCByZWZET00sIHJlZlRvcDtcbiAgICBmb3IgKGxldCB4ID0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgeSA9IHN0YXJ0WSArIDE7IHkgPCBNYXRoLm1pbihpbm5lckhlaWdodCwgcmVjdC5ib3R0b20pOyB5ICs9IDUpIHtcbiAgICAgICAgbGV0IGRvbSA9IHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoIWRvbSB8fCBkb20gPT0gdmlldy5kb20gfHwgIXZpZXcuZG9tLmNvbnRhaW5zKGRvbSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IGxvY2FsUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKGxvY2FsUmVjdC50b3AgPj0gc3RhcnRZIC0gMjApIHtcbiAgICAgICAgICAgIHJlZkRPTSA9IGRvbTtcbiAgICAgICAgICAgIHJlZlRvcCA9IGxvY2FsUmVjdC50b3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZET006IHJlZkRPTSwgcmVmVG9wOiByZWZUb3AsIHN0YWNrOiBzY3JvbGxTdGFjayh2aWV3LmRvbSkgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbFN0YWNrKGRvbSkge1xuICAgIGxldCBzdGFjayA9IFtdLCBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gcGFyZW50Tm9kZShjdXIpKSB7XG4gICAgICAgIHN0YWNrLnB1c2goeyBkb206IGN1ciwgdG9wOiBjdXIuc2Nyb2xsVG9wLCBsZWZ0OiBjdXIuc2Nyb2xsTGVmdCB9KTtcbiAgICAgICAgaWYgKGRvbSA9PSBkb2MpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuLy8gUmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzIHRvIHRoYXQgd2hhdFxuLy8gaXQgd2FzIGJlZm9yZSwgd2hlbiBzdG9yZVNjcm9sbFBvcyB3YXMgY2FsbGVkLlxuZnVuY3Rpb24gcmVzZXRTY3JvbGxQb3MoeyByZWZET00sIHJlZlRvcCwgc3RhY2sgfSkge1xuICAgIGxldCBuZXdSZWZUb3AgPSByZWZET00gPyByZWZET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogMDtcbiAgICByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIG5ld1JlZlRvcCA9PSAwID8gMCA6IG5ld1JlZlRvcCAtIHJlZlRvcCk7XG59XG5mdW5jdGlvbiByZXN0b3JlU2Nyb2xsU3RhY2soc3RhY2ssIGRUb3ApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7IGRvbSwgdG9wLCBsZWZ0IH0gPSBzdGFja1tpXTtcbiAgICAgICAgaWYgKGRvbS5zY3JvbGxUb3AgIT0gdG9wICsgZFRvcClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxUb3AgPSB0b3AgKyBkVG9wO1xuICAgICAgICBpZiAoZG9tLnNjcm9sbExlZnQgIT0gbGVmdClcbiAgICAgICAgICAgIGRvbS5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9XG59XG5sZXQgcHJldmVudFNjcm9sbFN1cHBvcnRlZCA9IG51bGw7XG4vLyBGZWF0dXJlLWRldGVjdHMgc3VwcG9ydCBmb3IgLmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSksIGFuZCB1c2VzXG4vLyBhIGZhbGxiYWNrIGtsdWRnZSB3aGVuIG5vdCBzdXBwb3J0ZWQuXG5mdW5jdGlvbiBmb2N1c1ByZXZlbnRTY3JvbGwoZG9tKSB7XG4gICAgaWYgKGRvbS5zZXRBY3RpdmUpXG4gICAgICAgIHJldHVybiBkb20uc2V0QWN0aXZlKCk7IC8vIGluIElFXG4gICAgaWYgKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCk7XG4gICAgbGV0IHN0b3JlZCA9IHNjcm9sbFN0YWNrKGRvbSk7XG4gICAgZG9tLmZvY3VzKHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPT0gbnVsbCA/IHtcbiAgICAgICAgZ2V0IHByZXZlbnRTY3JvbGwoKSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0geyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gOiB1bmRlZmluZWQpO1xuICAgIGlmICghcHJldmVudFNjcm9sbFN1cHBvcnRlZCkge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdG9yZWQsIDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJbk5vZGUobm9kZSwgY29vcmRzKSB7XG4gICAgbGV0IGNsb3Nlc3QsIGR4Q2xvc2VzdCA9IDJlOCwgY29vcmRzQ2xvc2VzdCwgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcm93Qm90ID0gY29vcmRzLnRvcCwgcm93VG9wID0gY29vcmRzLnRvcDtcbiAgICBsZXQgZmlyc3RCZWxvdywgY29vcmRzQmVsb3c7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQsIGNoaWxkSW5kZXggPSAwOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZywgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgIGxldCByZWN0cztcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICByZWN0cyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZWN0cyA9IHRleHRSYW5nZShjaGlsZCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPD0gcm93Qm90ICYmIHJlY3QuYm90dG9tID49IHJvd1RvcCkge1xuICAgICAgICAgICAgICAgIHJvd0JvdCA9IE1hdGgubWF4KHJlY3QuYm90dG9tLCByb3dCb3QpO1xuICAgICAgICAgICAgICAgIHJvd1RvcCA9IE1hdGgubWluKHJlY3QudG9wLCByb3dUb3ApO1xuICAgICAgICAgICAgICAgIGxldCBkeCA9IHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0ID8gcmVjdC5sZWZ0IC0gY29vcmRzLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgOiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyBjb29yZHMubGVmdCAtIHJlY3QucmlnaHQgOiAwO1xuICAgICAgICAgICAgICAgIGlmIChkeCA8IGR4Q2xvc2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGR4Q2xvc2VzdCA9IGR4O1xuICAgICAgICAgICAgICAgICAgICBjb29yZHNDbG9zZXN0ID0gZHggJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVjdC5yaWdodCA8IGNvb3Jkcy5sZWZ0ID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogY29vcmRzLnRvcFxuICAgICAgICAgICAgICAgICAgICB9IDogY29vcmRzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSAmJiBkeClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAoY29vcmRzLmxlZnQgPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVjdC50b3AgPiBjb29yZHMudG9wICYmICFmaXJzdEJlbG93ICYmIHJlY3QubGVmdCA8PSBjb29yZHMubGVmdCAmJiByZWN0LnJpZ2h0ID49IGNvb3Jkcy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RCZWxvdyA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNvb3Jkc0JlbG93ID0geyBsZWZ0OiBNYXRoLm1heChyZWN0LmxlZnQsIE1hdGgubWluKHJlY3QucmlnaHQsIGNvb3Jkcy5sZWZ0KSksIHRvcDogcmVjdC50b3AgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2xvc2VzdCAmJiAoY29vcmRzLmxlZnQgPj0gcmVjdC5yaWdodCAmJiBjb29yZHMudG9wID49IHJlY3QudG9wIHx8XG4gICAgICAgICAgICAgICAgY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC5ib3R0b20pKVxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGNoaWxkSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2xvc2VzdCAmJiBmaXJzdEJlbG93KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBmaXJzdEJlbG93O1xuICAgICAgICBjb29yZHNDbG9zZXN0ID0gY29vcmRzQmVsb3c7XG4gICAgICAgIGR4Q2xvc2VzdCA9IDA7XG4gICAgfVxuICAgIGlmIChjbG9zZXN0ICYmIGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIGZpbmRPZmZzZXRJblRleHQoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG4gICAgaWYgKCFjbG9zZXN0IHx8IChkeENsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAxKSlcbiAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0IH07XG4gICAgcmV0dXJuIGZpbmRPZmZzZXRJbk5vZGUoY2xvc2VzdCwgY29vcmRzQ2xvc2VzdCk7XG59XG5mdW5jdGlvbiBmaW5kT2Zmc2V0SW5UZXh0KG5vZGUsIGNvb3Jkcykge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBpICsgMSk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGkpO1xuICAgICAgICBsZXQgcmVjdCA9IHNpbmdsZVJlY3QocmFuZ2UsIDEpO1xuICAgICAgICBpZiAocmVjdC50b3AgPT0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiBpICsgKGNvb3Jkcy5sZWZ0ID49IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbm9kZSwgb2Zmc2V0OiAwIH07XG59XG5mdW5jdGlvbiBpblJlY3QoY29vcmRzLCByZWN0KSB7XG4gICAgcmV0dXJuIGNvb3Jkcy5sZWZ0ID49IHJlY3QubGVmdCAtIDEgJiYgY29vcmRzLmxlZnQgPD0gcmVjdC5yaWdodCArIDEgJiZcbiAgICAgICAgY29vcmRzLnRvcCA+PSByZWN0LnRvcCAtIDEgJiYgY29vcmRzLnRvcCA8PSByZWN0LmJvdHRvbSArIDE7XG59XG5mdW5jdGlvbiB0YXJnZXRLbHVkZ2UoZG9tLCBjb29yZHMpIHtcbiAgICBsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAmJiAvXmxpJC9pLnRlc3QocGFyZW50Lm5vZGVOYW1lKSAmJiBjb29yZHMubGVmdCA8IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIHJldHVybiBkb207XG59XG5mdW5jdGlvbiBwb3NGcm9tRWxlbWVudCh2aWV3LCBlbHQsIGNvb3Jkcykge1xuICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gZmluZE9mZnNldEluTm9kZShlbHQsIGNvb3JkcyksIGJpYXMgPSAtMTtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmICFub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBiaWFzID0gcmVjdC5sZWZ0ICE9IHJlY3QucmlnaHQgJiYgY29vcmRzLmxlZnQgPiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCBiaWFzKTtcbn1cbmZ1bmN0aW9uIHBvc0Zyb21DYXJldCh2aWV3LCBub2RlLCBvZmZzZXQsIGNvb3Jkcykge1xuICAgIC8vIEJyb3dzZXIgKGluIGNhcmV0UG9zaXRpb24vUmFuZ2VGcm9tUG9pbnQpIHdpbGwgYWdyZXNzaXZlbHlcbiAgICAvLyBub3JtYWxpemUgdG93YXJkcyBuZWFyYnkgaW5saW5lIG5vZGVzLiBTaW5jZSB3ZSBhcmUgaW50ZXJlc3RlZCBpblxuICAgIC8vIHBvc2l0aW9ucyBiZXR3ZWVuIGJsb2NrIG5vZGVzIHRvbywgd2UgZmlyc3Qgd2FsayB1cCB0aGUgaGllcmFyY2h5XG4gICAgLy8gb2Ygbm9kZXMgdG8gc2VlIGlmIHRoZXJlIGFyZSBibG9jayBub2RlcyB0aGF0IHRoZSBjb29yZGluYXRlc1xuICAgIC8vIGZhbGwgb3V0c2lkZSBvZi4gSWYgc28sIHdlIHRha2UgdGhlIHBvc2l0aW9uIGJlZm9yZS9hZnRlciB0aGF0XG4gICAgLy8gYmxvY2suIElmIG5vdCwgd2UgY2FsbCBgcG9zRnJvbURPTWAgb24gdGhlIHJhdyBub2RlL29mZnNldC5cbiAgICBsZXQgb3V0c2lkZUJsb2NrID0gLTE7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZSwgc2F3QmxvY2sgPSBmYWxzZTs7KSB7XG4gICAgICAgIGlmIChjdXIgPT0gdmlldy5kb20pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoY3VyLCB0cnVlKSwgcmVjdDtcbiAgICAgICAgaWYgKCFkZXNjKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChkZXNjLmRvbS5ub2RlVHlwZSA9PSAxICYmIChkZXNjLm5vZGUuaXNCbG9jayAmJiBkZXNjLnBhcmVudCB8fCAhZGVzYy5jb250ZW50RE9NKSAmJlxuICAgICAgICAgICAgLy8gSWdub3JlIGVsZW1lbnRzIHdpdGggemVyby1zaXplIGJvdW5kaW5nIHJlY3RhbmdsZXNcbiAgICAgICAgICAgICgocmVjdCA9IGRlc2MuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKS53aWR0aCB8fCByZWN0LmhlaWdodCkpIHtcbiAgICAgICAgICAgIGlmIChkZXNjLm5vZGUuaXNCbG9jayAmJiBkZXNjLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgdGhlIGhvcml6b250YWwgdGVzdCB0byB0aGUgaW5uZXJtb3N0IGJsb2NrLiBWZXJ0aWNhbCBmb3IgYW55IHBhcmVudC5cbiAgICAgICAgICAgICAgICBpZiAoIXNhd0Jsb2NrICYmIHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0IHx8IHJlY3QudG9wID4gY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZUJsb2NrID0gZGVzYy5wb3NCZWZvcmU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNhd0Jsb2NrICYmIHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCB8fCByZWN0LmJvdHRvbSA8IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG91dHNpZGVCbG9jayA9IGRlc2MucG9zQWZ0ZXI7XG4gICAgICAgICAgICAgICAgc2F3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjLmNvbnRlbnRET00gJiYgb3V0c2lkZUJsb2NrIDwgMCAmJiAhZGVzYy5ub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbnNpZGUgYSBsZWFmLCByZXR1cm4gdGhlIHNpZGUgb2YgdGhlIGxlYWYgY2xvc2VyIHRvIHRoZSBjb29yZHNcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gZGVzYy5ub2RlLmlzQmxvY2sgPyBjb29yZHMudG9wIDwgKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IGNvb3Jkcy5sZWZ0IDwgKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlID8gZGVzYy5wb3NCZWZvcmUgOiBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGRlc2MuZG9tLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBvdXRzaWRlQmxvY2sgPiAtMSA/IG91dHNpZGVCbG9jayA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgLTEpO1xufVxuZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChlbGVtZW50LCBjb29yZHMsIGJveCkge1xuICAgIGxldCBsZW4gPSBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGlmIChsZW4gJiYgYm94LnRvcCA8IGJveC5ib3R0b20pIHtcbiAgICAgICAgZm9yIChsZXQgc3RhcnRJID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVuIC0gMSwgTWF0aC5mbG9vcihsZW4gKiAoY29vcmRzLnRvcCAtIGJveC50b3ApIC8gKGJveC5ib3R0b20gLSBib3gudG9wKSkgLSAyKSksIGkgPSBzdGFydEk7Oykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRGcm9tUG9pbnQoY2hpbGQsIGNvb3JkcywgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0gKGkgKyAxKSAlIGxlbikgPT0gc3RhcnRJKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuLy8gR2l2ZW4gYW4geCx5IHBvc2l0aW9uIG9uIHRoZSBlZGl0b3IsIGdldCB0aGUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgY29vcmRzKSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQsIG5vZGUsIG9mZnNldCA9IDA7XG4gICAgbGV0IGNhcmV0ID0gY2FyZXRGcm9tUG9pbnQoZG9jLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgaWYgKGNhcmV0KVxuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGNhcmV0KTtcbiAgICBsZXQgZWx0ID0gKHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50ID8gdmlldy5yb290IDogZG9jKVxuICAgICAgICAuZWxlbWVudEZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgbGV0IHBvcztcbiAgICBpZiAoIWVsdCB8fCAhdmlldy5kb20uY29udGFpbnMoZWx0Lm5vZGVUeXBlICE9IDEgPyBlbHQucGFyZW50Tm9kZSA6IGVsdCkpIHtcbiAgICAgICAgbGV0IGJveCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWluUmVjdChjb29yZHMsIGJveCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWx0ID0gZWxlbWVudEZyb21Qb2ludCh2aWV3LmRvbSwgY29vcmRzLCBib3gpO1xuICAgICAgICBpZiAoIWVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHJldHVybnMgbm9uc2Vuc2Ugd2hlbiBvbiBhIGRyYWdnYWJsZSBlbGVtZW50XG4gICAgaWYgKHNhZmFyaSkge1xuICAgICAgICBmb3IgKGxldCBwID0gZWx0OyBub2RlICYmIHA7IHAgPSBwYXJlbnROb2RlKHApKVxuICAgICAgICAgICAgaWYgKHAuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsdCA9IHRhcmdldEtsdWRnZShlbHQsIGNvb3Jkcyk7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gb2Zmc2V0cyBpbnRvIDxpbnB1dD4gbm9kZXMsIHdoaWNoXG4gICAgICAgICAgICAvLyBoYXZlIG5vIGFjdHVhbCBjaGlsZHJlbiwgZnJvbSBjYXJldFBvc2l0aW9uRnJvbVBvaW50ICgjOTUzKVxuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIEl0J2xsIGFsc28gbW92ZSB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYmVmb3JlIGltYWdlIG5vZGVzLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aG9zZSBhcmUgYmVoaW5kIGl0LlxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCBib3g7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiAoYm94ID0gbmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkucmlnaHQgPD0gY29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgICAgICAgICAgYm94LmJvdHRvbSA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwcmV2O1xuICAgICAgICAvLyBXaGVuIGNsaWNraW5nIGFib3ZlIHRoZSByaWdodCBzaWRlIG9mIGFuIHVuZWRpdGFibGUgbm9kZSwgQ2hyb21lIHdpbGwgcmVwb3J0IGEgY3Vyc29yIHBvc2l0aW9uIGFmdGVyIHRoYXQgbm9kZS5cbiAgICAgICAgaWYgKHdlYmtpdCAmJiBvZmZzZXQgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIChwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdKS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgJiYgcHJldi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgPj0gY29vcmRzLnRvcClcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAvLyBTdXNwaWNpb3VzbHkgc3BlY2lmaWMga2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyBuZXZlciByZXR1cm5pbmcgYSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgJiYgbm9kZS5sYXN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgY29vcmRzLnRvcCA+IG5vZGUubGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSlcbiAgICAgICAgICAgIHBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgLy8gSWdub3JlIHBvc2l0aW9ucyBkaXJlY3RseSBhZnRlciBhIEJSLCBzaW5jZSBjYXJldCpGcm9tUG9pbnRcbiAgICAgICAgLy8gJ3JvdW5kIHVwJyBwb3NpdGlvbnMgdGhhdCB3b3VsZCBiZSBtb3JlIGFjY3VyYXRlbHkgcGxhY2VkXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgQlIgbm9kZS5cbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID09IDAgfHwgbm9kZS5ub2RlVHlwZSAhPSAxIHx8IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICAgICAgICBwb3MgPSBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpO1xuICAgIH1cbiAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgIHBvcyA9IHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKTtcbiAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhlbHQsIHRydWUpO1xuICAgIHJldHVybiB7IHBvcywgaW5zaWRlOiBkZXNjID8gZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIgOiAtMSB9O1xufVxuZnVuY3Rpb24gbm9uWmVybyhyZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wIDwgcmVjdC5ib3R0b20gfHwgcmVjdC5sZWZ0IDwgcmVjdC5yaWdodDtcbn1cbmZ1bmN0aW9uIHNpbmdsZVJlY3QodGFyZ2V0LCBiaWFzKSB7XG4gICAgbGV0IHJlY3RzID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZmlyc3QgPSByZWN0c1tiaWFzIDwgMCA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG5vblplcm8oZmlyc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgbm9uWmVybykgfHwgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuY29uc3QgQklESSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXS87XG4vLyBHaXZlbiBhIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBtb2RlbCwgZ2V0IGEgYm91bmRpbmcgYm94IG9mIHRoZVxuLy8gY2hhcmFjdGVyIGF0IHRoYXQgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cuXG5mdW5jdGlvbiBjb29yZHNBdFBvcyh2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQsIGF0b20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgIGxldCBzdXBwb3J0RW1wdHlSYW5nZSA9IHdlYmtpdCB8fCBnZWNrbztcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIC8vIFRoZXNlIGJyb3dzZXJzIHN1cHBvcnQgcXVlcnlpbmcgZW1wdHkgdGV4dCByYW5nZXMuIFByZWZlciB0aGF0IGluXG4gICAgICAgIC8vIGJpZGkgY29udGV4dCBvciB3aGVuIGF0IHRoZSBlbmQgb2YgYSBub2RlLlxuICAgICAgICBpZiAoc3VwcG9ydEVtcHR5UmFuZ2UgJiYgKEJJREkudGVzdChub2RlLm5vZGVWYWx1ZSkgfHwgKHNpZGUgPCAwID8gIW9mZnNldCA6IG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCksIHNpZGUpO1xuICAgICAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIGJhZCByZXN1bHRzICh0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBzcGFjZSlcbiAgICAgICAgICAgIC8vIHdoZW4gcXVlcnlpbmcgYSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciBsaW5lLWJyb2tlblxuICAgICAgICAgICAgLy8gd2hpdGVzcGFjZS4gRGV0ZWN0IHRoaXMgc2l0dWF0aW9uIGFuZCBhbmQga2x1ZGdlIGFyb3VuZCBpdFxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIG9mZnNldCAmJiAvXFxzLy50ZXN0KG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdKSAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCAtIDEsIG9mZnNldCAtIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUudG9wID09IHJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QWZ0ZXIgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCArIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QWZ0ZXIudG9wICE9IHJlY3QudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHJlY3RBZnRlciwgcmVjdEFmdGVyLmxlZnQgPCByZWN0QmVmb3JlLmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBvZmZzZXQsIHRvID0gb2Zmc2V0LCB0YWtlU2lkZSA9IHNpZGUgPCAwID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmICFvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlID49IDAgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICB0YWtlU2lkZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlIDwgMCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pLCB0YWtlU2lkZSksIHRha2VTaWRlIDwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0ICRkb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyAtIChhdG9tIHx8IDApKTtcbiAgICAvLyBSZXR1cm4gYSBob3Jpem9udGFsIGxpbmUgaW4gYmxvY2sgY29udGV4dFxuICAgIGlmICghJGRvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYmVmb3JlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYWZ0ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuSChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzaWRlID49IDApO1xuICAgIH1cbiAgICAvLyBJbmxpbmUsIG5vdCBpbiB0ZXh0IG5vZGUgKHRoaXMgaXMgbm90IEJpZGktc2FmZSlcbiAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYmVmb3JlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYmVmb3JlLCBub2RlU2l6ZShiZWZvcmUpIC0gKHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpKVxuICAgICAgICAgICAgLy8gQlIgbm9kZXMgdGVuZCB0byBvbmx5IHJldHVybiB0aGUgcmVjdGFuZ2xlIGJlZm9yZSB0aGVtLlxuICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlbSBpZiB0aGV5IGFyZSB0aGUgbGFzdCBlbGVtZW50IGluIHRoZWlyIHBhcmVudFxuICAgICAgICAgICAgOiBiZWZvcmUubm9kZVR5cGUgPT0gMSAmJiAoYmVmb3JlLm5vZGVOYW1lICE9IFwiQlJcIiB8fCAhYmVmb3JlLm5leHRTaWJsaW5nKSA/IGJlZm9yZSA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIDEpLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0IDwgbm9kZVNpemUobm9kZSkpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIHdoaWxlIChhZnRlci5wbVZpZXdEZXNjICYmIGFmdGVyLnBtVmlld0Rlc2MuaWdub3JlRm9yQ29vcmRzKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgbGV0IHRhcmdldCA9ICFhZnRlciA/IG51bGwgOiBhZnRlci5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGFmdGVyLCAwLCAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICA6IGFmdGVyLm5vZGVUeXBlID09IDEgPyBhZnRlciA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIC0xKSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIEFsbCBlbHNlIGZhaWxlZCwganVzdCB0cnkgdG8gZ2V0IGEgcmVjdGFuZ2xlIGZvciB0aGUgdGFyZ2V0IG5vZGVcbiAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdChub2RlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2Uobm9kZSkgOiBub2RlLCAtc2lkZSksIHNpZGUgPj0gMCk7XG59XG5mdW5jdGlvbiBmbGF0dGVuVihyZWN0LCBsZWZ0KSB7XG4gICAgaWYgKHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tLCBsZWZ0OiB4LCByaWdodDogeCB9O1xufVxuZnVuY3Rpb24gZmxhdHRlbkgocmVjdCwgdG9wKSB7XG4gICAgaWYgKHJlY3QuaGVpZ2h0ID09IDApXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIGxldCB5ID0gdG9wID8gcmVjdC50b3AgOiByZWN0LmJvdHRvbTtcbiAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCB9O1xufVxuZnVuY3Rpb24gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZikge1xuICAgIGxldCB2aWV3U3RhdGUgPSB2aWV3LnN0YXRlLCBhY3RpdmUgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAodmlld1N0YXRlICE9IHN0YXRlKVxuICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXdTdGF0ZSk7XG4gICAgICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20gJiYgYWN0aXZlKVxuICAgICAgICAgICAgYWN0aXZlLmZvY3VzKCk7XG4gICAgfVxufVxuLy8gV2hldGhlciB2ZXJ0aWNhbCBwb3NpdGlvbiBtb3Rpb24gaW4gYSBnaXZlbiBkaXJlY3Rpb25cbi8vIGZyb20gYSBwb3NpdGlvbiB3b3VsZCBsZWF2ZSBhIHRleHQgYmxvY2suXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkcG9zID0gZGlyID09IFwidXBcIiA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsICgpID0+IHtcbiAgICAgICAgbGV0IHsgbm9kZTogZG9tIH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcygkcG9zLnBvcywgZGlyID09IFwidXBcIiA/IC0xIDogMSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGRvbSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobmVhcmVzdC5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBkb20gPSBuZWFyZXN0LmNvbnRlbnRET00gfHwgbmVhcmVzdC5kb207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20gPSBuZWFyZXN0LmRvbS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb29yZHMgPSBjb29yZHNBdFBvcyh2aWV3LCAkcG9zLnBvcywgMSk7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBsZXQgYm94ZXM7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBib3hlcyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIGJveGVzID0gdGV4dFJhbmdlKGNoaWxkLCAwLCBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYm94LmJvdHRvbSA+IGJveC50b3AgKyAxICYmXG4gICAgICAgICAgICAgICAgICAgIChkaXIgPT0gXCJ1cFwiID8gY29vcmRzLnRvcCAtIGJveC50b3AgPiAoYm94LmJvdHRvbSAtIGNvb3Jkcy50b3ApICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBib3guYm90dG9tIC0gY29vcmRzLmJvdHRvbSA+IChjb29yZHMuYm90dG9tIC0gYm94LnRvcCkgKiAyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuY29uc3QgbWF5YmVSVEwgPSAvW1xcdTA1OTAtXFx1MDhhY10vO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9ICRoZWFkLnBhcmVudE9mZnNldCwgYXRTdGFydCA9ICFvZmZzZXQsIGF0RW5kID0gb2Zmc2V0ID09ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWwpXG4gICAgICAgIHJldHVybiAkaGVhZC5wb3MgPT0gJGhlYWQuc3RhcnQoKSB8fCAkaGVhZC5wb3MgPT0gJGhlYWQuZW5kKCk7XG4gICAgLy8gSWYgdGhlIHRleHRibG9jayBpcyBhbGwgTFRSLCBvciB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnRcbiAgICAvLyBTZWxlY3Rpb24ubW9kaWZ5IChFZGdlKSwgZmFsbCBiYWNrIHRvIGEgcHJpbWl0aXZlIGFwcHJvYWNoXG4gICAgaWYgKCFtYXliZVJUTC50ZXN0KCRoZWFkLnBhcmVudC50ZXh0Q29udGVudCkgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgIHJldHVybiBkaXIgPT0gXCJsZWZ0XCIgfHwgZGlyID09IFwiYmFja3dhcmRcIiA/IGF0U3RhcnQgOiBhdEVuZDtcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaHVnZSBoYWNrLCBidXQgYXBwZWFycyB0byBiZSB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gY3VycmVudGx5IGRvOiB1c2UgYFNlbGVjdGlvbi5tb2RpZnlgIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiBieVxuICAgICAgICAvLyBvbmUgY2hhcmFjdGVyLCBhbmQgc2VlIGlmIHRoYXQgbW92ZXMgdGhlIGN1cnNvciBvdXQgb2YgdGhlXG4gICAgICAgIC8vIHRleHRibG9jayAob3IgZG9lc24ndCBtb3ZlIGl0IGF0IGFsbCwgd2hlbiBhdCB0aGUgc3RhcnQvZW5kIG9mXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudCkuXG4gICAgICAgIGxldCB7IGZvY3VzTm9kZTogb2xkTm9kZSwgZm9jdXNPZmZzZXQ6IG9sZE9mZiwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBvbGRCaWRpTGV2ZWwgPSBzZWwuY2FyZXRCaWRpTGV2ZWwgLy8gT25seSBmb3IgRmlyZWZveFxuICAgICAgICA7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGRpciwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSAkaGVhZC5kZXB0aCA/IHZpZXcuZG9jVmlldy5kb21BZnRlclBvcygkaGVhZC5iZWZvcmUoKSkgOiB2aWV3LmRvbTtcbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBuZXdOb2RlLCBmb2N1c09mZnNldDogbmV3T2ZmIH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXdOb2RlICYmICFwYXJlbnRET00uY29udGFpbnMobmV3Tm9kZS5ub2RlVHlwZSA9PSAxID8gbmV3Tm9kZSA6IG5ld05vZGUucGFyZW50Tm9kZSkgfHxcbiAgICAgICAgICAgIChvbGROb2RlID09IG5ld05vZGUgJiYgb2xkT2ZmID09IG5ld09mZik7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICBpZiAob2xkTm9kZSAmJiAob2xkTm9kZSAhPSBhbmNob3JOb2RlIHx8IG9sZE9mZiAhPSBhbmNob3JPZmZzZXQpICYmIHNlbC5leHRlbmQpXG4gICAgICAgICAgICAgICAgc2VsLmV4dGVuZChvbGROb2RlLCBvbGRPZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgaWYgKG9sZEJpZGlMZXZlbCAhPSBudWxsKVxuICAgICAgICAgICAgc2VsLmNhcmV0QmlkaUxldmVsID0gb2xkQmlkaUxldmVsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxubGV0IGNhY2hlZFN0YXRlID0gbnVsbDtcbmxldCBjYWNoZWREaXIgPSBudWxsO1xubGV0IGNhY2hlZFJlc3VsdCA9IGZhbHNlO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2sodmlldywgc3RhdGUsIGRpcikge1xuICAgIGlmIChjYWNoZWRTdGF0ZSA9PSBzdGF0ZSAmJiBjYWNoZWREaXIgPT0gZGlyKVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIGNhY2hlZFN0YXRlID0gc3RhdGU7XG4gICAgY2FjaGVkRGlyID0gZGlyO1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQgPSBkaXIgPT0gXCJ1cFwiIHx8IGRpciA9PSBcImRvd25cIlxuICAgICAgICA/IGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcilcbiAgICAgICAgOiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcik7XG59XG5cbi8vIFZpZXcgZGVzY3JpcHRpb25zIGFyZSBkYXRhIHN0cnVjdHVyZXMgdGhhdCBkZXNjcmliZSB0aGUgRE9NIHRoYXQgaXNcbi8vIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBlZGl0b3IncyBjb250ZW50LiBUaGV5IGFyZSB1c2VkIGZvcjpcbi8vXG4vLyAtIEluY3JlbWVudGFsIHJlZHJhd2luZyB3aGVuIHRoZSBkb2N1bWVudCBjaGFuZ2VzXG4vL1xuLy8gLSBGaWd1cmluZyBvdXQgd2hhdCBwYXJ0IG9mIHRoZSBkb2N1bWVudCBhIGdpdmVuIERPTSBwb3NpdGlvblxuLy8gICBjb3JyZXNwb25kcyB0b1xuLy9cbi8vIC0gV2lyaW5nIGluIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIGVkaXRpbmcgaW50ZXJmYWNlIGZvciBhXG4vLyAgIGdpdmVuIG5vZGVcbi8vXG4vLyBUaGV5IGZvcm0gYSBkb3VibHktbGlua2VkIG11dGFibGUgdHJlZSwgc3RhcnRpbmcgYXQgYHZpZXcuZG9jVmlld2AuXG5jb25zdCBOT1RfRElSVFkgPSAwLCBDSElMRF9ESVJUWSA9IDEsIENPTlRFTlRfRElSVFkgPSAyLCBOT0RFX0RJUlRZID0gMztcbi8vIFN1cGVyY2xhc3MgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIGRlc2NyaXB0aW9ucy4gRGVmaW5lcyB0aGVpclxuLy8gYmFzaWMgc3RydWN0dXJlIGFuZCBzaGFyZWQgbWV0aG9kcy5cbmNsYXNzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNoaWxkcmVuLCBkb20sIFxuICAgIC8vIFRoaXMgaXMgdGhlIG5vZGUgdGhhdCBob2xkcyB0aGUgY2hpbGQgdmlld3MuIEl0IG1heSBiZSBudWxsIGZvclxuICAgIC8vIGRlc2NzIHRoYXQgZG9uJ3QgaGF2ZSBjaGlsZHJlbi5cbiAgICBjb250ZW50RE9NKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBjb250ZW50RE9NO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAvLyBBbiBleHBhbmRvIHByb3BlcnR5IG9uIHRoZSBET00gbm9kZSBwcm92aWRlcyBhIGxpbmsgYmFjayB0byBpdHNcbiAgICAgICAgLy8gZGVzY3JpcHRpb24uXG4gICAgICAgIGRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICB9XG4gICAgLy8gVXNlZCB0byBjaGVjayB3aGV0aGVyIGEgZ2l2ZW4gZGVzY3JpcHRpb24gY29ycmVzcG9uZHMgdG8gYVxuICAgIC8vIHdpZGdldC9tYXJrL25vZGUuXG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc01hcmsobWFyaykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzSGFjayhub2RlTmFtZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBXaGVuIHBhcnNpbmcgaW4tZWRpdG9yIGNvbnRlbnQgKGluIGRvbWNoYW5nZS5qcyksIHdlIGFsbG93XG4gICAgLy8gZGVzY3JpcHRpb25zIHRvIGRldGVybWluZSB0aGUgcGFyc2UgcnVsZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0b1xuICAgIC8vIHBhcnNlIHRoZW0uXG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8vIFVzZWQgYnkgdGhlIGVkaXRvcidzIGV2ZW50IGhhbmRsZXIgdG8gaWdub3JlIGV2ZW50cyB0aGF0IGNvbWVcbiAgICAvLyBmcm9tIGNlcnRhaW4gZGVzY3MuXG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFRoZSBzaXplIG9mIHRoZSBjb250ZW50IHJlcHJlc2VudGVkIGJ5IHRoaXMgZGVzYy5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzaXplICs9IHRoaXMuY2hpbGRyZW5baV0uc2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8vIEZvciBibG9jayBub2RlcywgdGhpcyByZXByZXNlbnRzIHRoZSBzcGFjZSB0YWtlbiB1cCBieSB0aGVpclxuICAgIC8vIHN0YXJ0L2VuZCB0b2tlbnMuXG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIDA7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuZG9tLnBtVmlld0Rlc2MgPT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICBwb3NCZWZvcmVDaGlsZChjaGlsZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gdGhpcy5wb3NBdFN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjdXIgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjdXIuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9zQmVmb3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIGdldCBwb3NBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKSArIHRoaXMuYm9yZGVyIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0FmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUgKyB0aGlzLnNpemU7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMuc2l6ZSAtIDIgKiB0aGlzLmJvcmRlcjtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIC8vIElmIHRoZSBET00gcG9zaXRpb24gaXMgaW4gdGhlIGNvbnRlbnQsIHVzZSB0aGUgY2hpbGQgZGVzYyBhZnRlclxuICAgICAgICAvLyBpdCB0byBmaWd1cmUgb3V0IGEgcG9zaXRpb24uXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQmVmb3JlLCBkZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQmVmb3JlICYmICEoKGRlc2MgPSBkb21CZWZvcmUucG1WaWV3RGVzYykgJiYgZGVzYy5wYXJlbnQgPT0gdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbUJlZm9yZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJlZm9yZSA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgKyBkZXNjLnNpemUgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbUFmdGVyICYmICEoKGRlc2MgPSBkb21BZnRlci5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb21BZnRlci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQWZ0ZXIgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpIDogdGhpcy5wb3NBdEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB2YXJpb3VzIGhldXJpc3RpY3MsIGZhbGxpbmcgYmFjayBvbiB0aGUgYmlhc1xuICAgICAgICAvLyBwYXJhbWV0ZXIsIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldHVybiB0aGUgcG9zaXRpb24gYXQgdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9yIGF0IHRoZSBlbmQgb2YgdGhpcyB2aWV3IGRlc2MuXG4gICAgICAgIGxldCBhdEVuZDtcbiAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmRvbSAmJiB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGF0RW5kID0gb2Zmc2V0ID4gZG9tSW5kZXgodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSkpIHtcbiAgICAgICAgICAgIGF0RW5kID0gZG9tLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuY29udGVudERPTSkgJiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gMClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSBkb207OyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXRFbmQgPT0gbnVsbCAmJiBvZmZzZXQgPT0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhdEVuZCA9PSBudWxsID8gYmlhcyA+IDAgOiBhdEVuZCkgPyB0aGlzLnBvc0F0RW5kIDogdGhpcy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBuZWFyZXN0RGVzYyhkb20sIG9ubHlOb2RlcyA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAobGV0IGZpcnN0ID0gdHJ1ZSwgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZ2V0RGVzYyhjdXIpLCBub2RlRE9NO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKCFvbmx5Tm9kZXMgfHwgZGVzYy5ub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGRvbSBpcyBvdXRzaWRlIG9mIHRoaXMgZGVzYydzIG5vZGVET00sIGRvbid0IGNvdW50IGl0LlxuICAgICAgICAgICAgICAgIGlmIChmaXJzdCAmJiAobm9kZURPTSA9IGRlc2Mubm9kZURPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlRE9NLm5vZGVUeXBlID09IDEgPyBub2RlRE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpIDogbm9kZURPTSA9PSBkb20pKVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVzYyhkb20pIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZGVzYzsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICAgICAgaWYgKGN1ciA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBkb207IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKHNjYW4pO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MubG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGRlc2MgZm9yIHRoZSBub2RlIGFmdGVyIHRoZSBnaXZlbiBwb3MsIGlmIGFueS4gKFdoZW4gYVxuICAgIC8vIHBhcmVudCBub2RlIG92ZXJyb2RlIHJlbmRlcmluZywgdGhlcmUgbWlnaHQgbm90IGJlIG9uZS4pXG4gICAgZGVzY0F0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyAmJiBlbmQgIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFjaGlsZC5ib3JkZXIgJiYgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNoaWxkLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc2NBdChwb3MgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5kb20sIG9mZnNldDogMCwgYXRvbTogcG9zICsgMSB9O1xuICAgICAgICAvLyBGaXJzdCBmaW5kIHRoZSBwb3NpdGlvbiBpbiB0aGUgY2hpbGQgYXJyYXlcbiAgICAgICAgbGV0IGkgPSAwLCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBjdXJQb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gY3VyUG9zICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmFpbGluZ0hhY2tWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBvcyAtIGN1clBvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIHBvaW50cyBpbnRvIHRoZSBtaWRkbGUgb2YgYSBjaGlsZCwgY2FsbCB0aHJvdWdoXG4gICAgICAgIGlmIChvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21Gcm9tUG9zKG9mZnNldCAtIHRoaXMuY2hpbGRyZW5baV0uYm9yZGVyLCBzaWRlKTtcbiAgICAgICAgLy8gR28gYmFjayBpZiB0aGVyZSB3ZXJlIGFueSB6ZXJvLWxlbmd0aCB3aWRnZXRzIHdpdGggc2lkZSA+PSAwIGJlZm9yZSB0aGlzIHBvaW50XG4gICAgICAgIGZvciAobGV0IHByZXY7IGkgJiYgIShwcmV2ID0gdGhpcy5jaGlsZHJlbltpIC0gMV0pLnNpemUgJiYgcHJldiBpbnN0YW5jZW9mIFdpZGdldFZpZXdEZXNjICYmIHByZXYuc2lkZSA+PSAwOyBpLS0pIHsgfVxuICAgICAgICAvLyBTY2FuIHRvd2FyZHMgdGhlIGZpcnN0IHVzZWFibGUgbm9kZVxuICAgICAgICBpZiAoc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpLS0sIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gaSA/IHRoaXMuY2hpbGRyZW5baSAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgc2lkZSAmJiBlbnRlciAmJiAhcHJldi5ib3JkZXIgJiYgIXByZXYuZG9tQXRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5kb21Gcm9tUG9zKHByZXYuc2l6ZSwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogcHJldiA/IGRvbUluZGV4KHByZXYuZG9tKSArIDEgOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpKyssIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlbltpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIGVudGVyICYmICFuZXh0LmJvcmRlciAmJiAhbmV4dC5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUZyb21Qb3MoMCwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogbmV4dCA/IGRvbUluZGV4KG5leHQuZG9tKSA6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gZmluZCBhIERPTSByYW5nZSBpbiBhIHNpbmdsZSBwYXJlbnQgZm9yIGEgZ2l2ZW4gY2hhbmdlZFxuICAgIC8vIHJhbmdlLlxuICAgIHBhcnNlUmFuZ2UoZnJvbSwgdG8sIGJhc2UgPSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldDogMCwgdG9PZmZzZXQ6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICBsZXQgZnJvbU9mZnNldCA9IC0xLCB0b09mZnNldCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSBiYXNlLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xICYmIGZyb20gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQmFzZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBtYXliZSBkZXNjZW5kIG1hcmsgdmlld3MgdG8gcGFyc2UgYSBuYXJyb3dlciByYW5nZT9cbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjaGlsZEJhc2UgJiYgdG8gPD0gZW5kIC0gY2hpbGQuYm9yZGVyICYmIGNoaWxkLm5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoY2hpbGQuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5wYXJzZVJhbmdlKGZyb20sIHRvLCBjaGlsZEJhc2UpO1xuICAgICAgICAgICAgICAgIGZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLmNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYuc2l6ZSAmJiBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhcHJldi5lbXB0eUNoaWxkQXQoMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSBkb21JbmRleChwcmV2LmRvbSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJvbSAtPSBwcmV2LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBmcm9tT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID4gLTEgJiYgKGVuZCA+IHRvIHx8IGkgPT0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgIHRvID0gZW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5zaXplICYmIG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFuZXh0LmVtcHR5Q2hpbGRBdCgtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gZG9tSW5kZXgobmV4dC5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG8gKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgZnJvbSwgdG8sIGZyb21PZmZzZXQsIHRvT2Zmc2V0IH07XG4gICAgfVxuICAgIGVtcHR5Q2hpbGRBdChzaWRlKSB7XG4gICAgICAgIGlmICh0aGlzLmJvcmRlciB8fCAhdGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltzaWRlIDwgMCA/IDAgOiB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gY2hpbGQuc2l6ZSA9PSAwIHx8IGNoaWxkLmVtcHR5Q2hpbGRBdChzaWRlKTtcbiAgICB9XG4gICAgZG9tQWZ0ZXJQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gdGhpcy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEgfHwgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYWZ0ZXIgcG9zIFwiICsgcG9zKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBWaWV3IGRlc2NzIGFyZSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbnkgc2VsZWN0aW9uIHRoYXQgZmFsbHNcbiAgICAvLyBlbnRpcmVseSBpbnNpZGUgb2YgdGhlbSwgc28gdGhhdCBjdXN0b20gaW1wbGVtZW50YXRpb25zIGNhbiBkb1xuICAgIC8vIGN1c3RvbSB0aGluZ3Mgd2l0aCB0aGUgc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmYWxscyBhcGFydCB3aGVuXG4gICAgLy8gYSBzZWxlY3Rpb24gc3RhcnRzIGluIHN1Y2ggYSBub2RlIGFuZCBlbmRzIGluIGFub3RoZXIsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB3ZSBqdXN0IHVzZSB3aGF0ZXZlciBkb21Gcm9tUG9zIHByb2R1Y2VzIGFzIGEgYmVzdCBlZmZvcnQuXG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldywgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGZhbGxzIGVudGlyZWx5IGluIGEgY2hpbGQsIGdpdmUgaXQgdG8gdGhhdCBjaGlsZFxuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKGFuY2hvciwgaGVhZCksIHRvID0gTWF0aC5tYXgoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb20gPiBvZmZzZXQgJiYgdG8gPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNldFNlbGVjdGlvbihhbmNob3IgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIGhlYWQgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIHZpZXcsIGZvcmNlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5jaG9yRE9NID0gdGhpcy5kb21Gcm9tUG9zKGFuY2hvciwgYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGhlYWRET00gPSBoZWFkID09IGFuY2hvciA/IGFuY2hvckRPTSA6IHRoaXMuZG9tRnJvbVBvcyhoZWFkLCBoZWFkID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHZpZXcucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNlbFJhbmdlID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgYnJLbHVkZ2UgPSBmYWxzZTtcbiAgICAgICAgLy8gT24gRmlyZWZveCwgdXNpbmcgU2VsZWN0aW9uLmNvbGxhcHNlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIGFcbiAgICAgICAgLy8gQlIgbm9kZSBmb3Igc29tZSByZWFzb24gZG9lc24ndCBhbHdheXMgd29yayAoIzEwNzMpLiBPbiBTYWZhcmksXG4gICAgICAgIC8vIHRoZSBjdXJzb3Igc29tZXRpbWVzIGluZXhwbGljYWJsZSB2aXN1YWxseSBsYWdzIGJlaGluZCBpdHNcbiAgICAgICAgLy8gcmVwb3J0ZWQgcG9zaXRpb24gaW4gc3VjaCBzaXR1YXRpb25zICgjMTA5MikuXG4gICAgICAgIGlmICgoZ2Vja28gfHwgc2FmYXJpKSAmJiBhbmNob3IgPT0gaGVhZCkge1xuICAgICAgICAgICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSBhbmNob3JET007XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgYnJLbHVkZ2UgPSAhIShvZmZzZXQgJiYgbm9kZS5ub2RlVmFsdWVbb2Zmc2V0IC0gMV0gPT0gXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgLy8gSXNzdWUgIzExMjhcbiAgICAgICAgICAgICAgICBpZiAoYnJLbHVkZ2UgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgYWZ0ZXI7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlciA9IHNjYW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZU5hbWUgPT0gXCJCUlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NID0geyBub2RlOiBhZnRlci5wYXJlbnROb2RlLCBvZmZzZXQ6IGRvbUluZGV4KGFmdGVyKSArIDEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXNjID0gc2Nhbi5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgYnJLbHVkZ2UgPSBwcmV2ICYmIChwcmV2Lm5vZGVOYW1lID09IFwiQlJcIiB8fCBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmVmb3ggY2FuIGFjdCBzdHJhbmdlbHkgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGZyb250IG9mIGFuXG4gICAgICAgIC8vIHVuZWRpdGFibGUgbm9kZS4gU2VlICMxMTYzIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzA5NTM2XG4gICAgICAgIGlmIChnZWNrbyAmJiBzZWxSYW5nZS5mb2N1c05vZGUgJiYgc2VsUmFuZ2UuZm9jdXNOb2RlICE9IGhlYWRET00ubm9kZSAmJiBzZWxSYW5nZS5mb2N1c05vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gc2VsUmFuZ2UuZm9jdXNOb2RlLmNoaWxkTm9kZXNbc2VsUmFuZ2UuZm9jdXNPZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZvcmNlIHx8IGJyS2x1ZGdlICYmIHNhZmFyaSkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBzZWxSYW5nZS5hbmNob3JOb2RlLCBzZWxSYW5nZS5hbmNob3JPZmZzZXQpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0LCBzZWxSYW5nZS5mb2N1c05vZGUsIHNlbFJhbmdlLmZvY3VzT2Zmc2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gU2VsZWN0aW9uLmV4dGVuZCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gJ2ludmVydGVkJyBzZWxlY3Rpb25cbiAgICAgICAgLy8gKG9uZSB3aGVyZSB0aGUgZm9jdXMgaXMgYmVmb3JlIHRoZSBhbmNob3IpLCBidXQgbm90IGFsbFxuICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0IGl0IHlldC5cbiAgICAgICAgbGV0IGRvbVNlbEV4dGVuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICgoZG9tU2VsLmV4dGVuZCB8fCBhbmNob3IgPT0gaGVhZCkgJiYgIWJyS2x1ZGdlKSB7XG4gICAgICAgICAgICBkb21TZWwuY29sbGFwc2UoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yICE9IGhlYWQpXG4gICAgICAgICAgICAgICAgICAgIGRvbVNlbC5leHRlbmQoaGVhZERPTS5ub2RlLCBoZWFkRE9NLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZG9tU2VsRXh0ZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzIHdpdGggQ2hyb21lIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYWZ0ZXIgY2FsbGluZ1xuICAgICAgICAgICAgICAgIC8vIGNvbGxhcHNlLCBldmVuIHdoZW4gaXQgc2hvdWxkIGJlIHZhbGlkLiBUaGlzIGFwcGVhcnMgdG8gYmUgYSBidWcsIGJ1dFxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIGRpZmZpY3VsdCB0byBpc29sYXRlLiBJZiB0aGlzIGhhcHBlbnMgZmFsbGJhY2sgdG8gdGhlIG9sZCBwYXRoXG4gICAgICAgICAgICAgICAgLy8gd2l0aG91dCB1c2luZyBleHRlbmQuXG4gICAgICAgICAgICAgICAgLy8gU2ltaWxhcmx5LCB0aGlzIGNvdWxkIGNyYXNoIG9uIFNhZmFyaSBpZiB0aGUgZWRpdG9yIGlzIGhpZGRlbiwgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgd2FzIG5vIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvbVNlbEV4dGVuZGVkKSB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yID4gaGVhZCkge1xuICAgICAgICAgICAgICAgIGxldCB0bXAgPSBhbmNob3JET007XG4gICAgICAgICAgICAgICAgYW5jaG9yRE9NID0gaGVhZERPTTtcbiAgICAgICAgICAgICAgICBoZWFkRE9NID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLnNldEVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0KTtcbiAgICAgICAgICAgIGRvbVNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgIGRvbVNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbnRlbnRET00gJiYgbXV0YXRpb24udHlwZSAhPSBcInNlbGVjdGlvblwiO1xuICAgIH1cbiAgICBnZXQgY29udGVudExvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NICE9IHRoaXMuZG9tICYmICF0aGlzLmRvbS5jb250YWlucyh0aGlzLmNvbnRlbnRET00pO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgYSBzdWJ0cmVlIG9mIHRoZSBlbGVtZW50IHRyZWUgdGhhdCBoYXMgYmVlbiB0b3VjaGVkXG4gICAgLy8gYnkgYSBET00gY2hhbmdlLCBzbyB0aGF0IHRoZSBuZXh0IHVwZGF0ZSB3aWxsIHJlZHJhdyBpdC5cbiAgICBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gMCwgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBlbmQgPyBmcm9tIDw9IGVuZCAmJiB0byA+PSBvZmZzZXQgOiBmcm9tIDwgZW5kICYmIHRvID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5zaWRlID0gb2Zmc2V0ICsgY2hpbGQuYm9yZGVyLCBlbmRJbnNpZGUgPSBlbmQgLSBjaGlsZC5ib3JkZXI7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPj0gc3RhcnRJbnNpZGUgJiYgdG8gPD0gZW5kSW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmcm9tID09IG9mZnNldCB8fCB0byA9PSBlbmQgPyBDT05URU5UX0RJUlRZIDogQ0hJTERfRElSVFk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHN0YXJ0SW5zaWRlICYmIHRvID09IGVuZEluc2lkZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNoaWxkLmNvbnRlbnRMb3N0IHx8IGNoaWxkLmRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IE5PREVfRElSVFk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLm1hcmtEaXJ0eShmcm9tIC0gc3RhcnRJbnNpZGUsIHRvIC0gc3RhcnRJbnNpZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IGNoaWxkLmRvbSA9PSBjaGlsZC5jb250ZW50RE9NICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhY2hpbGQuY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICA/IENPTlRFTlRfRElSVFkgOiBOT0RFX0RJUlRZO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICB9XG4gICAgbWFya1BhcmVudHNEaXJ0eSgpIHtcbiAgICAgICAgbGV0IGxldmVsID0gMTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRoaXMucGFyZW50OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnQsIGxldmVsKyspIHtcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IGxldmVsID09IDEgPyBDT05URU5UX0RJUlRZIDogQ0hJTERfRElSVFk7XG4gICAgICAgICAgICBpZiAobm9kZS5kaXJ0eSA8IGRpcnR5KVxuICAgICAgICAgICAgICAgIG5vZGUuZGlydHkgPSBkaXJ0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlnbm9yZUZvckNvb3JkcygpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGlnbm9yZUZvclNlbGVjdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaXNUZXh0KHRleHQpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG4vLyBBIHdpZGdldCBkZXNjIHJlcHJlc2VudHMgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggaXMgYSBET00gbm9kZVxuLy8gZHJhd24gYmV0d2VlbiB0aGUgZG9jdW1lbnQgbm9kZXMuXG5jbGFzcyBXaWRnZXRWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHdpZGdldCwgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBzZWxmLCBkb20gPSB3aWRnZXQudHlwZS50b0RPTTtcbiAgICAgICAgaWYgKHR5cGVvZiBkb20gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgZG9tID0gZG9tKHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF3aWRnZXQudHlwZS5zcGVjLnJhdykge1xuICAgICAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgICAgICB3cmFwLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gd3JhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLXdpZGdldFwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHNlbGYgPSB0aGlzO1xuICAgIH1cbiAgICBtYXRjaGVzV2lkZ2V0KHdpZGdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgd2lkZ2V0LnR5cGUuZXEodGhpcy53aWRnZXQudHlwZSk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHsgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07IH1cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgbGV0IHN0b3AgPSB0aGlzLndpZGdldC5zcGVjLnN0b3BFdmVudDtcbiAgICAgICAgcmV0dXJuIHN0b3AgPyBzdG9wKGV2ZW50KSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcInNlbGVjdGlvblwiIHx8IHRoaXMud2lkZ2V0LnNwZWMuaWdub3JlU2VsZWN0aW9uO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLndpZGdldC50eXBlLmRlc3Ryb3kodGhpcy5kb20pO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGdldCBpZ25vcmVGb3JTZWxlY3Rpb24oKSB7IHJldHVybiAhIXRoaXMud2lkZ2V0LnR5cGUuc3BlYy5yZWxheGVkU2lkZTsgfVxuICAgIGdldCBzaWRlKCkgeyByZXR1cm4gdGhpcy53aWRnZXQudHlwZS5zaWRlOyB9XG59XG5jbGFzcyBDb21wb3NpdGlvblZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgZG9tLCB0ZXh0RE9NLCB0ZXh0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgIHRoaXMudGV4dERPTSA9IHRleHRET007XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCBzaXplKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCkge1xuICAgICAgICBpZiAoZG9tICE9IHRoaXMudGV4dERPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyAob2Zmc2V0ID8gdGhpcy5zaXplIDogMCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyBvZmZzZXQ7XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zKSB7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMudGV4dERPTSwgb2Zmc2V0OiBwb3MgfTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0KSB7XG4gICAgICAgIHJldHVybiBtdXQudHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnICYmIG11dC50YXJnZXQubm9kZVZhbHVlID09IG11dC5vbGRWYWx1ZTtcbiAgICB9XG59XG4vLyBBIG1hcmsgZGVzYyByZXByZXNlbnRzIGEgbWFyay4gTWF5IGhhdmUgbXVsdGlwbGUgY2hpbGRyZW4sXG4vLyBkZXBlbmRpbmcgb24gaG93IHRoZSBtYXJrIGlzIHNwbGl0LiBOb3RlIHRoYXQgbWFya3MgYXJlIGRyYXduIHVzaW5nXG4vLyBhIGZpeGVkIG5lc3Rpbmcgb3JkZXIsIGZvciBzaW1wbGljaXR5IGFuZCBwcmVkaWN0YWJpbGl0eSwgc28gaW5cbi8vIHNvbWUgY2FzZXMgdGhleSB3aWxsIGJlIHNwbGl0IG1vcmUgb2Z0ZW4gdGhhbiB3b3VsZCBhcHBlYXJcbi8vIG5lY2Vzc2FyeS5cbmNsYXNzIE1hcmtWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG1hcmssIGRvbSwgY29udGVudERPTSwgc3BlYykge1xuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIGNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKHBhcmVudCwgbWFyaywgaW5saW5lLCB2aWV3KSB7XG4gICAgICAgIGxldCBjdXN0b20gPSB2aWV3Lm5vZGVWaWV3c1ttYXJrLnR5cGUubmFtZV07XG4gICAgICAgIGxldCBzcGVjID0gY3VzdG9tICYmIGN1c3RvbShtYXJrLCB2aWV3LCBpbmxpbmUpO1xuICAgICAgICBpZiAoIXNwZWMgfHwgIXNwZWMuZG9tKVxuICAgICAgICAgICAgc3BlYyA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2N1bWVudCwgbWFyay50eXBlLnNwZWMudG9ET00obWFyaywgaW5saW5lKSwgbnVsbCwgbWFyay5hdHRycyk7XG4gICAgICAgIHJldHVybiBuZXcgTWFya1ZpZXdEZXNjKHBhcmVudCwgbWFyaywgc3BlYy5kb20sIHNwZWMuY29udGVudERPTSB8fCBzcGVjLmRvbSwgc3BlYyk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgaWYgKCh0aGlzLmRpcnR5ICYgTk9ERV9ESVJUWSkgfHwgdGhpcy5tYXJrLnR5cGUuc3BlYy5yZXBhcnNlSW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB7IG1hcms6IHRoaXMubWFyay50eXBlLm5hbWUsIGF0dHJzOiB0aGlzLm1hcmsuYXR0cnMsIGNvbnRlbnRFbGVtZW50OiB0aGlzLmNvbnRlbnRET00gfTtcbiAgICB9XG4gICAgbWF0Y2hlc01hcmsobWFyaykgeyByZXR1cm4gdGhpcy5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHRoaXMubWFyay5lcShtYXJrKTsgfVxuICAgIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgICBzdXBlci5tYXJrRGlydHkoZnJvbSwgdG8pO1xuICAgICAgICAvLyBNb3ZlIGRpcnR5IGluZm8gdG8gbmVhcmVzdCBub2RlIHZpZXdcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAoIXBhcmVudC5ub2RlKVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocGFyZW50LmRpcnR5IDwgdGhpcy5kaXJ0eSlcbiAgICAgICAgICAgICAgICBwYXJlbnQuZGlydHkgPSB0aGlzLmRpcnR5O1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzbGljZShmcm9tLCB0bywgdmlldykge1xuICAgICAgICBsZXQgY29weSA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy5wYXJlbnQsIHRoaXMubWFyaywgdHJ1ZSwgdmlldyk7XG4gICAgICAgIGxldCBub2RlcyA9IHRoaXMuY2hpbGRyZW4sIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIGlmICh0byA8IHNpemUpXG4gICAgICAgICAgICBub2RlcyA9IHJlcGxhY2VOb2Rlcyhub2RlcywgdG8sIHNpemUsIHZpZXcpO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBub2RlcyA9IHJlcGxhY2VOb2Rlcyhub2RlcywgMCwgZnJvbSwgdmlldyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2Rlc1tpXS5wYXJlbnQgPSBjb3B5O1xuICAgICAgICBjb3B5LmNoaWxkcmVuID0gbm9kZXM7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uID8gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSA6IHN1cGVyLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3koKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbi8vIE5vZGUgdmlldyBkZXNjcyBhcmUgdGhlIG1haW4sIG1vc3QgY29tbW9uIHR5cGUgb2YgdmlldyBkZXNjLCBhbmRcbi8vIGNvcnJlc3BvbmQgdG8gYW4gYWN0dWFsIG5vZGUgaW4gdGhlIGRvY3VtZW50LiBVbmxpa2UgbWFyayBkZXNjcyxcbi8vIHRoZXkgcG9wdWxhdGUgdGhlaXIgY2hpbGQgYXJyYXkgdGhlbXNlbHZlcy5cbmNsYXNzIE5vZGVWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHZpZXcsIHBvcykge1xuICAgICAgICBzdXBlcihwYXJlbnQsIFtdLCBkb20sIGNvbnRlbnRET00pO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm91dGVyRGVjbyA9IG91dGVyRGVjbztcbiAgICAgICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgICAgIHRoaXMubm9kZURPTSA9IG5vZGVET007XG4gICAgfVxuICAgIC8vIEJ5IGRlZmF1bHQsIGEgbm9kZSBpcyByZW5kZXJlZCB1c2luZyB0aGUgYHRvRE9NYCBtZXRob2QgZnJvbSB0aGVcbiAgICAvLyBub2RlIHR5cGUgc3BlYy4gQnV0IGNsaWVudCBjb2RlIGNhbiB1c2UgdGhlIGBub2RlVmlld3NgIHNwZWMgdG9cbiAgICAvLyBzdXBwbHkgYSBjdXN0b20gbm9kZSB2aWV3LCB3aGljaCBjYW4gaW5mbHVlbmNlIHZhcmlvdXMgYXNwZWN0cyBvZlxuICAgIC8vIHRoZSB3YXkgdGhlIG5vZGUgd29ya3MuXG4gICAgLy9cbiAgICAvLyAoVXNpbmcgc3ViY2xhc3NpbmcgZm9yIHRoaXMgd2FzIGludGVudGlvbmFsbHkgZGVjaWRlZCBhZ2FpbnN0LFxuICAgIC8vIHNpbmNlIGl0J2QgcmVxdWlyZSBleHBvc2luZyBhIHdob2xlIHNsZXcgb2YgZmluaWNreVxuICAgIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbHMgdG8gdGhlIHVzZXIgY29kZSB0aGF0IHRoZXkgcHJvYmFibHkgd2lsbFxuICAgIC8vIG5ldmVyIG5lZWQuKVxuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBjdXN0b20gPSB2aWV3Lm5vZGVWaWV3c1tub2RlLnR5cGUubmFtZV0sIGRlc2NPYmo7XG4gICAgICAgIGxldCBzcGVjID0gY3VzdG9tICYmIGN1c3RvbShub2RlLCB2aWV3LCAoKSA9PiB7XG4gICAgICAgICAgICAvLyAoVGhpcyBpcyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoZSBjdXN0b20gdmlldyB0byBmaW5kIGl0c1xuICAgICAgICAgICAgLy8gb3duIHBvc2l0aW9uKVxuICAgICAgICAgICAgaWYgKCFkZXNjT2JqKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBpZiAoZGVzY09iai5wYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NPYmoucGFyZW50LnBvc0JlZm9yZUNoaWxkKGRlc2NPYmopO1xuICAgICAgICB9LCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgIGxldCBkb20gPSBzcGVjICYmIHNwZWMuZG9tLCBjb250ZW50RE9NID0gc3BlYyAmJiBzcGVjLmNvbnRlbnRET007XG4gICAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgaWYgKCFkb20pXG4gICAgICAgICAgICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS50ZXh0KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSAhPSAzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGV4dCBtdXN0IGJlIHJlbmRlcmVkIGFzIGEgRE9NIHRleHQgbm9kZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZG9tKSB7XG4gICAgICAgICAgICBsZXQgc3BlYyA9IERPTVNlcmlhbGl6ZXIucmVuZGVyU3BlYyhkb2N1bWVudCwgbm9kZS50eXBlLnNwZWMudG9ET00obm9kZSksIG51bGwsIG5vZGUuYXR0cnMpO1xuICAgICAgICAgICAgKHsgZG9tLCBjb250ZW50RE9NIH0gPSBzcGVjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRlbnRET00gJiYgIW5vZGUuaXNUZXh0ICYmIGRvbS5ub2RlTmFtZSAhPSBcIkJSXCIpIHsgLy8gQ2hyb21lIGdldHMgY29uZnVzZWQgYnkgPGJyIGNvbnRlbnRlZGl0YWJsZT1mYWxzZT5cbiAgICAgICAgICAgIGlmICghZG9tLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSlcbiAgICAgICAgICAgICAgICBkb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgICAgICBkb20uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZURPTSA9IGRvbTtcbiAgICAgICAgZG9tID0gYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIG5vZGUpO1xuICAgICAgICBpZiAoc3BlYylcbiAgICAgICAgICAgIHJldHVybiBkZXNjT2JqID0gbmV3IEN1c3RvbU5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgc3BlYywgdmlldywgcG9zICsgMSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0Vmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlVmlld0Rlc2MocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NIHx8IG51bGwsIG5vZGVET00sIHZpZXcsIHBvcyArIDEpO1xuICAgIH1cbiAgICBwYXJzZVJ1bGUoKSB7XG4gICAgICAgIC8vIEV4cGVyaW1lbnRhbCBrbHVkZ2UgdG8gYWxsb3cgb3B0LWluIHJlLXBhcnNpbmcgb2Ygbm9kZXNcbiAgICAgICAgaWYgKHRoaXMubm9kZS50eXBlLnNwZWMucmVwYXJzZUluVmlldylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBGSVhNRSB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgY2FuIGFsd2F5cyByZXR1cm4gdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gYXR0cnMgbWVhbnMgdGhhdCBpZiB0aGUgdXNlciBzb21laG93IG1hbmFnZXMgdG8gY2hhbmdlIHRoZVxuICAgICAgICAvLyBhdHRycyBpbiB0aGUgZG9tLCB0aGF0IHdvbid0IGJlIHBpY2tlZCB1cC4gTm90IGVudGlyZWx5IHN1cmVcbiAgICAgICAgLy8gd2hldGhlciB0aGlzIGlzIGEgcHJvYmxlbVxuICAgICAgICBsZXQgcnVsZSA9IHsgbm9kZTogdGhpcy5ub2RlLnR5cGUubmFtZSwgYXR0cnM6IHRoaXMubm9kZS5hdHRycyB9O1xuICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiKVxuICAgICAgICAgICAgcnVsZS5wcmVzZXJ2ZVdoaXRlc3BhY2UgPSBcImZ1bGxcIjtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudCA9ICgpID0+IHRoaXMubm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRlbnRMb3N0KSB7XG4gICAgICAgICAgICBydWxlLmNvbnRlbnRFbGVtZW50ID0gdGhpcy5jb250ZW50RE9NO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2hyb21lIGxpa2VzIHRvIHJhbmRvbWx5IHJlY3JlYXRlIHBhcmVudCBub2RlcyB3aGVuXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyB0aGluZ3MuIFdoZW4gdGhhdCBoYXBwZW5zLCB0aGlzIHRyaWVzIHRvIGZpbmQgdGhlXG4gICAgICAgICAgICAvLyBuZXcgcGFyZW50LlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvbS5jb250YWlucyhjaGlsZC5kb20ucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5jb250ZW50RWxlbWVudCA9IGNoaWxkLmRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJ1bGUuY29udGVudEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50ID0gKCkgPT4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfVxuICAgIG1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiBub2RlLmVxKHRoaXMubm9kZSkgJiZcbiAgICAgICAgICAgIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm91dGVyRGVjbykgJiYgaW5uZXJEZWNvLmVxKHRoaXMuaW5uZXJEZWNvKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLm5vZGUubm9kZVNpemU7IH1cbiAgICBnZXQgYm9yZGVyKCkgeyByZXR1cm4gdGhpcy5ub2RlLmlzTGVhZiA/IDAgOiAxOyB9XG4gICAgLy8gU3luY3MgYHRoaXMuY2hpbGRyZW5gIHRvIG1hdGNoIGB0aGlzLm5vZGUuY29udGVudGAgYW5kIHRoZSBsb2NhbFxuICAgIC8vIGRlY29yYXRpb25zLCBwb3NzaWJseSBpbnRyb2R1Y2luZyBuZXN0aW5nIGZvciBtYXJrcy4gVGhlbiwgaW4gYVxuICAgIC8vIHNlcGFyYXRlIHN0ZXAsIHN5bmNzIHRoZSBET00gaW5zaWRlIGB0aGlzLmNvbnRlbnRET01gIHRvXG4gICAgLy8gYHRoaXMuY2hpbGRyZW5gLlxuICAgIHVwZGF0ZUNoaWxkcmVuKHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgaW5saW5lID0gdGhpcy5ub2RlLmlubGluZUNvbnRlbnQsIG9mZiA9IHBvcztcbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uID0gdmlldy5jb21wb3NpbmcgPyB0aGlzLmxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykgOiBudWxsO1xuICAgICAgICBsZXQgbG9jYWxDb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9uICYmIGNvbXBvc2l0aW9uLnBvcyA+IC0xID8gY29tcG9zaXRpb24gOiBudWxsO1xuICAgICAgICBsZXQgY29tcG9zaXRpb25JbkNoaWxkID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zIDwgMDtcbiAgICAgICAgbGV0IHVwZGF0ZXIgPSBuZXcgVmlld1RyZWVVcGRhdGVyKHRoaXMsIGxvY2FsQ29tcG9zaXRpb24gJiYgbG9jYWxDb21wb3NpdGlvbi5ub2RlLCB2aWV3KTtcbiAgICAgICAgaXRlckRlY28odGhpcy5ub2RlLCB0aGlzLmlubmVyRGVjbywgKHdpZGdldCwgaSwgaW5zaWRlTm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHdpZGdldC5zcGVjLm1hcmtzKVxuICAgICAgICAgICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3Mod2lkZ2V0LnNwZWMubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICBlbHNlIGlmICh3aWRnZXQudHlwZS5zaWRlID49IDAgJiYgIWluc2lkZU5vZGUpXG4gICAgICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhpID09IHRoaXMubm9kZS5jaGlsZENvdW50ID8gTWFyay5ub25lIDogdGhpcy5ub2RlLmNoaWxkKGkpLm1hcmtzLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgbm9kZSBpcyBhIGRlc2MgbWF0Y2hpbmcgdGhpcyB3aWRnZXQsIHJldXNlIGl0LFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGluc2VydCB0aGUgd2lkZ2V0IGFzIGEgbmV3IHZpZXcgZGVzYy5cbiAgICAgICAgICAgIHVwZGF0ZXIucGxhY2VXaWRnZXQod2lkZ2V0LCB2aWV3LCBvZmYpO1xuICAgICAgICB9LCAoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpKSA9PiB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHdyYXBwaW5nIG1hcmsgZGVzY3MgbWF0Y2ggdGhlIG5vZGUncyBtYXJrcy5cbiAgICAgICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoY2hpbGQubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAvLyBUcnkgc2V2ZXJhbCBzdHJhdGVnaWVzIGZvciBkcmF3aW5nIHRoaXMgbm9kZVxuICAgICAgICAgICAgbGV0IGNvbXBJbmRleDtcbiAgICAgICAgICAgIGlmICh1cGRhdGVyLmZpbmROb2RlTWF0Y2goY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9zaXRpb25JbkNoaWxkICYmIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPiBvZmYgJiZcbiAgICAgICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byA8IG9mZiArIGNoaWxkLm5vZGVTaXplICYmXG4gICAgICAgICAgICAgICAgKGNvbXBJbmRleCA9IHVwZGF0ZXIuZmluZEluZGV4V2l0aENoaWxkKGNvbXBvc2l0aW9uLm5vZGUpKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgdXBkYXRlci51cGRhdGVOb2RlQXQoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBjb21wSW5kZXgsIHZpZXcpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICh1cGRhdGVyLnVwZGF0ZU5leHROb2RlKGNoaWxkLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgaSwgb2ZmKSkgO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGl0IGFzIGEgbmV3IHZpZXdcbiAgICAgICAgICAgICAgICB1cGRhdGVyLmFkZE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBvZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRHJvcCBhbGwgcmVtYWluaW5nIGRlc2NzIGFmdGVyIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKFtdLCBpbmxpbmUsIHZpZXcpO1xuICAgICAgICBpZiAodGhpcy5ub2RlLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgdXBkYXRlci5hZGRUZXh0YmxvY2tIYWNrcygpO1xuICAgICAgICB1cGRhdGVyLmRlc3Ryb3lSZXN0KCk7XG4gICAgICAgIC8vIFN5bmMgdGhlIERPTSBpZiBhbnl0aGluZyBjaGFuZ2VkXG4gICAgICAgIGlmICh1cGRhdGVyLmNoYW5nZWQgfHwgdGhpcy5kaXJ0eSA9PSBDT05URU5UX0RJUlRZKSB7XG4gICAgICAgICAgICAvLyBNYXkgaGF2ZSB0byBwcm90ZWN0IGZvY3VzZWQgRE9NIGZyb20gYmVpbmcgY2hhbmdlZCBpZiBhIGNvbXBvc2l0aW9uIGlzIGFjdGl2ZVxuICAgICAgICAgICAgaWYgKGxvY2FsQ29tcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgdGhpcy5wcm90ZWN0TG9jYWxDb21wb3NpdGlvbih2aWV3LCBsb2NhbENvbXBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlckRlc2NzKHRoaXMuY29udGVudERPTSwgdGhpcy5jaGlsZHJlbiwgdmlldyk7XG4gICAgICAgICAgICBpZiAoaW9zKVxuICAgICAgICAgICAgICAgIGlvc0hhY2tzKHRoaXMuZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2NhbENvbXBvc2l0aW9uSW5mbyh2aWV3LCBwb3MpIHtcbiAgICAgICAgLy8gT25seSBkbyBzb21ldGhpbmcgaWYgYm90aCB0aGUgc2VsZWN0aW9uIGFuZCBhIGZvY3VzZWQgdGV4dCBub2RlXG4gICAgICAgIC8vIGFyZSBpbnNpZGUgb2YgdGhpcyBub2RlXG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB8fCBmcm9tIDwgcG9zIHx8IHRvID4gcG9zICsgdGhpcy5ub2RlLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdGV4dE5vZGUgPSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZTtcbiAgICAgICAgaWYgKCF0ZXh0Tm9kZSB8fCAhdGhpcy5kb20uY29udGFpbnModGV4dE5vZGUucGFyZW50Tm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSB0ZXh0IGluIHRoZSBmb2N1c2VkIG5vZGUgaW4gdGhlIG5vZGUsIHN0b3AgaWYgaXQncyBub3RcbiAgICAgICAgICAgIC8vIHRoZXJlIChtYXkgaGF2ZSBiZWVuIG1vZGlmaWVkIHRocm91Z2ggb3RoZXIgbWVhbnMsIGluIHdoaWNoXG4gICAgICAgICAgICAvLyBjYXNlIGl0IHNob3VsZCBvdmVyd3JpdHRlbilcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gdGV4dE5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgbGV0IHRleHRQb3MgPSBmaW5kVGV4dEluRnJhZ21lbnQodGhpcy5ub2RlLmNvbnRlbnQsIHRleHQsIGZyb20gLSBwb3MsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0UG9zIDwgMCA/IG51bGwgOiB7IG5vZGU6IHRleHROb2RlLCBwb3M6IHRleHRQb3MsIHRleHQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHRleHROb2RlLCBwb3M6IC0xLCB0ZXh0OiBcIlwiIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvdGVjdExvY2FsQ29tcG9zaXRpb24odmlldywgeyBub2RlLCBwb3MsIHRleHQgfSkge1xuICAgICAgICAvLyBUaGUgbm9kZSBpcyBhbHJlYWR5IHBhcnQgb2YgYSBsb2NhbCB2aWV3IGRlc2MsIGxlYXZlIGl0IHRoZXJlXG4gICAgICAgIGlmICh0aGlzLmdldERlc2Mobm9kZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbXBvc2l0aW9uIHZpZXcgZm9yIHRoZSBvcnBoYW5lZCBub2Rlc1xuICAgICAgICBsZXQgdG9wTm9kZSA9IG5vZGU7XG4gICAgICAgIGZvciAoOzsgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgaWYgKHRvcE5vZGUucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB3aGlsZSAodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgdG9wTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvcE5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgIHdoaWxlICh0b3BOb2RlLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgICAgIHRvcE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b3BOb2RlLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIGlmICh0b3BOb2RlLnBtVmlld0Rlc2MpXG4gICAgICAgICAgICAgICAgdG9wTm9kZS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXNjID0gbmV3IENvbXBvc2l0aW9uVmlld0Rlc2ModGhpcywgdG9wTm9kZSwgbm9kZSwgdGV4dCk7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5wdXNoKGRlc2MpO1xuICAgICAgICAvLyBQYXRjaCB1cCB0aGlzLmNoaWxkcmVuIHRvIGNvbnRhaW4gdGhlIGNvbXBvc2l0aW9uIHZpZXdcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IHJlcGxhY2VOb2Rlcyh0aGlzLmNoaWxkcmVuLCBwb3MsIHBvcyArIHRleHQubGVuZ3RoLCB2aWV3LCBkZXNjKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyBkZXNjIG11c3QgYmUgdXBkYXRlZCB0byBtYXRjaCB0aGUgZ2l2ZW4gbm9kZSBkZWNvcmF0aW9uLFxuICAgIC8vIGRvIHNvIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIHRoaXMudXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbyk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuaW5uZXJEZWNvID0gaW5uZXJEZWNvO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbih2aWV3LCB0aGlzLnBvc0F0U3RhcnQpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgIH1cbiAgICB1cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKSB7XG4gICAgICAgIGlmIChzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgdGhpcy5vdXRlckRlY28pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbmVlZHNXcmFwID0gdGhpcy5ub2RlRE9NLm5vZGVUeXBlICE9IDE7XG4gICAgICAgIGxldCBvbGRET00gPSB0aGlzLmRvbTtcbiAgICAgICAgdGhpcy5kb20gPSBwYXRjaE91dGVyRGVjbyh0aGlzLmRvbSwgdGhpcy5ub2RlRE9NLCBjb21wdXRlT3V0ZXJEZWNvKHRoaXMub3V0ZXJEZWNvLCB0aGlzLm5vZGUsIG5lZWRzV3JhcCksIGNvbXB1dGVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm5vZGUsIG5lZWRzV3JhcCkpO1xuICAgICAgICBpZiAodGhpcy5kb20gIT0gb2xkRE9NKSB7XG4gICAgICAgICAgICBvbGRET00ucG1WaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgIH1cbiAgICAvLyBNYXJrIHRoaXMgbm9kZSBhcyBiZWluZyB0aGUgc2VsZWN0ZWQgbm9kZS5cbiAgICBzZWxlY3ROb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlRE9NLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICB0aGlzLm5vZGVET00uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSB8fCAhdGhpcy5ub2RlLnR5cGUuc3BlYy5kcmFnZ2FibGUpXG4gICAgICAgICAgICB0aGlzLmRvbS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgc2VsZWN0ZWQgbm9kZSBtYXJraW5nIGZyb20gdGhpcyBub2RlLlxuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVET00uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRoaXMubm9kZS5pc0F0b207IH1cbn1cbi8vIENyZWF0ZSBhIHZpZXcgZGVzYyBmb3IgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBub2RlLCB0byBiZSBleHBvcnRlZFxuLy8gYW5kIHVzZWQgYnkgdGhlIHZpZXcgY2xhc3MuXG5mdW5jdGlvbiBkb2NWaWV3RGVzYyhkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIHZpZXcpIHtcbiAgICBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgZG9jKTtcbiAgICBsZXQgZG9jVmlldyA9IG5ldyBOb2RlVmlld0Rlc2ModW5kZWZpbmVkLCBkb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGRvbSwgZG9tLCB2aWV3LCAwKTtcbiAgICBpZiAoZG9jVmlldy5jb250ZW50RE9NKVxuICAgICAgICBkb2NWaWV3LnVwZGF0ZUNoaWxkcmVuKHZpZXcsIDApO1xuICAgIHJldHVybiBkb2NWaWV3O1xufVxuY2xhc3MgVGV4dFZpZXdEZXNjIGV4dGVuZHMgTm9kZVZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBudWxsLCBub2RlRE9NLCB2aWV3LCAwKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICBsZXQgc2tpcCA9IHRoaXMubm9kZURPTS5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSAoc2tpcCAmJiBza2lwICE9IHRoaXMuZG9tICYmICFza2lwLnBtSXNEZWNvKVxuICAgICAgICAgICAgc2tpcCA9IHNraXAucGFyZW50Tm9kZTtcbiAgICAgICAgcmV0dXJuIHsgc2tpcDogKHNraXAgfHwgdHJ1ZSkgfTtcbiAgICB9XG4gICAgdXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09IE5PREVfRElSVFkgfHwgKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZICYmICF0aGlzLmluUGFyZW50KCkpIHx8XG4gICAgICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlT3V0ZXJEZWNvKG91dGVyRGVjbyk7XG4gICAgICAgIGlmICgodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkgfHwgbm9kZS50ZXh0ICE9IHRoaXMubm9kZS50ZXh0KSAmJiBub2RlLnRleHQgIT0gdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLm5vZGVWYWx1ZSA9IG5vZGUudGV4dDtcbiAgICAgICAgICAgIGlmICh2aWV3LnRyYWNrV3JpdGVzID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaW5QYXJlbnQoKSB7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSB0aGlzLnBhcmVudC5jb250ZW50RE9NO1xuICAgICAgICBmb3IgKGxldCBuID0gdGhpcy5ub2RlRE9NOyBuOyBuID0gbi5wYXJlbnROb2RlKVxuICAgICAgICAgICAgaWYgKG4gPT0gcGFyZW50RE9NKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zKSB7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMubm9kZURPTSwgb2Zmc2V0OiBwb3MgfTtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGlmIChkb20gPT0gdGhpcy5ub2RlRE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIE1hdGgubWluKG9mZnNldCwgdGhpcy5ub2RlLnRleHQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcyk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwiY2hhcmFjdGVyRGF0YVwiICYmIG11dGF0aW9uLnR5cGUgIT0gXCJzZWxlY3Rpb25cIjtcbiAgICB9XG4gICAgc2xpY2UoZnJvbSwgdG8sIHZpZXcpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLm5vZGUuY3V0KGZyb20sIHRvKSwgZG9tID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS50ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Vmlld0Rlc2ModGhpcy5wYXJlbnQsIG5vZGUsIHRoaXMub3V0ZXJEZWNvLCB0aGlzLmlubmVyRGVjbywgZG9tLCBkb20sIHZpZXcpO1xuICAgIH1cbiAgICBtYXJrRGlydHkoZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIubWFya0RpcnR5KGZyb20sIHRvKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9IHRoaXMubm9kZURPTSAmJiAoZnJvbSA9PSAwIHx8IHRvID09IHRoaXMubm9kZURPTS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBOT0RFX0RJUlRZO1xuICAgIH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaXNUZXh0KHRleHQpIHsgcmV0dXJuIHRoaXMubm9kZS50ZXh0ID09IHRleHQ7IH1cbn1cbi8vIEEgZHVtbXkgZGVzYyB1c2VkIHRvIHRhZyB0cmFpbGluZyBCUiBvciBJTUcgbm9kZXMgY3JlYXRlZCB0byB3b3JrXG4vLyBhcm91bmQgY29udGVudEVkaXRhYmxlIHRlcnJpYmxlbmVzcy5cbmNsYXNzIFRyYWlsaW5nSGFja1ZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIHBhcnNlUnVsZSgpIHsgcmV0dXJuIHsgaWdub3JlOiB0cnVlIH07IH1cbiAgICBtYXRjaGVzSGFjayhub2RlTmFtZSkgeyByZXR1cm4gdGhpcy5kaXJ0eSA9PSBOT1RfRElSVFkgJiYgdGhpcy5kb20ubm9kZU5hbWUgPT0gbm9kZU5hbWU7IH1cbiAgICBnZXQgZG9tQXRvbSgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaWdub3JlRm9yQ29vcmRzKCkgeyByZXR1cm4gdGhpcy5kb20ubm9kZU5hbWUgPT0gXCJJTUdcIjsgfVxufVxuLy8gQSBzZXBhcmF0ZSBzdWJjbGFzcyBpcyB1c2VkIGZvciBjdXN0b21pemVkIG5vZGUgdmlld3MsIHNvIHRoYXQgdGhlXG4vLyBleHRyYSBjaGVja3Mgb25seSBoYXZlIHRvIGJlIG1hZGUgZm9yIG5vZGVzIHRoYXQgYXJlIGFjdHVhbGx5XG4vLyBjdXN0b21pemVkLlxuY2xhc3MgQ3VzdG9tTm9kZVZpZXdEZXNjIGV4dGVuZHMgTm9kZVZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHNwZWMsIHZpZXcsIHBvcykge1xuICAgICAgICBzdXBlcihwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00sIG5vZGVET00sIHZpZXcsIHBvcyk7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxuICAgIC8vIEEgY3VzdG9tIGB1cGRhdGVgIG1ldGhvZCBnZXRzIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSB1cGRhdGUgZ29lc1xuICAgIC8vIHRocm91Z2guIElmIGl0IGRvZXMsIGFuZCB0aGVyZSdzIGEgYGNvbnRlbnRET01gIG5vZGUsIG91ciBsb2dpY1xuICAgIC8vIHVwZGF0ZXMgdGhlIGNoaWxkcmVuLlxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zcGVjLnVwZGF0ZSAmJiAodGhpcy5ub2RlLnR5cGUgPT0gbm9kZS50eXBlIHx8IHRoaXMuc3BlYy5tdWx0aVR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zcGVjLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5jb250ZW50RE9NICYmICFub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuc2VsZWN0Tm9kZSgpIDogc3VwZXIuc2VsZWN0Tm9kZSgpO1xuICAgIH1cbiAgICBkZXNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5kZXNlbGVjdE5vZGUgPyB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlKCkgOiBzdXBlci5kZXNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldywgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5zcGVjLnNldFNlbGVjdGlvbiA/IHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LnJvb3QpXG4gICAgICAgICAgICA6IHN1cGVyLnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcsIGZvcmNlKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3koKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5zdG9wRXZlbnQgPyB0aGlzLnNwZWMuc3RvcEV2ZW50KGV2ZW50KSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uID8gdGhpcy5zcGVjLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSA6IHN1cGVyLmlnbm9yZU11dGF0aW9uKG11dGF0aW9uKTtcbiAgICB9XG59XG4vLyBTeW5jIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiBET00gbm9kZSB3aXRoIHRoZSBub2RlcyBhc3NvY2lhdGVkXG4vLyB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZiB2aWV3IGRlc2NzLCByZWN1cnNpbmcgaW50byBtYXJrIGRlc2NzXG4vLyBiZWNhdXNlIHRoaXMgc2hvdWxkIHN5bmMgdGhlIHN1YnRyZWUgZm9yIGEgd2hvbGUgbm9kZSBhdCBhIHRpbWUuXG5mdW5jdGlvbiByZW5kZXJEZXNjcyhwYXJlbnRET00sIGRlc2NzLCB2aWV3KSB7XG4gICAgbGV0IGRvbSA9IHBhcmVudERPTS5maXJzdENoaWxkLCB3cml0dGVuID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZGVzYyA9IGRlc2NzW2ldLCBjaGlsZERPTSA9IGRlc2MuZG9tO1xuICAgICAgICBpZiAoY2hpbGRET00ucGFyZW50Tm9kZSA9PSBwYXJlbnRET00pIHtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZERPTSAhPSBkb20pIHtcbiAgICAgICAgICAgICAgICBkb20gPSBybShkb20pO1xuICAgICAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tID0gZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICBwYXJlbnRET00uaW5zZXJ0QmVmb3JlKGNoaWxkRE9NLCBkb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gZG9tID8gZG9tLnByZXZpb3VzU2libGluZyA6IHBhcmVudERPTS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICByZW5kZXJEZXNjcyhkZXNjLmNvbnRlbnRET00sIGRlc2MuY2hpbGRyZW4sIHZpZXcpO1xuICAgICAgICAgICAgZG9tID0gcG9zID8gcG9zLm5leHRTaWJsaW5nIDogcGFyZW50RE9NLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgICBkb20gPSBybShkb20pO1xuICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHdyaXR0ZW4gJiYgdmlldy50cmFja1dyaXRlcyA9PSBwYXJlbnRET00pXG4gICAgICAgIHZpZXcudHJhY2tXcml0ZXMgPSBudWxsO1xufVxuY29uc3QgT3V0ZXJEZWNvTGV2ZWwgPSBmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgICBpZiAobm9kZU5hbWUpXG4gICAgICAgIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcbn07XG5PdXRlckRlY29MZXZlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3Qgbm9EZWNvID0gW25ldyBPdXRlckRlY29MZXZlbF07XG5mdW5jdGlvbiBjb21wdXRlT3V0ZXJEZWNvKG91dGVyRGVjbywgbm9kZSwgbmVlZHNXcmFwKSB7XG4gICAgaWYgKG91dGVyRGVjby5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG5vRGVjbztcbiAgICBsZXQgdG9wID0gbmVlZHNXcmFwID8gbm9EZWNvWzBdIDogbmV3IE91dGVyRGVjb0xldmVsLCByZXN1bHQgPSBbdG9wXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGVyRGVjby5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYXR0cnMgPSBvdXRlckRlY29baV0udHlwZS5hdHRycztcbiAgICAgICAgaWYgKCFhdHRycylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYXR0cnMubm9kZU5hbWUpXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0b3AgPSBuZXcgT3V0ZXJEZWNvTGV2ZWwoYXR0cnMubm9kZU5hbWUpKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG5lZWRzV3JhcCAmJiByZXN1bHQubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKG5vZGUuaXNJbmxpbmUgPyBcInNwYW5cIiA6IFwiZGl2XCIpKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICB0b3AuY2xhc3MgPSAodG9wLmNsYXNzID8gdG9wLmNsYXNzICsgXCIgXCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgIHRvcC5zdHlsZSA9ICh0b3Auc3R5bGUgPyB0b3Auc3R5bGUgKyBcIjtcIiA6IFwiXCIpICsgdmFsO1xuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSAhPSBcIm5vZGVOYW1lXCIpXG4gICAgICAgICAgICAgICAgdG9wW25hbWVdID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXRjaE91dGVyRGVjbyhvdXRlckRPTSwgbm9kZURPTSwgcHJldkNvbXB1dGVkLCBjdXJDb21wdXRlZCkge1xuICAgIC8vIFNob3J0Y3V0IGZvciB0cml2aWFsIGNhc2VcbiAgICBpZiAocHJldkNvbXB1dGVkID09IG5vRGVjbyAmJiBjdXJDb21wdXRlZCA9PSBub0RlY28pXG4gICAgICAgIHJldHVybiBub2RlRE9NO1xuICAgIGxldCBjdXJET00gPSBub2RlRE9NO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyQ29tcHV0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlY28gPSBjdXJDb21wdXRlZFtpXSwgcHJldiA9IHByZXZDb21wdXRlZFtpXTtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2Lm5vZGVOYW1lID09IGRlY28ubm9kZU5hbWUgJiYgY3VyRE9NICE9IG91dGVyRE9NICYmXG4gICAgICAgICAgICAgICAgKHBhcmVudCA9IGN1ckRPTS5wYXJlbnROb2RlKSAmJiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSBkZWNvLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkZWNvLm5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQucG1Jc0RlY28gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjdXJET00pO1xuICAgICAgICAgICAgICAgIHByZXYgPSBub0RlY29bMF07XG4gICAgICAgICAgICAgICAgY3VyRE9NID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhdGNoQXR0cmlidXRlcyhjdXJET00sIHByZXYgfHwgbm9EZWNvWzBdLCBkZWNvKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1ckRPTTtcbn1cbmZ1bmN0aW9uIHBhdGNoQXR0cmlidXRlcyhkb20sIHByZXYsIGN1cikge1xuICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmICEobmFtZSBpbiBjdXIpKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGN1cilcbiAgICAgICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiICYmIG5hbWUgIT0gXCJzdHlsZVwiICYmIG5hbWUgIT0gXCJub2RlTmFtZVwiICYmIGN1cltuYW1lXSAhPSBwcmV2W25hbWVdKVxuICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBjdXJbbmFtZV0pO1xuICAgIGlmIChwcmV2LmNsYXNzICE9IGN1ci5jbGFzcykge1xuICAgICAgICBsZXQgcHJldkxpc3QgPSBwcmV2LmNsYXNzID8gcHJldi5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGxldCBjdXJMaXN0ID0gY3VyLmNsYXNzID8gY3VyLmNsYXNzLnNwbGl0KFwiIFwiKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2TGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChjdXJMaXN0LmluZGV4T2YocHJldkxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QucmVtb3ZlKHByZXZMaXN0W2ldKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHByZXZMaXN0LmluZGV4T2YoY3VyTGlzdFtpXSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoY3VyTGlzdFtpXSk7XG4gICAgICAgIGlmIChkb20uY2xhc3NMaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgIH1cbiAgICBpZiAocHJldi5zdHlsZSAhPSBjdXIuc3R5bGUpIHtcbiAgICAgICAgaWYgKHByZXYuc3R5bGUpIHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gL1xccyooW1xcd1xcLVxceGExLVxcdWZmZmZdKylcXHMqOig/OlwiKD86XFxcXC58W15cIl0pKlwifCcoPzpcXFxcLnxbXiddKSonfFxcKC4qP1xcKXxbXjtdKSovZywgbTtcbiAgICAgICAgICAgIHdoaWxlIChtID0gcHJvcC5leGVjKHByZXYuc3R5bGUpKVxuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShtWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyLnN0eWxlKVxuICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgKz0gY3VyLnN0eWxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5T3V0ZXJEZWNvKGRvbSwgZGVjbywgbm9kZSkge1xuICAgIHJldHVybiBwYXRjaE91dGVyRGVjbyhkb20sIGRvbSwgbm9EZWNvLCBjb21wdXRlT3V0ZXJEZWNvKGRlY28sIG5vZGUsIGRvbS5ub2RlVHlwZSAhPSAxKSk7XG59XG5mdW5jdGlvbiBzYW1lT3V0ZXJEZWNvKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS50eXBlLmVxKGJbaV0udHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXG5mdW5jdGlvbiBybShkb20pIHtcbiAgICBsZXQgbmV4dCA9IGRvbS5uZXh0U2libGluZztcbiAgICBkb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb20pO1xuICAgIHJldHVybiBuZXh0O1xufVxuLy8gSGVscGVyIGNsYXNzIGZvciBpbmNyZW1lbnRhbGx5IHVwZGF0aW5nIGEgdHJlZSBvZiBtYXJrIGRlc2NzIGFuZFxuLy8gdGhlIHdpZGdldCBhbmQgbm9kZSBkZXNjcyBpbnNpZGUgb2YgdGhlbS5cbmNsYXNzIFZpZXdUcmVlVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3IodG9wLCBsb2NrLCB2aWV3KSB7XG4gICAgICAgIHRoaXMubG9jayA9IGxvY2s7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIC8vIEluZGV4IGludG8gYHRoaXMudG9wYCdzIGNoaWxkIGFycmF5LCByZXByZXNlbnRzIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbi5cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIC8vIFdoZW4gZW50ZXJpbmcgYSBtYXJrLCB0aGUgY3VycmVudCB0b3AgYW5kIGluZGV4IGFyZSBwdXNoZWRcbiAgICAgICAgLy8gb250byB0aGlzLlxuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIGFueXRoaW5nIHdhcyBjaGFuZ2VkXG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5wcmVNYXRjaCA9IHByZU1hdGNoKHRvcC5ub2RlLmNvbnRlbnQsIHRvcCk7XG4gICAgfVxuICAgIC8vIERlc3Ryb3kgYW5kIHJlbW92ZSB0aGUgY2hpbGRyZW4gYmV0d2VlbiB0aGUgZ2l2ZW4gaW5kaWNlcyBpblxuICAgIC8vIGB0aGlzLnRvcGAuXG4gICAgZGVzdHJveUJldHdlZW4oc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIC8vIERlc3Ryb3kgYWxsIHJlbWFpbmluZyBjaGlsZHJlbiBpbiBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lSZXN0KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN5bmMgdGhlIGN1cnJlbnQgc3RhY2sgb2YgbWFyayBkZXNjcyB3aXRoIHRoZSBnaXZlbiBhcnJheSBvZlxuICAgIC8vIG1hcmtzLCByZXVzaW5nIGV4aXN0aW5nIG1hcmsgZGVzY3Mgd2hlbiBwb3NzaWJsZS5cbiAgICBzeW5jVG9NYXJrcyhtYXJrcywgaW5saW5lLCB2aWV3KSB7XG4gICAgICAgIGxldCBrZWVwID0gMCwgZGVwdGggPSB0aGlzLnN0YWNrLmxlbmd0aCA+PiAxO1xuICAgICAgICBsZXQgbWF4S2VlcCA9IE1hdGgubWluKGRlcHRoLCBtYXJrcy5sZW5ndGgpO1xuICAgICAgICB3aGlsZSAoa2VlcCA8IG1heEtlZXAgJiZcbiAgICAgICAgICAgIChrZWVwID09IGRlcHRoIC0gMSA/IHRoaXMudG9wIDogdGhpcy5zdGFja1soa2VlcCArIDEpIDw8IDFdKVxuICAgICAgICAgICAgICAgIC5tYXRjaGVzTWFyayhtYXJrc1trZWVwXSkgJiYgbWFya3Nba2VlcF0udHlwZS5zcGVjLnNwYW5uaW5nICE9PSBmYWxzZSlcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBkZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UmVzdCgpO1xuICAgICAgICAgICAgdGhpcy50b3AuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGRlcHRoIDwgbWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy50b3AsIHRoaXMuaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCBNYXRoLm1pbih0aGlzLmluZGV4ICsgMywgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5tYXRjaGVzTWFyayhtYXJrc1tkZXB0aF0pICYmICF0aGlzLmlzTG9ja2VkKG5leHQuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrRGVzYyA9IE1hcmtWaWV3RGVzYy5jcmVhdGUodGhpcy50b3AsIG1hcmtzW2RlcHRoXSwgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCwgMCwgbWFya0Rlc2MpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gbWFya0Rlc2M7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIG5vZGUgZGVzYyBtYXRjaGluZyB0aGUgZ2l2ZW4gZGF0YS4gU2tpcCBvdmVyIGl0IGFuZFxuICAgIC8vIHJldHVybiB0cnVlIHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICBmaW5kTm9kZU1hdGNoKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCkge1xuICAgICAgICBsZXQgZm91bmQgPSAtMSwgdGFyZ2V0RGVzYztcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMucHJlTWF0Y2guaW5kZXggJiZcbiAgICAgICAgICAgICh0YXJnZXREZXNjID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVzW2luZGV4IC0gdGhpcy5wcmVNYXRjaC5pbmRleF0pLnBhcmVudCA9PSB0aGlzLnRvcCAmJlxuICAgICAgICAgICAgdGFyZ2V0RGVzYy5tYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdGhpcy50b3AuY2hpbGRyZW4uaW5kZXhPZih0YXJnZXREZXNjLCB0aGlzLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4LCBlID0gTWF0aC5taW4odGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoLCBpICsgNSk7IGkgPCBlOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pICYmICF0aGlzLnByZU1hdGNoLm1hdGNoZWQuaGFzKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmQgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGZvdW5kKTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlTm9kZUF0KG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBpbmRleCwgdmlldykge1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgIGlmIChjaGlsZC5kaXJ0eSA9PSBOT0RFX0RJUlRZICYmIGNoaWxkLmRvbSA9PSBjaGlsZC5jb250ZW50RE9NKVxuICAgICAgICAgICAgY2hpbGQuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgICAgICBpZiAoIWNoaWxkLnVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaW5kZXgpO1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmaW5kSW5kZXhXaXRoQ2hpbGQoZG9tTm9kZSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PSB0aGlzLnRvcC5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlc2MgPSBkb21Ob2RlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvcC5jaGlsZHJlbltpXSA9PSBkZXNjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tTm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gdXBkYXRlIHRoZSBuZXh0IG5vZGUsIGlmIGFueSwgdG8gdGhlIGdpdmVuIGRhdGEuIENoZWNrc1xuICAgIC8vIHByZS1tYXRjaGVzIHRvIGF2b2lkIG92ZXJ3cml0aW5nIG5vZGVzIHRoYXQgY291bGQgc3RpbGwgYmUgdXNlZC5cbiAgICB1cGRhdGVOZXh0Tm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgaW5kZXgsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMudG9wLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBOb2RlVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJlTWF0Y2ggPSB0aGlzLnByZU1hdGNoLm1hdGNoZWQuZ2V0KG5leHQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVNYXRjaCAhPSBudWxsICYmIHByZU1hdGNoICE9IGluZGV4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRET00gPSBuZXh0LmRvbSwgdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCB1cGRhdGUgaWYgbmV4dERPTSBpcyBvciBjb250YWlucyB0aGlzLmxvY2ssIGV4Y2VwdCBpZlxuICAgICAgICAgICAgICAgIC8vIGl0J3MgYSB0ZXh0IG5vZGUgd2hvc2UgY29udGVudCBhbHJlYWR5IG1hdGNoZXMgdGhlIG5ldyB0ZXh0XG4gICAgICAgICAgICAgICAgLy8gYW5kIHdob3NlIGRlY29yYXRpb25zIG1hdGNoIHRoZSBuZXcgb25lcy5cbiAgICAgICAgICAgICAgICBsZXQgbG9ja2VkID0gdGhpcy5pc0xvY2tlZChuZXh0RE9NKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKG5vZGUuaXNUZXh0ICYmIG5leHQubm9kZSAmJiBuZXh0Lm5vZGUuaXNUZXh0ICYmIG5leHQubm9kZURPTS5ub2RlVmFsdWUgPT0gbm9kZS50ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmRpcnR5ICE9IE5PREVfRElSVFkgJiYgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIG5leHQub3V0ZXJEZWNvKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NrZWQgJiYgbmV4dC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveUJldHdlZW4odGhpcy5pbmRleCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbSAhPSBuZXh0RE9NKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWxvY2tlZCAmJiAodXBkYXRlZCA9IHRoaXMucmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVkLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZC51cGRhdGVDaGlsZHJlbih2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXaGVuIGEgbm9kZSB3aXRoIGNvbnRlbnQgaXMgcmVwbGFjZWQgYnkgYSBkaWZmZXJlbnQgbm9kZSB3aXRoXG4gICAgLy8gaWRlbnRpY2FsIGNvbnRlbnQsIG1vdmUgb3ZlciBpdHMgY2hpbGRyZW4uXG4gICAgcmVjcmVhdGVXcmFwcGVyKG5leHQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgaWYgKG5leHQuZGlydHkgfHwgbm9kZS5pc0F0b20gfHwgIW5leHQuY2hpbGRyZW4ubGVuZ3RoIHx8XG4gICAgICAgICAgICAhbmV4dC5ub2RlLmNvbnRlbnQuZXEobm9kZS5jb250ZW50KSB8fFxuICAgICAgICAgICAgIXNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykgfHwgIWlubmVyRGVjby5lcShuZXh0LmlubmVyRGVjbykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKTtcbiAgICAgICAgaWYgKHdyYXBwZXIuY29udGVudERPTSkge1xuICAgICAgICAgICAgd3JhcHBlci5jaGlsZHJlbiA9IG5leHQuY2hpbGRyZW47XG4gICAgICAgICAgICBuZXh0LmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBjaCBvZiB3cmFwcGVyLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoLnBhcmVudCA9IHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dC5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICAvLyBJbnNlcnQgdGhlIG5vZGUgYXMgYSBuZXdseSBjcmVhdGVkIG5vZGUgZGVzYy5cbiAgICBhZGROb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGRlc2MgPSBOb2RlVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKTtcbiAgICAgICAgaWYgKGRlc2MuY29udGVudERPTSlcbiAgICAgICAgICAgIGRlc2MudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGRlc2MpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIHBvcykge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuaW5kZXggPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGggPyB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4XSA6IG51bGw7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQubWF0Y2hlc1dpZGdldCh3aWRnZXQpICYmXG4gICAgICAgICAgICAod2lkZ2V0ID09IG5leHQud2lkZ2V0IHx8ICFuZXh0LndpZGdldC50eXBlLnRvRE9NLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IG5ldyBXaWRnZXRWaWV3RGVzYyh0aGlzLnRvcCwgd2lkZ2V0LCB2aWV3LCBwb3MpO1xuICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgZGVzYyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhIHRleHRibG9jayBsb29rcyBhbmQgYmVoYXZlcyBjb3JyZWN0bHkgaW5cbiAgICAvLyBjb250ZW50RWRpdGFibGUuXG4gICAgYWRkVGV4dGJsb2NrSGFja3MoKSB7XG4gICAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLnRvcC5jaGlsZHJlblt0aGlzLmluZGV4IC0gMV0sIHBhcmVudCA9IHRoaXMudG9wO1xuICAgICAgICB3aGlsZSAobGFzdENoaWxkIGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGFzdENoaWxkIHx8IC8vIEVtcHR5IHRleHRibG9ja1xuICAgICAgICAgICAgIShsYXN0Q2hpbGQgaW5zdGFuY2VvZiBUZXh0Vmlld0Rlc2MpIHx8XG4gICAgICAgICAgICAvXFxuJC8udGVzdChsYXN0Q2hpbGQubm9kZS50ZXh0KSB8fFxuICAgICAgICAgICAgKHRoaXMudmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgJiYgL1xccyQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkpKSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBidWdzIGluIFNhZmFyaSdzIGN1cnNvciBkcmF3aW5nICgjMTE2NSkgYW5kIENocm9tZSdzIG1vdXNlIHNlbGVjdGlvbiAoIzExNTIpXG4gICAgICAgICAgICBpZiAoKHNhZmFyaSB8fCBjaHJvbWUpICYmIGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuZG9tLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIklNR1wiLCBwYXJlbnQpO1xuICAgICAgICAgICAgdGhpcy5hZGRIYWNrTm9kZShcIkJSXCIsIHRoaXMudG9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIYWNrTm9kZShub2RlTmFtZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AgJiYgdGhpcy5pbmRleCA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggJiYgcGFyZW50LmNoaWxkcmVuW3RoaXMuaW5kZXhdLm1hdGNoZXNIYWNrKG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09IFwiSU1HXCIpIHtcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgICAgICAgICBkb20uYWx0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSBcIkJSXCIpXG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItdHJhaWxpbmdCcmVha1wiO1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBuZXcgVHJhaWxpbmdIYWNrVmlld0Rlc2ModGhpcy50b3AsIFtdLCBkb20sIG51bGwpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAhPSB0aGlzLnRvcClcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChoYWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgrKywgMCwgaGFjayk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzTG9ja2VkKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jayAmJiAobm9kZSA9PSB0aGlzLmxvY2sgfHwgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY29udGFpbnModGhpcy5sb2NrLnBhcmVudE5vZGUpKTtcbiAgICB9XG59XG4vLyBJdGVyYXRlIGZyb20gdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgYW5kIGFycmF5IG9mIGRlc2NzIHRvIGZpbmRcbi8vIGRpcmVjdGx5IG1hdGNoaW5nIG9uZXMsIGluIG9yZGVyIHRvIGF2b2lkIG92ZXJlYWdlcmx5IHJldXNpbmcgdGhvc2Vcbi8vIGZvciBvdGhlciBub2Rlcy4gUmV0dXJucyB0aGUgZnJhZ21lbnQgaW5kZXggb2YgdGhlIGZpcnN0IG5vZGUgdGhhdFxuLy8gaXMgcGFydCBvZiB0aGUgc2VxdWVuY2Ugb2YgbWF0Y2hlZCBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuLy8gZnJhZ21lbnQuXG5mdW5jdGlvbiBwcmVNYXRjaChmcmFnLCBwYXJlbnREZXNjKSB7XG4gICAgbGV0IGN1ckRlc2MgPSBwYXJlbnREZXNjLCBkZXNjSSA9IGN1ckRlc2MuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBmSSA9IGZyYWcuY2hpbGRDb3VudCwgbWF0Y2hlZCA9IG5ldyBNYXAsIG1hdGNoZXMgPSBbXTtcbiAgICBvdXRlcjogd2hpbGUgKGZJID4gMCkge1xuICAgICAgICBsZXQgZGVzYztcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKGRlc2NJKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjdXJEZXNjLmNoaWxkcmVuW2Rlc2NJIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgaW5zdGFuY2VvZiBNYXJrVmlld0Rlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyRGVzYyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NJID0gbmV4dC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXNjID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZGVzY0ktLTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VyRGVzYyA9PSBwYXJlbnREZXNjKSB7XG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgIGRlc2NJID0gY3VyRGVzYy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjdXJEZXNjKTtcbiAgICAgICAgICAgICAgICBjdXJEZXNjID0gY3VyRGVzYy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vZGUgPSBkZXNjLm5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZSAhPSBmcmFnLmNoaWxkKGZJIC0gMSkpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLS1mSTtcbiAgICAgICAgbWF0Y2hlZC5zZXQoZGVzYywgZkkpO1xuICAgICAgICBtYXRjaGVzLnB1c2goZGVzYyk7XG4gICAgfVxuICAgIHJldHVybiB7IGluZGV4OiBmSSwgbWF0Y2hlZCwgbWF0Y2hlczogbWF0Y2hlcy5yZXZlcnNlKCkgfTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVTaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYS50eXBlLnNpZGUgLSBiLnR5cGUuc2lkZTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gYWJzdHJhY3RzIGl0ZXJhdGluZyBvdmVyIHRoZSBub2RlcyBhbmQgZGVjb3JhdGlvbnMgaW5cbi8vIGEgZnJhZ21lbnQuIENhbGxzIGBvbk5vZGVgIGZvciBlYWNoIG5vZGUsIHdpdGggaXRzIGxvY2FsIGFuZCBjaGlsZFxuLy8gZGVjb3JhdGlvbnMuIFNwbGl0cyB0ZXh0IG5vZGVzIHdoZW4gdGhlcmUgaXMgYSBkZWNvcmF0aW9uIHN0YXJ0aW5nXG4vLyBvciBlbmRpbmcgaW5zaWRlIG9mIHRoZW0uIENhbGxzIGBvbldpZGdldGAgZm9yIGVhY2ggd2lkZ2V0LlxuZnVuY3Rpb24gaXRlckRlY28ocGFyZW50LCBkZWNvLCBvbldpZGdldCwgb25Ob2RlKSB7XG4gICAgbGV0IGxvY2FscyA9IGRlY28ubG9jYWxzKHBhcmVudCksIG9mZnNldCA9IDA7XG4gICAgLy8gU2ltcGxlLCBjaGVhcCB2YXJpYW50IGZvciB3aGVuIHRoZXJlIGFyZSBubyBsb2NhbCBkZWNvcmF0aW9uc1xuICAgIGlmIChsb2NhbHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaSk7XG4gICAgICAgICAgICBvbk5vZGUoY2hpbGQsIGxvY2FscywgZGVjby5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKSwgaSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZGVjb0luZGV4ID0gMCwgYWN0aXZlID0gW10sIHJlc3ROb2RlID0gbnVsbDtcbiAgICBmb3IgKGxldCBwYXJlbnRJbmRleCA9IDA7Oykge1xuICAgICAgICBsZXQgd2lkZ2V0LCB3aWRnZXRzO1xuICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA9PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbG9jYWxzW2RlY29JbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChuZXh0LndpZGdldCkge1xuICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICB3aWRnZXQgPSBuZXh0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKHdpZGdldHMgfHwgKHdpZGdldHMgPSBbd2lkZ2V0XSkpLnB1c2gobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZGdldCkge1xuICAgICAgICAgICAgaWYgKHdpZGdldHMpIHtcbiAgICAgICAgICAgICAgICB3aWRnZXRzLnNvcnQoY29tcGFyZVNpZGUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkZ2V0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0c1tpXSwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25XaWRnZXQod2lkZ2V0LCBwYXJlbnRJbmRleCwgISFyZXN0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkLCBpbmRleDtcbiAgICAgICAgaWYgKHJlc3ROb2RlKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY2hpbGQgPSByZXN0Tm9kZTtcbiAgICAgICAgICAgIHJlc3ROb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnRJbmRleCA8IHBhcmVudC5jaGlsZENvdW50KSB7XG4gICAgICAgICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgICAgICAgICAgY2hpbGQgPSBwYXJlbnQuY2hpbGQocGFyZW50SW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPD0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8PSBvZmZzZXQgJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPiBvZmZzZXQpXG4gICAgICAgICAgICBhY3RpdmUucHVzaChsb2NhbHNbZGVjb0luZGV4KytdKTtcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldCArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgICAgICBsZXQgY3V0QXQgPSBlbmQ7XG4gICAgICAgICAgICBpZiAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS5mcm9tIDwgY3V0QXQpXG4gICAgICAgICAgICAgICAgY3V0QXQgPSBsb2NhbHNbZGVjb0luZGV4XS5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVtpXS50byA8IGN1dEF0KVxuICAgICAgICAgICAgICAgICAgICBjdXRBdCA9IGFjdGl2ZVtpXS50bztcbiAgICAgICAgICAgIGlmIChjdXRBdCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHJlc3ROb2RlID0gY2hpbGQuY3V0KGN1dEF0IC0gb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dCgwLCBjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgZW5kID0gY3V0QXQ7XG4gICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvIDwgZW5kKVxuICAgICAgICAgICAgICAgIGRlY29JbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRlckRlY28gPSBjaGlsZC5pc0lubGluZSAmJiAhY2hpbGQuaXNMZWFmID8gYWN0aXZlLmZpbHRlcihkID0+ICFkLmlubGluZSkgOiBhY3RpdmUuc2xpY2UoKTtcbiAgICAgICAgb25Ob2RlKGNoaWxkLCBvdXRlckRlY28sIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGluZGV4KTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgIH1cbn1cbi8vIExpc3QgbWFya2VycyBpbiBNb2JpbGUgU2FmYXJpIHdpbGwgbXlzdGVyaW91c2x5IGRpc2FwcGVhclxuLy8gc29tZXRpbWVzLiBUaGlzIHdvcmtzIGFyb3VuZCB0aGF0LlxuZnVuY3Rpb24gaW9zSGFja3MoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIlVMXCIgfHwgZG9tLm5vZGVOYW1lID09IFwiT0xcIikge1xuICAgICAgICBsZXQgb2xkQ1NTID0gZG9tLnN0eWxlLmNzc1RleHQ7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTICsgXCI7IGxpc3Qtc3R5bGU6IHNxdWFyZSAhaW1wb3J0YW50XCI7XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbSkubGlzdFN0eWxlO1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUztcbiAgICB9XG59XG4vLyBGaW5kIGEgcGllY2Ugb2YgdGV4dCBpbiBhbiBpbmxpbmUgZnJhZ21lbnQsIG92ZXJsYXBwaW5nIGZyb20tdG9cbmZ1bmN0aW9uIGZpbmRUZXh0SW5GcmFnbWVudChmcmFnLCB0ZXh0LCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgZnJhZy5jaGlsZENvdW50ICYmIHBvcyA8PSB0bzspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZnJhZy5jaGlsZChpKyspLCBjaGlsZFN0YXJ0ID0gcG9zO1xuICAgICAgICBwb3MgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGlmICghY2hpbGQuaXNUZXh0KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBzdHIgPSBjaGlsZC50ZXh0O1xuICAgICAgICB3aGlsZSAoaSA8IGZyYWcuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmcmFnLmNoaWxkKGkrKyk7XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmICghbmV4dC5pc1RleHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdHIgKz0gbmV4dC50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgaWYgKHBvcyA+PSB0byAmJiBzdHIuc2xpY2UodG8gLSB0ZXh0Lmxlbmd0aCAtIGNoaWxkU3RhcnQsIHRvIC0gY2hpbGRTdGFydCkgPT0gdGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gdG8gLSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGNoaWxkU3RhcnQgPCB0byA/IHN0ci5sYXN0SW5kZXhPZih0ZXh0LCB0byAtIGNoaWxkU3RhcnQgLSAxKSA6IC0xO1xuICAgICAgICAgICAgaWYgKGZvdW5kID49IDAgJiYgZm91bmQgKyB0ZXh0Lmxlbmd0aCArIGNoaWxkU3RhcnQgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRTdGFydCArIGZvdW5kO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gdG8gJiYgc3RyLmxlbmd0aCA+PSAodG8gKyB0ZXh0Lmxlbmd0aCkgLSBjaGlsZFN0YXJ0ICYmXG4gICAgICAgICAgICAgICAgc3RyLnNsaWNlKHRvIC0gY2hpbGRTdGFydCwgdG8gLSBjaGlsZFN0YXJ0ICsgdGV4dC5sZW5ndGgpID09IHRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8vIFJlcGxhY2UgcmFuZ2UgZnJvbS10byBpbiBhbiBhcnJheSBvZiB2aWV3IGRlc2NzIHdpdGggcmVwbGFjZW1lbnRcbi8vIChtYXkgYmUgbnVsbCB0byBqdXN0IGRlbGV0ZSkuIFRoaXMgZ29lcyB2ZXJ5IG11Y2ggYWdhaW5zdCB0aGUgZ3JhaW5cbi8vIG9mIHRoZSByZXN0IG9mIHRoaXMgY29kZSwgd2hpY2ggdGVuZHMgdG8gY3JlYXRlIG5vZGVzIHdpdGggdGhlXG4vLyByaWdodCBzaGFwZSBpbiBvbmUgZ28sIHJhdGhlciB0aGFuIG1lc3Npbmcgd2l0aCB0aGVtIGFmdGVyXG4vLyBjcmVhdGlvbiwgYnV0IGlzIG5lY2Vzc2FyeSBpbiB0aGUgY29tcG9zaXRpb24gaGFjay5cbmZ1bmN0aW9uIHJlcGxhY2VOb2Rlcyhub2RlcywgZnJvbSwgdG8sIHZpZXcsIHJlcGxhY2VtZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZXNbaV0sIHN0YXJ0ID0gb2ZmLCBlbmQgPSBvZmYgKz0gY2hpbGQuc2l6ZTtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRvIHx8IGVuZCA8PSBmcm9tKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCBmcm9tKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKDAsIGZyb20gLSBzdGFydCwgdmlldykpO1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkLnNsaWNlKHRvIC0gc3RhcnQsIGNoaWxkLnNpemUsIHZpZXcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcsIG9yaWdpbiA9IG51bGwpIHtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpLCBkb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBpZiAoIWRvbVNlbC5mb2N1c05vZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBuZWFyZXN0RGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhkb21TZWwuZm9jdXNOb2RlKSwgaW5XaWRnZXQgPSBuZWFyZXN0RGVzYyAmJiBuZWFyZXN0RGVzYy5zaXplID09IDA7XG4gICAgbGV0IGhlYWQgPSB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIDEpO1xuICAgIGlmIChoZWFkIDwgMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0ICRoZWFkID0gZG9jLnJlc29sdmUoaGVhZCksIGFuY2hvciwgc2VsZWN0aW9uO1xuICAgIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoZG9tU2VsKSkge1xuICAgICAgICBhbmNob3IgPSBoZWFkO1xuICAgICAgICB3aGlsZSAobmVhcmVzdERlc2MgJiYgIW5lYXJlc3REZXNjLm5vZGUpXG4gICAgICAgICAgICBuZWFyZXN0RGVzYyA9IG5lYXJlc3REZXNjLnBhcmVudDtcbiAgICAgICAgbGV0IG5lYXJlc3REZXNjTm9kZSA9IG5lYXJlc3REZXNjLm5vZGU7XG4gICAgICAgIGlmIChuZWFyZXN0RGVzYyAmJiBuZWFyZXN0RGVzY05vZGUuaXNBdG9tICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5lYXJlc3REZXNjTm9kZSkgJiYgbmVhcmVzdERlc2MucGFyZW50XG4gICAgICAgICAgICAmJiAhKG5lYXJlc3REZXNjTm9kZS5pc0lubGluZSAmJiBpc09uRWRnZShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQsIG5lYXJlc3REZXNjLmRvbSkpKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gbmVhcmVzdERlc2MucG9zQmVmb3JlO1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gbmV3IE5vZGVTZWxlY3Rpb24oaGVhZCA9PSBwb3MgPyAkaGVhZCA6IGRvYy5yZXNvbHZlKHBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZG9tU2VsIGluc3RhbmNlb2Ygdmlldy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5TZWxlY3Rpb24gJiYgZG9tU2VsLnJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgICAgICBsZXQgbWluID0gaGVhZCwgbWF4ID0gaGVhZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tU2VsLnJhbmdlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGRvbVNlbC5nZXRSYW5nZUF0KGkpO1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgdmlldy5kb2NWaWV3LnBvc0Zyb21ET00ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCAxKSk7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgLTEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaW4gPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgW2FuY2hvciwgaGVhZF0gPSBtYXggPT0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yID8gW21heCwgbWluXSA6IFttaW4sIG1heF07XG4gICAgICAgICAgICAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmNob3IgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgICBsZXQgYmlhcyA9IG9yaWdpbiA9PSBcInBvaW50ZXJcIiB8fCAodmlldy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCA8ICRoZWFkLnBvcyAmJiAhaW5XaWRnZXQpID8gMSA6IC0xO1xuICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb25CZXR3ZWVuKHZpZXcsICRhbmNob3IsICRoZWFkLCBiaWFzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGVkaXRvck93bnNTZWxlY3Rpb24odmlldykge1xuICAgIHJldHVybiB2aWV3LmVkaXRhYmxlID8gdmlldy5oYXNGb2N1cygpIDpcbiAgICAgICAgaGFzU2VsZWN0aW9uKHZpZXcpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jb250YWlucyh2aWV3LmRvbSk7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0RPTSh2aWV3LCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIHN5bmNOb2RlU2VsZWN0aW9uKHZpZXcsIHNlbCk7XG4gICAgaWYgKCFlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gVGhlIGRlbGF5ZWQgZHJhZyBzZWxlY3Rpb24gY2F1c2VzIGlzc3VlcyB3aXRoIENlbGwgU2VsZWN0aW9uc1xuICAgIC8vIGluIFNhZmFyaS4gQW5kIHRoZSBkcmFnIHNlbGVjdGlvbiBkZWxheSBpcyB0byB3b3JrYXJvbmQgaXNzdWVzXG4gICAgLy8gd2hpY2ggb25seSBwcmVzZW50IGluIENocm9tZS5cbiAgICBpZiAoIWZvcmNlICYmIHZpZXcuaW5wdXQubW91c2VEb3duICYmIHZpZXcuaW5wdXQubW91c2VEb3duLmFsbG93RGVmYXVsdCAmJiBjaHJvbWUpIHtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSwgY3VyU2VsID0gdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICBpZiAoZG9tU2VsLmFuY2hvck5vZGUgJiYgY3VyU2VsLmFuY2hvck5vZGUgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0LCBjdXJTZWwuYW5jaG9yTm9kZSwgY3VyU2VsLmFuY2hvck9mZnNldCkpIHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duLmRlbGF5ZWRTZWxlY3Rpb25TeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5kaXNjb25uZWN0U2VsZWN0aW9uKCk7XG4gICAgaWYgKHZpZXcuY3Vyc29yV3JhcHBlcikge1xuICAgICAgICBzZWxlY3RDdXJzb3JXcmFwcGVyKHZpZXcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHsgYW5jaG9yLCBoZWFkIH0gPSBzZWwsIHJlc2V0RWRpdGFibGVGcm9tLCByZXNldEVkaXRhYmxlVG87XG4gICAgICAgIGlmIChicm9rZW5TZWxlY3RCZXR3ZWVuVW5lZGl0YWJsZSAmJiAhKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAoIXNlbC4kZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlRnJvbSA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC5mcm9tKTtcbiAgICAgICAgICAgIGlmICghc2VsLmVtcHR5ICYmICFzZWwuJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZVRvID0gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgc2VsLnRvKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRvY1ZpZXcuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldywgZm9yY2UpO1xuICAgICAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGlmIChyZXNldEVkaXRhYmxlRnJvbSlcbiAgICAgICAgICAgICAgICByZXNldEVkaXRhYmxlKHJlc2V0RWRpdGFibGVGcm9tKTtcbiAgICAgICAgICAgIGlmIChyZXNldEVkaXRhYmxlVG8pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlVG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWwudmlzaWJsZSkge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChcIm9uc2VsZWN0aW9uY2hhbmdlXCIgaW4gZG9jdW1lbnQpXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuY29ubmVjdFNlbGVjdGlvbigpO1xufVxuLy8gS2x1ZGdlIHRvIHdvcmsgYXJvdW5kIFdlYmtpdCBub3QgYWxsb3dpbmcgYSBzZWxlY3Rpb24gdG8gc3RhcnQvZW5kXG4vLyBiZXR3ZWVuIG5vbi1lZGl0YWJsZSBibG9jayBub2Rlcy4gV2UgYnJpZWZseSBtYWtlIHNvbWV0aGluZ1xuLy8gZWRpdGFibGUsIHNldCB0aGUgc2VsZWN0aW9uLCB0aGVuIHNldCBpdCB1bmVkaXRhYmxlIGFnYWluLlxuY29uc3QgYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgPSBzYWZhcmkgfHwgY2hyb21lICYmIGNocm9tZV92ZXJzaW9uIDwgNjM7XG5mdW5jdGlvbiB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBwb3MpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQgfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgbGV0IGFmdGVyID0gb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdIDogbnVsbDtcbiAgICBsZXQgYmVmb3JlID0gb2Zmc2V0ID8gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdIDogbnVsbDtcbiAgICBpZiAoc2FmYXJpICYmIGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShhZnRlcik7XG4gICAgaWYgKCghYWZ0ZXIgfHwgYWZ0ZXIuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikgJiZcbiAgICAgICAgKCFiZWZvcmUgfHwgYmVmb3JlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpKSB7XG4gICAgICAgIGlmIChhZnRlcilcbiAgICAgICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShhZnRlcik7XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZSlcbiAgICAgICAgICAgIHJldHVybiBzZXRFZGl0YWJsZShiZWZvcmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIGlmIChzYWZhcmkgJiYgZWxlbWVudC5kcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgZWxlbWVudC53YXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIHJlc2V0RWRpdGFibGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICAgIGlmIChlbGVtZW50Lndhc0RyYWdnYWJsZSkge1xuICAgICAgICBlbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVDbGFzc09uU2VsZWN0aW9uQ2hhbmdlKHZpZXcpIHtcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCk7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IGRvbVNlbC5hbmNob3JOb2RlLCBvZmZzZXQgPSBkb21TZWwuYW5jaG9yT2Zmc2V0O1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkID0gKCkgPT4ge1xuICAgICAgICBpZiAoZG9tU2VsLmFuY2hvck5vZGUgIT0gbm9kZSB8fCBkb21TZWwuYW5jaG9yT2Zmc2V0ICE9IG9mZnNldCkge1xuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZWxlY3RDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb24oKSwgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGlmICghZG9tU2VsKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG5vZGUgPSB2aWV3LmN1cnNvcldyYXBwZXIuZG9tLCBpbWcgPSBub2RlLm5vZGVOYW1lID09IFwiSU1HXCI7XG4gICAgaWYgKGltZylcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZS5wYXJlbnROb2RlLCBkb21JbmRleChub2RlKSArIDEpO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgMCk7XG4gICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIGRvbVNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgLy8gS2x1ZGdlIHRvIGtpbGwgJ2NvbnRyb2wgc2VsZWN0aW9uJyBpbiBJRTExIHdoZW4gc2VsZWN0aW5nIGFuXG4gICAgLy8gaW52aXNpYmxlIGN1cnNvciB3cmFwcGVyLCBzaW5jZSB0aGF0IHdvdWxkIHJlc3VsdCBpbiB0aG9zZSB3ZWlyZFxuICAgIC8vIHJlc2l6ZSBoYW5kbGVzIGFuZCBhIHNlbGVjdGlvbiB0aGF0IGNvbnNpZGVycyB0aGUgYWJzb2x1dGVseVxuICAgIC8vIHBvc2l0aW9uZWQgd3JhcHBlciwgcmF0aGVyIHRoYW4gdGhlIHJvb3QgZWRpdGFibGUgbm9kZSwgdGhlXG4gICAgLy8gZm9jdXNlZCBlbGVtZW50LlxuICAgIGlmICghaW1nICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlICYmIGllICYmIGllX3ZlcnNpb24gPD0gMTEpIHtcbiAgICAgICAgbm9kZS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIG5vZGUuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpIHtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQoc2VsLmZyb20pO1xuICAgICAgICBpZiAoZGVzYyAhPSB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgICAgICAgICBjbGVhck5vZGVTZWxlY3Rpb24odmlldyk7XG4gICAgICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgICAgICBkZXNjLnNlbGVjdE5vZGUoKTtcbiAgICAgICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSBkZXNjO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjbGVhck5vZGVTZWxlY3Rpb24odmlldyk7XG4gICAgfVxufVxuLy8gQ2xlYXIgYWxsIERPTSBzdGF0ZWZ1bG5lc3Mgb2YgdGhlIGxhc3Qgbm9kZSBzZWxlY3Rpb24uXG5mdW5jdGlvbiBjbGVhck5vZGVTZWxlY3Rpb24odmlldykge1xuICAgIGlmICh2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjKSB7XG4gICAgICAgIGlmICh2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLnBhcmVudClcbiAgICAgICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MuZGVzZWxlY3ROb2RlKCk7XG4gICAgICAgIHZpZXcubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcykge1xuICAgIHJldHVybiB2aWV3LnNvbWVQcm9wKFwiY3JlYXRlU2VsZWN0aW9uQmV0d2VlblwiLCBmID0+IGYodmlldywgJGFuY2hvciwgJGhlYWQpKVxuICAgICAgICB8fCBUZXh0U2VsZWN0aW9uLmJldHdlZW4oJGFuY2hvciwgJGhlYWQsIGJpYXMpO1xufVxuZnVuY3Rpb24gaGFzRm9jdXNBbmRTZWxlY3Rpb24odmlldykge1xuICAgIGlmICh2aWV3LmVkaXRhYmxlICYmICF2aWV3Lmhhc0ZvY3VzKCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaGFzU2VsZWN0aW9uKHZpZXcpO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmICghc2VsLmFuY2hvck5vZGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAgICAgLy8gcHJvcGVydGllcyBvZiBgc2VsLmFuY2hvck5vZGVgIHdoZW4gaXQncyBpbiBhIGdlbmVyYXRlZCBDU1NcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcmV0dXJuIHZpZXcuZG9tLmNvbnRhaW5zKHNlbC5hbmNob3JOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuYW5jaG9yTm9kZS5wYXJlbnROb2RlIDogc2VsLmFuY2hvck5vZGUpICYmXG4gICAgICAgICAgICAodmlldy5lZGl0YWJsZSB8fCB2aWV3LmRvbS5jb250YWlucyhzZWwuZm9jdXNOb2RlLm5vZGVUeXBlID09IDMgPyBzZWwuZm9jdXNOb2RlLnBhcmVudE5vZGUgOiBzZWwuZm9jdXNOb2RlKSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhbmNob3JJblJpZ2h0UGxhY2Uodmlldykge1xuICAgIGxldCBhbmNob3JET00gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IsIDApO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgcmV0dXJuIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIG1vdmVTZWxlY3Rpb25CbG9jayhzdGF0ZSwgZGlyKSB7XG4gICAgbGV0IHsgJGFuY2hvciwgJGhlYWQgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgJHNpZGUgPSBkaXIgPiAwID8gJGFuY2hvci5tYXgoJGhlYWQpIDogJGFuY2hvci5taW4oJGhlYWQpO1xuICAgIGxldCAkc3RhcnQgPSAhJHNpZGUucGFyZW50LmlubGluZUNvbnRlbnQgPyAkc2lkZSA6ICRzaWRlLmRlcHRoID8gc3RhdGUuZG9jLnJlc29sdmUoZGlyID4gMCA/ICRzaWRlLmFmdGVyKCkgOiAkc2lkZS5iZWZvcmUoKSkgOiBudWxsO1xuICAgIHJldHVybiAkc3RhcnQgJiYgU2VsZWN0aW9uLmZpbmRGcm9tKCRzdGFydCwgZGlyKTtcbn1cbmZ1bmN0aW9uIGFwcGx5KHZpZXcsIHNlbCkge1xuICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgJGhlYWQgfSA9IHNlbCwgbm9kZSA9ICRoZWFkLnRleHRPZmZzZXQgPyBudWxsIDogZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXI7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc1RleHQgfHwgIW5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCAkbmV3SGVhZCA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoJGhlYWQucG9zICsgbm9kZS5ub2RlU2l6ZSAqIChkaXIgPCAwID8gLTEgOiAxKSk7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24oc2VsLiRhbmNob3IsICRuZXdIZWFkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXNlbC5lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyID4gMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIChuZXh0IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEobWFjICYmIG1vZHMuaW5kZXhPZihcIm1cIikgPiAtMSkpIHtcbiAgICAgICAgICAgIGxldCAkaGVhZCA9IHNlbC4kaGVhZCwgbm9kZSA9ICRoZWFkLnRleHRPZmZzZXQgPyBudWxsIDogZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGVQb3MgPSBkaXIgPCAwID8gJGhlYWQucG9zIC0gbm9kZS5ub2RlU2l6ZSA6ICRoZWFkLnBvcztcbiAgICAgICAgICAgIGlmICghKG5vZGUuaXNBdG9tIHx8IChkZXNjID0gdmlldy5kb2NWaWV3LmRlc2NBdChub2RlUG9zKSkgJiYgIWRlc2MuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBOb2RlU2VsZWN0aW9uKGRpciA8IDAgPyB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKCRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUpIDogJGhlYWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdlYmtpdCkge1xuICAgICAgICAgICAgICAgIC8vIENocm9tZSBhbmQgU2FmYXJpIHdpbGwgaW50cm9kdWNlIGV4dHJhIHBvaW50bGVzcyBjdXJzb3JcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbnMgYXJvdW5kIGlubGluZSB1bmVkaXRhYmxlIG5vZGVzLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgICAgICAgICAgLy8gdGFrZSBvdmVyIGFuZCBtb3ZlIHRoZSBjdXJzb3IgcGFzdCB0aGVtICgjOTM3KVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgVGV4dFNlbGVjdGlvbih2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGRpciA8IDAgPyBub2RlUG9zIDogbm9kZVBvcyArIG5vZGUubm9kZVNpemUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzZWwubm9kZS5pc0lubGluZSkge1xuICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24oZGlyID4gMCA/IHNlbC4kdG8gOiBzZWwuJGZyb20pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5leHQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9kZUxlbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc0lnbm9yYWJsZShkb20sIGRpcikge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5zaXplID09IDAgJiYgKGRpciA8IDAgfHwgZG9tLm5leHRTaWJsaW5nIHx8IGRvbS5ub2RlTmFtZSAhPSBcIkJSXCIpO1xufVxuZnVuY3Rpb24gc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpIHtcbiAgICByZXR1cm4gZGlyIDwgMCA/IHNraXBJZ25vcmVkTm9kZXNCZWZvcmUodmlldykgOiBza2lwSWdub3JlZE5vZGVzQWZ0ZXIodmlldyk7XG59XG4vLyBNYWtlIHN1cmUgdGhlIGN1cnNvciBpc24ndCBkaXJlY3RseSBhZnRlciBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcywgd2hpY2ggd2lsbCBjb25mdXNlIHRoZSBicm93c2VyJ3MgY3Vyc29yIG1vdGlvbiBsb2dpYy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNCZWZvcmUodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG1vdmVOb2RlLCBtb3ZlT2Zmc2V0LCBmb3JjZSA9IGZhbHNlO1xuICAgIC8vIEdlY2tvIHdpbGwgZG8gb2RkIHRoaW5ncyB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZGlyZWN0bHkgaW4gZnJvbnRcbiAgICAvLyBvZiBhIG5vbi1lZGl0YWJsZSBub2RlLCBzbyBpbiB0aGF0IGNhc2UsIG1vdmUgaXQgaW50byB0aGUgbmV4dFxuICAgIC8vIG5vZGUgaWYgcG9zc2libGUuIElzc3VlIHByb3NlbWlycm9yL3Byb3NlbWlycm9yIzgzMi5cbiAgICBpZiAoZ2Vja28gJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGVMZW4obm9kZSkgJiYgaXNJZ25vcmFibGUobm9kZS5jaGlsZE5vZGVzW29mZnNldF0sIC0xKSlcbiAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGlzSWdub3JhYmxlKGJlZm9yZSwgLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9mZnNldCA9IC0tb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICYmIGlzSWdub3JhYmxlKHByZXYsIC0xKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChwcmV2KTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gcHJldi5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHByZXY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZUxlbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9yY2UpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCk7XG4gICAgZWxzZSBpZiAobW92ZU5vZGUpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cbi8vIE1ha2Ugc3VyZSB0aGUgY3Vyc29yIGlzbid0IGRpcmVjdGx5IGJlZm9yZSBvbmUgb3IgbW9yZSBpZ25vcmVkXG4vLyBub2Rlcy5cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXNBZnRlcih2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbGVuID0gbm9kZUxlbihub2RlKTtcbiAgICBsZXQgbW92ZU5vZGUsIG1vdmVPZmZzZXQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoaXNJZ25vcmFibGUoYWZ0ZXIsIDEpKSB7XG4gICAgICAgICAgICAgICAgbW92ZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSArK29mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jsb2NrTm9kZShub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCAmJiBpc0lnbm9yYWJsZShuZXh0LCAxKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbmV4dC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSBkb21JbmRleChuZXh0KSArIDE7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09IHZpZXcuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBsZW4gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBsZW4gPSBub2RlTGVuKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtb3ZlTm9kZSlcbiAgICAgICAgc2V0U2VsRm9jdXModmlldywgbW92ZU5vZGUsIG1vdmVPZmZzZXQpO1xufVxuZnVuY3Rpb24gaXNCbG9ja05vZGUoZG9tKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICByZXR1cm4gZGVzYyAmJiBkZXNjLm5vZGUgJiYgZGVzYy5ub2RlLmlzQmxvY2s7XG59XG5mdW5jdGlvbiB0ZXh0Tm9kZUFmdGVyKG5vZGUsIG9mZnNldCkge1xuICAgIHdoaWxlIChub2RlICYmIG9mZnNldCA9PSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMSAmJiBuZXh0LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dE5vZGVCZWZvcmUobm9kZSwgb2Zmc2V0KSB7XG4gICAgd2hpbGUgKG5vZGUgJiYgIW9mZnNldCAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG5leHQgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgPT0gMSAmJiBuZXh0LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIG9mZnNldCA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0U2VsRm9jdXModmlldywgbm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMykge1xuICAgICAgICBsZXQgYmVmb3JlLCBhZnRlcjtcbiAgICAgICAgaWYgKGFmdGVyID0gdGV4dE5vZGVBZnRlcihub2RlLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBub2RlID0gYWZ0ZXI7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJlZm9yZSA9IHRleHROb2RlQmVmb3JlKG5vZGUsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBiZWZvcmU7XG4gICAgICAgICAgICBvZmZzZXQgPSBiZWZvcmUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChzZWxlY3Rpb25Db2xsYXBzZWQoc2VsKSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWwuZXh0ZW5kKSB7XG4gICAgICAgIHNlbC5leHRlbmQobm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldztcbiAgICAvLyBJZiBubyBzdGF0ZSB1cGRhdGUgZW5kcyB1cCBoYXBwZW5pbmcsIHJlc2V0IHRoZSBzZWxlY3Rpb24uXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlID09IHN0YXRlKVxuICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gZmluZERpcmVjdGlvbih2aWV3LCBwb3MpIHtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoIShjaHJvbWUgfHwgd2luZG93cykgJiYgJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgY29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICBpZiAocG9zID4gJHBvcy5zdGFydCgpKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gdmlldy5jb29yZHNBdFBvcyhwb3MgLSAxKTtcbiAgICAgICAgICAgIGxldCBtaWQgPSAoYmVmb3JlLnRvcCArIGJlZm9yZS5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgIGlmIChtaWQgPiBjb29yZHMudG9wICYmIG1pZCA8IGNvb3Jkcy5ib3R0b20gJiYgTWF0aC5hYnMoYmVmb3JlLmxlZnQgLSBjb29yZHMubGVmdCkgPiAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBiZWZvcmUubGVmdCA8IGNvb3Jkcy5sZWZ0ID8gXCJsdHJcIiA6IFwicnRsXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA8ICRwb3MuZW5kKCkpIHtcbiAgICAgICAgICAgIGxldCBhZnRlciA9IHZpZXcuY29vcmRzQXRQb3MocG9zICsgMSk7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGFmdGVyLnRvcCArIGFmdGVyLmJvdHRvbSkgLyAyO1xuICAgICAgICAgICAgaWYgKG1pZCA+IGNvb3Jkcy50b3AgJiYgbWlkIDwgY29vcmRzLmJvdHRvbSAmJiBNYXRoLmFicyhhZnRlci5sZWZ0IC0gY29vcmRzLmxlZnQpID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXIubGVmdCA+IGNvb3Jkcy5sZWZ0ID8gXCJsdHJcIiA6IFwicnRsXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh2aWV3LmRvbSkuZGlyZWN0aW9uO1xuICAgIHJldHVybiBjb21wdXRlZCA9PSBcInJ0bFwiID8gXCJydGxcIiA6IFwibHRyXCI7XG59XG4vLyBDaGVjayB3aGV0aGVyIHZlcnRpY2FsIHNlbGVjdGlvbiBtb3Rpb24gd291bGQgaW52b2x2ZSBub2RlXG4vLyBzZWxlY3Rpb25zLiBJZiBzbywgYXBwbHkgaXQgKGlmIG5vdCwgdGhlIHJlc3VsdCBpcyBsZWZ0IHRvIHRoZVxuLy8gYnJvd3NlcilcbmZ1bmN0aW9uIHNlbGVjdFZlcnRpY2FsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmICFzZWwuZW1wdHkgfHwgbW9kcy5pbmRleE9mKFwic1wiKSA+IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA8IDAgPyBcInVwXCIgOiBcImRvd25cIikpIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlU2VsZWN0aW9uQmxvY2sodmlldy5zdGF0ZSwgZGlyKTtcbiAgICAgICAgaWYgKG5leHQgJiYgKG5leHQgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICB9XG4gICAgaWYgKCEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBsZXQgc2lkZSA9IGRpciA8IDAgPyAkZnJvbSA6ICR0bztcbiAgICAgICAgbGV0IGJleW9uZCA9IHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiA/IFNlbGVjdGlvbi5uZWFyKHNpZGUsIGRpcikgOiBTZWxlY3Rpb24uZmluZEZyb20oc2lkZSwgZGlyKTtcbiAgICAgICAgcmV0dXJuIGJleW9uZCA/IGFwcGx5KHZpZXcsIGJleW9uZCkgOiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgZGlyKSB7XG4gICAgaWYgKCEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IsIGVtcHR5IH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodmlldy5lbmRPZlRleHRibG9jayhkaXIgPiAwID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbmV4dE5vZGUgPSAhJGhlYWQudGV4dE9mZnNldCAmJiAoZGlyIDwgMCA/ICRoZWFkLm5vZGVCZWZvcmUgOiAkaGVhZC5ub2RlQWZ0ZXIpO1xuICAgIGlmIChuZXh0Tm9kZSAmJiAhbmV4dE5vZGUuaXNUZXh0KSB7XG4gICAgICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgIGlmIChkaXIgPCAwKVxuICAgICAgICAgICAgdHIuZGVsZXRlKCRoZWFkLnBvcyAtIG5leHROb2RlLm5vZGVTaXplLCAkaGVhZC5wb3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ci5kZWxldGUoJGhlYWQucG9zLCAkaGVhZC5wb3MgKyBuZXh0Tm9kZS5ub2RlU2l6ZSk7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3dpdGNoRWRpdGFibGUodmlldywgbm9kZSwgc3RhdGUpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IHN0YXRlO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbn1cbi8vIElzc3VlICM4NjcgLyAjMTA5MCAvIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkwMzgyMVxuLy8gSW4gd2hpY2ggU2FmYXJpIChhbmQgYXQgc29tZSBwb2ludCBpbiB0aGUgcGFzdCwgQ2hyb21lKSBkb2VzIHJlYWxseVxuLy8gd3JvbmcgdGhpbmdzIHdoZW4gdGhlIGRvd24gYXJyb3cgaXMgcHJlc3NlZCB3aGVuIHRoZSBjdXJzb3IgaXNcbi8vIGRpcmVjdGx5IGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jayBhbmQgaGFzIGFuIHVuZWRpdGFibGUgbm9kZVxuLy8gYWZ0ZXIgaXRcbmZ1bmN0aW9uIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB7XG4gICAgaWYgKCFzYWZhcmkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQgfSA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoZm9jdXNOb2RlICYmIGZvY3VzTm9kZS5ub2RlVHlwZSA9PSAxICYmIGZvY3VzT2Zmc2V0ID09IDAgJiZcbiAgICAgICAgZm9jdXNOb2RlLmZpcnN0Q2hpbGQgJiYgZm9jdXNOb2RlLmZpcnN0Q2hpbGQuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIikge1xuICAgICAgICBsZXQgY2hpbGQgPSBmb2N1c05vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwidHJ1ZVwiKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzd2l0Y2hFZGl0YWJsZSh2aWV3LCBjaGlsZCwgXCJmYWxzZVwiKSwgMjApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyBBIGJhY2tkcm9wIGtleSBtYXBwaW5nIHVzZWQgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBzdXBwcmVzcyBrZXlzXG4vLyB0aGF0IGhhdmUgYSBkYW5nZXJvdXMgZGVmYXVsdCBlZmZlY3QsIGV2ZW4gaWYgdGhlIGNvbW1hbmRzIHRoZXkgYXJlXG4vLyBib3VuZCB0byByZXR1cm4gZmFsc2UsIGFuZCB0byBtYWtlIHN1cmUgdGhhdCBjdXJzb3ItbW90aW9uIGtleXNcbi8vIGZpbmQgYSBjdXJzb3IgKGFzIG9wcG9zZWQgdG8gYSBub2RlIHNlbGVjdGlvbikgd2hlbiBwcmVzc2VkLiBGb3Jcbi8vIGN1cnNvci1tb3Rpb24ga2V5cywgdGhlIGNvZGUgaW4gdGhlIGhhbmRsZXJzIGFsc28gdGFrZXMgY2FyZSBvZlxuLy8gYmxvY2sgc2VsZWN0aW9ucy5cbmZ1bmN0aW9uIGdldE1vZHMoZXZlbnQpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwiY1wiO1xuICAgIGlmIChldmVudC5tZXRhS2V5KVxuICAgICAgICByZXN1bHQgKz0gXCJtXCI7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwiYVwiO1xuICAgIGlmIChldmVudC5zaGlmdEtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwic1wiO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjYXB0dXJlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgIGxldCBjb2RlID0gZXZlbnQua2V5Q29kZSwgbW9kcyA9IGdldE1vZHMoZXZlbnQpO1xuICAgIGlmIChjb2RlID09IDggfHwgKG1hYyAmJiBjb2RlID09IDcyICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIEJhY2tzcGFjZSwgQ3RybC1oIG9uIE1hY1xuICAgICAgICByZXR1cm4gc3RvcE5hdGl2ZUhvcml6b250YWxEZWxldGUodmlldywgLTEpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgLTEpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZSA9PSA0NiAmJiAhZXZlbnQuc2hpZnRLZXkpIHx8IChtYWMgJiYgY29kZSA9PSA2OCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBEZWxldGUsIEN0cmwtZCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIDEpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMTMgfHwgY29kZSA9PSAyNykgeyAvLyBFbnRlciwgRXNjXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM3IHx8IChtYWMgJiYgY29kZSA9PSA2NiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBMZWZ0IGFycm93LCBDdHJsLWIgb24gTWFjXG4gICAgICAgIGxldCBkaXIgPSBjb2RlID09IDM3ID8gKGZpbmREaXJlY3Rpb24odmlldywgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSkgPT0gXCJsdHJcIiA/IC0xIDogMSkgOiAtMTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEhvcml6b250YWxseSh2aWV3LCBkaXIsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzOSB8fCAobWFjICYmIGNvZGUgPT0gNzAgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gUmlnaHQgYXJyb3csIEN0cmwtZiBvbiBNYWNcbiAgICAgICAgbGV0IGRpciA9IGNvZGUgPT0gMzkgPyAoZmluZERpcmVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tKSA9PSBcImx0clwiID8gMSA6IC0xKSA6IDE7XG4gICAgICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzggfHwgKG1hYyAmJiBjb2RlID09IDgwICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIFVwIGFycm93LCBDdHJsLXAgb24gTWFjXG4gICAgICAgIHJldHVybiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIC0xLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSA0MCB8fCAobWFjICYmIGNvZGUgPT0gNzggJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gRG93biBhcnJvdywgQ3RybC1uIG9uIE1hY1xuICAgICAgICByZXR1cm4gc2FmYXJpRG93bkFycm93QnVnKHZpZXcpIHx8IHNlbGVjdFZlcnRpY2FsbHkodmlldywgMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobW9kcyA9PSAobWFjID8gXCJtXCIgOiBcImNcIikgJiZcbiAgICAgICAgKGNvZGUgPT0gNjYgfHwgY29kZSA9PSA3MyB8fCBjb2RlID09IDg5IHx8IGNvZGUgPT0gOTApKSB7IC8vIE1vZC1bYml5el1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHZpZXcsIHNsaWNlKSB7XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybUNvcGllZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgbGV0IGNvbnRleHQgPSBbXSwgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHNsaWNlO1xuICAgIHdoaWxlIChvcGVuU3RhcnQgPiAxICYmIG9wZW5FbmQgPiAxICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxICYmIGNvbnRlbnQuZmlyc3RDaGlsZC5jaGlsZENvdW50ID09IDEpIHtcbiAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgIG9wZW5FbmQtLTtcbiAgICAgICAgbGV0IG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNvbnRleHQucHVzaChub2RlLnR5cGUubmFtZSwgbm9kZS5hdHRycyAhPSBub2RlLnR5cGUuZGVmYXVsdEF0dHJzID8gbm9kZS5hdHRycyA6IG51bGwpO1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICAgIH1cbiAgICBsZXQgc2VyaWFsaXplciA9IHZpZXcuc29tZVByb3AoXCJjbGlwYm9hcmRTZXJpYWxpemVyXCIpIHx8IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgbGV0IGRvYyA9IGRldGFjaGVkRG9jKCksIHdyYXAgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB3cmFwLmFwcGVuZENoaWxkKHNlcmlhbGl6ZXIuc2VyaWFsaXplRnJhZ21lbnQoY29udGVudCwgeyBkb2N1bWVudDogZG9jIH0pKTtcbiAgICBsZXQgZmlyc3RDaGlsZCA9IHdyYXAuZmlyc3RDaGlsZCwgbmVlZHNXcmFwLCB3cmFwcGVycyA9IDA7XG4gICAgd2hpbGUgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxICYmIChuZWVkc1dyYXAgPSB3cmFwTWFwW2ZpcnN0Q2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBuZWVkc1dyYXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3cmFwcGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQobmVlZHNXcmFwW2ldKTtcbiAgICAgICAgICAgIHdoaWxlICh3cmFwLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh3cmFwLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgIHdyYXBwZXJzKys7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RDaGlsZCA9IHdyYXAuZmlyc3RDaGlsZDtcbiAgICB9XG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICBmaXJzdENoaWxkLnNldEF0dHJpYnV0ZShcImRhdGEtcG0tc2xpY2VcIiwgYCR7b3BlblN0YXJ0fSAke29wZW5FbmR9JHt3cmFwcGVycyA/IGAgLSR7d3JhcHBlcnN9YCA6IFwiXCJ9ICR7SlNPTi5zdHJpbmdpZnkoY29udGV4dCl9YCk7XG4gICAgbGV0IHRleHQgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXJcIiwgZiA9PiBmKHNsaWNlLCB2aWV3KSkgfHxcbiAgICAgICAgc2xpY2UuY29udGVudC50ZXh0QmV0d2VlbigwLCBzbGljZS5jb250ZW50LnNpemUsIFwiXFxuXFxuXCIpO1xuICAgIHJldHVybiB7IGRvbTogd3JhcCwgdGV4dCwgc2xpY2UgfTtcbn1cbi8vIFJlYWQgYSBzbGljZSBvZiBjb250ZW50IGZyb20gdGhlIGNsaXBib2FyZCAob3IgZHJvcCBkYXRhKS5cbmZ1bmN0aW9uIHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwbGFpblRleHQsICRjb250ZXh0KSB7XG4gICAgbGV0IGluQ29kZSA9ICRjb250ZXh0LnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgZG9tLCBzbGljZTtcbiAgICBpZiAoIWh0bWwgJiYgIXRleHQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhc1RleHQgPSB0ZXh0ICYmIChwbGFpblRleHQgfHwgaW5Db2RlIHx8ICFodG1sKTtcbiAgICBpZiAoYXNUZXh0KSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRUZXh0XCIsIGYgPT4geyB0ZXh0ID0gZih0ZXh0LCBpbkNvZGUgfHwgcGxhaW5UZXh0LCB2aWV3KTsgfSk7XG4gICAgICAgIGlmIChpbkNvZGUpXG4gICAgICAgICAgICByZXR1cm4gdGV4dCA/IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHZpZXcuc3RhdGUuc2NoZW1hLnRleHQodGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpKSksIDAsIDApIDogU2xpY2UuZW1wdHk7XG4gICAgICAgIGxldCBwYXJzZWQgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkVGV4dFBhcnNlclwiLCBmID0+IGYodGV4dCwgJGNvbnRleHQsIHBsYWluVGV4dCwgdmlldykpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBzbGljZSA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9ICRjb250ZXh0Lm1hcmtzKCk7XG4gICAgICAgICAgICBsZXQgeyBzY2hlbWEgfSA9IHZpZXcuc3RhdGUsIHNlcmlhbGl6ZXIgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0ZXh0LnNwbGl0KC8oPzpcXHJcXG4/fFxcbikrLykuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSBkb20uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIikpO1xuICAgICAgICAgICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICAgICAgICAgICAgcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZU5vZGUoc2NoZW1hLnRleHQoYmxvY2ssIG1hcmtzKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRIVE1MXCIsIGYgPT4geyBodG1sID0gZihodG1sLCB2aWV3KTsgfSk7XG4gICAgICAgIGRvbSA9IHJlYWRIVE1MKGh0bWwpO1xuICAgICAgICBpZiAod2Via2l0KVxuICAgICAgICAgICAgcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSk7XG4gICAgfVxuICAgIGxldCBjb250ZXh0Tm9kZSA9IGRvbSAmJiBkb20ucXVlcnlTZWxlY3RvcihcIltkYXRhLXBtLXNsaWNlXVwiKTtcbiAgICBsZXQgc2xpY2VEYXRhID0gY29udGV4dE5vZGUgJiYgL14oXFxkKykgKFxcZCspKD86IC0oXFxkKykpPyAoLiopLy5leGVjKGNvbnRleHROb2RlLmdldEF0dHJpYnV0ZShcImRhdGEtcG0tc2xpY2VcIikgfHwgXCJcIik7XG4gICAgaWYgKHNsaWNlRGF0YSAmJiBzbGljZURhdGFbM10pXG4gICAgICAgIGZvciAobGV0IGkgPSArc2xpY2VEYXRhWzNdOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBkb20uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZCAmJiBjaGlsZC5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZG9tID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICBpZiAoIXNsaWNlKSB7XG4gICAgICAgIGxldCBwYXJzZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkUGFyc2VyXCIpIHx8IHZpZXcuc29tZVByb3AoXCJkb21QYXJzZXJcIikgfHwgRE9NUGFyc2VyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgICAgICBzbGljZSA9IHBhcnNlci5wYXJzZVNsaWNlKGRvbSwge1xuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAhIShhc1RleHQgfHwgc2xpY2VEYXRhKSxcbiAgICAgICAgICAgIGNvbnRleHQ6ICRjb250ZXh0LFxuICAgICAgICAgICAgcnVsZUZyb21Ob2RlKGRvbSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmICFkb20ubmV4dFNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgZG9tLnBhcmVudE5vZGUgJiYgIWlubGluZVBhcmVudHMudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNsaWNlRGF0YSkge1xuICAgICAgICBzbGljZSA9IGFkZENvbnRleHQoY2xvc2VTbGljZShzbGljZSwgK3NsaWNlRGF0YVsxXSwgK3NsaWNlRGF0YVsyXSksIHNsaWNlRGF0YVs0XSk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyBIVE1MIHdhc24ndCBjcmVhdGVkIGJ5IFByb3NlTWlycm9yLiBNYWtlIHN1cmUgdG9wLWxldmVsIHNpYmxpbmdzIGFyZSBjb2hlcmVudFxuICAgICAgICBzbGljZSA9IFNsaWNlLm1heE9wZW4obm9ybWFsaXplU2libGluZ3Moc2xpY2UuY29udGVudCwgJGNvbnRleHQpLCB0cnVlKTtcbiAgICAgICAgaWYgKHNsaWNlLm9wZW5TdGFydCB8fCBzbGljZS5vcGVuRW5kKSB7XG4gICAgICAgICAgICBsZXQgb3BlblN0YXJ0ID0gMCwgb3BlbkVuZCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2xpY2UuY29udGVudC5maXJzdENoaWxkOyBvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlblN0YXJ0KyssIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQpIHsgfVxuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNsaWNlLmNvbnRlbnQubGFzdENoaWxkOyBvcGVuRW5kIDwgc2xpY2Uub3BlbkVuZCAmJiAhbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nOyBvcGVuRW5kKyssIG5vZGUgPSBub2RlLmxhc3RDaGlsZCkgeyB9XG4gICAgICAgICAgICBzbGljZSA9IGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3KTsgfSk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuY29uc3QgaW5saW5lUGFyZW50cyA9IC9eKGF8YWJicnxhY3JvbnltfGJ8Y2l0ZXxjb2RlfGRlbHxlbXxpfGluc3xrYmR8bGFiZWx8b3V0cHV0fHF8cnVieXxzfHNhbXB8c3BhbnxzdHJvbmd8c3VifHN1cHx0aW1lfHV8dHR8dmFyKSQvaTtcbi8vIFRha2VzIGEgc2xpY2UgcGFyc2VkIHdpdGggcGFyc2VTbGljZSwgd2hpY2ggbWVhbnMgdGhlcmUgaGFzbid0IGJlZW5cbi8vIGFueSBjb250ZW50LWV4cHJlc3Npb24gY2hlY2tpbmcgZG9uZSBvbiB0aGUgdG9wIG5vZGVzLCB0cmllcyB0b1xuLy8gZmluZCBhIHBhcmVudCBub2RlIGluIHRoZSBjdXJyZW50IGNvbnRleHQgdGhhdCBtaWdodCBmaXQgdGhlIG5vZGVzLFxuLy8gYW5kIGlmIHN1Y2Nlc3NmdWwsIHJlYnVpbGRzIHRoZSBzbGljZSBzbyB0aGF0IGl0IGZpdHMgaW50byB0aGF0IHBhcmVudC5cbi8vXG4vLyBUaGlzIGFkZHJlc3NlcyB0aGUgcHJvYmxlbSB0aGF0IFRyYW5zZm9ybS5yZXBsYWNlIGV4cGVjdHMgYVxuLy8gY29oZXJlbnQgc2xpY2UsIGFuZCB3aWxsIGZhaWwgdG8gcGxhY2UgYSBzZXQgb2Ygc2libGluZ3MgdGhhdCBkb24ndFxuLy8gZml0IGFueXdoZXJlIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBub3JtYWxpemVTaWJsaW5ncyhmcmFnbWVudCwgJGNvbnRleHQpIHtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA8IDIpXG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkY29udGV4dC5ub2RlKGQpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXgoZCkpO1xuICAgICAgICBsZXQgbGFzdFdyYXAsIHJlc3VsdCA9IFtdO1xuICAgICAgICBmcmFnbWVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSwgaW5MYXN0O1xuICAgICAgICAgICAgaWYgKCF3cmFwKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGluTGFzdCA9IHJlc3VsdC5sZW5ndGggJiYgbGFzdFdyYXAubGVuZ3RoICYmIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gaW5MYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBjbG9zZVJpZ2h0KHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxhc3RXcmFwLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwZWQgPSB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god3JhcHBlZCk7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaFR5cGUod3JhcHBlZC50eXBlKTtcbiAgICAgICAgICAgICAgICBsYXN0V3JhcCA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20ocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGZyb20gPSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IHdyYXAubGVuZ3RoIC0gMTsgaSA+PSBmcm9tOyBpLS0pXG4gICAgICAgIG5vZGUgPSB3cmFwW2ldLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbi8vIFVzZWQgdG8gZ3JvdXAgYWRqYWNlbnQgbm9kZXMgd3JhcHBlZCBpbiBzaW1pbGFyIHBhcmVudHMgYnlcbi8vIG5vcm1hbGl6ZVNpYmxpbmdzIGludG8gdGhlIHNhbWUgcGFyZW50IG5vZGVcbmZ1bmN0aW9uIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZywgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPCB3cmFwLmxlbmd0aCAmJiBkZXB0aCA8IGxhc3RXcmFwLmxlbmd0aCAmJiB3cmFwW2RlcHRoXSA9PSBsYXN0V3JhcFtkZXB0aF0pIHtcbiAgICAgICAgbGV0IGlubmVyID0gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLmxhc3RDaGlsZCwgZGVwdGggKyAxKTtcbiAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQucmVwbGFjZUNoaWxkKHNpYmxpbmcuY2hpbGRDb3VudCAtIDEsIGlubmVyKSk7XG4gICAgICAgIGxldCBtYXRjaCA9IHNpYmxpbmcuY29udGVudE1hdGNoQXQoc2libGluZy5jaGlsZENvdW50KTtcbiAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZShkZXB0aCA9PSB3cmFwLmxlbmd0aCAtIDEgPyBub2RlLnR5cGUgOiB3cmFwW2RlcHRoICsgMV0pKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQuYXBwZW5kKEZyYWdtZW50LmZyb20od2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGRlcHRoICsgMSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VSaWdodChub2RlLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBsZXQgZnJhZ21lbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKG5vZGUuY2hpbGRDb3VudCAtIDEsIGNsb3NlUmlnaHQobm9kZS5sYXN0Q2hpbGQsIGRlcHRoIC0gMSkpO1xuICAgIGxldCBmaWxsID0gbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgIHJldHVybiBub2RlLmNvcHkoZnJhZ21lbnQuYXBwZW5kKGZpbGwpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlUmFuZ2UoZnJhZ21lbnQsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCwgb3BlbkVuZCkge1xuICAgIGxldCBub2RlID0gc2lkZSA8IDAgPyBmcmFnbWVudC5maXJzdENoaWxkIDogZnJhZ21lbnQubGFzdENoaWxkLCBpbm5lciA9IG5vZGUuY29udGVudDtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgIG9wZW5FbmQgPSAwO1xuICAgIGlmIChkZXB0aCA8IHRvIC0gMSlcbiAgICAgICAgaW5uZXIgPSBjbG9zZVJhbmdlKGlubmVyLCBzaWRlLCBmcm9tLCB0bywgZGVwdGggKyAxLCBvcGVuRW5kKTtcbiAgICBpZiAoZGVwdGggPj0gZnJvbSlcbiAgICAgICAgaW5uZXIgPSBzaWRlIDwgMCA/IG5vZGUuY29udGVudE1hdGNoQXQoMCkuZmlsbEJlZm9yZShpbm5lciwgb3BlbkVuZCA8PSBkZXB0aCkuYXBwZW5kKGlubmVyKVxuICAgICAgICAgICAgOiBpbm5lci5hcHBlbmQobm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKHNpZGUgPCAwID8gMCA6IGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBub2RlLmNvcHkoaW5uZXIpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgLTEsIG9wZW5TdGFydCwgc2xpY2Uub3BlblN0YXJ0LCAwLCBzbGljZS5vcGVuRW5kKSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKTtcbiAgICBpZiAob3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgMSwgb3BlbkVuZCwgc2xpY2Uub3BlbkVuZCwgMCwgMCksIHNsaWNlLm9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuLy8gVHJpY2sgZnJvbSBqUXVlcnkgLS0gc29tZSBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gb3RoZXJcbi8vIGVsZW1lbnRzIGZvciBpbm5lckhUTUwgdG8gd29yay4gSS5lLiBpZiB5b3UgZG8gYGRpdi5pbm5lckhUTUwgPVxuLy8gXCI8dGQ+Li48L3RkPlwiYCB0aGUgdGFibGUgY2VsbHMgYXJlIGlnbm9yZWQuXG5jb25zdCB3cmFwTWFwID0ge1xuICAgIHRoZWFkOiBbXCJ0YWJsZVwiXSxcbiAgICB0Ym9keTogW1widGFibGVcIl0sXG4gICAgdGZvb3Q6IFtcInRhYmxlXCJdLFxuICAgIGNhcHRpb246IFtcInRhYmxlXCJdLFxuICAgIGNvbGdyb3VwOiBbXCJ0YWJsZVwiXSxcbiAgICBjb2w6IFtcInRhYmxlXCIsIFwiY29sZ3JvdXBcIl0sXG4gICAgdHI6IFtcInRhYmxlXCIsIFwidGJvZHlcIl0sXG4gICAgdGQ6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXSxcbiAgICB0aDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdXG59O1xubGV0IF9kZXRhY2hlZERvYyA9IG51bGw7XG5mdW5jdGlvbiBkZXRhY2hlZERvYygpIHtcbiAgICByZXR1cm4gX2RldGFjaGVkRG9jIHx8IChfZGV0YWNoZWREb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJ0aXRsZVwiKSk7XG59XG5sZXQgX3BvbGljeSA9IG51bGw7XG5mdW5jdGlvbiBtYXliZVdyYXBUcnVzdGVkKGh0bWwpIHtcbiAgICBsZXQgdHJ1c3RlZFR5cGVzID0gd2luZG93LnRydXN0ZWRUeXBlcztcbiAgICBpZiAoIXRydXN0ZWRUeXBlcylcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgLy8gV2l0aCB0aGUgcmVxdWlyZS10cnVzdGVkLXR5cGVzLWZvciBDU1AsIENocm9tZSB3aWxsIGJsb2NrXG4gICAgLy8gaW5uZXJIVE1MLCBldmVuIG9uIGEgZGV0YWNoZWQgZG9jdW1lbnQuIFRoaXMgd3JhcHMgdGhlIHN0cmluZyBpblxuICAgIC8vIGEgd2F5IHRoYXQgbWFrZXMgdGhlIGJyb3dzZXIgYWxsb3cgdXMgdG8gdXNlIGl0cyBwYXJzZXIgYWdhaW4uXG4gICAgaWYgKCFfcG9saWN5KVxuICAgICAgICBfcG9saWN5ID0gdHJ1c3RlZFR5cGVzLmRlZmF1bHRQb2xpY3kgfHwgdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShcIlByb3NlTWlycm9yQ2xpcGJvYXJkXCIsIHsgY3JlYXRlSFRNTDogKHMpID0+IHMgfSk7XG4gICAgcmV0dXJuIF9wb2xpY3kuY3JlYXRlSFRNTChodG1sKTtcbn1cbmZ1bmN0aW9uIHJlYWRIVE1MKGh0bWwpIHtcbiAgICBsZXQgbWV0YXMgPSAvXihcXHMqPG1ldGEgW14+XSo+KSovLmV4ZWMoaHRtbCk7XG4gICAgaWYgKG1ldGFzKVxuICAgICAgICBodG1sID0gaHRtbC5zbGljZShtZXRhc1swXS5sZW5ndGgpO1xuICAgIGxldCBlbHQgPSBkZXRhY2hlZERvYygpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbGV0IGZpcnN0VGFnID0gLzwoW2Etel1bXj5cXHNdKykvaS5leGVjKGh0bWwpLCB3cmFwO1xuICAgIGlmICh3cmFwID0gZmlyc3RUYWcgJiYgd3JhcE1hcFtmaXJzdFRhZ1sxXS50b0xvd2VyQ2FzZSgpXSlcbiAgICAgICAgaHRtbCA9IHdyYXAubWFwKG4gPT4gXCI8XCIgKyBuICsgXCI+XCIpLmpvaW4oXCJcIikgKyBodG1sICsgd3JhcC5tYXAobiA9PiBcIjwvXCIgKyBuICsgXCI+XCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIGVsdC5pbm5lckhUTUwgPSBtYXliZVdyYXBUcnVzdGVkKGh0bWwpO1xuICAgIGlmICh3cmFwKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBlbHQgPSBlbHQucXVlcnlTZWxlY3Rvcih3cmFwW2ldKSB8fCBlbHQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbi8vIFdlYmtpdCBicm93c2VycyBkbyBzb21lIGhhcmQtdG8tcHJlZGljdCByZXBsYWNlbWVudCBvZiByZWd1bGFyXG4vLyBzcGFjZXMgd2l0aCBub24tYnJlYWtpbmcgc3BhY2VzIHdoZW4gcHV0dGluZyBjb250ZW50IG9uIHRoZVxuLy8gY2xpcGJvYXJkLiBUaGlzIHRyaWVzIHRvIGNvbnZlcnQgc3VjaCBub24tYnJlYWtpbmcgc3BhY2VzICh3aGljaFxuLy8gd2lsbCBiZSB3cmFwcGVkIGluIGEgcGxhaW4gc3BhbiBvbiBDaHJvbWUsIGEgc3BhbiB3aXRoIGNsYXNzXG4vLyBBcHBsZS1jb252ZXJ0ZWQtc3BhY2Ugb24gU2FmYXJpKSBiYWNrIHRvIHJlZ3VsYXIgc3BhY2VzLlxuZnVuY3Rpb24gcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSkge1xuICAgIGxldCBub2RlcyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKGNocm9tZSA/IFwic3Bhbjpub3QoW2NsYXNzXSk6bm90KFtzdHlsZV0pXCIgOiBcInNwYW4uQXBwbGUtY29udmVydGVkLXNwYWNlXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLnRleHRDb250ZW50ID09IFwiXFx1MDBhMFwiICYmIG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRDb250ZXh0KHNsaWNlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgbGV0IHNjaGVtYSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLnNjaGVtYSwgYXJyYXk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXJyYXkgPSBKU09OLnBhcnNlKGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfVxuICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm5vZGVzW2FycmF5W2ldXTtcbiAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGFycmF5W2kgKyAxXSwgY29udGVudCkpO1xuICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgb3BlbkVuZCsrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbi8vIEEgY29sbGVjdGlvbiBvZiBET00gZXZlbnRzIHRoYXQgb2NjdXIgd2l0aGluIHRoZSBlZGl0b3IsIGFuZCBjYWxsYmFjayBmdW5jdGlvbnNcbi8vIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBmaXJlcy5cbmNvbnN0IGhhbmRsZXJzID0ge307XG5jb25zdCBlZGl0SGFuZGxlcnMgPSB7fTtcbmNvbnN0IHBhc3NpdmVIYW5kbGVycyA9IHsgdG91Y2hzdGFydDogdHJ1ZSwgdG91Y2htb3ZlOiB0cnVlIH07XG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaGlmdEtleSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdENsaWNrID0geyB0aW1lOiAwLCB4OiAwLCB5OiAwLCB0eXBlOiBcIlwiLCBidXR0b246IDAgfTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXMgPSAwO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaCA9IDA7XG4gICAgICAgIHRoaXMubGFzdENocm9tZURlbGV0ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25Ob2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21wb3NpbmdUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25JRCA9IDE7XG4gICAgICAgIC8vIFNldCB0byBhIGNvbXBvc2l0aW9uIElEIHdoZW4gdGhlcmUgYXJlIHBlbmRpbmcgY2hhbmdlcyBhdCBjb21wb3NpdGlvbmVuZFxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSAwO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5oaWRlU2VsZWN0aW9uR3VhcmQgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRJbnB1dCh2aWV3KSB7XG4gICAgZm9yIChsZXQgZXZlbnQgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1tldmVudF0gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpICYmICFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJlxuICAgICAgICAgICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgICAgICAgICBoYW5kbGVyKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgfSwgcGFzc2l2ZUhhbmRsZXJzW2V2ZW50XSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gT24gU2FmYXJpLCBmb3IgcmVhc29ucyBiZXlvbmQgbXkgdW5kZXJzdGFuZGluZywgYWRkaW5nIGFuIGlucHV0XG4gICAgLy8gZXZlbnQgaGFuZGxlciBtYWtlcyBhbiBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlblxuICAgIC8vIHlvdSBwcmVzcyBlbnRlciBnbyBhd2F5LlxuICAgIGlmIChzYWZhcmkpXG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiBudWxsKTtcbiAgICBlbnN1cmVMaXN0ZW5lcnModmlldyk7XG59XG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgb3JpZ2luKSB7XG4gICAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xufVxuZnVuY3Rpb24gZGVzdHJveUlucHV0KHZpZXcpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBmb3IgKGxldCB0eXBlIGluIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVycylcbiAgICAgICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCk7XG59XG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5lcnModmlldykge1xuICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgY3VycmVudEhhbmRsZXJzID0+IHtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBjdXJyZW50SGFuZGxlcnMpXG4gICAgICAgICAgICBpZiAoIXZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSlcbiAgICAgICAgICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSA9IGV2ZW50ID0+IHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBoYW5kbGVycyA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgICAgIHJldHVybiBoYW5kbGVyID8gaGFuZGxlcih2aWV3LCBldmVudCkgfHwgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQ7IG5vZGUgIT0gdmlldy5kb207IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8XG4gICAgICAgICAgICAobm9kZS5wbVZpZXdEZXNjICYmIG5vZGUucG1WaWV3RGVzYy5zdG9wRXZlbnQoZXZlbnQpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmIGhhbmRsZXJzW2V2ZW50LnR5cGVdICYmXG4gICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgaGFuZGxlcnNbZXZlbnQudHlwZV0odmlldywgZXZlbnQpO1xufVxuZWRpdEhhbmRsZXJzLmtleWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5rZXlDb2RlID09IDE2IHx8IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAvLyBTdXBwcmVzcyBlbnRlciBrZXkgZXZlbnRzIG9uIENocm9tZSBBbmRyb2lkLCBiZWNhdXNlIHRob3NlIHRlbmRcbiAgICAvLyB0byBiZSBwYXJ0IG9mIGEgY29uZnVzZWQgc2VxdWVuY2Ugb2YgY29tcG9zaXRpb24gZXZlbnRzIGZpcmVkLFxuICAgIC8vIGFuZCBoYW5kbGluZyB0aGVtIGVhZ2VybHkgdGVuZHMgdG8gY29ycnVwdCB0aGUgaW5wdXQuXG4gICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lICYmIGV2ZW50LmtleUNvZGUgPT0gMTMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyMjkpXG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgIC8vIE9uIGlPUywgaWYgd2UgcHJldmVudERlZmF1bHQgZW50ZXIga2V5IHByZXNzZXMsIHRoZSB2aXJ0dWFsXG4gICAgLy8ga2V5Ym9hcmQgZ2V0cyBjb25mdXNlZC4gU28gdGhlIGhhY2sgaGVyZSBpcyB0byBzZXQgYSBmbGFnIHRoYXRcbiAgICAvLyBtYWtlcyB0aGUgRE9NIGNoYW5nZSBjb2RlIHJlY29nbml6ZSB0aGF0IHdoYXQganVzdCBoYXBwZW5zIHNob3VsZFxuICAgIC8vIGJlIHJlcGxhY2VkIGJ5IHdoYXRldmVyIHRoZSBFbnRlciBrZXkgaGFuZGxlcnMgZG8uXG4gICAgaWYgKGlvcyAmJiBldmVudC5rZXlDb2RlID09IDEzICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gbm93O1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXQubGFzdElPU0VudGVyID09IG5vdykge1xuICAgICAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpO1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkgfHwgY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJrZXlcIik7XG4gICAgfVxufTtcbmVkaXRIYW5kbGVycy5rZXl1cCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDE2KVxuICAgICAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZmFsc2U7XG59O1xuZWRpdEhhbmRsZXJzLmtleXByZXNzID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkgfHwgIWV2ZW50LmNoYXJDb2RlIHx8XG4gICAgICAgIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSB8fCBtYWMgJiYgZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5UHJlc3NcIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgIXNlbC4kZnJvbS5zYW1lUGFyZW50KHNlbC4kdG8pKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSk7XG4gICAgICAgIGxldCBkZWZsdCA9ICgpID0+IHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0KS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICBpZiAoIS9bXFxyXFxuXS8udGVzdCh0ZXh0KSAmJiAhdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgc2VsLiRmcm9tLnBvcywgc2VsLiR0by5wb3MsIHRleHQsIGRlZmx0KSkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKGRlZmx0KCkpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBldmVudENvb3JkcyhldmVudCkgeyByZXR1cm4geyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfTsgfVxuZnVuY3Rpb24gaXNOZWFyKGV2ZW50LCBjbGljaykge1xuICAgIGxldCBkeCA9IGNsaWNrLnggLSBldmVudC5jbGllbnRYLCBkeSA9IGNsaWNrLnkgLSBldmVudC5jbGllbnRZO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8IDEwMDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgcHJvcE5hbWUsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHZpZXcuc29tZVByb3AocHJvcE5hbWUsIGYgPT4gaSA+ICRwb3MuZGVwdGggPyBmKHZpZXcsIHBvcywgJHBvcy5ub2RlQWZ0ZXIsICRwb3MuYmVmb3JlKGkpLCBldmVudCwgdHJ1ZSlcbiAgICAgICAgICAgIDogZih2aWV3LCBwb3MsICRwb3Mubm9kZShpKSwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBzZWxlY3Rpb24sIG9yaWdpbikge1xuICAgIGlmICghdmlldy5mb2N1c2VkKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgIHRyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpLCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5pc0F0b20gJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBzZWxlY3RlZE5vZGUsIHNlbGVjdEF0O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKVxuICAgICAgICBzZWxlY3RlZE5vZGUgPSBzZWwubm9kZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgc2VsLiRmcm9tLmRlcHRoID4gMCAmJlxuICAgICAgICAgICAgICAgIGkgPj0gc2VsLiRmcm9tLmRlcHRoICYmICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCArIDEpID09IHNlbC4kZnJvbS5wb3MpXG4gICAgICAgICAgICAgICAgc2VsZWN0QXQgPSAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0QXQgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHNlbGVjdEF0KSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTaW5nbGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQsIHNlbGVjdE5vZGUpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKSB8fFxuICAgICAgICAoc2VsZWN0Tm9kZSA/IHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkgOiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlRG91YmxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVEb3VibGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpO1xufVxuZnVuY3Rpb24gaGFuZGxlVHJpcGxlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVUcmlwbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZVRyaXBsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKGluc2lkZSA9PSAtMSkge1xuICAgICAgICBpZiAoZG9jLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIDAsIGRvYy5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBsZXQgbm9kZVBvcyA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyArIDEsIG5vZGVQb3MgKyAxICsgbm9kZS5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2UgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyksIFwicG9pbnRlclwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcmNlRE9NRmx1c2godmlldykge1xuICAgIHJldHVybiBlbmRDb21wb3NpdGlvbih2aWV3KTtcbn1cbmNvbnN0IHNlbGVjdE5vZGVNb2RpZmllciA9IG1hYyA/IFwibWV0YUtleVwiIDogXCJjdHJsS2V5XCI7XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5zaGlmdEtleTtcbiAgICBsZXQgZmx1c2hlZCA9IGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgbGV0IG5vdyA9IERhdGUubm93KCksIHR5cGUgPSBcInNpbmdsZUNsaWNrXCI7XG4gICAgaWYgKG5vdyAtIHZpZXcuaW5wdXQubGFzdENsaWNrLnRpbWUgPCA1MDAgJiYgaXNOZWFyKGV2ZW50LCB2aWV3LmlucHV0Lmxhc3RDbGljaykgJiYgIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl0gJiZcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0Q2xpY2suYnV0dG9uID09IGV2ZW50LmJ1dHRvbikge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpXG4gICAgICAgICAgICB0eXBlID0gXCJkb3VibGVDbGlja1wiO1xuICAgICAgICBlbHNlIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwiZG91YmxlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcInRyaXBsZUNsaWNrXCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdENsaWNrID0geyB0aW1lOiBub3csIHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHR5cGUsIGJ1dHRvbjogZXZlbnQuYnV0dG9uIH07XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIXBvcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlID09IFwic2luZ2xlQ2xpY2tcIikge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5tb3VzZURvd24pXG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kb25lKCk7XG4gICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duID0gbmV3IE1vdXNlRG93bih2aWV3LCBwb3MsIGV2ZW50LCAhIWZsdXNoZWQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZSA9PSBcImRvdWJsZUNsaWNrXCIgPyBoYW5kbGVEb3VibGVDbGljayA6IGhhbmRsZVRyaXBsZUNsaWNrKSh2aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gICAgfVxufTtcbmNsYXNzIE1vdXNlRG93biB7XG4gICAgY29uc3RydWN0b3IodmlldywgcG9zLCBldmVudCwgZmx1c2hlZCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLmZsdXNoZWQgPSBmbHVzaGVkO1xuICAgICAgICB0aGlzLmRlbGF5ZWRTZWxlY3Rpb25TeW5jID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWlnaHREcmFnID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdE5vZGUgPSAhIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl07XG4gICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIGxldCB0YXJnZXROb2RlLCB0YXJnZXRQb3M7XG4gICAgICAgIGlmIChwb3MuaW5zaWRlID4gLTEpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSB2aWV3LnN0YXRlLmRvYy5ub2RlQXQocG9zLmluc2lkZSk7XG4gICAgICAgICAgICB0YXJnZXRQb3MgPSBwb3MuaW5zaWRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9ICRwb3MucGFyZW50O1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gJHBvcy5kZXB0aCA/ICRwb3MuYmVmb3JlKCkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGZsdXNoZWQgPyBudWxsIDogZXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXREZXNjID0gdGFyZ2V0ID8gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKHRhcmdldCwgdHJ1ZSkgOiBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldERlc2MgJiYgdGFyZ2V0RGVzYy5kb20ubm9kZVR5cGUgPT0gMSA/IHRhcmdldERlc2MuZG9tIDogbnVsbDtcbiAgICAgICAgbGV0IHsgc2VsZWN0aW9uIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgIHRhcmdldE5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiB0YXJnZXROb2RlLnR5cGUuc3BlYy5zZWxlY3RhYmxlICE9PSBmYWxzZSB8fFxuICAgICAgICAgICAgc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzZWxlY3Rpb24uZnJvbSA8PSB0YXJnZXRQb3MgJiYgc2VsZWN0aW9uLnRvID4gdGFyZ2V0UG9zKVxuICAgICAgICAgICAgdGhpcy5taWdodERyYWcgPSB7XG4gICAgICAgICAgICAgICAgbm9kZTogdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgICAgICBwb3M6IHRhcmdldFBvcyxcbiAgICAgICAgICAgICAgICBhZGRBdHRyOiAhISh0aGlzLnRhcmdldCAmJiAhdGhpcy50YXJnZXQuZHJhZ2dhYmxlKSxcbiAgICAgICAgICAgICAgICBzZXRVbmVkaXRhYmxlOiAhISh0aGlzLnRhcmdldCAmJiBnZWNrbyAmJiAhdGhpcy50YXJnZXQuaGFzQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0ICYmIHRoaXMubWlnaHREcmFnICYmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyIHx8IHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LmlucHV0Lm1vdXNlRG93biA9PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQuc2V0QXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIsIFwiZmFsc2VcIik7XG4gICAgICAgICAgICAgICAgfSwgMjApO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpO1xuICAgICAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gICAgfVxuICAgIGRvbmUoKSB7XG4gICAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXApO1xuICAgICAgICB0aGlzLnZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG4gICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZyAmJiB0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5hZGRBdHRyKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcImRyYWdnYWJsZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1pZ2h0RHJhZy5zZXRVbmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRTZWxlY3Rpb25TeW5jKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZWxlY3Rpb25Ub0RPTSh0aGlzLnZpZXcpKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0Lm1vdXNlRG93biA9IG51bGw7XG4gICAgfVxuICAgIHVwKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZG9uZSgpO1xuICAgICAgICBpZiAoIXRoaXMudmlldy5kb20uY29udGFpbnMoZXZlbnQudGFyZ2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zO1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmRvYyAhPSB0aGlzLnN0YXJ0RG9jKVxuICAgICAgICAgICAgcG9zID0gdGhpcy52aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgICAgIHRoaXMudXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dEZWZhdWx0IHx8ICFwb3MpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoYW5kbGVTaW5nbGVDbGljayh0aGlzLnZpZXcsIHBvcy5wb3MsIHBvcy5pbnNpZGUsIGV2ZW50LCB0aGlzLnNlbGVjdE5vZGUpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmJ1dHRvbiA9PSAwICYmXG4gICAgICAgICAgICAodGhpcy5mbHVzaGVkIHx8XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGlnbm9yZXMgY2xpY2tzIG9uIGRyYWdnYWJsZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIChzYWZhcmkgJiYgdGhpcy5taWdodERyYWcgJiYgIXRoaXMubWlnaHREcmFnLm5vZGUuaXNBdG9tKSB8fFxuICAgICAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHNvbWV0aW1lcyB0cmVhdCBhIG5vZGUgc2VsZWN0aW9uIGFzIGFcbiAgICAgICAgICAgICAgICAvLyBjdXJzb3IsIGJ1dCBzdGlsbCByZXBvcnQgdGhhdCB0aGUgbm9kZSBpcyBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gYXNrZWQgdGhyb3VnaCBnZXRTZWxlY3Rpb24uIFlvdSdsbCB0aGVuIGdldCBhXG4gICAgICAgICAgICAgICAgLy8gc2l0dWF0aW9uIHdoZXJlIGNsaWNraW5nIGF0IHRoZSBwb2ludCB3aGVyZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gKGhpZGRlbikgY3Vyc29yIGlzIGRvZXNuJ3QgY2hhbmdlIHRoZSBzZWxlY3Rpb24sIGFuZFxuICAgICAgICAgICAgICAgIC8vIHRodXMgZG9lc24ndCBnZXQgYSByZWFjdGlvbiBmcm9tIFByb3NlTWlycm9yLiBUaGlzXG4gICAgICAgICAgICAgICAgLy8gd29ya3MgYXJvdW5kIHRoYXQuXG4gICAgICAgICAgICAgICAgKGNocm9tZSAmJiAhdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlICYmXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pLCBNYXRoLmFicyhwb3MucG9zIC0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi50bykpIDw9IDIpKSkge1xuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHRoaXMudmlldywgU2VsZWN0aW9uLm5lYXIodGhpcy52aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpKSwgXCJwb2ludGVyXCIpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih0aGlzLnZpZXcsIFwicG9pbnRlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKVxuICAgICAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgfVxuICAgIHVwZGF0ZUFsbG93RGVmYXVsdChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsb3dEZWZhdWx0ICYmIChNYXRoLmFicyh0aGlzLmV2ZW50LnggLSBldmVudC5jbGllbnRYKSA+IDQgfHxcbiAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuZXZlbnQueSAtIGV2ZW50LmNsaWVudFkpID4gNCkpXG4gICAgICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IHRydWU7XG4gICAgfVxufVxuaGFuZGxlcnMudG91Y2hzdGFydCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXQubGFzdFRvdWNoID0gRGF0ZS5ub3coKTtcbiAgICBmb3JjZURPTUZsdXNoKHZpZXcpO1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMudG91Y2htb3ZlID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0VG91Y2ggPSBEYXRlLm5vdygpO1xuICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMuY29udGV4dG1lbnUgPSB2aWV3ID0+IGZvcmNlRE9NRmx1c2godmlldyk7XG5mdW5jdGlvbiBpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXG4gICAgLy8gT24gSmFwYW5lc2UgaW5wdXQgbWV0aG9kIGVkaXRvcnMgKElNRXMpLCB0aGUgRW50ZXIga2V5IGlzIHVzZWQgdG8gY29uZmlybSBjaGFyYWN0ZXJcbiAgICAvLyBzZWxlY3Rpb24uIE9uIFNhZmFyaSwgd2hlbiBFbnRlciBpcyBwcmVzc2VkLCBjb21wb3NpdGlvbmVuZCBhbmQga2V5ZG93biBldmVudHMgYXJlXG4gICAgLy8gZW1pdHRlZC4gVGhlIGtleWRvd24gZXZlbnQgdHJpZ2dlcnMgbmV3bGluZSBpbnNlcnRpb24sIHdoaWNoIHdlIGRvbid0IHdhbnQuXG4gICAgLy8gVGhpcyBtZXRob2QgcmV0dXJucyB0cnVlIGlmIHRoZSBrZXlkb3duIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkLlxuICAgIC8vIFdlIG9ubHkgaWdub3JlIGl0IG9uY2UsIGFzIHByZXNzaW5nIEVudGVyIGEgc2Vjb25kIHRpbWUgKnNob3VsZCogaW5zZXJ0IGEgbmV3bGluZS5cbiAgICAvLyBGdXJ0aGVybW9yZSwgdGhlIGtleWRvd24gZXZlbnQgdGltZXN0YW1wIG11c3QgYmUgY2xvc2UgdG8gdGhlIGNvbXBvc2l0aW9uRW5kZWRBdCB0aW1lc3RhbXAuXG4gICAgLy8gVGhpcyBndWFyZHMgYWdhaW5zdCB0aGUgY2FzZSB3aGVyZSBjb21wb3NpdGlvbmVuZCBpcyB0cmlnZ2VyZWQgd2l0aG91dCB0aGUga2V5Ym9hcmRcbiAgICAvLyAoZS5nLiBjaGFyYWN0ZXIgY29uZmlybWF0aW9uIG1heSBiZSBkb25lIHdpdGggdGhlIG1vdXNlKSwgYW5kIGtleWRvd24gaXMgdHJpZ2dlcmVkXG4gICAgLy8gYWZ0ZXJ3YXJkcy0gd2Ugd291bGRuJ3Qgd2FudCB0byBpZ25vcmUgdGhlIGtleWRvd24gZXZlbnQgaW4gdGhpcyBjYXNlLlxuICAgIGlmIChzYWZhcmkgJiYgTWF0aC5hYnMoZXZlbnQudGltZVN0YW1wIC0gdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQpIDwgNTAwKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gLTJlODtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIERyb3AgYWN0aXZlIGNvbXBvc2l0aW9uIGFmdGVyIDUgc2Vjb25kcyBvZiBpbmFjdGl2aXR5IG9uIEFuZHJvaWRcbmNvbnN0IHRpbWVvdXRDb21wb3NpdGlvbiA9IGFuZHJvaWQgPyA1MDAwIDogLTE7XG5lZGl0SGFuZGxlcnMuY29tcG9zaXRpb25zdGFydCA9IGVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnVwZGF0ZSA9IHZpZXcgPT4ge1xuICAgIGlmICghdmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5mbHVzaCgpO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgJHBvcyA9IHN0YXRlLnNlbGVjdGlvbi4kdG87XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmXG4gICAgICAgICAgICAoc3RhdGUuc3RvcmVkTWFya3MgfHxcbiAgICAgICAgICAgICAgICAoISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLnBhcmVudE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3Muc29tZShtID0+IG0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UpKSkpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gd3JhcCB0aGUgY3Vyc29yIGluIG1hcmsgbm9kZXMgZGlmZmVyZW50IGZyb20gdGhlIG9uZXMgaW4gdGhlIERPTSBjb250ZXh0XG4gICAgICAgICAgICB2aWV3Lm1hcmtDdXJzb3IgPSB2aWV3LnN0YXRlLnN0b3JlZE1hcmtzIHx8ICRwb3MubWFya3MoKTtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsIHRydWUpO1xuICAgICAgICAgICAgdmlldy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZENvbXBvc2l0aW9uKHZpZXcsICFzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpO1xuICAgICAgICAgICAgLy8gSW4gZmlyZWZveCwgaWYgdGhlIGN1cnNvciBpcyBhZnRlciBidXQgb3V0c2lkZSBhIG1hcmtlZCBub2RlLFxuICAgICAgICAgICAgLy8gdGhlIGluc2VydGVkIHRleHQgd29uJ3QgaW5oZXJpdCB0aGUgbWFya3MuIFNvIHRoaXMgbW92ZXMgaXRcbiAgICAgICAgICAgIC8vIGluc2lkZSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICBpZiAoZ2Vja28gJiYgc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICEkcG9zLnRleHRPZmZzZXQgJiYgJHBvcy5ub2RlQmVmb3JlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNlbC5mb2N1c05vZGUsIG9mZnNldCA9IHNlbC5mb2N1c09mZnNldDsgbm9kZSAmJiBub2RlLm5vZGVUeXBlID09IDEgJiYgb2Zmc2V0ICE9IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBvZmZzZXQgPCAwID8gbm9kZS5sYXN0Q2hpbGQgOiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbC5jb2xsYXBzZShiZWZvcmUsIGJlZm9yZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIHRpbWVvdXRDb21wb3NpdGlvbik7XG59O1xuZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9uZW5kID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSB2aWV3LmRvbU9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID8gdmlldy5pbnB1dC5jb21wb3NpdGlvbklEIDogMDtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGUgPSBudWxsO1xuICAgICAgICBpZiAodmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCkpO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQrKztcbiAgICAgICAgc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIDIwKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gc2NoZWR1bGVDb21wb3NlRW5kKHZpZXcsIGRlbGF5KSB7XG4gICAgY2xlYXJUaW1lb3V0KHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCk7XG4gICAgaWYgKGRlbGF5ID4gLTEpXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gZW5kQ29tcG9zaXRpb24odmlldyksIGRlbGF5KTtcbn1cbmZ1bmN0aW9uIGNsZWFyQ29tcG9zaXRpb24odmlldykge1xuICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCA9IHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpO1xuICAgIH1cbiAgICB3aGlsZSAodmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLmxlbmd0aCA+IDApXG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2Rlcy5wb3AoKS5tYXJrUGFyZW50c0RpcnR5KCk7XG59XG5mdW5jdGlvbiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGlmICghc2VsLmZvY3VzTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHRleHRCZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZSQxKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgbGV0IHRleHRBZnRlciA9IHRleHROb2RlQWZ0ZXIkMShzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGlmICh0ZXh0QmVmb3JlICYmIHRleHRBZnRlciAmJiB0ZXh0QmVmb3JlICE9IHRleHRBZnRlcikge1xuICAgICAgICBsZXQgZGVzY0FmdGVyID0gdGV4dEFmdGVyLnBtVmlld0Rlc2MsIGxhc3RDaGFuZ2VkID0gdmlldy5kb21PYnNlcnZlci5sYXN0Q2hhbmdlZFRleHROb2RlO1xuICAgICAgICBpZiAodGV4dEJlZm9yZSA9PSBsYXN0Q2hhbmdlZCB8fCB0ZXh0QWZ0ZXIgPT0gbGFzdENoYW5nZWQpXG4gICAgICAgICAgICByZXR1cm4gbGFzdENoYW5nZWQ7XG4gICAgICAgIGlmICghZGVzY0FmdGVyIHx8ICFkZXNjQWZ0ZXIuaXNUZXh0KHRleHRBZnRlci5ub2RlVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2RlID09IHRleHRBZnRlcikge1xuICAgICAgICAgICAgbGV0IGRlc2NCZWZvcmUgPSB0ZXh0QmVmb3JlLnBtVmlld0Rlc2M7XG4gICAgICAgICAgICBpZiAoISghZGVzY0JlZm9yZSB8fCAhZGVzY0JlZm9yZS5pc1RleHQodGV4dEJlZm9yZS5ub2RlVmFsdWUpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0QmVmb3JlIHx8IHRleHRBZnRlcjtcbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcEZyb21DdXN0b21FdmVudCgpIHtcbiAgICBsZXQgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGV2ZW50LmluaXRFdmVudChcImV2ZW50XCIsIHRydWUsIHRydWUpO1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXA7XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIGVuZENvbXBvc2l0aW9uKHZpZXcsIHJlc3RhcnRpbmcgPSBmYWxzZSkge1xuICAgIGlmIChhbmRyb2lkICYmIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hpbmdTb29uID49IDApXG4gICAgICAgIHJldHVybjtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICBjbGVhckNvbXBvc2l0aW9uKHZpZXcpO1xuICAgIGlmIChyZXN0YXJ0aW5nIHx8IHZpZXcuZG9jVmlldyAmJiB2aWV3LmRvY1ZpZXcuZGlydHkpIHtcbiAgICAgICAgbGV0IHNlbCA9IHNlbGVjdGlvbkZyb21ET00odmlldyksIGN1ciA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc2VsICYmICFzZWwuZXEoY3VyKSlcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsKSk7XG4gICAgICAgIGVsc2UgaWYgKCh2aWV3Lm1hcmtDdXJzb3IgfHwgcmVzdGFydGluZykgJiYgIWN1ci4kZnJvbS5ub2RlKGN1ci4kZnJvbS5zaGFyZWREZXB0aChjdXIudG8pKS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmlldy51cGRhdGVTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBpZiAoIXZpZXcuZG9tLnBhcmVudE5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgd3JhcCA9IHZpZXcuZG9tLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgIHdyYXAuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbigpLCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGRvbSk7XG4gICAgLy8gRG9uZSBiZWNhdXNlIElFIHdpbGwgZmlyZSBhIHNlbGVjdGlvbmNoYW5nZSBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgIC8vIHRvIGl0cyBzdGFydCB3aGVuIHJlbW92ZUFsbFJhbmdlcyBpcyBjYWxsZWQgYW5kIHRoZSBlZGl0b3Igc3RpbGxcbiAgICAvLyBoYXMgZm9jdXMgKHdoaWNoIHdpbGwgbWVzcyB1cCB0aGUgZWRpdG9yJ3Mgc2VsZWN0aW9uIHN0YXRlKS5cbiAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3cmFwLnBhcmVudE5vZGUpXG4gICAgICAgICAgICB3cmFwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUElcdTIwMTRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoaWUgJiYgaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChpb3MgJiYgd2Via2l0X3ZlcnNpb24gPCA2MDQpO1xuaGFuZGxlcnMuY29weSA9IGVkaXRIYW5kbGVycy5jdXQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiwgY3V0ID0gZXZlbnQudHlwZSA9PSBcImN1dFwiO1xuICAgIGlmIChzZWwuZW1wdHkpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBJRSBhbmQgRWRnZSdzIGNsaXBib2FyZCBpbnRlcmZhY2UgaXMgY29tcGxldGVseSBicm9rZW5cbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBzbGljZSA9IHNlbC5jb250ZW50KCksIHsgZG9tLCB0ZXh0IH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgc2xpY2UpO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVDb3B5KHZpZXcsIGRvbSk7XG4gICAgfVxuICAgIGlmIChjdXQpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiY3V0XCIpKTtcbn07XG5mdW5jdGlvbiBzbGljZVNpbmdsZU5vZGUoc2xpY2UpIHtcbiAgICByZXR1cm4gc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uub3BlbkVuZCA9PSAwICYmIHNsaWNlLmNvbnRlbnQuY2hpbGRDb3VudCA9PSAxID8gc2xpY2UuY29udGVudC5maXJzdENoaWxkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCkge1xuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBwbGFpblRleHQgPSB2aWV3LmlucHV0LnNoaWZ0S2V5IHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZTtcbiAgICBsZXQgdGFyZ2V0ID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KHBsYWluVGV4dCA/IFwidGV4dGFyZWFcIiA6IFwiZGl2XCIpKTtcbiAgICBpZiAoIXBsYWluVGV4dClcbiAgICAgICAgdGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9IFwidHJ1ZVwiO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgaWYgKHRhcmdldC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBsYWluVGV4dClcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlLCBudWxsLCBwbGFpbiwgZXZlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb1Bhc3RlKHZpZXcsIHRhcmdldC50ZXh0Q29udGVudCwgdGFyZ2V0LmlubmVySFRNTCwgcGxhaW4sIGV2ZW50KTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBkb1Bhc3RlKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCBldmVudCkge1xuICAgIGxldCBzbGljZSA9IHBhcnNlRnJvbUNsaXBib2FyZCh2aWV3LCB0ZXh0LCBodG1sLCBwcmVmZXJQbGFpbiwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20pO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlUGFzdGVcIiwgZiA9PiBmKHZpZXcsIGV2ZW50LCBzbGljZSB8fCBTbGljZS5lbXB0eSkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNpbmdsZU5vZGUgPSBzbGljZVNpbmdsZU5vZGUoc2xpY2UpO1xuICAgIGxldCB0ciA9IHNpbmdsZU5vZGVcbiAgICAgICAgPyB2aWV3LnN0YXRlLnRyLnJlcGxhY2VTZWxlY3Rpb25XaXRoKHNpbmdsZU5vZGUsIHByZWZlclBsYWluKVxuICAgICAgICA6IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbihzbGljZSk7XG4gICAgdmlldy5kaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpLnNldE1ldGEoXCJwYXN0ZVwiLCB0cnVlKS5zZXRNZXRhKFwidWlFdmVudFwiLCBcInBhc3RlXCIpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldFRleHQoY2xpcGJvYXJkRGF0YSkge1xuICAgIGxldCB0ZXh0ID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSB8fCBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpO1xuICAgIGlmICh0ZXh0KVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBsZXQgdXJpcyA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHQvdXJpLWxpc3RcIik7XG4gICAgcmV0dXJuIHVyaXMgPyB1cmlzLnJlcGxhY2UoL1xccj9cXG4vZywgXCIgXCIpIDogXCJcIjtcbn1cbmVkaXRIYW5kbGVycy5wYXN0ZSA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gSGFuZGxpbmcgcGFzdGUgZnJvbSBKYXZhU2NyaXB0IGR1cmluZyBjb21wb3NpdGlvbiBpcyB2ZXJ5IHBvb3JseVxuICAgIC8vIGhhbmRsZWQgYnkgYnJvd3NlcnMsIHNvIGFzIGEgZG9kZ3kgYnV0IHByZWZlcmFibGUga2x1ZGdlLCB3ZSBqdXN0XG4gICAgLy8gbGV0IHRoZSBicm93c2VyIGRvIGl0cyBuYXRpdmUgdGhpbmcgdGhlcmUsIGV4Y2VwdCBvbiBBbmRyb2lkLFxuICAgIC8vIHdoZXJlIHRoZSBlZGl0b3IgaXMgYWxtb3N0IGFsd2F5cyBjb21wb3NpbmcuXG4gICAgaWYgKHZpZXcuY29tcG9zaW5nICYmICFhbmRyb2lkKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGRhdGEgPSBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBsZXQgcGxhaW4gPSB2aWV3LmlucHV0LnNoaWZ0S2V5ICYmIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgIT0gNDU7XG4gICAgaWYgKGRhdGEgJiYgZG9QYXN0ZSh2aWV3LCBnZXRUZXh0KGRhdGEpLCBkYXRhLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIHBsYWluLCBldmVudCkpXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZWxzZVxuICAgICAgICBjYXB0dXJlUGFzdGUodmlldywgZXZlbnQpO1xufTtcbmNsYXNzIERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihzbGljZSwgbW92ZSwgbm9kZSkge1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMubW92ZSA9IG1vdmU7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxufVxuY29uc3QgZHJhZ0NvcHlNb2RpZmllciA9IG1hYyA/IFwiYWx0S2V5XCIgOiBcImN0cmxLZXlcIjtcbmZ1bmN0aW9uIGRyYWdNb3Zlcyh2aWV3LCBldmVudCkge1xuICAgIGxldCBtb3ZlcyA9IHZpZXcuc29tZVByb3AoXCJkcmFnQ29waWVzXCIsIHRlc3QgPT4gIXRlc3QoZXZlbnQpKTtcbiAgICByZXR1cm4gbW92ZXMgIT0gbnVsbCA/IG1vdmVzIDogIWV2ZW50W2RyYWdDb3B5TW9kaWZpZXJdO1xufVxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBsZXQgbW91c2VEb3duID0gdmlldy5pbnB1dC5tb3VzZURvd247XG4gICAgaWYgKG1vdXNlRG93bilcbiAgICAgICAgbW91c2VEb3duLmRvbmUoKTtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcG9zID0gc2VsLmVtcHR5ID8gbnVsbCA6IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBsZXQgbm9kZTtcbiAgICBpZiAocG9zICYmIHBvcy5wb3MgPj0gc2VsLmZyb20gJiYgcG9zLnBvcyA8PSAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiA/IHNlbC50byAtIDEgOiBzZWwudG8pKSA7XG4gICAgZWxzZSBpZiAobW91c2VEb3duICYmIG1vdXNlRG93bi5taWdodERyYWcpIHtcbiAgICAgICAgbm9kZSA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBtb3VzZURvd24ubWlnaHREcmFnLnBvcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhldmVudC50YXJnZXQsIHRydWUpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSAmJiBkZXNjICE9IHZpZXcuZG9jVmlldylcbiAgICAgICAgICAgIG5vZGUgPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgZGVzYy5wb3NCZWZvcmUpO1xuICAgIH1cbiAgICBsZXQgZHJhZ2dlZFNsaWNlID0gKG5vZGUgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24pLmNvbnRlbnQoKTtcbiAgICBsZXQgeyBkb20sIHRleHQsIHNsaWNlIH0gPSBzZXJpYWxpemVGb3JDbGlwYm9hcmQodmlldywgZHJhZ2dlZFNsaWNlKTtcbiAgICAvLyBQcmUtMTIwIENocm9tZSB2ZXJzaW9ucyBjbGVhciBmaWxlcyB3aGVuIGNhbGxpbmcgYGNsZWFyRGF0YWAgKCMxNDcyKVxuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCB8fCAhY2hyb21lIHx8IGNocm9tZV92ZXJzaW9uID4gMTIwKVxuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuY2xlYXJEYXRhKCk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoYnJva2VuQ2xpcGJvYXJkQVBJID8gXCJUZXh0XCIgOiBcInRleHQvaHRtbFwiLCBkb20uaW5uZXJIVE1MKTtcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy8xMTU2XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgaWYgKCFicm9rZW5DbGlwYm9hcmRBUEkpXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICB2aWV3LmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKHNsaWNlLCBkcmFnTW92ZXModmlldywgZXZlbnQpLCBub2RlKTtcbn07XG5oYW5kbGVycy5kcmFnZW5kID0gdmlldyA9PiB7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3LmRyYWdnaW5nID09IGRyYWdnaW5nKVxuICAgICAgICAgICAgdmlldy5kcmFnZ2luZyA9IG51bGw7XG4gICAgfSwgNTApO1xufTtcbmVkaXRIYW5kbGVycy5kcmFnb3ZlciA9IGVkaXRIYW5kbGVycy5kcmFnZW50ZXIgPSAoXywgZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuZWRpdEhhbmRsZXJzLmRyb3AgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBkcmFnZ2luZyA9IHZpZXcuZHJhZ2dpbmc7XG4gICAgdmlldy5kcmFnZ2luZyA9IG51bGw7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZXZlbnRQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKGV2ZW50Q29vcmRzKGV2ZW50KSk7XG4gICAgaWYgKCFldmVudFBvcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCAkbW91c2UgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGV2ZW50UG9zLnBvcyk7XG4gICAgbGV0IHNsaWNlID0gZHJhZ2dpbmcgJiYgZHJhZ2dpbmcuc2xpY2U7XG4gICAgaWYgKHNsaWNlKSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2xpY2UgPSBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgZ2V0VGV4dChldmVudC5kYXRhVHJhbnNmZXIpLCBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIGZhbHNlLCAkbW91c2UpO1xuICAgIH1cbiAgICBsZXQgbW92ZSA9ICEhKGRyYWdnaW5nICYmIGRyYWdNb3Zlcyh2aWV3LCBldmVudCkpO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRHJvcFwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5LCBtb3ZlKSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgaW5zZXJ0UG9zID0gc2xpY2UgPyBkcm9wUG9pbnQodmlldy5zdGF0ZS5kb2MsICRtb3VzZS5wb3MsIHNsaWNlKSA6ICRtb3VzZS5wb3M7XG4gICAgaWYgKGluc2VydFBvcyA9PSBudWxsKVxuICAgICAgICBpbnNlcnRQb3MgPSAkbW91c2UucG9zO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgaWYgKG1vdmUpIHtcbiAgICAgICAgbGV0IHsgbm9kZSB9ID0gZHJhZ2dpbmc7XG4gICAgICAgIGlmIChub2RlKVxuICAgICAgICAgICAgbm9kZS5yZXBsYWNlKHRyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGxldCBwb3MgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgIGxldCBpc05vZGUgPSBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDE7XG4gICAgbGV0IGJlZm9yZUluc2VydCA9IHRyLmRvYztcbiAgICBpZiAoaXNOb2RlKVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKHBvcywgcG9zLCBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIGVsc2VcbiAgICAgICAgdHIucmVwbGFjZVJhbmdlKHBvcywgcG9zLCBzbGljZSk7XG4gICAgaWYgKHRyLmRvYy5lcShiZWZvcmVJbnNlcnQpKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmIChpc05vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSAmJlxuICAgICAgICAkcG9zLm5vZGVBZnRlciAmJiAkcG9zLm5vZGVBZnRlci5zYW1lTWFya3VwKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBlbmQgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgICAgICB0ci5tYXBwaW5nLm1hcHNbdHIubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4gZW5kID0gbmV3VG8pO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkcG9zLCB0ci5kb2MucmVzb2x2ZShlbmQpKSk7XG4gICAgfVxuICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiZHJvcFwiKSk7XG59O1xuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IERhdGUubm93KCk7XG4gICAgaWYgKCF2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3Lmhhc0ZvY3VzKCkgJiYgIXZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxufTtcbmhhbmRsZXJzLmJsdXIgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmICh2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ICYmIHZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGRvIG1vcmUgd2l0aCBiZWZvcmVpbnB1dCBldmVudHMsIGJ1dCBzdXBwb3J0XG4gICAgLy8gaXMgc28gc3BvdHR5IHRoYXQgSSdtIHN0aWxsIHdhaXRpbmcgdG8gc2VlIHdoZXJlIHRoZXkgYXJlIGdvaW5nLlxuICAgIC8vIFZlcnkgc3BlY2lmaWMgaGFjayB0byBkZWFsIHdpdGggYmFja3NwYWNlIHNvbWV0aW1lcyBmYWlsaW5nIG9uXG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2hlbiBhZnRlciBhbiB1bmVkaXRhYmxlIG5vZGUuXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgICAgIGxldCB7IGRvbUNoYW5nZUNvdW50IH0gPSB2aWV3LmlucHV0O1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50ICE9IGRvbUNoYW5nZUNvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRXZlbnQgYWxyZWFkeSBoYWQgc29tZSBlZmZlY3RcbiAgICAgICAgICAgIC8vIFRoaXMgYnVnIHRlbmRzIHRvIGNsb3NlIHRoZSB2aXJ0dWFsIGtleWJvYXJkLCBzbyB3ZSByZWZvY3VzXG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAvLyBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIGJhY2tzcGFjZSBiZWhhdmlvciB3aGVuIG5vIGNvbW1hbmQgaGFuZGxlZCBpdFxuICAgICAgICAgICAgaWYgKCRjdXJzb3IgJiYgJGN1cnNvci5wb3MgPiAwKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGUoJGN1cnNvci5wb3MgLSAxLCAkY3Vyc29yLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59O1xuLy8gTWFrZSBzdXJlIGFsbCBoYW5kbGVycyBnZXQgcmVnaXN0ZXJlZFxuZm9yIChsZXQgcHJvcCBpbiBlZGl0SGFuZGxlcnMpXG4gICAgaGFuZGxlcnNbcHJvcF0gPSBlZGl0SGFuZGxlcnNbcHJvcF07XG5cbmZ1bmN0aW9uIGNvbXBhcmVPYmpzKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvRE9NLCBzcGVjKSB7XG4gICAgICAgIHRoaXMudG9ET00gPSB0b0RPTTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgICAgIHRoaXMuc2lkZSA9IHRoaXMuc3BlYy5zaWRlIHx8IDA7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgeyBwb3MsIGRlbGV0ZWQgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKHBvcyAtIG9mZnNldCwgcG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFR5cGUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zcGVjLmtleSAmJiB0aGlzLnNwZWMua2V5ID09IG90aGVyLnNwZWMua2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9ET00gPT0gb3RoZXIudG9ET00gJiYgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSkpO1xuICAgIH1cbiAgICBkZXN0cm95KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3kobm9kZSk7XG4gICAgfVxufVxuY2xhc3MgSW5saW5lVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlU3RhcnQgPyAtMSA6IDEpIC0gb2Zmc2V0O1xuICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChzcGFuLnRvICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlRW5kID8gMSA6IC0xKSAtIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGZyb20gPj0gdG8gPyBudWxsIDogbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChfLCBzcGFuKSB7IHJldHVybiBzcGFuLmZyb20gPCBzcGFuLnRvOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIElubGluZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpcyhzcGFuKSB7IHJldHVybiBzcGFuLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuY2xhc3MgTm9kZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi50byArIG9sZE9mZnNldCwgLTEpO1xuICAgICAgICBpZiAodG8uZGVsZXRlZCB8fCB0by5wb3MgPD0gZnJvbS5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20ucG9zIC0gb2Zmc2V0LCB0by5wb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChub2RlLCBzcGFuKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoc3Bhbi5mcm9tKSwgY2hpbGQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPT0gc3Bhbi5mcm9tICYmICEoY2hpbGQgPSBub2RlLmNoaWxkKGluZGV4KSkuaXNUZXh0ICYmIG9mZnNldCArIGNoaWxkLm5vZGVTaXplID09IHNwYW4udG87XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBOb2RlVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuLyoqXG5EZWNvcmF0aW9uIG9iamVjdHMgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSB2aWV3IHRocm91Z2ggdGhlXG5bYGRlY29yYXRpb25zYCBwcm9wXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5kZWNvcmF0aW9ucykuIFRoZXkgY29tZSBpblxuc2V2ZXJhbCB2YXJpYW50c1x1MjAxNHNlZSB0aGUgc3RhdGljIG1lbWJlcnMgb2YgdGhpcyBjbGFzcyBmb3IgZGV0YWlscy5cbiovXG5jbGFzcyBEZWNvcmF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24uIFdpbGwgYmUgdGhlIHNhbWUgYXMgYGZyb21gIGZvciBbd2lkZ2V0XG4gICAgZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ed2lkZ2V0KS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuZXEob3RoZXIudHlwZSkgJiYgdGhpcy5mcm9tICsgb2Zmc2V0ID09IG90aGVyLmZyb20gJiYgdGhpcy50byArIG9mZnNldCA9PSBvdGhlci50bztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5tYXAobWFwcGluZywgdGhpcywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGUgdGhhdCdzIHNob3duIGluXG4gICAgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3VcbiAgICBkZWxheSByZW5kZXJpbmcgdGhlIHdpZGdldCBieSBwYXNzaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAgY2FsbGVkIHdoZW4gdGhlIHdpZGdldCBpcyBhY3R1YWxseSBkcmF3biBpbiBhIHZpZXcsIGJ1dCB5b3UgY2FuXG4gICAgYWxzbyBkaXJlY3RseSBwYXNzIGEgRE9NIG5vZGUuIGBnZXRQb3NgIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlXG4gICAgd2lkZ2V0J3MgY3VycmVudCBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQocG9zLCB0b0RPTSwgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24ocG9zLCBwb3MsIG5ldyBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYW4gaW5saW5lIGRlY29yYXRpb24sIHdoaWNoIGFkZHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG9cbiAgICBlYWNoIGlubGluZSBub2RlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgc3RhdGljIGlubGluZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgSW5saW5lVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgbm9kZSBkZWNvcmF0aW9uLiBgZnJvbWAgYW5kIGB0b2Agc2hvdWxkIHBvaW50IHByZWNpc2VseVxuICAgIGJlZm9yZSBhbmQgYWZ0ZXIgYSBub2RlIGluIHRoZSBkb2N1bWVudC4gVGhhdCBub2RlLCBhbmQgb25seSB0aGF0XG4gICAgbm9kZSwgd2lsbCByZWNlaXZlIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc3RhdGljIG5vZGUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IE5vZGVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgdGhpcyBkZWNvcmF0aW9uLiBDYW4gYmUgdXNlZnVsXG4gICAgaWYgeW91J3ZlIHN0b3JlZCBleHRyYSBpbmZvcm1hdGlvbiBpbiB0aGF0IG9iamVjdC5cbiAgICAqL1xuICAgIGdldCBzcGVjKCkgeyByZXR1cm4gdGhpcy50eXBlLnNwZWM7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0KCkgeyByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgV2lkZ2V0VHlwZTsgfVxufVxuY29uc3Qgbm9uZSA9IFtdLCBub1NwZWMgPSB7fTtcbi8qKlxuQSBjb2xsZWN0aW9uIG9mIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbiksIG9yZ2FuaXplZCBpbiBzdWNoXG5hIHdheSB0aGF0IHRoZSBkcmF3aW5nIGFsZ29yaXRobSBjYW4gZWZmaWNpZW50bHkgdXNlIGFuZCBjb21wYXJlXG50aGVtLiBUaGlzIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZVx1MjAxNGl0IGlzIG5vdCBtb2RpZmllZCxcbnVwZGF0ZXMgY3JlYXRlIGEgbmV3IHZhbHVlLlxuKi9cbmNsYXNzIERlY29yYXRpb25TZXQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWwsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbC5sZW5ndGggPyBsb2NhbCA6IG5vbmU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbiA6IG5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBkZWNvcmF0aW9ucywgdXNpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW5cbiAgICBkb2N1bWVudC4gVGhpcyB3aWxsIGNvbnN1bWUgKG1vZGlmeSkgdGhlIGBkZWNvcmF0aW9uc2AgYXJyYXksIHNvXG4gICAgeW91IG11c3QgbWFrZSBhIGNvcHkgaWYgeW91IHdhbnQgbmVlZCB0byBwcmVzZXJ2ZSB0aGF0LlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0aW9ucy5sZW5ndGggPyBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIGRvYywgMCwgbm9TcGVjKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCB3aGljaCB0b3VjaCB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICAoaW5jbHVkaW5nIGRlY29yYXRpb25zIHRoYXQgc3RhcnQgb3IgZW5kIGRpcmVjdGx5IGF0IHRoZVxuICAgIGJvdW5kYXJpZXMpIGFuZCBtYXRjaCB0aGUgZ2l2ZW4gcHJlZGljYXRlIG9uIHRoZWlyIHNwZWMuIFdoZW5cbiAgICBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgb21pdHRlZCwgYWxsIGRlY29yYXRpb25zIGluIHRoZSBzZXQgYXJlXG4gICAgY29uc2lkZXJlZC4gV2hlbiBgcHJlZGljYXRlYCBpc24ndCBnaXZlbiwgYWxsIGRlY29yYXRpb25zIGFyZVxuICAgIGFzc3VtZWQgdG8gbWF0Y2guXG4gICAgKi9cbiAgICBmaW5kKHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZmluZElubmVyKHN0YXJ0ID09IG51bGwgPyAwIDogc3RhcnQsIGVuZCA9PSBudWxsID8gMWU5IDogZW5kLCByZXN1bHQsIDAsIHByZWRpY2F0ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmRJbm5lcihzdGFydCwgZW5kLCByZXN1bHQsIG9mZnNldCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBlbmQgJiYgc3Bhbi50byA+PSBzdGFydCAmJiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoc3Bhbi5zcGVjKSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Bhbi5jb3B5KHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPCBlbmQgJiYgdGhpcy5jaGlsZHJlbltpICsgMV0gPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE9mZiA9IHRoaXMuY2hpbGRyZW5baV0gKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDJdLmZpbmRJbm5lcihzdGFydCAtIGNoaWxkT2ZmLCBlbmQgLSBjaGlsZE9mZiwgcmVzdWx0LCBvZmZzZXQgKyBjaGlsZE9mZiwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBpbiByZXNwb25zZSB0byBhIGNoYW5nZSBpbiB0aGVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nLCBkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkgfHwgbWFwcGluZy5tYXBzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcElubmVyKG1hcHBpbmcsIGRvYywgMCwgMCwgb3B0aW9ucyB8fCBub1NwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcElubmVyKG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBuZXdMb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAmJiBtYXBwZWQudHlwZS52YWxpZChub2RlLCBtYXBwZWQpKVxuICAgICAgICAgICAgICAgIChuZXdMb2NhbCB8fCAobmV3TG9jYWwgPSBbXSkpLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZSh0aGlzLmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBtYXBDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBuZXdMb2NhbCB8fCBbXSwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3TG9jYWwgPyBuZXcgRGVjb3JhdGlvblNldChuZXdMb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSkgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBhcnJheSBvZiBkZWNvcmF0aW9ucyB0byB0aGUgb25lcyBpbiB0aGUgc2V0LFxuICAgIHByb2R1Y2luZyBhIG5ldyBzZXQuIENvbnN1bWVzIHRoZSBgZGVjb3JhdGlvbnNgIGFycmF5LiBOZWVkc1xuICAgIGFjY2VzcyB0byB0aGUgY3VycmVudCBkb2N1bWVudCB0byBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIHRyZWVcbiAgICBzdHJ1Y3R1cmUuXG4gICAgKi9cbiAgICBhZGQoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICBpZiAoIWRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICAgIGFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4sIGNoaWxkSW5kZXggPSAwO1xuICAgICAgICBkb2MuZm9yRWFjaCgoY2hpbGROb2RlLCBjaGlsZE9mZnNldCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJhc2VPZmZzZXQgPSBjaGlsZE9mZnNldCArIG9mZnNldCwgZm91bmQ7XG4gICAgICAgICAgICBpZiAoIShmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoZGVjb3JhdGlvbnMsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltjaGlsZEluZGV4XSA8IGNoaWxkT2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXggKz0gMztcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltjaGlsZEluZGV4XSA9PSBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0gPSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0uYWRkSW5uZXIoY2hpbGROb2RlLCBmb3VuZCwgYmFzZU9mZnNldCArIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZE9mZnNldCwgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUsIGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBiYXNlT2Zmc2V0ICsgMSwgbm9TcGVjKSk7XG4gICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbG9jYWwgPSBtb3ZlU3BhbnMoY2hpbGRJbmRleCA/IHdpdGhvdXROdWxscyhkZWNvcmF0aW9ucykgOiBkZWNvcmF0aW9ucywgLW9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWxvY2FsW2ldLnR5cGUudmFsaWQoZG9jLCBsb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5sZW5ndGggPyB0aGlzLmxvY2FsLmNvbmNhdChsb2NhbCkuc29ydChieVBvcykgOiB0aGlzLmxvY2FsLCBjaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHNldCB0aGF0IGNvbnRhaW5zIHRoZSBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCwgbWludXNcbiAgICB0aGUgb25lcyBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gICAgKi9cbiAgICByZW1vdmUoZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKGRlY29yYXRpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICByZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGxvY2FsID0gdGhpcy5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZvdW5kO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBjaGlsZHJlbltpXSArIG9mZnNldCwgdG8gPSBjaGlsZHJlbltpICsgMV0gKyBvZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgc3BhbjsgaiA8IGRlY29yYXRpb25zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA+IGZyb20gJiYgc3Bhbi50byA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9uc1tqXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWQgPSBjaGlsZHJlbltpICsgMl0ucmVtb3ZlSW5uZXIoZm91bmQsIGZyb20gKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gcmVtb3ZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICAgICAgICBpIC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNwYW4gPSBkZWNvcmF0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2FsLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsW2pdLmVxKHNwYW4sIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLmxvY2FsLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbiAmJiBsb2NhbCA9PSB0aGlzLmxvY2FsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBsb2NhbC5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWwsIGNoaWxkcmVuKSA6IGVtcHR5O1xuICAgIH1cbiAgICBmb3JDaGlsZChvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBjaGlsZCwgbG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID09IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2kgKyAyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gb2Zmc2V0ICsgMSwgZW5kID0gc3RhcnQgKyBub2RlLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZGVjID0gdGhpcy5sb2NhbFtpXTtcbiAgICAgICAgICAgIGlmIChkZWMuZnJvbSA8IGVuZCAmJiBkZWMudG8gPiBzdGFydCAmJiAoZGVjLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoc3RhcnQsIGRlYy5mcm9tKSAtIHN0YXJ0LCB0byA9IE1hdGgubWluKGVuZCwgZGVjLnRvKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pXG4gICAgICAgICAgICAgICAgICAgIChsb2NhbCB8fCAobG9jYWwgPSBbXSkpLnB1c2goZGVjLmNvcHkoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgIGxldCBsb2NhbFNldCA9IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLnNvcnQoYnlQb3MpLCBub25lKTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA/IG5ldyBEZWNvcmF0aW9uR3JvdXAoW2xvY2FsU2V0LCBjaGlsZF0pIDogbG9jYWxTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09IG90aGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgfHxcbiAgICAgICAgICAgIHRoaXMubG9jYWwubGVuZ3RoICE9IG90aGVyLmxvY2FsLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggIT0gb3RoZXIuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9jYWxbaV0uZXEob3RoZXIubG9jYWxbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gIT0gb3RoZXIuY2hpbGRyZW5baV0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2kgKyAxXSAhPSBvdGhlci5jaGlsZHJlbltpICsgMV0gfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5jaGlsZHJlbltpICsgMl0uZXEob3RoZXIuY2hpbGRyZW5baSArIDJdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVPdmVybGFwKHRoaXMubG9jYWxzSW5uZXIobm9kZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvY2Fsc0lubmVyKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gbm9uZTtcbiAgICAgICAgaWYgKG5vZGUuaW5saW5lQ29udGVudCB8fCAhdGhpcy5sb2NhbC5zb21lKElubGluZVR5cGUuaXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWw7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLmxvY2FsW2ldLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxvY2FsW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmb3JFYWNoU2V0KGYpIHsgZih0aGlzKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIGRlY29yYXRpb25zLlxuKi9cbkRlY29yYXRpb25TZXQuZW1wdHkgPSBuZXcgRGVjb3JhdGlvblNldChbXSwgW10pO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5EZWNvcmF0aW9uU2V0LnJlbW92ZU92ZXJsYXAgPSByZW1vdmVPdmVybGFwO1xuY29uc3QgZW1wdHkgPSBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuLy8gQW4gYWJzdHJhY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGNvZGUgZGVhbGluZyB3aXRoIGRlY29yYXRpb25zIHRvXG4vLyB0cmVhdCBtdWx0aXBsZSBEZWNvcmF0aW9uU2V0IG9iamVjdHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBvYmplY3Rcbi8vIHdpdGggKGEgc3Vic2V0IG9mKSB0aGUgc2FtZSBpbnRlcmZhY2UuXG5jbGFzcyBEZWNvcmF0aW9uR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKG1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIGRvYykge1xuICAgICAgICBjb25zdCBtYXBwZWREZWNvcyA9IHRoaXMubWVtYmVycy5tYXAobWVtYmVyID0+IG1lbWJlci5tYXAobWFwcGluZywgZG9jLCBub1NwZWMpKTtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKG1hcHBlZERlY29zKTtcbiAgICB9XG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWVtYmVyc1tpXS5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQuY29uY2F0KHJlc3VsdC5tZW1iZXJzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApIHx8XG4gICAgICAgICAgICBvdGhlci5tZW1iZXJzLmxlbmd0aCAhPSB0aGlzLm1lbWJlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5tZW1iZXJzW2ldLmVxKG90aGVyLm1lbWJlcnNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIGxldCByZXN1bHQsIHNvcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxzID0gdGhpcy5tZW1iZXJzW2ldLmxvY2Fsc0lubmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFsb2NhbHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsb2NhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxvY2Fsc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlbW92ZU92ZXJsYXAoc29ydGVkID8gcmVzdWx0IDogcmVzdWx0LnNvcnQoYnlQb3MpKSA6IG5vbmU7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbiBzZXRzLCBvciByZXR1cm5cbiAgICAvLyBhIHNpbmdsZSBzZXQgd2hlbiBwb3NzaWJsZS5cbiAgICBzdGF0aWMgZnJvbShtZW1iZXJzKSB7XG4gICAgICAgIHN3aXRjaCAobWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGVtcHR5O1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbWVtYmVyc1swXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBuZXcgRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMuZXZlcnkobSA9PiBtIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgPyBtZW1iZXJzIDpcbiAgICAgICAgICAgICAgICBtZW1iZXJzLnJlZHVjZSgociwgbSkgPT4gci5jb25jYXQobSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQgPyBtIDogbS5tZW1iZXJzKSwgW10pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoU2V0KGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLm1lbWJlcnNbaV0uZm9yRWFjaFNldChmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBDaGlsZHJlbihvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gb2xkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgICAvLyBNYXJrIHRoZSBjaGlsZHJlbiB0aGF0IGFyZSBkaXJlY3RseSB0b3VjaGVkIGJ5IGNoYW5nZXMsIGFuZFxuICAgIC8vIG1vdmUgdGhvc2UgdGhhdCBhcmUgYWZ0ZXIgdGhlIGNoYW5nZXMuXG4gICAgZm9yIChsZXQgaSA9IDAsIGJhc2VPZmZzZXQgPSBvbGRPZmZzZXQ7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG1vdmVkID0gMDtcbiAgICAgICAgbWFwcGluZy5tYXBzW2ldLmZvckVhY2goKG9sZFN0YXJ0LCBvbGRFbmQsIG5ld1N0YXJ0LCBuZXdFbmQpID0+IHtcbiAgICAgICAgICAgIGxldCBkU2l6ZSA9IChuZXdFbmQgLSBuZXdTdGFydCkgLSAob2xkRW5kIC0gb2xkU3RhcnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBjaGlsZHJlbltpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA8IDAgfHwgb2xkU3RhcnQgPiBlbmQgKyBiYXNlT2Zmc2V0IC0gbW92ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGNoaWxkcmVuW2ldICsgYmFzZU9mZnNldCAtIG1vdmVkO1xuICAgICAgICAgICAgICAgIGlmIChvbGRFbmQgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gb2xkU3RhcnQgPD0gc3RhcnQgPyAtMiA6IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRTdGFydCA+PSBiYXNlT2Zmc2V0ICYmIGRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldICs9IGRTaXplO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gKz0gZFNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW92ZWQgKz0gZFNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICBiYXNlT2Zmc2V0ID0gbWFwcGluZy5tYXBzW2ldLm1hcChiYXNlT2Zmc2V0LCAtMSk7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGNoaWxkIG5vZGVzIHRoYXQgc3RpbGwgY29ycmVzcG9uZCB0byBhIHNpbmdsZSBub2RlLFxuICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgbWFwSW5uZXIgb24gdGhlbSBhbmQgdXBkYXRlIHRoZWlyIHBvc2l0aW9ucy5cbiAgICBsZXQgbXVzdFJlYnVpbGQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdIDwgMCkgeyAvLyBUb3VjaGVkIG5vZGVzXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdID09IC0yKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IC0xO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCksIGZyb21Mb2NhbCA9IGZyb20gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoZnJvbUxvY2FsIDwgMCB8fCBmcm9tTG9jYWwgPj0gbm9kZS5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNdXN0IHJlYWQgb2xkQ2hpbGRyZW4gYmVjYXVzZSBjaGlsZHJlbiB3YXMgdGFnZ2VkIHdpdGggLTFcbiAgICAgICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwKG9sZENoaWxkcmVuW2kgKyAxXSArIG9sZE9mZnNldCwgLTEpLCB0b0xvY2FsID0gdG8gLSBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0OiBjaGlsZE9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChmcm9tTG9jYWwpO1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkT2Zmc2V0ID09IGZyb21Mb2NhbCAmJiBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSA9PSB0b0xvY2FsKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGNoaWxkcmVuW2kgKyAyXVxuICAgICAgICAgICAgICAgICAgICAubWFwSW5uZXIobWFwcGluZywgY2hpbGROb2RlLCBmcm9tICsgMSwgb2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0gZnJvbUxvY2FsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSB0b0xvY2FsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMl0gPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIC8vIFJlbWFpbmluZyBjaGlsZHJlbiBtdXN0IGJlIGNvbGxlY3RlZCBhbmQgcmVidWlsdCBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdHJ1Y3R1cmVcbiAgICBpZiAobXVzdFJlYnVpbGQpIHtcbiAgICAgICAgbGV0IGRlY29yYXRpb25zID0gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgYnVpbHQgPSBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIG5vZGUsIDAsIG9wdGlvbnMpO1xuICAgICAgICBuZXdMb2NhbCA9IGJ1aWx0LmxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMyk7XG4gICAgICAgICAgICAgICAgaSAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBidWlsdC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWlsdC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2pdIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBqICs9IDM7XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMCwgYnVpbHQuY2hpbGRyZW5baV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAxXSwgYnVpbHQuY2hpbGRyZW5baSArIDJdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcyksIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIG1vdmVTcGFucyhzcGFucywgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQgfHwgIXNwYW5zLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHNwYW5zO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzcGFuID0gc3BhbnNbaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEZWNvcmF0aW9uKHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCwgc3Bhbi50eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyhjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIGRlY29yYXRpb25zLCBtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgIC8vIEdhdGhlciBhbGwgZGVjb3JhdGlvbnMgZnJvbSB0aGUgcmVtYWluaW5nIG1hcmtlZCBjaGlsZHJlblxuICAgIGZ1bmN0aW9uIGdhdGhlcihzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHNldC5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUoc2V0LmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgZ2F0aGVyKHNldC5jaGlsZHJlbltpICsgMl0sIHNldC5jaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdID09IC0xKVxuICAgICAgICAgICAgZ2F0aGVyKGNoaWxkcmVuW2kgKyAyXSwgb2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5mdW5jdGlvbiB0YWtlU3BhbnNGb3JOb2RlKHNwYW5zLCBub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBlbmQgPSBvZmZzZXQgKyBub2RlLm5vZGVTaXplLCBmb3VuZCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIHNwYW47IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKHNwYW4gPSBzcGFuc1tpXSkgJiYgc3Bhbi5mcm9tID4gb2Zmc2V0ICYmIHNwYW4udG8gPCBlbmQpIHtcbiAgICAgICAgICAgIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICAgICAgICBzcGFuc1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gd2l0aG91dE51bGxzKGFycmF5KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChhcnJheVtpXSAhPSBudWxsKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBCdWlsZCB1cCBhIHRyZWUgdGhhdCBjb3JyZXNwb25kcyB0byBhIHNldCBvZiBkZWNvcmF0aW9ucy4gYG9mZnNldGBcbi8vIGlzIGEgYmFzZSBvZmZzZXQgdGhhdCBzaG91bGQgYmUgc3VidHJhY3RlZCBmcm9tIHRoZSBgZnJvbWAgYW5kIGB0b2Bcbi8vIHBvc2l0aW9ucyBpbiB0aGUgc3BhbnMgKHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBhbGxvY2F0ZSBuZXcgc3BhbnNcbi8vIGZvciByZWN1cnNpdmUgY2FsbHMpLlxuZnVuY3Rpb24gYnVpbGRUcmVlKHNwYW5zLCBub2RlLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgaGFzTnVsbHMgPSBmYWxzZTtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkTm9kZSwgbG9jYWxTdGFydCkgPT4ge1xuICAgICAgICBsZXQgZm91bmQgPSB0YWtlU3BhbnNGb3JOb2RlKHNwYW5zLCBjaGlsZE5vZGUsIGxvY2FsU3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIGhhc051bGxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzdWJ0cmVlID0gYnVpbGRUcmVlKGZvdW5kLCBjaGlsZE5vZGUsIG9mZnNldCArIGxvY2FsU3RhcnQgKyAxLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdWJ0cmVlICE9IGVtcHR5KVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobG9jYWxTdGFydCwgbG9jYWxTdGFydCArIGNoaWxkTm9kZS5ub2RlU2l6ZSwgc3VidHJlZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgbG9jYWxzID0gbW92ZVNwYW5zKGhhc051bGxzID8gd2l0aG91dE51bGxzKHNwYW5zKSA6IHNwYW5zLCAtb2Zmc2V0KS5zb3J0KGJ5UG9zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2Fscy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFsb2NhbHNbaV0udHlwZS52YWxpZChub2RlLCBsb2NhbHNbaV0pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKGxvY2Fsc1tpXS5zcGVjKTtcbiAgICAgICAgICAgIGxvY2Fscy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBsb2NhbHMubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FscywgY2hpbGRyZW4pIDogZW1wdHk7XG59XG4vLyBVc2VkIHRvIHNvcnQgZGVjb3JhdGlvbnMgc28gdGhhdCBvbmVzIHdpdGggYSBsb3cgc3RhcnQgcG9zaXRpb25cbi8vIGNvbWUgZmlyc3QsIGFuZCB3aXRoaW4gYSBzZXQgd2l0aCB0aGUgc2FtZSBzdGFydCBwb3NpdGlvbiwgdGhvc2Vcbi8vIHdpdGggYW4gc21hbGxlciBlbmQgcG9zaXRpb24gY29tZSBmaXJzdC5cbmZ1bmN0aW9uIGJ5UG9zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudG8gLSBiLnRvO1xufVxuLy8gU2NhbiBhIHNvcnRlZCBhcnJheSBvZiBkZWNvcmF0aW9ucyBmb3IgcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zLFxuLy8gYW5kIHNwbGl0IHRob3NlIHNvIHRoYXQgb25seSBmdWxseSBvdmVybGFwcGluZyBzcGFucyBhcmUgbGVmdCAodG9cbi8vIG1ha2Ugc3Vic2VxdWVudCByZW5kZXJpbmcgZWFzaWVyKS4gV2lsbCByZXR1cm4gdGhlIGlucHV0IGFycmF5IGlmXG4vLyBubyBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGZvdW5kICh0aGUgY29tbW9uIGNhc2UpLlxuZnVuY3Rpb24gcmVtb3ZlT3ZlcmxhcChzcGFucykge1xuICAgIGxldCB3b3JraW5nID0gc3BhbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JraW5nLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHdvcmtpbmdbaV07XG4gICAgICAgIGlmIChzcGFuLmZyb20gIT0gc3Bhbi50bylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHdvcmtpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHdvcmtpbmdbal07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA9PSBzcGFuLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQudG8gIT0gc3Bhbi50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcgPT0gc3BhbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IHNwYW5zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb2xsb3dlZCBieSBhIHBhcnRpYWxseSBvdmVybGFwcGluZyBsYXJnZXIgc3Bhbi4gU3BsaXQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Bhbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdbal0gPSBuZXh0LmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGogKyAxLCBuZXh0LmNvcHkoc3Bhbi50bywgbmV4dC50bykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA8IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVuZCBvZiB0aGlzIG9uZSBvdmVybGFwcyB3aXRoIGEgc3Vic2VxdWVudCBzcGFuLiBTcGxpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2ldID0gc3Bhbi5jb3B5KHNwYW4uZnJvbSwgbmV4dC5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGosIHNwYW4uY29weShuZXh0LmZyb20sIHNwYW4udG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3b3JraW5nO1xufVxuZnVuY3Rpb24gaW5zZXJ0QWhlYWQoYXJyYXksIGksIGRlY28pIHtcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCAmJiBieVBvcyhkZWNvLCBhcnJheVtpXSkgPiAwKVxuICAgICAgICBpKys7XG4gICAgYXJyYXkuc3BsaWNlKGksIDAsIGRlY28pO1xufVxuLy8gR2V0IHRoZSBkZWNvcmF0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgcHJvcHMgb2YgYSB2aWV3LlxuZnVuY3Rpb24gdmlld0RlY29yYXRpb25zKHZpZXcpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiZGVjb3JhdGlvbnNcIiwgZiA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBmKHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCAhPSBlbXB0eSlcbiAgICAgICAgICAgIGZvdW5kLnB1c2gocmVzdWx0KTtcbiAgICB9KTtcbiAgICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKVxuICAgICAgICBmb3VuZC5wdXNoKERlY29yYXRpb25TZXQuY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBbdmlldy5jdXJzb3JXcmFwcGVyLmRlY29dKSk7XG4gICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbn1cblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG8gRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXG5jb25zdCB1c2VDaGFyRGF0YSA9IGllICYmIGllX3ZlcnNpb24gPD0gMTE7XG5jbGFzcyBTZWxlY3Rpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgc2V0KHNlbCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgfVxuICAgIGVxKHNlbCkge1xuICAgICAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgPT0gdGhpcy5hbmNob3JOb2RlICYmIHNlbC5hbmNob3JPZmZzZXQgPT0gdGhpcy5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHNlbC5mb2N1c05vZGUgPT0gdGhpcy5mb2N1c05vZGUgJiYgc2VsLmZvY3VzT2Zmc2V0ID09IHRoaXMuZm9jdXNPZmZzZXQ7XG4gICAgfVxufVxuY2xhc3MgRE9NT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGhhbmRsZURPTUNoYW5nZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZSA9IGhhbmRsZURPTUNoYW5nZTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IC0xO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvblN0YXRlO1xuICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2VkVGV4dE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgJiZcbiAgICAgICAgICAgIG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0YXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgLy8gdGV4dCBub2RlIGFmdGVyIGEgQlIgbm9kZSkgY2FsbCB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgYWN0dWFsbHkgdXBkYXRpbmcgdGhlIERPTSwgd2hpY2ggd2lsbCBjYXVzZVxuICAgICAgICAgICAgICAgIC8vIFByb3NlTWlycm9yIHRvIG1pc3MgdGhlIGNoYW5nZSAoc2VlICM5MzApXG4gICAgICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSBlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goeyB0YXJnZXQ6IGUudGFyZ2V0LCB0eXBlOiBcImNoYXJhY3RlckRhdGFcIiwgb2xkVmFsdWU6IGUucHJldlZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGZsdXNoU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmx1c2hpbmdTb29uIDwgMClcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmZsdXNoaW5nU29vbiA9IC0xOyB0aGlzLmZsdXNoKCk7IH0sIDIwKTtcbiAgICB9XG4gICAgZm9yY2VGbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmx1c2hpbmdTb29uID4gLTEpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5mbHVzaGluZ1Nvb24pO1xuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnZpZXcuZG9tLCBvYnNlcnZlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmNvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGxldCB0YWtlID0gdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgaWYgKHRha2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2godGFrZVtpXSk7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaCgpLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbkNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBjb25uZWN0U2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIHN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2UsIDUwKTtcbiAgICB9XG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgIGlmICghaGFzRm9jdXNBbmRTZWxlY3Rpb24odGhpcy52aWV3KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzKVxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvblRvRE9NKHRoaXMudmlldyk7XG4gICAgICAgIC8vIERlbGV0aW9ucyBvbiBJRTExIGZpcmUgdGhlaXIgZXZlbnRzIGluIHRoZSB3cm9uZyBvcmRlciwgZ2l2aW5nXG4gICAgICAgIC8vIHVzIGEgc2VsZWN0aW9uIGNoYW5nZSBldmVudCBiZWZvcmUgdGhlIERPTSBjaGFuZ2VzIGFyZVxuICAgICAgICAvLyByZXBvcnRlZC5cbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgIXRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBzZWwgPSB0aGlzLnZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgIC8vIFNlbGVjdGlvbi5pc0NvbGxhcHNlZCBpc24ndCByZWxpYWJsZSBvbiBJRVxuICAgICAgICAgICAgaWYgKHNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICBzZXRDdXJTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQodGhpcy52aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpO1xuICAgIH1cbiAgICBpZ25vcmVTZWxlY3Rpb25DaGFuZ2Uoc2VsKSB7XG4gICAgICAgIGlmICghc2VsLmZvY3VzTm9kZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgYW5jZXN0b3JzID0gbmV3IFNldCwgY29udGFpbmVyO1xuICAgICAgICBmb3IgKGxldCBzY2FuID0gc2VsLmZvY3VzTm9kZTsgc2Nhbjsgc2NhbiA9IHBhcmVudE5vZGUoc2NhbikpXG4gICAgICAgICAgICBhbmNlc3RvcnMuYWRkKHNjYW4pO1xuICAgICAgICBmb3IgKGxldCBzY2FuID0gc2VsLmFuY2hvck5vZGU7IHNjYW47IHNjYW4gPSBwYXJlbnROb2RlKHNjYW4pKVxuICAgICAgICAgICAgaWYgKGFuY2VzdG9ycy5oYXMoc2NhbikpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBzY2FuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgZGVzYyA9IGNvbnRhaW5lciAmJiB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjb250YWluZXIpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLmlnbm9yZU11dGF0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgICB0YXJnZXQ6IGNvbnRhaW5lci5ub2RlVHlwZSA9PSAzID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXJcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwZW5kaW5nUmVjb3JkcygpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpXG4gICAgICAgICAgICBmb3IgKGxldCBtdXQgb2YgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGlmICghdmlldy5kb2NWaWV3IHx8IHRoaXMuZmx1c2hpbmdTb29uID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtdXRhdGlvbnMgPSB0aGlzLnBlbmRpbmdSZWNvcmRzKCk7XG4gICAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgbmV3U2VsID0gIXRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzICYmICF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSAmJiBoYXNGb2N1c0FuZFNlbGVjdGlvbih2aWV3KSAmJiAhdGhpcy5pZ25vcmVTZWxlY3Rpb25DaGFuZ2Uoc2VsKTtcbiAgICAgICAgbGV0IGZyb20gPSAtMSwgdG8gPSAtMSwgdHlwZU92ZXIgPSBmYWxzZSwgYWRkZWQgPSBbXTtcbiAgICAgICAgaWYgKHZpZXcuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVnaXN0ZXJNdXRhdGlvbihtdXRhdGlvbnNbaV0sIGFkZGVkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBmcm9tIDwgMCA/IHJlc3VsdC5mcm9tIDogTWF0aC5taW4ocmVzdWx0LmZyb20sIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB0byA9IHRvIDwgMCA/IHJlc3VsdC50byA6IE1hdGgubWF4KHJlc3VsdC50bywgdG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGVPdmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2Vja28gJiYgYWRkZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgYnJzID0gYWRkZWQuZmlsdGVyKG4gPT4gbi5ub2RlTmFtZSA9PSBcIkJSXCIpO1xuICAgICAgICAgICAgaWYgKGJycy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgIGxldCBbYSwgYl0gPSBicnM7XG4gICAgICAgICAgICAgICAgaWYgKGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PSBiLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZm9jdXNOb2RlIH0gPSB0aGlzLmN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYnIgb2YgYnJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBici5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZSA9PSBcIkxJXCIgJiYgKCFmb2N1c05vZGUgfHwgYmxvY2tQYXJlbnQodmlldywgZm9jdXNOb2RlKSAhPSBwYXJlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWFkU2VsID0gbnVsbDtcbiAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSB0aGUgYnJvd3NlciBoYXMgcmVzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGRvY3VtZW50IGFmdGVyIGZvY3VzLCByZXN0b3JlIHRoZSBzZWxlY3Rpb24gZnJvbVxuICAgICAgICAvLyB0aGUgc3RhdGVcbiAgICAgICAgaWYgKGZyb20gPCAwICYmIG5ld1NlbCAmJiB2aWV3LmlucHV0Lmxhc3RGb2N1cyA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIE1hdGgubWF4KHZpZXcuaW5wdXQubGFzdFRvdWNoLCB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lKSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpICYmIChyZWFkU2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSkgJiZcbiAgICAgICAgICAgIHJlYWRTZWwuZXEoU2VsZWN0aW9uLm5lYXIodmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgwKSwgMSkpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgICAgIHZpZXcuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgY2hlY2tDU1Modmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZShmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHNlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihtdXQsIGFkZGVkKSB7XG4gICAgICAgIC8vIElnbm9yZSBtdXRhdGlvbnMgaW5zaWRlIG5vZGVzIHRoYXQgd2VyZSBhbHJlYWR5IG5vdGVkIGFzIGluc2VydGVkXG4gICAgICAgIGlmIChhZGRlZC5pbmRleE9mKG11dC50YXJnZXQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhtdXQudGFyZ2V0KTtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmXG4gICAgICAgICAgICAoZGVzYyA9PSB0aGlzLnZpZXcuZG9jVmlldyB8fCBtdXQuYXR0cmlidXRlTmFtZSA9PSBcImNvbnRlbnRlZGl0YWJsZVwiIHx8XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzb21ldGltZXMgZmlyZXMgc3B1cmlvdXMgZXZlbnRzIGZvciBudWxsL2VtcHR5IHN0eWxlc1xuICAgICAgICAgICAgICAgIChtdXQuYXR0cmlidXRlTmFtZSA9PSBcInN0eWxlXCIgJiYgIW11dC5vbGRWYWx1ZSAmJiAhbXV0LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghZGVzYyB8fCBkZXNjLmlnbm9yZU11dGF0aW9uKG11dCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG11dC5hZGRlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGFkZGVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlZFRleHROb2RlID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXNjLmNvbnRlbnRET00gJiYgZGVzYy5jb250ZW50RE9NICE9IGRlc2MuZG9tICYmICFkZXNjLmNvbnRlbnRET00uY29udGFpbnMobXV0LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NCZWZvcmUsIHRvOiBkZXNjLnBvc0FmdGVyIH07XG4gICAgICAgICAgICBsZXQgcHJldiA9IG11dC5wcmV2aW91c1NpYmxpbmcsIG5leHQgPSBtdXQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXQuYWRkZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJRTExIGdpdmVzIHVzIGluY29ycmVjdCBuZXh0L3ByZXYgc2libGluZ3MgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnRpb25zLCBzbyBpZiB0aGVyZSBhcmUgYWRkZWQgbm9kZXMsIHJlY29tcHV0ZSB0aG9zZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcHJldmlvdXNTaWJsaW5nLCBuZXh0U2libGluZyB9ID0gbXV0LmFkZGVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIHByZXZpb3VzU2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0U2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBuZXh0U2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gcHJldiAmJiBwcmV2LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgocHJldikgKyAxIDogMDtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgZnJvbU9mZnNldCwgLTEpO1xuICAgICAgICAgICAgbGV0IHRvT2Zmc2V0ID0gbmV4dCAmJiBuZXh0LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgobmV4dCkgOiBtdXQudGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHRvID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgdG9PZmZzZXQsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIsIHRvOiBkZXNjLnBvc0F0RW5kICsgZGVzYy5ib3JkZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gXCJjaGFyYWN0ZXJEYXRhXCJcbiAgICAgICAgICAgIHRoaXMubGFzdENoYW5nZWRUZXh0Tm9kZSA9IG11dC50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogZGVzYy5wb3NBdEVuZCxcbiAgICAgICAgICAgICAgICAvLyBBbiBldmVudCB3YXMgZ2VuZXJhdGVkIGZvciBhIHRleHQgY2hhbmdlIHRoYXQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFueSB0ZXh0LiBNYXJrIHRoZSBkb20gY2hhbmdlIHRvIGZhbGwgYmFjayB0byBhc3N1bWluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb24gd2FzIHR5cGVkIG92ZXIgd2l0aCBhbiBpZGVudGljYWwgdmFsdWUgaWYgaXQgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFub3RoZXIgY2hhbmdlLlxuICAgICAgICAgICAgICAgIHR5cGVPdmVyOiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgY3NzQ2hlY2tlZCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgY3NzQ2hlY2tXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrQ1NTKHZpZXcpIHtcbiAgICBpZiAoY3NzQ2hlY2tlZC5oYXModmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICBjc3NDaGVja2VkLnNldCh2aWV3LCBudWxsKTtcbiAgICBpZiAoWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZS1saW5lJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS53aGl0ZVNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgdmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBnZWNrbztcbiAgICAgICAgaWYgKGNzc0NoZWNrV2FybmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTtcbiAgICAgICAgY3NzQ2hlY2tXYXJuZWQgPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCByYW5nZSkge1xuICAgIGxldCBhbmNob3JOb2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsIGFuY2hvck9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgIGxldCBmb2N1c05vZGUgPSByYW5nZS5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgIGxldCBjdXJyZW50QW5jaG9yID0gdmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IpO1xuICAgIC8vIFNpbmNlIHN1Y2ggYSByYW5nZSBkb2Vzbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gYW5jaG9yIGFuZCBoZWFkLFxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXG4gICAgLy8gY3VycmVudCBhbmNob3IuXG4gICAgaWYgKGlzRXF1aXZhbGVudFBvc2l0aW9uKGN1cnJlbnRBbmNob3Iubm9kZSwgY3VycmVudEFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWdcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDE0IGZpeFxuZnVuY3Rpb24gc2FmYXJpU2hhZG93U2VsZWN0aW9uUmFuZ2Uodmlldywgc2VsZWN0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0Q29tcG9zZWRSYW5nZXModmlldy5yb290KVswXTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCByYW5nZSk7XG4gICAgfVxuICAgIGxldCBmb3VuZDtcbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIyKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd1Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdFx1MjAxNHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbmRlbnRcIik7XG4gICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIHJldHVybiBmb3VuZCA/IHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCBmb3VuZCkgOiBudWxsO1xufVxuZnVuY3Rpb24gYmxvY2tQYXJlbnQodmlldywgbm9kZSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlLnBhcmVudE5vZGU7IHAgJiYgcCAhPSB2aWV3LmRvbTsgcCA9IHAucGFyZW50Tm9kZSkge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhwLCB0cnVlKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlLmlzQmxvY2spXG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIE5vdGUgdGhhdCBhbGwgcmVmZXJlbmNpbmcgYW5kIHBhcnNpbmcgaXMgZG9uZSB3aXRoIHRoZVxuLy8gc3RhcnQtb2Ytb3BlcmF0aW9uIHNlbGVjdGlvbiBhbmQgZG9jdW1lbnQsIHNpbmNlIHRoYXQncyB0aGUgb25lXG4vLyB0aGF0IHRoZSBET00gcmVwcmVzZW50cy4gSWYgYW55IGNoYW5nZXMgY2FtZSBpbiBpbiB0aGUgbWVhbnRpbWUsXG4vLyB0aGUgbW9kaWZpY2F0aW9uIGlzIG1hcHBlZCBvdmVyIHRob3NlIGJlZm9yZSBpdCBpcyBhcHBsaWVkLCBpblxuLy8gcmVhZERPTUNoYW5nZS5cbmZ1bmN0aW9uIHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tXywgdG9fKSB7XG4gICAgbGV0IHsgbm9kZTogcGFyZW50LCBmcm9tT2Zmc2V0LCB0b09mZnNldCwgZnJvbSwgdG8gfSA9IHZpZXcuZG9jVmlldy5wYXJzZVJhbmdlKGZyb21fLCB0b18pO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IGZpbmQ7XG4gICAgbGV0IGFuY2hvciA9IGRvbVNlbC5hbmNob3JOb2RlO1xuICAgIGlmIChhbmNob3IgJiYgdmlldy5kb20uY29udGFpbnMoYW5jaG9yLm5vZGVUeXBlID09IDEgPyBhbmNob3IgOiBhbmNob3IucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgZmluZCA9IFt7IG5vZGU6IGFuY2hvciwgb2Zmc2V0OiBkb21TZWwuYW5jaG9yT2Zmc2V0IH1dO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKVxuICAgICAgICAgICAgZmluZC5wdXNoKHsgbm9kZTogZG9tU2VsLmZvY3VzTm9kZSwgb2Zmc2V0OiBkb21TZWwuZm9jdXNPZmZzZXQgfSk7XG4gICAgfVxuICAgIC8vIFdvcmsgYXJvdW5kIGlzc3VlIGluIENocm9tZSB3aGVyZSBiYWNrc3BhY2luZyBzb21ldGltZXMgcmVwbGFjZXNcbiAgICAvLyB0aGUgZGVsZXRlZCBjb250ZW50IHdpdGggYSByYW5kb20gQlIgbm9kZSAoaXNzdWVzICM3OTksICM4MzEpXG4gICAgaWYgKGNocm9tZSAmJiB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSA4KSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRvT2Zmc2V0OyBvZmYgPiBmcm9tT2Zmc2V0OyBvZmYtLSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBwYXJlbnQuY2hpbGROb2Rlc1tvZmYgLSAxXSwgZGVzYyA9IG5vZGUucG1WaWV3RGVzYztcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZGVzYykge1xuICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gb2ZmO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IGRlc2Muc2l6ZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgbGV0ICRmcm9tID0gc3RhcnREb2MucmVzb2x2ZShmcm9tKTtcbiAgICBsZXQgc2VsID0gbnVsbCwgZG9jID0gcGFyc2VyLnBhcnNlKHBhcmVudCwge1xuICAgICAgICB0b3BOb2RlOiAkZnJvbS5wYXJlbnQsXG4gICAgICAgIHRvcE1hdGNoOiAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSksXG4gICAgICAgIHRvcE9wZW46IHRydWUsXG4gICAgICAgIGZyb206IGZyb21PZmZzZXQsXG4gICAgICAgIHRvOiB0b09mZnNldCxcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAkZnJvbS5wYXJlbnQudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBcImZ1bGxcIiA6IHRydWUsXG4gICAgICAgIGZpbmRQb3NpdGlvbnM6IGZpbmQsXG4gICAgICAgIHJ1bGVGcm9tTm9kZSxcbiAgICAgICAgY29udGV4dDogJGZyb21cbiAgICB9KTtcbiAgICBpZiAoZmluZCAmJiBmaW5kWzBdLnBvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCBhbmNob3IgPSBmaW5kWzBdLnBvcywgaGVhZCA9IGZpbmRbMV0gJiYgZmluZFsxXS5wb3M7XG4gICAgICAgIGlmIChoZWFkID09IG51bGwpXG4gICAgICAgICAgICBoZWFkID0gYW5jaG9yO1xuICAgICAgICBzZWwgPSB7IGFuY2hvcjogYW5jaG9yICsgZnJvbSwgaGVhZDogaGVhZCArIGZyb20gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9jLCBzZWwsIGZyb20sIHRvIH07XG59XG5mdW5jdGlvbiBydWxlRnJvbU5vZGUoZG9tKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICBpZiAoZGVzYykge1xuICAgICAgICByZXR1cm4gZGVzYy5wYXJzZVJ1bGUoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiBkb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAvLyBTYWZhcmkgcmVwbGFjZXMgdGhlIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsIHdpdGggYSBCUlxuICAgICAgICAvLyBkaXJlY3RseSBpbiB0aGUgbGlzdCBub2RlICg/ISkgaWYgeW91IGRlbGV0ZSB0aGUgbGFzdFxuICAgICAgICAvLyBjaGFyYWN0ZXIgaW4gYSBsaXN0IGl0ZW0gb3IgdGFibGUgY2VsbCAoIzcwOCwgIzg2MilcbiAgICAgICAgaWYgKHNhZmFyaSAmJiAvXih1bHxvbCkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBza2lwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHNraXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHNraXAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb20ucGFyZW50Tm9kZS5sYXN0Q2hpbGQgPT0gZG9tIHx8IHNhZmFyaSAmJiAvXih0cnx0YWJsZSkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIklNR1wiICYmIGRvbS5nZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIpKSB7XG4gICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGlzSW5saW5lID0gL14oYXxhYmJyfGFjcm9ueW18YnxiZFtpb118YmlnfGJyfGJ1dHRvbnxjaXRlfGNvZGV8ZGF0YShsaXN0KT98ZGVsfGRmbnxlbXxpfGluc3xrYmR8bGFiZWx8bWFwfG1hcmt8bWV0ZXJ8b3V0cHV0fHF8cnVieXxzfHNhbXB8c21hbGx8c3BhbnxzdHJvbmd8c3VbYnBdfHRpbWV8dXx0dHx2YXIpJC9pO1xuZnVuY3Rpb24gcmVhZERPTUNoYW5nZSh2aWV3LCBmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkTm9kZXMpIHtcbiAgICBsZXQgY29tcG9zaXRpb25JRCA9IHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyB8fCAodmlldy5jb21wb3NpbmcgPyB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQgOiAwKTtcbiAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSAwO1xuICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICBsZXQgb3JpZ2luID0gdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uVGltZSA+IERhdGUubm93KCkgLSA1MCA/IHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvbk9yaWdpbiA6IG51bGw7XG4gICAgICAgIGxldCBuZXdTZWwgPSBzZWxlY3Rpb25Gcm9tRE9NKHZpZXcsIG9yaWdpbik7XG4gICAgICAgIGlmIChuZXdTZWwgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLmVxKG5ld1NlbCkpIHtcbiAgICAgICAgICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCAmJlxuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPT09IDEzICYmIERhdGUubm93KCkgLSAxMDAgPCB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlVGltZSAmJlxuICAgICAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ld1NlbCk7XG4gICAgICAgICAgICBpZiAob3JpZ2luID09IFwicG9pbnRlclwiKVxuICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAob3JpZ2luID09IFwia2V5XCIpXG4gICAgICAgICAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbklEKVxuICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0ICRiZWZvcmUgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgIGxldCBzaGFyZWQgPSAkYmVmb3JlLnNoYXJlZERlcHRoKHRvKTtcbiAgICBmcm9tID0gJGJlZm9yZS5iZWZvcmUoc2hhcmVkICsgMSk7XG4gICAgdG8gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHRvKS5hZnRlcihzaGFyZWQgKyAxKTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHBhcnNlID0gcGFyc2VCZXR3ZWVuKHZpZXcsIGZyb20sIHRvKTtcbiAgICBsZXQgZG9jID0gdmlldy5zdGF0ZS5kb2MsIGNvbXBhcmUgPSBkb2Muc2xpY2UocGFyc2UuZnJvbSwgcGFyc2UudG8pO1xuICAgIGxldCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGU7XG4gICAgLy8gUHJlZmVyIGFuY2hvcmluZyB0byBlbmQgd2hlbiBCYWNrc3BhY2UgaXMgcHJlc3NlZFxuICAgIGlmICh2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSA4ICYmIERhdGUubm93KCkgLSAxMDAgPCB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlVGltZSkge1xuICAgICAgICBwcmVmZXJyZWRQb3MgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwiZW5kXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcmVmZXJyZWRQb3MgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tO1xuICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJzdGFydFwiO1xuICAgIH1cbiAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID0gbnVsbDtcbiAgICBsZXQgY2hhbmdlID0gZmluZERpZmYoY29tcGFyZS5jb250ZW50LCBwYXJzZS5kb2MuY29udGVudCwgcGFyc2UuZnJvbSwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKTtcbiAgICBpZiAoY2hhbmdlKVxuICAgICAgICB2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50Kys7XG4gICAgaWYgKChpb3MgJiYgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPiBEYXRlLm5vdygpIC0gMjI1IHx8IGFuZHJvaWQpICYmXG4gICAgICAgIGFkZGVkTm9kZXMuc29tZShuID0+IG4ubm9kZVR5cGUgPT0gMSAmJiAhaXNJbmxpbmUudGVzdChuLm5vZGVOYW1lKSkgJiZcbiAgICAgICAgKCFjaGFuZ2UgfHwgY2hhbmdlLmVuZEEgPj0gY2hhbmdlLmVuZEIpICYmXG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpKSB7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZSkge1xuICAgICAgICBpZiAodHlwZU92ZXIgJiYgc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiAhc2VsLmVtcHR5ICYmIHNlbC4kaGVhZC5zYW1lUGFyZW50KHNlbC4kYW5jaG9yKSAmJlxuICAgICAgICAgICAgIXZpZXcuY29tcG9zaW5nICYmICEocGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgIT0gcGFyc2Uuc2VsLmhlYWQpKSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB7IHN0YXJ0OiBzZWwuZnJvbSwgZW5kQTogc2VsLnRvLCBlbmRCOiBzZWwudG8gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXJzZS5zZWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VsID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB2aWV3LnN0YXRlLmRvYywgcGFyc2Uuc2VsKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsICYmICFzZWwuZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb3NpdGlvbklEKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIG92ZXJ3cml0aW5nIGEgc2VsZWN0aW9uIGJ5IHR5cGluZyBtYXRjaGVzXG4gICAgLy8gdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgc2VsZWN0ZWQgY29udGVudCwgY3JlYXRpbmcgYSBjaGFuZ2VcbiAgICAvLyB0aGF0J3Mgc21hbGxlciB0aGFuIHdoYXQgd2FzIGFjdHVhbGx5IG92ZXJ3cml0dGVuLlxuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tIDwgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gJiZcbiAgICAgICAgY2hhbmdlLnN0YXJ0ID09IGNoYW5nZS5lbmRCICYmXG4gICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgICBpZiAoY2hhbmdlLnN0YXJ0ID4gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSAmJiBjaGFuZ2Uuc3RhcnQgPD0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSArIDIgJiZcbiAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gPj0gcGFyc2UuZnJvbSkge1xuICAgICAgICAgICAgY2hhbmdlLnN0YXJ0ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFuZ2UuZW5kQSA8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvICYmIGNoYW5nZS5lbmRBID49IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIC0gMiAmJlxuICAgICAgICAgICAgdmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gPD0gcGFyc2UudG8pIHtcbiAgICAgICAgICAgIGNoYW5nZS5lbmRCICs9ICh2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIGNoYW5nZS5lbmRBKTtcbiAgICAgICAgICAgIGNoYW5nZS5lbmRBID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSUUxMSB3aWxsIGluc2VydCBhIG5vbi1icmVha2luZyBzcGFjZSBfYWhlYWRfIG9mIHRoZSBzcGFjZSBhZnRlclxuICAgIC8vIHRoZSBjdXJzb3Igc3BhY2Ugd2hlbiBhZGRpbmcgYSBzcGFjZSBiZWZvcmUgYW5vdGhlciBzcGFjZS4gV2hlblxuICAgIC8vIHRoYXQgaGFwcGVuZWQsIGFkanVzdCB0aGUgY2hhbmdlIHRvIGNvdmVyIHRoZSBzcGFjZSBpbnN0ZWFkLlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmIGNoYW5nZS5lbmRCID09IGNoYW5nZS5zdGFydCArIDEgJiZcbiAgICAgICAgY2hhbmdlLmVuZEEgPT0gY2hhbmdlLnN0YXJ0ICYmIGNoYW5nZS5zdGFydCA+IHBhcnNlLmZyb20gJiZcbiAgICAgICAgcGFyc2UuZG9jLnRleHRCZXR3ZWVuKGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20gLSAxLCBjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tICsgMSkgPT0gXCIgXFx1MDBhMFwiKSB7XG4gICAgICAgIGNoYW5nZS5zdGFydC0tO1xuICAgICAgICBjaGFuZ2UuZW5kQS0tO1xuICAgICAgICBjaGFuZ2UuZW5kQi0tO1xuICAgIH1cbiAgICBsZXQgJGZyb20gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSk7XG4gICAgbGV0ICR0byA9IHBhcnNlLmRvYy5yZXNvbHZlTm9DYWNoZShjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pO1xuICAgIGxldCAkZnJvbUEgPSBkb2MucmVzb2x2ZShjaGFuZ2Uuc3RhcnQpO1xuICAgIGxldCBpbmxpbmVDaGFuZ2UgPSAkZnJvbS5zYW1lUGFyZW50KCR0bykgJiYgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgJiYgJGZyb21BLmVuZCgpID49IGNoYW5nZS5lbmRBO1xuICAgIGxldCBuZXh0U2VsO1xuICAgIC8vIElmIHRoaXMgbG9va3MgbGlrZSB0aGUgZWZmZWN0IG9mIHByZXNzaW5nIEVudGVyIChvciB3YXMgcmVjb3JkZWRcbiAgICAvLyBhcyBiZWluZyBhbiBpT1MgZW50ZXIgcHJlc3MpLCBqdXN0IGRpc3BhdGNoIGFuIEVudGVyIGtleSBpbnN0ZWFkLlxuICAgIGlmICgoKGlvcyAmJiB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA+IERhdGUubm93KCkgLSAyMjUgJiZcbiAgICAgICAgKCFpbmxpbmVDaGFuZ2UgfHwgYWRkZWROb2Rlcy5zb21lKG4gPT4gbi5ub2RlTmFtZSA9PSBcIkRJVlwiIHx8IG4ubm9kZU5hbWUgPT0gXCJQXCIpKSkgfHxcbiAgICAgICAgKCFpbmxpbmVDaGFuZ2UgJiYgJGZyb20ucG9zIDwgcGFyc2UuZG9jLmNvbnRlbnQuc2l6ZSAmJlxuICAgICAgICAgICAgKCEkZnJvbS5zYW1lUGFyZW50KCR0bykgfHwgISRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KSAmJlxuICAgICAgICAgICAgIS9cXFMvLnRlc3QocGFyc2UuZG9jLnRleHRCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgXCJcIiwgXCJcIikpICYmXG4gICAgICAgICAgICAobmV4dFNlbCA9IFNlbGVjdGlvbi5maW5kRnJvbShwYXJzZS5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSwgMSwgdHJ1ZSkpICYmXG4gICAgICAgICAgICBuZXh0U2VsLmhlYWQgPiAkZnJvbS5wb3MpKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU2FtZSBmb3IgYmFja3NwYWNlXG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciA+IGNoYW5nZS5zdGFydCAmJlxuICAgICAgICBsb29rc0xpa2VCYWNrc3BhY2UoZG9jLCBjaGFuZ2Uuc3RhcnQsIGNoYW5nZS5lbmRBLCAkZnJvbSwgJHRvKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoOCwgXCJCYWNrc3BhY2VcIikpKSkge1xuICAgICAgICBpZiAoYW5kcm9pZCAmJiBjaHJvbWUpXG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpOyAvLyAjODIwXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2hyb21lIHdpbGwgb2NjYXNpb25hbGx5LCBkdXJpbmcgY29tcG9zaXRpb24sIGRlbGV0ZSB0aGVcbiAgICAvLyBlbnRpcmUgY29tcG9zaXRpb24gYW5kIHRoZW4gaW1tZWRpYXRlbHkgaW5zZXJ0IGl0IGFnYWluLiBUaGlzIGlzXG4gICAgLy8gdXNlZCB0byBkZXRlY3QgdGhhdCBzaXR1YXRpb24uXG4gICAgaWYgKGNocm9tZSAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQpXG4gICAgICAgIHZpZXcuaW5wdXQubGFzdENocm9tZURlbGV0ZSA9IERhdGUubm93KCk7XG4gICAgLy8gVGhpcyB0cmllcyB0byBkZXRlY3QgQW5kcm9pZCB2aXJ0dWFsIGtleWJvYXJkXG4gICAgLy8gZW50ZXItYW5kLXBpY2stc3VnZ2VzdGlvbiBhY3Rpb24uIFRoYXQgc29tZXRpbWVzIChzZWUgaXNzdWVcbiAgICAvLyAjMTA1OSkgZmlyc3QgZmlyZXMgYSBET00gbXV0YXRpb24sIGJlZm9yZSBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB0b1xuICAgIC8vIHRoZSBuZXdseSBjcmVhdGVkIGJsb2NrLiBBbmQgdGhlbiwgYmVjYXVzZSBQcm9zZU1pcnJvciBjbGVhbnMgdXBcbiAgICAvLyB0aGUgRE9NIHNlbGVjdGlvbiwgaXQgZ2l2ZXMgdXAgbW92aW5nIHRoZSBzZWxlY3Rpb24gZW50aXJlbHksXG4gICAgLy8gbGVhdmluZyB0aGUgY3Vyc29yIGluIHRoZSB3cm9uZyBwbGFjZS4gV2hlbiB0aGF0IGhhcHBlbnMsIHdlIGRyb3BcbiAgICAvLyB0aGUgbmV3IHBhcmFncmFwaCBmcm9tIHRoZSBpbml0aWFsIGNoYW5nZSwgYW5kIGZpcmUgYSBzaW11bGF0ZWRcbiAgICAvLyBlbnRlciBrZXkgYWZ0ZXJ3YXJkcy5cbiAgICBpZiAoYW5kcm9pZCAmJiAhaW5saW5lQ2hhbmdlICYmICRmcm9tLnN0YXJ0KCkgIT0gJHRvLnN0YXJ0KCkgJiYgJHRvLnBhcmVudE9mZnNldCA9PSAwICYmICRmcm9tLmRlcHRoID09ICR0by5kZXB0aCAmJlxuICAgICAgICBwYXJzZS5zZWwgJiYgcGFyc2Uuc2VsLmFuY2hvciA9PSBwYXJzZS5zZWwuaGVhZCAmJiBwYXJzZS5zZWwuaGVhZCA9PSBjaGFuZ2UuZW5kQSkge1xuICAgICAgICBjaGFuZ2UuZW5kQiAtPSAyO1xuICAgICAgICAkdG8gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSk7IH0pO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxuICAgIGxldCBjaEZyb20gPSBjaGFuZ2Uuc3RhcnQsIGNoVG8gPSBjaGFuZ2UuZW5kQTtcbiAgICBsZXQgbWtUciA9IChiYXNlKSA9PiB7XG4gICAgICAgIGxldCB0ciA9IGJhc2UgfHwgdmlldy5zdGF0ZS50ci5yZXBsYWNlKGNoRnJvbSwgY2hUbywgcGFyc2UuZG9jLnNsaWNlKGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20sIGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSkpO1xuICAgICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgICAgICBsZXQgc2VsID0gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCB0ci5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMsIGR1cmluZyBjb21wb3NpdGlvbiwgcmVwb3J0IHRoZVxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIGluIHRoZSB3cm9uZyBwbGFjZS4gSWYgaXQgbG9va3MgbGlrZSB0aGF0IGlzXG4gICAgICAgICAgICAvLyBoYXBwZW5pbmcsIGRvbid0IHVwZGF0ZSB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgICAgLy8gRWRnZSBqdXN0IGRvZXNuJ3QgbW92ZSB0aGUgY3Vyc29yIGZvcndhcmQgd2hlbiB5b3Ugc3RhcnQgdHlwaW5nXG4gICAgICAgICAgICAvLyBpbiBhbiBlbXB0eSBibG9jayBvciBiZXR3ZWVuIGJyIG5vZGVzLlxuICAgICAgICAgICAgaWYgKHNlbCAmJiAhKGNocm9tZSAmJiB2aWV3LmNvbXBvc2luZyAmJiBzZWwuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAoY2hhbmdlLnN0YXJ0ICE9IGNoYW5nZS5lbmRCIHx8IHZpZXcuaW5wdXQubGFzdENocm9tZURlbGV0ZSA8IERhdGUubm93KCkgLSAxMDApICYmXG4gICAgICAgICAgICAgICAgKHNlbC5oZWFkID09IGNoRnJvbSB8fCBzZWwuaGVhZCA9PSB0ci5tYXBwaW5nLm1hcChjaFRvKSAtIDEpIHx8XG4gICAgICAgICAgICAgICAgaWUgJiYgc2VsLmVtcHR5ICYmIHNlbC5oZWFkID09IGNoRnJvbSkpXG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvc2l0aW9uSUQpXG4gICAgICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgY29tcG9zaXRpb25JRCk7XG4gICAgICAgIHJldHVybiB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgIH07XG4gICAgbGV0IG1hcmtDaGFuZ2U7XG4gICAgaWYgKGlubGluZUNoYW5nZSkge1xuICAgICAgICBpZiAoJGZyb20ucG9zID09ICR0by5wb3MpIHsgLy8gRGVsZXRpb25cbiAgICAgICAgICAgIC8vIElFMTEgc29tZXRpbWVzIHdlaXJkbHkgbW92ZXMgdGhlIERPTSBzZWxlY3Rpb24gYXJvdW5kIGFmdGVyXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBvdXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSB0ZXh0YmxvY2tcbiAgICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDw9IDExICYmICRmcm9tLnBhcmVudE9mZnNldCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNlbGVjdGlvblRvRE9NKHZpZXcpLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHIgPSBta1RyKHZpZXcuc3RhdGUudHIuZGVsZXRlKGNoRnJvbSwgY2hUbykpO1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KS5tYXJrc0Fjcm9zcyhkb2MucmVzb2x2ZShjaGFuZ2UuZW5kQSkpO1xuICAgICAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCAvLyBBZGRpbmcgb3IgcmVtb3ZpbmcgYSBtYXJrXG4gICAgICAgIGNoYW5nZS5lbmRBID09IGNoYW5nZS5lbmRCICYmXG4gICAgICAgICAgICAobWFya0NoYW5nZSA9IGlzTWFya0NoYW5nZSgkZnJvbS5wYXJlbnQuY29udGVudC5jdXQoJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KSwgJGZyb21BLnBhcmVudC5jb250ZW50LmN1dCgkZnJvbUEucGFyZW50T2Zmc2V0LCBjaGFuZ2UuZW5kQSAtICRmcm9tQS5zdGFydCgpKSkpKSB7XG4gICAgICAgICAgICBsZXQgdHIgPSBta1RyKHZpZXcuc3RhdGUudHIpO1xuICAgICAgICAgICAgaWYgKG1hcmtDaGFuZ2UudHlwZSA9PSBcImFkZFwiKVxuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoY2hGcm9tLCBjaFRvLCBtYXJrQ2hhbmdlLm1hcmspO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsoY2hGcm9tLCBjaFRvLCBtYXJrQ2hhbmdlLm1hcmspO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJGZyb20ucGFyZW50LmNoaWxkKCRmcm9tLmluZGV4KCkpLmlzVGV4dCAmJiAkZnJvbS5pbmRleCgpID09ICR0by5pbmRleCgpIC0gKCR0by50ZXh0T2Zmc2V0ID8gMCA6IDEpKSB7XG4gICAgICAgICAgICAvLyBCb3RoIHBvc2l0aW9ucyBpbiB0aGUgc2FtZSB0ZXh0IG5vZGUgLS0gc2ltcGx5IGluc2VydCB0ZXh0XG4gICAgICAgICAgICBsZXQgdGV4dCA9ICRmcm9tLnBhcmVudC50ZXh0QmV0d2VlbigkZnJvbS5wYXJlbnRPZmZzZXQsICR0by5wYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IGRlZmx0ID0gKCkgPT4gbWtUcih2aWV3LnN0YXRlLnRyLmluc2VydFRleHQodGV4dCwgY2hGcm9tLCBjaFRvKSk7XG4gICAgICAgICAgICBpZiAoIXZpZXcuc29tZVByb3AoXCJoYW5kbGVUZXh0SW5wdXRcIiwgZiA9PiBmKHZpZXcsIGNoRnJvbSwgY2hUbywgdGV4dCwgZGVmbHQpKSlcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKGRlZmx0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKG1rVHIoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZVNlbGVjdGlvbih2aWV3LCBkb2MsIHBhcnNlZFNlbCkge1xuICAgIGlmIChNYXRoLm1heChwYXJzZWRTZWwuYW5jaG9yLCBwYXJzZWRTZWwuaGVhZCkgPiBkb2MuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCBkb2MucmVzb2x2ZShwYXJzZWRTZWwuYW5jaG9yKSwgZG9jLnJlc29sdmUocGFyc2VkU2VsLmhlYWQpKTtcbn1cbi8vIEdpdmVuIHR3byBzYW1lLWxlbmd0aCwgbm9uLWVtcHR5IGZyYWdtZW50cyBvZiBpbmxpbmUgY29udGVudCxcbi8vIGRldGVybWluZSB3aGV0aGVyIHRoZSBmaXJzdCBjb3VsZCBiZSBjcmVhdGVkIGZyb20gdGhlIHNlY29uZCBieVxuLy8gcmVtb3Zpbmcgb3IgYWRkaW5nIGEgc2luZ2xlIG1hcmsgdHlwZS5cbmZ1bmN0aW9uIGlzTWFya0NoYW5nZShjdXIsIHByZXYpIHtcbiAgICBsZXQgY3VyTWFya3MgPSBjdXIuZmlyc3RDaGlsZC5tYXJrcywgcHJldk1hcmtzID0gcHJldi5maXJzdENoaWxkLm1hcmtzO1xuICAgIGxldCBhZGRlZCA9IGN1ck1hcmtzLCByZW1vdmVkID0gcHJldk1hcmtzLCB0eXBlLCBtYXJrLCB1cGRhdGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2TWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgIGFkZGVkID0gcHJldk1hcmtzW2ldLnJlbW92ZUZyb21TZXQoYWRkZWQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlbW92ZWQgPSBjdXJNYXJrc1tpXS5yZW1vdmVGcm9tU2V0KHJlbW92ZWQpO1xuICAgIGlmIChhZGRlZC5sZW5ndGggPT0gMSAmJiByZW1vdmVkLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIG1hcmsgPSBhZGRlZFswXTtcbiAgICAgICAgdHlwZSA9IFwiYWRkXCI7XG4gICAgICAgIHVwZGF0ZSA9IChub2RlKSA9PiBub2RlLm1hcmsobWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFkZGVkLmxlbmd0aCA9PSAwICYmIHJlbW92ZWQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgbWFyayA9IHJlbW92ZWRbMF07XG4gICAgICAgIHR5cGUgPSBcInJlbW92ZVwiO1xuICAgICAgICB1cGRhdGUgPSAobm9kZSkgPT4gbm9kZS5tYXJrKG1hcmsucmVtb3ZlRnJvbVNldChub2RlLm1hcmtzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHVwZGF0ZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXYuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICB1cGRhdGVkLnB1c2godXBkYXRlKHByZXYuY2hpbGQoaSkpKTtcbiAgICBpZiAoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKS5lcShjdXIpKVxuICAgICAgICByZXR1cm4geyBtYXJrLCB0eXBlIH07XG59XG5mdW5jdGlvbiBsb29rc0xpa2VCYWNrc3BhY2Uob2xkLCBzdGFydCwgZW5kLCAkbmV3U3RhcnQsICRuZXdFbmQpIHtcbiAgICBpZiAoIC8vIFRoZSBjb250ZW50IG11c3QgaGF2ZSBzaHJ1bmtcbiAgICBlbmQgLSBzdGFydCA8PSAkbmV3RW5kLnBvcyAtICRuZXdTdGFydC5wb3MgfHxcbiAgICAgICAgLy8gbmV3RW5kIG11c3QgcG9pbnQgZGlyZWN0bHkgYXQgb3IgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgYmxvY2sgdGhhdCBuZXdTdGFydCBwb2ludHMgaW50b1xuICAgICAgICBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJG5ld1N0YXJ0LCB0cnVlLCBmYWxzZSkgPCAkbmV3RW5kLnBvcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkc3RhcnQgPSBvbGQucmVzb2x2ZShzdGFydCk7XG4gICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlLCByYXRoZXIgdGhhbiBqb2luaW5nIGJsb2NrcywgdGhlIGNoYW5nZSBqdXN0IHJlbW92ZWQgYW4gZW50aXJlIGJsb2NrXG4gICAgaWYgKCEkbmV3U3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgICAgIGxldCBhZnRlciA9ICRzdGFydC5ub2RlQWZ0ZXI7XG4gICAgICAgIHJldHVybiBhZnRlciAhPSBudWxsICYmIGVuZCA9PSBzdGFydCArIGFmdGVyLm5vZGVTaXplO1xuICAgIH1cbiAgICAvLyBTdGFydCBtdXN0IGJlIGF0IHRoZSBlbmQgb2YgYSBibG9ja1xuICAgIGlmICgkc3RhcnQucGFyZW50T2Zmc2V0IDwgJHN0YXJ0LnBhcmVudC5jb250ZW50LnNpemUgfHwgISRzdGFydC5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJG5leHQgPSBvbGQucmVzb2x2ZShza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJHN0YXJ0LCB0cnVlLCB0cnVlKSk7XG4gICAgLy8gVGhlIG5leHQgdGV4dGJsb2NrIG11c3Qgc3RhcnQgYmVmb3JlIGVuZCBhbmQgZW5kIG5lYXIgaXRcbiAgICBpZiAoISRuZXh0LnBhcmVudC5pc1RleHRibG9jayB8fCAkbmV4dC5wb3MgPiBlbmQgfHxcbiAgICAgICAgc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRuZXh0LCB0cnVlLCBmYWxzZSkgPCBlbmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBUaGUgZnJhZ21lbnRzIGFmdGVyIHRoZSBqb2luIHBvaW50IG11c3QgbWF0Y2hcbiAgICByZXR1cm4gJG5ld1N0YXJ0LnBhcmVudC5jb250ZW50LmN1dCgkbmV3U3RhcnQucGFyZW50T2Zmc2V0KS5lcSgkbmV4dC5wYXJlbnQuY29udGVudCk7XG59XG5mdW5jdGlvbiBza2lwQ2xvc2luZ0FuZE9wZW5pbmcoJHBvcywgZnJvbUVuZCwgbWF5T3Blbikge1xuICAgIGxldCBkZXB0aCA9ICRwb3MuZGVwdGgsIGVuZCA9IGZyb21FbmQgPyAkcG9zLmVuZCgpIDogJHBvcy5wb3M7XG4gICAgd2hpbGUgKGRlcHRoID4gMCAmJiAoZnJvbUVuZCB8fCAkcG9zLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRwb3Mubm9kZShkZXB0aCkuY2hpbGRDb3VudCkpIHtcbiAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgZW5kKys7XG4gICAgICAgIGZyb21FbmQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG1heU9wZW4pIHtcbiAgICAgICAgbGV0IG5leHQgPSAkcG9zLm5vZGUoZGVwdGgpLm1heWJlQ2hpbGQoJHBvcy5pbmRleEFmdGVyKGRlcHRoKSk7XG4gICAgICAgIHdoaWxlIChuZXh0ICYmICFuZXh0LmlzTGVhZikge1xuICAgICAgICAgICAgbmV4dCA9IG5leHQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBmaW5kRGlmZihhLCBiLCBwb3MsIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSkge1xuICAgIGxldCBzdGFydCA9IGEuZmluZERpZmZTdGFydChiLCBwb3MpO1xuICAgIGlmIChzdGFydCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgeyBhOiBlbmRBLCBiOiBlbmRCIH0gPSBhLmZpbmREaWZmRW5kKGIsIHBvcyArIGEuc2l6ZSwgcG9zICsgYi5zaXplKTtcbiAgICBpZiAocHJlZmVycmVkU2lkZSA9PSBcImVuZFwiKSB7XG4gICAgICAgIGxldCBhZGp1c3QgPSBNYXRoLm1heCgwLCBzdGFydCAtIE1hdGgubWluKGVuZEEsIGVuZEIpKTtcbiAgICAgICAgcHJlZmVycmVkUG9zIC09IGVuZEEgKyBhZGp1c3QgLSBzdGFydDtcbiAgICB9XG4gICAgaWYgKGVuZEEgPCBzdGFydCAmJiBhLnNpemUgPCBiLnNpemUpIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gc3RhcnQgJiYgcHJlZmVycmVkUG9zID49IGVuZEEgPyBzdGFydCAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIHN0YXJ0IC09IG1vdmU7XG4gICAgICAgIGlmIChzdGFydCAmJiBzdGFydCA8IGIuc2l6ZSAmJiBpc1N1cnJvZ2F0ZVBhaXIoYi50ZXh0QmV0d2VlbihzdGFydCAtIDEsIHN0YXJ0ICsgMSkpKVxuICAgICAgICAgICAgc3RhcnQgKz0gbW92ZSA/IDEgOiAtMTtcbiAgICAgICAgZW5kQiA9IHN0YXJ0ICsgKGVuZEIgLSBlbmRBKTtcbiAgICAgICAgZW5kQSA9IHN0YXJ0O1xuICAgIH1cbiAgICBlbHNlIGlmIChlbmRCIDwgc3RhcnQpIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gc3RhcnQgJiYgcHJlZmVycmVkUG9zID49IGVuZEIgPyBzdGFydCAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIHN0YXJ0IC09IG1vdmU7XG4gICAgICAgIGlmIChzdGFydCAmJiBzdGFydCA8IGEuc2l6ZSAmJiBpc1N1cnJvZ2F0ZVBhaXIoYS50ZXh0QmV0d2VlbihzdGFydCAtIDEsIHN0YXJ0ICsgMSkpKVxuICAgICAgICAgICAgc3RhcnQgKz0gbW92ZSA/IDEgOiAtMTtcbiAgICAgICAgZW5kQSA9IHN0YXJ0ICsgKGVuZEEgLSBlbmRCKTtcbiAgICAgICAgZW5kQiA9IHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kQSwgZW5kQiB9O1xufVxuZnVuY3Rpb24gaXNTdXJyb2dhdGVQYWlyKHN0cikge1xuICAgIGlmIChzdHIubGVuZ3RoICE9IDIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYSA9IHN0ci5jaGFyQ29kZUF0KDApLCBiID0gc3RyLmNoYXJDb2RlQXQoMSk7XG4gICAgcmV0dXJuIGEgPj0gMHhEQzAwICYmIGEgPD0gMHhERkZGICYmIGIgPj0gMHhEODAwICYmIGIgPD0gMHhEQkZGO1xufVxuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmNvbnN0IF9fcGFyc2VGcm9tQ2xpcGJvYXJkID0gcGFyc2VGcm9tQ2xpcGJvYXJkO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX2VuZENvbXBvc2l0aW9uID0gZW5kQ29tcG9zaXRpb247XG4vKipcbkFuIGVkaXRvciB2aWV3IG1hbmFnZXMgdGhlIERPTSBzdHJ1Y3R1cmUgdGhhdCByZXByZXNlbnRzIGFuXG5lZGl0YWJsZSBkb2N1bWVudC4gSXRzIHN0YXRlIGFuZCBiZWhhdmlvciBhcmUgZGV0ZXJtaW5lZCBieSBpdHNcbltwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGlyZWN0RWRpdG9yUHJvcHMpLlxuKi9cbmNsYXNzIEVkaXRvclZpZXcge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHZpZXcuIGBwbGFjZWAgbWF5IGJlIGEgRE9NIG5vZGUgdGhhdCB0aGUgZWRpdG9yIHNob3VsZFxuICAgIGJlIGFwcGVuZGVkIHRvLCBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBwbGFjZSBpdCBpbnRvIHRoZSBkb2N1bWVudCxcbiAgICBvciBhbiBvYmplY3Qgd2hvc2UgYG1vdW50YCBwcm9wZXJ0eSBob2xkcyB0aGUgbm9kZSB0byB1c2UgYXMgdGhlXG4gICAgZG9jdW1lbnQgY29udGFpbmVyLiBJZiBpdCBpcyBgbnVsbGAsIHRoZSBlZGl0b3Igd2lsbCBub3QgYmVcbiAgICBhZGRlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwbGFjZSwgcHJvcHMpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBLbHVkZ2UgdXNlZCB0byB3b3JrIGFyb3VuZCBhIENocm9tZSBidWcgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudHJhY2tXcml0ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtDdXJzb3IgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY3Vyc29yV3JhcHBlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0ZWRWaWV3RGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmlucHV0ID0gbmV3IElucHV0U3RhdGU7XG4gICAgICAgIHRoaXMucHJldkRpcmVjdFBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5wbHVnaW5WaWV3cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgSG9sZHMgYHRydWVgIHdoZW4gYSBoYWNrIG5vZGUgaXMgbmVlZGVkIGluIEZpcmVmb3ggdG8gcHJldmVudCB0aGVcbiAgICAgICAgW3NwYWNlIGlzIGVhdGVuIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3IvaXNzdWVzLzY1MSlcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucmVxdWlyZXNHZWNrb0hhY2tOb2RlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBXaGVuIGVkaXRvciBjb250ZW50IGlzIGJlaW5nIGRyYWdnZWQsIHRoaXMgb2JqZWN0IGNvbnRhaW5zXG4gICAgICAgIGluZm9ybWF0aW9uIGFib3V0IHRoZSBkcmFnZ2VkIHNsaWNlIGFuZCB3aGV0aGVyIGl0IGlzIGJlaW5nXG4gICAgICAgIGNvcGllZCBvciBtb3ZlZC4gQXQgYW55IG90aGVyIHRpbWUsIGl0IGlzIG51bGwuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLnN0YXRlID0gcHJvcHMuc3RhdGU7XG4gICAgICAgIHRoaXMuZGlyZWN0UGx1Z2lucyA9IHByb3BzLnBsdWdpbnMgfHwgW107XG4gICAgICAgIHRoaXMuZGlyZWN0UGx1Z2lucy5mb3JFYWNoKGNoZWNrU3RhdGVDb21wb25lbnQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRvbSA9IChwbGFjZSAmJiBwbGFjZS5tb3VudCkgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaWYgKHBsYWNlKSB7XG4gICAgICAgICAgICBpZiAocGxhY2UuYXBwZW5kQ2hpbGQpXG4gICAgICAgICAgICAgICAgcGxhY2UuYXBwZW5kQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBsYWNlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBwbGFjZSh0aGlzLmRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChwbGFjZS5tb3VudClcbiAgICAgICAgICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBnZXRFZGl0YWJsZSh0aGlzKTtcbiAgICAgICAgdXBkYXRlQ3Vyc29yV3JhcHBlcih0aGlzKTtcbiAgICAgICAgdGhpcy5ub2RlVmlld3MgPSBidWlsZE5vZGVWaWV3cyh0aGlzKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gZG9jVmlld0Rlc2ModGhpcy5zdGF0ZS5kb2MsIGNvbXB1dGVEb2NEZWNvKHRoaXMpLCB2aWV3RGVjb3JhdGlvbnModGhpcyksIHRoaXMuZG9tLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlciA9IG5ldyBET01PYnNlcnZlcih0aGlzLCAoZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCkgPT4gcmVhZERPTUNoYW5nZSh0aGlzLCBmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKSk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgaW5pdElucHV0KHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpblZpZXdzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEhvbGRzIGB0cnVlYCB3aGVuIGFcbiAgICBbY29tcG9zaXRpb25dKGh0dHBzOi8vdzNjLmdpdGh1Yi5pby91aWV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzKVxuICAgIGlzIGFjdGl2ZS5cbiAgICAqL1xuICAgIGdldCBjb21wb3NpbmcoKSB7IHJldHVybiB0aGlzLmlucHV0LmNvbXBvc2luZzsgfVxuICAgIC8qKlxuICAgIFRoZSB2aWV3J3MgY3VycmVudCBbcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzKS5cbiAgICAqL1xuICAgIGdldCBwcm9wcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb3BzLnN0YXRlICE9IHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gdGhpcy5fcHJvcHM7XG4gICAgICAgICAgICB0aGlzLl9wcm9wcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcmV2KVxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzW25hbWVdID0gcHJldltuYW1lXTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzLnN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHM7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldydzIHByb3BzLiBXaWxsIGltbWVkaWF0ZWx5IGNhdXNlIGFuIHVwZGF0ZSB0b1xuICAgIHRoZSBET00uXG4gICAgKi9cbiAgICB1cGRhdGUocHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzLmhhbmRsZURPTUV2ZW50cyAhPSB0aGlzLl9wcm9wcy5oYW5kbGVET01FdmVudHMpXG4gICAgICAgICAgICBlbnN1cmVMaXN0ZW5lcnModGhpcyk7XG4gICAgICAgIGxldCBwcmV2UHJvcHMgPSB0aGlzLl9wcm9wcztcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBwcm9wcztcbiAgICAgICAgaWYgKHByb3BzLnBsdWdpbnMpIHtcbiAgICAgICAgICAgIHByb3BzLnBsdWdpbnMuZm9yRWFjaChjaGVja1N0YXRlQ29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0UGx1Z2lucyA9IHByb3BzLnBsdWdpbnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHByb3BzLnN0YXRlLCBwcmV2UHJvcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcgYnkgdXBkYXRpbmcgZXhpc3RpbmcgcHJvcHMgb2JqZWN0IHdpdGggdGhlIG9iamVjdFxuICAgIGdpdmVuIGFzIGFyZ3VtZW50LiBFcXVpdmFsZW50IHRvIGB2aWV3LnVwZGF0ZShPYmplY3QuYXNzaWduKHt9LFxuICAgIHZpZXcucHJvcHMsIHByb3BzKSlgLlxuICAgICovXG4gICAgc2V0UHJvcHMocHJvcHMpIHtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLl9wcm9wcylcbiAgICAgICAgICAgIHVwZGF0ZWRbbmFtZV0gPSB0aGlzLl9wcm9wc1tuYW1lXTtcbiAgICAgICAgdXBkYXRlZC5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJvcHMpXG4gICAgICAgICAgICB1cGRhdGVkW25hbWVdID0gcHJvcHNbbmFtZV07XG4gICAgICAgIHRoaXMudXBkYXRlKHVwZGF0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIGVkaXRvcidzIGBzdGF0ZWAgcHJvcCwgd2l0aG91dCB0b3VjaGluZyBhbnkgb2YgdGhlXG4gICAgb3RoZXIgcHJvcHMuXG4gICAgKi9cbiAgICB1cGRhdGVTdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHRoaXMuX3Byb3BzKTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGVJbm5lcihzdGF0ZSwgcHJldlByb3BzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHByZXYgPSB0aGlzLnN0YXRlLCByZWRyYXcgPSBmYWxzZSwgdXBkYXRlU2VsID0gZmFsc2U7XG4gICAgICAgIC8vIFdoZW4gc3RvcmVkIG1hcmtzIGFyZSBhZGRlZCwgc3RvcCBjb21wb3NpdGlvbiwgc28gdGhhdCB0aGV5IGNhblxuICAgICAgICAvLyBiZSBkaXNwbGF5ZWQuXG4gICAgICAgIGlmIChzdGF0ZS5zdG9yZWRNYXJrcyAmJiB0aGlzLmNvbXBvc2luZykge1xuICAgICAgICAgICAgY2xlYXJDb21wb3NpdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZVNlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBsZXQgcGx1Z2luc0NoYW5nZWQgPSBwcmV2LnBsdWdpbnMgIT0gc3RhdGUucGx1Z2lucyB8fCB0aGlzLl9wcm9wcy5wbHVnaW5zICE9IHByZXZQcm9wcy5wbHVnaW5zO1xuICAgICAgICBpZiAocGx1Z2luc0NoYW5nZWQgfHwgdGhpcy5fcHJvcHMucGx1Z2lucyAhPSBwcmV2UHJvcHMucGx1Z2lucyB8fCB0aGlzLl9wcm9wcy5ub2RlVmlld3MgIT0gcHJldlByb3BzLm5vZGVWaWV3cykge1xuICAgICAgICAgICAgbGV0IG5vZGVWaWV3cyA9IGJ1aWxkTm9kZVZpZXdzKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWROb2RlVmlld3Mobm9kZVZpZXdzLCB0aGlzLm5vZGVWaWV3cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVWaWV3cyA9IG5vZGVWaWV3cztcbiAgICAgICAgICAgICAgICByZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbHVnaW5zQ2hhbmdlZCB8fCBwcmV2UHJvcHMuaGFuZGxlRE9NRXZlbnRzICE9IHRoaXMuX3Byb3BzLmhhbmRsZURPTUV2ZW50cykge1xuICAgICAgICAgICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBnZXRFZGl0YWJsZSh0aGlzKTtcbiAgICAgICAgdXBkYXRlQ3Vyc29yV3JhcHBlcih0aGlzKTtcbiAgICAgICAgbGV0IGlubmVyRGVjbyA9IHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgb3V0ZXJEZWNvID0gY29tcHV0ZURvY0RlY28odGhpcyk7XG4gICAgICAgIGxldCBzY3JvbGwgPSBwcmV2LnBsdWdpbnMgIT0gc3RhdGUucGx1Z2lucyAmJiAhcHJldi5kb2MuZXEoc3RhdGUuZG9jKSA/IFwicmVzZXRcIlxuICAgICAgICAgICAgOiBzdGF0ZS5zY3JvbGxUb1NlbGVjdGlvbiA+IHByZXYuc2Nyb2xsVG9TZWxlY3Rpb24gPyBcInRvIHNlbGVjdGlvblwiIDogXCJwcmVzZXJ2ZVwiO1xuICAgICAgICBsZXQgdXBkYXRlRG9jID0gcmVkcmF3IHx8ICF0aGlzLmRvY1ZpZXcubWF0Y2hlc05vZGUoc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbyk7XG4gICAgICAgIGlmICh1cGRhdGVEb2MgfHwgIXN0YXRlLnNlbGVjdGlvbi5lcShwcmV2LnNlbGVjdGlvbikpXG4gICAgICAgICAgICB1cGRhdGVTZWwgPSB0cnVlO1xuICAgICAgICBsZXQgb2xkU2Nyb2xsUG9zID0gc2Nyb2xsID09IFwicHJlc2VydmVcIiAmJiB1cGRhdGVTZWwgJiYgdGhpcy5kb20uc3R5bGUub3ZlcmZsb3dBbmNob3IgPT0gbnVsbCAmJiBzdG9yZVNjcm9sbFBvcyh0aGlzKTtcbiAgICAgICAgaWYgKHVwZGF0ZVNlbCkge1xuICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBhbiBpc3N1ZSBpbiBDaHJvbWUsIElFLCBhbmQgRWRnZSB3aGVyZSBjaGFuZ2luZ1xuICAgICAgICAgICAgLy8gdGhlIERPTSBhcm91bmQgYW4gYWN0aXZlIHNlbGVjdGlvbiBwdXRzIGl0IGludG8gYSBicm9rZW5cbiAgICAgICAgICAgIC8vIHN0YXRlIHdoZXJlIHRoZSB0aGluZyB0aGUgdXNlciBzZWVzIGRpZmZlcnMgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiByZXBvcnRlZCBieSB0aGUgU2VsZWN0aW9uIG9iamVjdCAoIzcxMCwgIzk3MyxcbiAgICAgICAgICAgIC8vICMxMDExLCAjMTAxMywgIzEwMzUpLlxuICAgICAgICAgICAgbGV0IGZvcmNlU2VsVXBkYXRlID0gdXBkYXRlRG9jICYmIChpZSB8fCBjaHJvbWUpICYmICF0aGlzLmNvbXBvc2luZyAmJlxuICAgICAgICAgICAgICAgICFwcmV2LnNlbGVjdGlvbi5lbXB0eSAmJiAhc3RhdGUuc2VsZWN0aW9uLmVtcHR5ICYmIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHByZXYuc2VsZWN0aW9uLCBzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZURvYykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBub2RlIHRoYXQgdGhlIHNlbGVjdGlvbiBwb2ludHMgaW50byBpcyB3cml0dGVuIHRvLFxuICAgICAgICAgICAgICAgIC8vIENocm9tZSBzb21ldGltZXMgc3RhcnRzIG1pc3JlcG9ydGluZyB0aGUgc2VsZWN0aW9uLCBzbyB0aGlzXG4gICAgICAgICAgICAgICAgLy8gdHJhY2tzIHRoYXQgYW5kIGZvcmNlcyBhIHNlbGVjdGlvbiByZXNldCB3aGVuIG91ciB1cGRhdGVcbiAgICAgICAgICAgICAgICAvLyBkaWQgd3JpdGUgdG8gdGhlIG5vZGUuXG4gICAgICAgICAgICAgICAgbGV0IGNocm9tZUtsdWRnZSA9IGNocm9tZSA/ICh0aGlzLnRyYWNrV3JpdGVzID0gdGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpLmZvY3VzTm9kZSkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2luZylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5jb21wb3NpdGlvbk5vZGUgPSBmaW5kQ29tcG9zaXRpb25Ob2RlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZWRyYXcgfHwgIXRoaXMuZG9jVmlldy51cGRhdGUoc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcgPSBkb2NWaWV3RGVzYyhzdGF0ZS5kb2MsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaHJvbWVLbHVkZ2UgJiYgIXRoaXMudHJhY2tXcml0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlU2VsVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGZvciBhbiBpc3N1ZSB3aGVyZSBhbiB1cGRhdGUgYXJyaXZpbmcgcmlnaHQgYmV0d2VlblxuICAgICAgICAgICAgLy8gYSBET00gc2VsZWN0aW9uIGNoYW5nZSBhbmQgdGhlIFwic2VsZWN0aW9uY2hhbmdlXCIgZXZlbnQgZm9yIGl0XG4gICAgICAgICAgICAvLyBjYW4gY2F1c2UgYSBzcHVyaW91cyBET00gc2VsZWN0aW9uIHVwZGF0ZSwgZGlzcnVwdGluZyBtb3VzZVxuICAgICAgICAgICAgLy8gZHJhZyBzZWxlY3Rpb24uXG4gICAgICAgICAgICBpZiAoZm9yY2VTZWxVcGRhdGUgfHxcbiAgICAgICAgICAgICAgICAhKHRoaXMuaW5wdXQubW91c2VEb3duICYmIHRoaXMuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvckluUmlnaHRQbGFjZSh0aGlzKSkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh0aGlzLCBmb3JjZVNlbFVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzeW5jTm9kZVNlbGVjdGlvbih0aGlzLCBzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cyhwcmV2KTtcbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmRyYWdnaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZSkgJiYgIXByZXYuZG9jLmVxKHN0YXRlLmRvYykpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURyYWdnZWROb2RlKHRoaXMuZHJhZ2dpbmcsIHByZXYpO1xuICAgICAgICBpZiAoc2Nyb2xsID09IFwicmVzZXRcIikge1xuICAgICAgICAgICAgdGhpcy5kb20uc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY3JvbGwgPT0gXCJ0byBzZWxlY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1NlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZFNjcm9sbFBvcykge1xuICAgICAgICAgICAgcmVzZXRTY3JvbGxQb3Mob2xkU2Nyb2xsUG9zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjcm9sbFRvU2VsZWN0aW9uKCkge1xuICAgICAgICBsZXQgc3RhcnRET00gPSB0aGlzLmRvbVNlbGVjdGlvblJhbmdlKCkuZm9jdXNOb2RlO1xuICAgICAgICBpZiAoIXN0YXJ0RE9NIHx8ICF0aGlzLmRvbS5jb250YWlucyhzdGFydERPTS5ub2RlVHlwZSA9PSAxID8gc3RhcnRET00gOiBzdGFydERPTS5wYXJlbnROb2RlKSkgO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnNvbWVQcm9wKFwiaGFuZGxlU2Nyb2xsVG9TZWxlY3Rpb25cIiwgZiA9PiBmKHRoaXMpKSkgO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmRvY1ZpZXcuZG9tQWZ0ZXJQb3ModGhpcy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgc3RhcnRET00pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsUmVjdEludG9WaWV3KHRoaXMsIHRoaXMuY29vcmRzQXRQb3ModGhpcy5zdGF0ZS5zZWxlY3Rpb24uaGVhZCwgMSksIHN0YXJ0RE9NKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95UGx1Z2luVmlld3MoKSB7XG4gICAgICAgIGxldCB2aWV3O1xuICAgICAgICB3aGlsZSAodmlldyA9IHRoaXMucGx1Z2luVmlld3MucG9wKCkpXG4gICAgICAgICAgICBpZiAodmlldy5kZXN0cm95KVxuICAgICAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgIH1cbiAgICB1cGRhdGVQbHVnaW5WaWV3cyhwcmV2U3RhdGUpIHtcbiAgICAgICAgaWYgKCFwcmV2U3RhdGUgfHwgcHJldlN0YXRlLnBsdWdpbnMgIT0gdGhpcy5zdGF0ZS5wbHVnaW5zIHx8IHRoaXMuZGlyZWN0UGx1Z2lucyAhPSB0aGlzLnByZXZEaXJlY3RQbHVnaW5zKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gdGhpcy5kaXJlY3RQbHVnaW5zO1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5zdGF0ZS5wbHVnaW5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uc3BlYy52aWV3KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpblZpZXdzLnB1c2gocGx1Z2luLnNwZWMudmlldyh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luVmlld3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGx1Z2luVmlldyA9IHRoaXMucGx1Z2luVmlld3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpblZpZXcudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5WaWV3LnVwZGF0ZSh0aGlzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZURyYWdnZWROb2RlKGRyYWdnaW5nLCBwcmV2KSB7XG4gICAgICAgIGxldCBzZWwgPSBkcmFnZ2luZy5ub2RlLCBmb3VuZCA9IC0xO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kb2Mubm9kZUF0KHNlbC5mcm9tKSA9PSBzZWwubm9kZSkge1xuICAgICAgICAgICAgZm91bmQgPSBzZWwuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtb3ZlZFBvcyA9IHNlbC5mcm9tICsgKHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSAtIHByZXYuZG9jLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgICAgICBsZXQgbW92ZWQgPSBtb3ZlZFBvcyA+IDAgJiYgdGhpcy5zdGF0ZS5kb2Mubm9kZUF0KG1vdmVkUG9zKTtcbiAgICAgICAgICAgIGlmIChtb3ZlZCA9PSBzZWwubm9kZSlcbiAgICAgICAgICAgICAgICBmb3VuZCA9IG1vdmVkUG9zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBuZXcgRHJhZ2dpbmcoZHJhZ2dpbmcuc2xpY2UsIGRyYWdnaW5nLm1vdmUsIGZvdW5kIDwgMCA/IHVuZGVmaW5lZCA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRoaXMuc3RhdGUuZG9jLCBmb3VuZCkpO1xuICAgIH1cbiAgICBzb21lUHJvcChwcm9wTmFtZSwgZikge1xuICAgICAgICBsZXQgcHJvcCA9IHRoaXMuX3Byb3BzICYmIHRoaXMuX3Byb3BzW3Byb3BOYW1lXSwgdmFsdWU7XG4gICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRpcmVjdFBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gdGhpcy5kaXJlY3RQbHVnaW5zW2ldLnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIGlmIChwcm9wICE9IG51bGwgJiYgKHZhbHVlID0gZiA/IGYocHJvcCkgOiBwcm9wKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBsdWdpbnMgPSB0aGlzLnN0YXRlLnBsdWdpbnM7XG4gICAgICAgIGlmIChwbHVnaW5zKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwbHVnaW5zW2ldLnByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGUgdmlldyBoYXMgZm9jdXMuXG4gICAgKi9cbiAgICBoYXNGb2N1cygpIHtcbiAgICAgICAgLy8gV29yayBhcm91bmQgSUUgbm90IGhhbmRsaW5nIGZvY3VzIGNvcnJlY3RseSBpZiByZXNpemUgaGFuZGxlcyBhcmUgc2hvd24uXG4gICAgICAgIC8vIElmIHRoZSBjdXJzb3IgaXMgaW5zaWRlIGFuIGVsZW1lbnQgd2l0aCByZXNpemUgaGFuZGxlcywgYWN0aXZlRWxlbWVudFxuICAgICAgICAvLyB3aWxsIGJlIHRoYXQgZWxlbWVudCBpbnN0ZWFkIG9mIHRoaXMuZG9tLlxuICAgICAgICBpZiAoaWUpIHtcbiAgICAgICAgICAgIC8vIElmIGFjdGl2ZUVsZW1lbnQgaXMgd2l0aGluIHRoaXMuZG9tLCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBzZXR0aW5nIGBjb250ZW50ZWRpdGFibGVgIHRvIGZhbHNlIGluIGJldHdlZW4sIHRyZWF0IGl0IGFzIGZvY3VzZWQuXG4gICAgICAgICAgICBsZXQgbm9kZSA9IHRoaXMucm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKG5vZGUgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoIW5vZGUgfHwgIXRoaXMuZG9tLmNvbnRhaW5zKG5vZGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICYmIHRoaXMuZG9tICE9IG5vZGUgJiYgdGhpcy5kb20uY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gJ2ZhbHNlJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb207XG4gICAgfVxuICAgIC8qKlxuICAgIEZvY3VzIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmxlKVxuICAgICAgICAgICAgZm9jdXNQcmV2ZW50U2Nyb2xsKHRoaXMuZG9tKTtcbiAgICAgICAgc2VsZWN0aW9uVG9ET00odGhpcyk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBkb2N1bWVudCByb290IGluIHdoaWNoIHRoZSBlZGl0b3IgZXhpc3RzLiBUaGlzIHdpbGxcbiAgICB1c3VhbGx5IGJlIHRoZSB0b3AtbGV2ZWwgYGRvY3VtZW50YCwgYnV0IG1pZ2h0IGJlIGEgW3NoYWRvd1xuICAgIERPTV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvV2ViX0NvbXBvbmVudHMvU2hhZG93X0RPTSlcbiAgICByb290IGlmIHRoZSBlZGl0b3IgaXMgaW5zaWRlIG9uZS5cbiAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICBsZXQgY2FjaGVkID0gdGhpcy5fcm9vdDtcbiAgICAgICAgaWYgKGNhY2hlZCA9PSBudWxsKVxuICAgICAgICAgICAgZm9yIChsZXQgc2VhcmNoID0gdGhpcy5kb20ucGFyZW50Tm9kZTsgc2VhcmNoOyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubm9kZVR5cGUgPT0gOSB8fCAoc2VhcmNoLm5vZGVUeXBlID09IDExICYmIHNlYXJjaC5ob3N0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlYXJjaC5nZXRTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VhcmNoKS5nZXRTZWxlY3Rpb24gPSAoKSA9PiBzZWFyY2gub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QgPSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkIHx8IGRvY3VtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIGFuIGV4aXN0aW5nIGVkaXRvciB2aWV3IGlzIG1vdmVkIHRvIGEgbmV3IGRvY3VtZW50IG9yXG4gICAgc2hhZG93IHRyZWUsIGNhbGwgdGhpcyB0byBtYWtlIGl0IHJlY29tcHV0ZSBpdHMgcm9vdC5cbiAgICAqL1xuICAgIHVwZGF0ZVJvb3QoKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBHaXZlbiBhIHBhaXIgb2Ygdmlld3BvcnQgY29vcmRpbmF0ZXMsIHJldHVybiB0aGUgZG9jdW1lbnRcbiAgICBwb3NpdGlvbiB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZW0uIE1heSByZXR1cm4gbnVsbCBpZiB0aGUgZ2l2ZW5cbiAgICBjb29yZGluYXRlcyBhcmVuJ3QgaW5zaWRlIG9mIHRoZSBlZGl0b3IuIFdoZW4gYW4gb2JqZWN0IGlzXG4gICAgcmV0dXJuZWQsIGl0cyBgcG9zYCBwcm9wZXJ0eSBpcyB0aGUgcG9zaXRpb24gbmVhcmVzdCB0byB0aGVcbiAgICBjb29yZGluYXRlcywgYW5kIGl0cyBgaW5zaWRlYCBwcm9wZXJ0eSBob2xkcyB0aGUgcG9zaXRpb24gb2YgdGhlXG4gICAgaW5uZXIgbm9kZSB0aGF0IHRoZSBwb3NpdGlvbiBmYWxscyBpbnNpZGUgb2YsIG9yIC0xIGlmIGl0IGlzIGF0XG4gICAgdGhlIHRvcCBsZXZlbCwgbm90IGluIGFueSBub2RlLlxuICAgICovXG4gICAgcG9zQXRDb29yZHMoY29vcmRzKSB7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSB2aWV3cG9ydCByZWN0YW5nbGUgYXQgYSBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBgbGVmdGAgYW5kIGByaWdodGAgd2lsbCBiZSB0aGUgc2FtZSBudW1iZXIsIGFzIHRoaXMgcmV0dXJucyBhXG4gICAgZmxhdCBjdXJzb3ItaXNoIHJlY3RhbmdsZS4gSWYgdGhlIHBvc2l0aW9uIGlzIGJldHdlZW4gdHdvIHRoaW5nc1xuICAgIHRoYXQgYXJlbid0IGRpcmVjdGx5IGFkamFjZW50LCBgc2lkZWAgZGV0ZXJtaW5lcyB3aGljaCBlbGVtZW50XG4gICAgaXMgdXNlZC4gV2hlbiA8IDAsIHRoZSBlbGVtZW50IGJlZm9yZSB0aGUgcG9zaXRpb24gaXMgdXNlZCxcbiAgICBvdGhlcndpc2UgdGhlIGVsZW1lbnQgYWZ0ZXIuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNBdFBvcyh0aGlzLCBwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICBwb3NpdGlvbi4gV2hlbiBgc2lkZWAgaXMgbmVnYXRpdmUsIGZpbmQgdGhlIHBvc2l0aW9uIGFzIGNsb3NlIGFzXG4gICAgcG9zc2libGUgdG8gdGhlIGNvbnRlbnQgYmVmb3JlIHRoZSBwb3NpdGlvbi4gV2hlbiBwb3NpdGl2ZSxcbiAgICBwcmVmZXIgcG9zaXRpb25zIGNsb3NlIHRvIHRoZSBjb250ZW50IGFmdGVyIHRoZSBwb3NpdGlvbi4gV2hlblxuICAgIHplcm8sIHByZWZlciBhcyBzaGFsbG93IGEgcG9zaXRpb24gYXMgcG9zc2libGUuXG4gICAgXG4gICAgTm90ZSB0aGF0IHlvdSBzaG91bGQgKipub3QqKiBtdXRhdGUgdGhlIGVkaXRvcidzIGludGVybmFsIERPTSxcbiAgICBvbmx5IGluc3BlY3QgaXQgKGFuZCBldmVuIHRoYXQgaXMgdXN1YWxseSBub3QgbmVjZXNzYXJ5KS5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBub2RlIHRoYXQgcmVwcmVzZW50cyB0aGUgZG9jdW1lbnQgbm9kZSBhZnRlciB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbi4gTWF5IHJldHVybiBgbnVsbGAgd2hlbiB0aGUgcG9zaXRpb24gZG9lc24ndCBwb2ludFxuICAgIGluIGZyb250IG9mIGEgbm9kZSBvciBpZiB0aGUgbm9kZSBpcyBpbnNpZGUgYW4gb3BhcXVlIG5vZGUgdmlldy5cbiAgICBcbiAgICBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGFibGUgdG8gY2FsbCB0aGluZ3MgbGlrZVxuICAgIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG9uIHRoYXQgRE9NIG5vZGUuIERvICoqbm90KiogbXV0YXRlIHRoZVxuICAgIGVkaXRvciBET00gZGlyZWN0bHksIG9yIGFkZCBzdHlsaW5nIHRoaXMgd2F5LCBzaW5jZSB0aGF0IHdpbGwgYmVcbiAgICBpbW1lZGlhdGVseSBvdmVycmlkZW4gYnkgdGhlIGVkaXRvciBhcyBpdCByZWRyYXdzIHRoZSBub2RlLlxuICAgICovXG4gICAgbm9kZURPTShwb3MpIHtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLmRvY1ZpZXcuZGVzY0F0KHBvcyk7XG4gICAgICAgIHJldHVybiBkZXNjID8gZGVzYy5ub2RlRE9NIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZG9jdW1lbnQgcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byBhIGdpdmVuIERPTVxuICAgIHBvc2l0aW9uLiAoV2hlbmV2ZXIgcG9zc2libGUsIGl0IGlzIHByZWZlcmFibGUgdG8gaW5zcGVjdCB0aGVcbiAgICBkb2N1bWVudCBzdHJ1Y3R1cmUgZGlyZWN0bHksIHJhdGhlciB0aGFuIHBva2luZyBhcm91bmQgaW4gdGhlXG4gICAgRE9NLCBidXQgc29tZXRpbWVzXHUyMDE0Zm9yIGV4YW1wbGUgd2hlbiBpbnRlcnByZXRpbmcgYW4gZXZlbnRcbiAgICB0YXJnZXRcdTIwMTR5b3UgZG9uJ3QgaGF2ZSBhIGNob2ljZS4pXG4gICAgXG4gICAgVGhlIGBiaWFzYCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gaW5mbHVlbmNlIHdoaWNoIHNpZGUgb2YgYSBET01cbiAgICBub2RlIHRvIHVzZSB3aGVuIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgYSBsZWFmIG5vZGUuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQsIGJpYXMgPSAtMSkge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00obm9kZSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJET00gcG9zaXRpb24gbm90IGluc2lkZSB0aGUgZWRpdG9yXCIpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIG91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jayB3aGVuXG4gICAgbW92aW5nIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLiBXaGVuLCBmb3IgZXhhbXBsZSwgZ2l2ZW4gYFwibGVmdFwiYCxcbiAgICBpdCB3aWxsIHJldHVybiB0cnVlIGlmIG1vdmluZyBsZWZ0IGZyb20gdGhlIGN1cnJlbnQgY3Vyc29yXG4gICAgcG9zaXRpb24gd291bGQgbGVhdmUgdGhhdCBwb3NpdGlvbidzIHBhcmVudCB0ZXh0YmxvY2suIFdpbGwgYXBwbHlcbiAgICB0byB0aGUgdmlldydzIGN1cnJlbnQgc3RhdGUgYnkgZGVmYXVsdCwgYnV0IGl0IGlzIHBvc3NpYmxlIHRvXG4gICAgcGFzcyBhIGRpZmZlcmVudCBzdGF0ZS5cbiAgICAqL1xuICAgIGVuZE9mVGV4dGJsb2NrKGRpciwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGVuZE9mVGV4dGJsb2NrKHRoaXMsIHN0YXRlIHx8IHRoaXMuc3RhdGUsIGRpcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biB0aGUgZWRpdG9yJ3MgcGFzdGUgbG9naWMgd2l0aCB0aGUgZ2l2ZW4gSFRNTCBzdHJpbmcuIFRoZVxuICAgIGBldmVudGAsIGlmIGdpdmVuLCB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICBbYGhhbmRsZVBhc3RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuaGFuZGxlUGFzdGUpIGhvb2suXG4gICAgKi9cbiAgICBwYXN0ZUhUTUwoaHRtbCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFzdGUodGhpcywgXCJcIiwgaHRtbCwgZmFsc2UsIGV2ZW50IHx8IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIHRoZSBlZGl0b3IncyBwYXN0ZSBsb2dpYyB3aXRoIHRoZSBnaXZlbiBwbGFpbi10ZXh0IGlucHV0LlxuICAgICovXG4gICAgcGFzdGVUZXh0KHRleHQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkb1Bhc3RlKHRoaXMsIHRleHQsIG51bGwsIHRydWUsIGV2ZW50IHx8IG5ldyBDbGlwYm9hcmRFdmVudChcInBhc3RlXCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoZSBnaXZlbiBzbGljZSBhcyBpdCB3b3VsZCBiZSBpZiBpdCB3YXMgY29waWVkIGZyb21cbiAgICB0aGlzIGVkaXRvci4gUmV0dXJucyBhIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgYVxuICAgIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzbGljZSBhcyBpdHMgY2hpbGRyZW4sIGEgdGV4dHVhbFxuICAgIHJlcHJlc2VudGF0aW9uLCBhbmQgdGhlIHRyYW5zZm9ybWVkIHNsaWNlICh3aGljaCBjYW4gYmVcbiAgICBkaWZmZXJlbnQgZnJvbSB0aGUgZ2l2ZW4gaW5wdXQgZHVlIHRvIGhvb2tzIGxpa2VcbiAgICBbYHRyYW5zZm9ybUNvcGllZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLnRyYW5zZm9ybUNvcGllZCkpLlxuICAgICovXG4gICAgc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHNsaWNlKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVGb3JDbGlwYm9hcmQodGhpcywgc2xpY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIHRoZSBlZGl0b3IgZnJvbSB0aGUgRE9NIGFuZCBkZXN0cm95cyBhbGwgW25vZGVcbiAgICB2aWV3c10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuTm9kZVZpZXcpLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvY1ZpZXcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlc3Ryb3lJbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0cm95UGx1Z2luVmlld3MoKTtcbiAgICAgICAgaWYgKHRoaXMubW91bnRlZCkge1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZSh0aGlzLnN0YXRlLmRvYywgW10sIHZpZXdEZWNvcmF0aW9ucyh0aGlzKSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRvbS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3ID0gbnVsbDtcbiAgICAgICAgY2xlYXJSZXVzZWRSYW5nZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGlzIGlzIHRydWUgd2hlbiB0aGUgdmlldyBoYXMgYmVlblxuICAgIFtkZXN0cm95ZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZGVzdHJveSkgKGFuZCB0aHVzIHNob3VsZCBub3QgYmVcbiAgICB1c2VkIGFueW1vcmUpLlxuICAgICovXG4gICAgZ2V0IGlzRGVzdHJveWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3ID09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFVzZWQgZm9yIHRlc3RpbmcuXG4gICAgKi9cbiAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21TZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuZG9tU2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICghc2VsKVxuICAgICAgICAgICAgcmV0dXJuIHsgZm9jdXNOb2RlOiBudWxsLCBmb2N1c09mZnNldDogMCwgYW5jaG9yTm9kZTogbnVsbCwgYW5jaG9yT2Zmc2V0OiAwIH07XG4gICAgICAgIHJldHVybiBzYWZhcmkgJiYgdGhpcy5yb290Lm5vZGVUeXBlID09PSAxMSAmJlxuICAgICAgICAgICAgZGVlcEFjdGl2ZUVsZW1lbnQodGhpcy5kb20ub3duZXJEb2N1bWVudCkgPT0gdGhpcy5kb20gJiYgc2FmYXJpU2hhZG93U2VsZWN0aW9uUmFuZ2UodGhpcywgc2VsKSB8fCBzZWw7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LmdldFNlbGVjdGlvbigpO1xuICAgIH1cbn1cbkVkaXRvclZpZXcucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHRyKSB7XG4gICAgbGV0IGRpc3BhdGNoVHJhbnNhY3Rpb24gPSB0aGlzLl9wcm9wcy5kaXNwYXRjaFRyYW5zYWN0aW9uO1xuICAgIGlmIChkaXNwYXRjaFRyYW5zYWN0aW9uKVxuICAgICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uLmNhbGwodGhpcywgdHIpO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLnN0YXRlLmFwcGx5KHRyKSk7XG59O1xuZnVuY3Rpb24gY29tcHV0ZURvY0RlY28odmlldykge1xuICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgYXR0cnMuY2xhc3MgPSBcIlByb3NlTWlycm9yXCI7XG4gICAgYXR0cnMuY29udGVudGVkaXRhYmxlID0gU3RyaW5nKHZpZXcuZWRpdGFibGUpO1xuICAgIHZpZXcuc29tZVByb3AoXCJhdHRyaWJ1dGVzXCIsIHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlKHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICBmb3IgKGxldCBhdHRyIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIgPT0gXCJjbGFzc1wiKVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5jbGFzcyArPSBcIiBcIiArIHZhbHVlW2F0dHJdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0dHIgPT0gXCJzdHlsZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRycy5zdHlsZSA9IChhdHRycy5zdHlsZSA/IGF0dHJzLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbHVlW2F0dHJdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdHRyc1thdHRyXSAmJiBhdHRyICE9IFwiY29udGVudGVkaXRhYmxlXCIgJiYgYXR0ciAhPSBcIm5vZGVOYW1lXCIpXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2F0dHJdID0gU3RyaW5nKHZhbHVlW2F0dHJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWF0dHJzLnRyYW5zbGF0ZSlcbiAgICAgICAgYXR0cnMudHJhbnNsYXRlID0gXCJub1wiO1xuICAgIHJldHVybiBbRGVjb3JhdGlvbi5ub2RlKDAsIHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSwgYXR0cnMpXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUN1cnNvcldyYXBwZXIodmlldykge1xuICAgIGlmICh2aWV3Lm1hcmtDdXJzb3IpIHtcbiAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXNlcGFyYXRvclwiO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwibWFyay1wbGFjZWhvbGRlclwiLCBcInRydWVcIik7XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoXCJhbHRcIiwgXCJcIik7XG4gICAgICAgIHZpZXcuY3Vyc29yV3JhcHBlciA9IHsgZG9tLCBkZWNvOiBEZWNvcmF0aW9uLndpZGdldCh2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tLCBkb20sIHsgcmF3OiB0cnVlLCBtYXJrczogdmlldy5tYXJrQ3Vyc29yIH0pIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVkaXRhYmxlKHZpZXcpIHtcbiAgICByZXR1cm4gIXZpZXcuc29tZVByb3AoXCJlZGl0YWJsZVwiLCB2YWx1ZSA9PiB2YWx1ZSh2aWV3LnN0YXRlKSA9PT0gZmFsc2UpO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uQ29udGV4dENoYW5nZWQoc2VsMSwgc2VsMikge1xuICAgIGxldCBkZXB0aCA9IE1hdGgubWluKHNlbDEuJGFuY2hvci5zaGFyZWREZXB0aChzZWwxLmhlYWQpLCBzZWwyLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMi5oZWFkKSk7XG4gICAgcmV0dXJuIHNlbDEuJGFuY2hvci5zdGFydChkZXB0aCkgIT0gc2VsMi4kYW5jaG9yLnN0YXJ0KGRlcHRoKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkTm9kZVZpZXdzKHZpZXcpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmdW5jdGlvbiBhZGQob2JqKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBwcm9wKSlcbiAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgfVxuICAgIHZpZXcuc29tZVByb3AoXCJub2RlVmlld3NcIiwgYWRkKTtcbiAgICB2aWV3LnNvbWVQcm9wKFwibWFya1ZpZXdzXCIsIGFkZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNoYW5nZWROb2RlVmlld3MoYSwgYikge1xuICAgIGxldCBuQSA9IDAsIG5CID0gMDtcbiAgICBmb3IgKGxldCBwcm9wIGluIGEpIHtcbiAgICAgICAgaWYgKGFbcHJvcF0gIT0gYltwcm9wXSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBuQSsrO1xuICAgIH1cbiAgICBmb3IgKGxldCBfIGluIGIpXG4gICAgICAgIG5CKys7XG4gICAgcmV0dXJuIG5BICE9IG5CO1xufVxuZnVuY3Rpb24gY2hlY2tTdGF0ZUNvbXBvbmVudChwbHVnaW4pIHtcbiAgICBpZiAocGx1Z2luLnNwZWMuc3RhdGUgfHwgcGx1Z2luLnNwZWMuZmlsdGVyVHJhbnNhY3Rpb24gfHwgcGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUGx1Z2lucyBwYXNzZWQgZGlyZWN0bHkgdG8gdGhlIHZpZXcgbXVzdCBub3QgaGF2ZSBhIHN0YXRlIGNvbXBvbmVudFwiKTtcbn1cblxuZXhwb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCwgRWRpdG9yVmlldywgX19lbmRDb21wb3NpdGlvbiwgX19wYXJzZUZyb21DbGlwYm9hcmQgfTtcbiIsICJleHBvcnQgdmFyIGJhc2UgPSB7XG4gIDg6IFwiQmFja3NwYWNlXCIsXG4gIDk6IFwiVGFiXCIsXG4gIDEwOiBcIkVudGVyXCIsXG4gIDEyOiBcIk51bUxvY2tcIixcbiAgMTM6IFwiRW50ZXJcIixcbiAgMTY6IFwiU2hpZnRcIixcbiAgMTc6IFwiQ29udHJvbFwiLFxuICAxODogXCJBbHRcIixcbiAgMjA6IFwiQ2Fwc0xvY2tcIixcbiAgMjc6IFwiRXNjYXBlXCIsXG4gIDMyOiBcIiBcIixcbiAgMzM6IFwiUGFnZVVwXCIsXG4gIDM0OiBcIlBhZ2VEb3duXCIsXG4gIDM1OiBcIkVuZFwiLFxuICAzNjogXCJIb21lXCIsXG4gIDM3OiBcIkFycm93TGVmdFwiLFxuICAzODogXCJBcnJvd1VwXCIsXG4gIDM5OiBcIkFycm93UmlnaHRcIixcbiAgNDA6IFwiQXJyb3dEb3duXCIsXG4gIDQ0OiBcIlByaW50U2NyZWVuXCIsXG4gIDQ1OiBcIkluc2VydFwiLFxuICA0NjogXCJEZWxldGVcIixcbiAgNTk6IFwiO1wiLFxuICA2MTogXCI9XCIsXG4gIDkxOiBcIk1ldGFcIixcbiAgOTI6IFwiTWV0YVwiLFxuICAxMDY6IFwiKlwiLFxuICAxMDc6IFwiK1wiLFxuICAxMDg6IFwiLFwiLFxuICAxMDk6IFwiLVwiLFxuICAxMTA6IFwiLlwiLFxuICAxMTE6IFwiL1wiLFxuICAxNDQ6IFwiTnVtTG9ja1wiLFxuICAxNDU6IFwiU2Nyb2xsTG9ja1wiLFxuICAxNjA6IFwiU2hpZnRcIixcbiAgMTYxOiBcIlNoaWZ0XCIsXG4gIDE2MjogXCJDb250cm9sXCIsXG4gIDE2MzogXCJDb250cm9sXCIsXG4gIDE2NDogXCJBbHRcIixcbiAgMTY1OiBcIkFsdFwiLFxuICAxNzM6IFwiLVwiLFxuICAxODY6IFwiO1wiLFxuICAxODc6IFwiPVwiLFxuICAxODg6IFwiLFwiLFxuICAxODk6IFwiLVwiLFxuICAxOTA6IFwiLlwiLFxuICAxOTE6IFwiL1wiLFxuICAxOTI6IFwiYFwiLFxuICAyMTk6IFwiW1wiLFxuICAyMjA6IFwiXFxcXFwiLFxuICAyMjE6IFwiXVwiLFxuICAyMjI6IFwiJ1wiXG59XG5cbmV4cG9ydCB2YXIgc2hpZnQgPSB7XG4gIDQ4OiBcIilcIixcbiAgNDk6IFwiIVwiLFxuICA1MDogXCJAXCIsXG4gIDUxOiBcIiNcIixcbiAgNTI6IFwiJFwiLFxuICA1MzogXCIlXCIsXG4gIDU0OiBcIl5cIixcbiAgNTU6IFwiJlwiLFxuICA1NjogXCIqXCIsXG4gIDU3OiBcIihcIixcbiAgNTk6IFwiOlwiLFxuICA2MTogXCIrXCIsXG4gIDE3MzogXCJfXCIsXG4gIDE4NjogXCI6XCIsXG4gIDE4NzogXCIrXCIsXG4gIDE4ODogXCI8XCIsXG4gIDE4OTogXCJfXCIsXG4gIDE5MDogXCI+XCIsXG4gIDE5MTogXCI/XCIsXG4gIDE5MjogXCJ+XCIsXG4gIDIxOTogXCJ7XCIsXG4gIDIyMDogXCJ8XCIsXG4gIDIyMTogXCJ9XCIsXG4gIDIyMjogXCJcXFwiXCJcbn1cblxudmFyIG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbnZhciBpZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBcXGR8VHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcblxuLy8gRmlsbCBpbiB0aGUgZGlnaXQga2V5c1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSBiYXNlWzQ4ICsgaV0gPSBiYXNlWzk2ICsgaV0gPSBTdHJpbmcoaSlcblxuLy8gVGhlIGZ1bmN0aW9uIGtleXNcbmZvciAodmFyIGkgPSAxOyBpIDw9IDI0OyBpKyspIGJhc2VbaSArIDExMV0gPSBcIkZcIiArIGlcblxuLy8gQW5kIHRoZSBhbHBoYWJldGljIGtleXNcbmZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XG4gIGJhc2VbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAzMilcbiAgc2hpZnRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXG59XG5cbi8vIEZvciBlYWNoIGNvZGUgdGhhdCBkb2Vzbid0IGhhdmUgYSBzaGlmdC1lcXVpdmFsZW50LCBjb3B5IHRoZSBiYXNlIG5hbWVcbmZvciAodmFyIGNvZGUgaW4gYmFzZSkgaWYgKCFzaGlmdC5oYXNPd25Qcm9wZXJ0eShjb2RlKSkgc2hpZnRbY29kZV0gPSBiYXNlW2NvZGVdXG5cbmV4cG9ydCBmdW5jdGlvbiBrZXlOYW1lKGV2ZW50KSB7XG4gIC8vIE9uIG1hY09TLCBrZXlzIGhlbGQgd2l0aCBTaGlmdCBhbmQgQ21kIGRvbid0IHJlZmxlY3QgdGhlIGVmZmVjdCBvZiBTaGlmdCBpbiBgLmtleWAuXG4gIC8vIE9uIElFLCBzaGlmdCBlZmZlY3QgaXMgbmV2ZXIgaW5jbHVkZWQgaW4gYC5rZXlgLlxuICB2YXIgaWdub3JlS2V5ID0gbWFjICYmIGV2ZW50Lm1ldGFLZXkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSB8fFxuICAgICAgaWUgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ICYmIGV2ZW50LmtleS5sZW5ndGggPT0gMSB8fFxuICAgICAgZXZlbnQua2V5ID09IFwiVW5pZGVudGlmaWVkXCJcbiAgdmFyIG5hbWUgPSAoIWlnbm9yZUtleSAmJiBldmVudC5rZXkpIHx8XG4gICAgKGV2ZW50LnNoaWZ0S2V5ID8gc2hpZnQgOiBiYXNlKVtldmVudC5rZXlDb2RlXSB8fFxuICAgIGV2ZW50LmtleSB8fCBcIlVuaWRlbnRpZmllZFwiXG4gIC8vIEVkZ2Ugc29tZXRpbWVzIHByb2R1Y2VzIHdyb25nIG5hbWVzIChJc3N1ZSAjMylcbiAgaWYgKG5hbWUgPT0gXCJFc2NcIikgbmFtZSA9IFwiRXNjYXBlXCJcbiAgaWYgKG5hbWUgPT0gXCJEZWxcIikgbmFtZSA9IFwiRGVsZXRlXCJcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvODg2MDU3MS9cbiAgaWYgKG5hbWUgPT0gXCJMZWZ0XCIpIG5hbWUgPSBcIkFycm93TGVmdFwiXG4gIGlmIChuYW1lID09IFwiVXBcIikgbmFtZSA9IFwiQXJyb3dVcFwiXG4gIGlmIChuYW1lID09IFwiUmlnaHRcIikgbmFtZSA9IFwiQXJyb3dSaWdodFwiXG4gIGlmIChuYW1lID09IFwiRG93blwiKSBuYW1lID0gXCJBcnJvd0Rvd25cIlxuICByZXR1cm4gbmFtZVxufVxuIiwgImltcG9ydCB7IGtleU5hbWUsIGJhc2UgfSBmcm9tICd3M2Mta2V5bmFtZSc7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbmNvbnN0IG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCB3aW5kb3dzID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9XaW4vLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSkge1xuICAgIGxldCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pLCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAocmVzdWx0ID09IFwiU3BhY2VcIilcbiAgICAgICAgcmVzdWx0ID0gXCIgXCI7XG4gICAgbGV0IGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKG1hYylcbiAgICAgICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpO1xuICAgIH1cbiAgICBpZiAoYWx0KVxuICAgICAgICByZXN1bHQgPSBcIkFsdC1cIiArIHJlc3VsdDtcbiAgICBpZiAoY3RybClcbiAgICAgICAgcmVzdWx0ID0gXCJDdHJsLVwiICsgcmVzdWx0O1xuICAgIGlmIChtZXRhKVxuICAgICAgICByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7XG4gICAgaWYgKHNoaWZ0KVxuICAgICAgICByZXN1bHQgPSBcIlNoaWZ0LVwiICsgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemUobWFwKSB7XG4gICAgbGV0IGNvcHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICBjb3B5W25vcm1hbGl6ZUtleU5hbWUocHJvcCldID0gbWFwW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCA9IHRydWUpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0ICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG4vKipcbkNyZWF0ZSBhIGtleW1hcCBwbHVnaW4gZm9yIHRoZSBnaXZlbiBzZXQgb2YgYmluZGluZ3MuXG5cbkJpbmRpbmdzIHNob3VsZCBtYXAga2V5IG5hbWVzIHRvIFtjb21tYW5kXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMpLXN0eWxlXG5mdW5jdGlvbnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYChFZGl0b3JTdGF0ZSwgZGlzcGF0Y2gsXG5FZGl0b3JWaWV3KWAgYXJndW1lbnRzLCBhbmQgc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gdGhleSd2ZSBoYW5kbGVkXG50aGUga2V5LiBOb3RlIHRoYXQgdGhlIHZpZXcgYXJndW1lbnQgaXNuJ3QgcGFydCBvZiB0aGUgY29tbWFuZFxucHJvdG9jb2wsIGJ1dCBjYW4gYmUgdXNlZCBhcyBhbiBlc2NhcGUgaGF0Y2ggaWYgYSBiaW5kaW5nIG5lZWRzIHRvXG5kaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZSBVSS5cblxuS2V5IG5hbWVzIG1heSBiZSBzdHJpbmdzIGxpa2UgYFwiU2hpZnQtQ3RybC1FbnRlclwiYFx1MjAxNGEga2V5XG5pZGVudGlmaWVyIHByZWZpeGVkIHdpdGggemVybyBvciBtb3JlIG1vZGlmaWVycy4gS2V5IGlkZW50aWZpZXJzXG5hcmUgYmFzZWQgb24gdGhlIHN0cmluZ3MgdGhhdCBjYW4gYXBwZWFyIGluXG5bYEtleUV2ZW50LmtleWBdKGh0dHBzOmRldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkpLlxuVXNlIGxvd2VyY2FzZSBsZXR0ZXJzIHRvIHJlZmVyIHRvIGxldHRlciBrZXlzIChvciB1cHBlcmNhc2UgbGV0dGVyc1xuaWYgeW91IHdhbnQgc2hpZnQgdG8gYmUgaGVsZCkuIFlvdSBtYXkgdXNlIGBcIlNwYWNlXCJgIGFzIGFuIGFsaWFzXG5mb3IgdGhlIGBcIiBcImAgbmFtZS5cblxuTW9kaWZpZXJzIGNhbiBiZSBnaXZlbiBpbiBhbnkgb3JkZXIuIGBTaGlmdC1gIChvciBgcy1gKSwgYEFsdC1gIChvclxuYGEtYCksIGBDdHJsLWAgKG9yIGBjLWAgb3IgYENvbnRyb2wtYCkgYW5kIGBDbWQtYCAob3IgYG0tYCBvclxuYE1ldGEtYCkgYXJlIHJlY29nbml6ZWQuIEZvciBjaGFyYWN0ZXJzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgaG9sZGluZ1xuc2hpZnQsIHRoZSBgU2hpZnQtYCBwcmVmaXggaXMgaW1wbGllZCwgYW5kIHNob3VsZCBub3QgYmUgYWRkZWRcbmV4cGxpY2l0bHkuXG5cbllvdSBjYW4gdXNlIGBNb2QtYCBhcyBhIHNob3J0aGFuZCBmb3IgYENtZC1gIG9uIE1hYyBhbmQgYEN0cmwtYCBvblxub3RoZXIgcGxhdGZvcm1zLlxuXG5Zb3UgY2FuIGFkZCBtdWx0aXBsZSBrZXltYXAgcGx1Z2lucyB0byBhbiBlZGl0b3IuIFRoZSBvcmRlciBpblxud2hpY2ggdGhleSBhcHBlYXIgZGV0ZXJtaW5lcyB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBlYXJseSBpblxudGhlIGFycmF5IGdldCB0byBkaXNwYXRjaCBmaXJzdCkuXG4qL1xuZnVuY3Rpb24ga2V5bWFwKGJpbmRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oeyBwcm9wczogeyBoYW5kbGVLZXlEb3duOiBrZXlkb3duSGFuZGxlcihiaW5kaW5ncykgfSB9KTtcbn1cbi8qKlxuR2l2ZW4gYSBzZXQgb2YgYmluZGluZ3MgKHVzaW5nIHRoZSBzYW1lIGZvcm1hdCBhc1xuW2BrZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8ja2V5bWFwLmtleW1hcCkpLCByZXR1cm4gYSBba2V5ZG93blxuaGFuZGxlcl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuaGFuZGxlS2V5RG93bikgdGhhdCBoYW5kbGVzIHRoZW0uXG4qL1xuZnVuY3Rpb24ga2V5ZG93bkhhbmRsZXIoYmluZGluZ3MpIHtcbiAgICBsZXQgbWFwID0gbm9ybWFsaXplKGJpbmRpbmdzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCksIGJhc2VOYW1lLCBkaXJlY3QgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50KV07XG4gICAgICAgIGlmIChkaXJlY3QgJiYgZGlyZWN0KHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIEEgY2hhcmFjdGVyIGtleVxuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT0gMSAmJiBuYW1lICE9IFwiIFwiKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBuYW1lIHdhcyBhbHJlYWR5IG1vZGlmaWVkIGJ5IHNoaWZ0LCB0cnkgbG9va2luZ1xuICAgICAgICAgICAgICAgIC8vIGl0IHVwIHdpdGhvdXQgaXRzIHNoaWZ0IG1vZGlmaWVyXG4gICAgICAgICAgICAgICAgbGV0IG5vU2hpZnQgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBmYWxzZSldO1xuICAgICAgICAgICAgICAgIGlmIChub1NoaWZ0ICYmIG5vU2hpZnQodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJlxuICAgICAgICAgICAgICAgIC8vIEN0cmwtQWx0IG1heSBiZSB1c2VkIGZvciBBbHRHciBvbiBXaW5kb3dzXG4gICAgICAgICAgICAgICAgISh3aW5kb3dzICYmIGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuYWx0S2V5KSAmJlxuICAgICAgICAgICAgICAgIChiYXNlTmFtZSA9IGJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZmFsbGluZyBiYWNrIHRvIHRoZSBrZXlDb2RlIHdoZW4gdGhlcmUncyBhIG1vZGlmaWVyXG4gICAgICAgICAgICAgICAgLy8gYWN0aXZlIG9yIHRoZSBjaGFyYWN0ZXIgcHJvZHVjZWQgaXNuJ3QgQVNDSUksIGFuZCBvdXIgdGFibGVcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWNlcyBhIGRpZmZlcmVudCBuYW1lIGZyb20gdGhlIHRoZSBrZXlDb2RlLiBTZWUgIzY2OCxcbiAgICAgICAgICAgICAgICAvLyAjMTA2MCwgIzE1MjkuXG4gICAgICAgICAgICAgICAgbGV0IGZyb21Db2RlID0gbWFwW21vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQpXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUNvZGUgJiYgZnJvbUNvZGUodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBrZXlkb3duSGFuZGxlciwga2V5bWFwIH07XG4iLCAiaW1wb3J0IHsgbGlmdFRhcmdldCwgcmVwbGFjZVN0ZXAsIFJlcGxhY2VTdGVwLCBjYW5Kb2luLCBqb2luUG9pbnQsIGNhblNwbGl0LCBSZXBsYWNlQXJvdW5kU3RlcCwgZmluZFdyYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IE5vZGVTZWxlY3Rpb24sIFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgQWxsU2VsZWN0aW9uLCBTZWxlY3Rpb25SYW5nZSB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgaWYgdGhlcmUgaXMgb25lLlxuKi9cbmNvbnN0IGRlbGV0ZVNlbGVjdGlvbiA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA+IDApKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gJGN1cnNvcjtcbn1cbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCB0cnkgdG9cbnJlZHVjZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGJsb2NrIGFuZCB0aGUgb25lIGJlZm9yZSBpdFx1MjAxNGlmXG50aGVyZSdzIGEgYmxvY2sgZGlyZWN0bHkgYmVmb3JlIGl0IHRoYXQgY2FuIGJlIGpvaW5lZCwgam9pbiB0aGVtLlxuSWYgbm90LCB0cnkgdG8gbW92ZSB0aGUgc2VsZWN0ZWQgYmxvY2sgY2xvc2VyIHRvIHRoZSBuZXh0IG9uZSBpblxudGhlIGRvY3VtZW50IHN0cnVjdHVyZSBieSBsaWZ0aW5nIGl0IG91dCBvZiBpdHMgcGFyZW50IG9yIG1vdmluZyBpdFxuaW50byBhIHBhcmVudCBvZiB0aGUgcHJldmlvdXMgYmxvY2suIFdpbGwgdXNlIHRoZSB2aWV3IGZvciBhY2N1cmF0ZVxuKGJpZGktYXdhcmUpIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4qL1xuY29uc3Qgam9pbkJhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgdGhpcywgdHJ5IHRvIGxpZnRcbiAgICBpZiAoISRjdXQpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlO1xuICAgIC8vIEFwcGx5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmIChkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCwgLTEpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBJZiB0aGUgbm9kZSBiZWxvdyBoYXMgbm8gY29udGVudCBhbmQgdGhlIG5vZGUgYWJvdmUgaXNcbiAgICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYmVsb3cgYW5kIHNlbGVjdCB0aGUgb25lIGFib3ZlLlxuICAgIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgICAodGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShiZWZvcmUpKSkge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9ICRjdXJzb3IuZGVwdGg7OyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgZGVsU3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoZGVwdGgpLCAkY3Vyc29yLmFmdGVyKGRlcHRoKSwgU2xpY2UuZW1wdHkpO1xuICAgICAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKGRlbFN0ZXApO1xuICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MsIC0xKSksIC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplKSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXB0aCA9PSAxIHx8ICRjdXJzb3Iubm9kZShkZXB0aCAtIDEpLmNoaWxkQ291bnQgPiAxKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBub2RlIGJlZm9yZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYmVmb3JlLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJGN1dC5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5CYWNrd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luQmFja3dhcmQpXG50aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBiZWZvcmVcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiovXG5jb25zdCBqb2luVGV4dGJsb2NrQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG4vKipcbkEgbW9yZSBsaW1pdGVkIGZvcm0gb2YgW2Bqb2luRm9yd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luRm9yd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGFmdGVyXG5pdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tGb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja0VuZChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGN1cnNvcik7XG4gICAgcmV0dXJuICRjdXQgPyBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSwgYmVmb3JlVGV4dCA9IGJlZm9yZSwgYmVmb3JlUG9zID0gJGN1dC5wb3MgLSAxO1xuICAgIGZvciAoOyAhYmVmb3JlVGV4dC5pc1RleHRibG9jazsgYmVmb3JlUG9zLS0pIHtcbiAgICAgICAgaWYgKGJlZm9yZVRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYmVmb3JlVGV4dC5sYXN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGJlZm9yZVRleHQgPSBjaGlsZDtcbiAgICB9XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsIGFmdGVyVGV4dCA9IGFmdGVyLCBhZnRlclBvcyA9ICRjdXQucG9zICsgMTtcbiAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJQb3MrKykge1xuICAgICAgICBpZiAoYWZ0ZXJUZXh0LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IGFmdGVyVGV4dC5maXJzdENoaWxkO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBhZnRlclRleHQgPSBjaGlsZDtcbiAgICB9XG4gICAgbGV0IHN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsIGJlZm9yZVBvcywgYWZ0ZXJQb3MsIFNsaWNlLmVtcHR5KTtcbiAgICBpZiAoIXN0ZXAgfHwgc3RlcC5mcm9tICE9IGJlZm9yZVBvcyB8fFxuICAgICAgICBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgJiYgc3RlcC5zbGljZS5zaXplID49IGFmdGVyUG9zIC0gYmVmb3JlUG9zKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoc3RlcCk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIGJlZm9yZVBvcykpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0ZXh0YmxvY2tBdChub2RlLCBzaWRlLCBvbmx5ID0gZmFsc2UpIHtcbiAgICBmb3IgKGxldCBzY2FuID0gbm9kZTsgc2Nhbjsgc2NhbiA9IChzaWRlID09IFwic3RhcnRcIiA/IHNjYW4uZmlyc3RDaGlsZCA6IHNjYW4ubGFzdENoaWxkKSkge1xuICAgICAgICBpZiAoc2Nhbi5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAob25seSAmJiBzY2FuLmNoaWxkQ291bnQgIT0gMSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBiZWZvcmUgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG5ib3VuZCB0byBrZXlzIGxpa2UgYmFja3NwYWNlLCBhZnRlclxuW2Bqb2luQmFja3dhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkJhY2t3YXJkKSBvciBvdGhlciBkZWxldGluZ1xuY29tbWFuZHMsIGFzIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0IGFsbG93XG5kZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUJhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCB7ICRoZWFkLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uLCAkY3V0ID0gJGhlYWQ7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKSA6ICRoZWFkLnBhcmVudE9mZnNldCA+IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUJlZm9yZTtcbiAgICBpZiAoIW5vZGUgfHwgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCAkY3V0LnBvcyAtIG5vZGUubm9kZVNpemUpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBmaW5kQ3V0QmVmb3JlKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICgkcG9zLmluZGV4KGkpID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmJlZm9yZShpICsgMSkpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShpKS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KSB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSlcbiAgICAgICAgOiAkY3Vyc29yLnBhcmVudE9mZnNldCA8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYVxudGV4dGJsb2NrLCB0cnkgdG8gcmVkdWNlIG9yIHJlbW92ZSB0aGUgYm91bmRhcnkgYmV0d2VlbiB0aGF0IGJsb2NrXG5hbmQgdGhlIG9uZSBhZnRlciBpdCwgZWl0aGVyIGJ5IGpvaW5pbmcgdGhlbSBvciBieSBtb3ZpbmcgdGhlIG90aGVyXG5ibG9jayBjbG9zZXIgdG8gdGhpcyBvbmUgaW4gdGhlIHRyZWUgc3RydWN0dXJlLiBXaWxsIHVzZSB0aGUgdmlld1xuZm9yIGFjY3VyYXRlIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4qL1xuY29uc3Qgam9pbkZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGFmdGVyIHRoaXMsIHRoZXJlJ3Mgbm90aGluZyB0byBkb1xuICAgIGlmICghJGN1dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhZnRlciA9ICRjdXQubm9kZUFmdGVyO1xuICAgIC8vIFRyeSB0aGUgam9pbmluZyBhbGdvcml0aG1cbiAgICBpZiAoZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gsIDEpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBJZiB0aGUgbm9kZSBhYm92ZSBoYXMgbm8gY29udGVudCBhbmQgdGhlIG5vZGUgYmVsb3cgaXNcbiAgICAvLyBzZWxlY3RhYmxlLCBkZWxldGUgdGhlIG5vZGUgYWJvdmUgYW5kIHNlbGVjdCB0aGUgb25lIGJlbG93LlxuICAgIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJlxuICAgICAgICAodGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgfHwgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYWZ0ZXIpKSkge1xuICAgICAgICBsZXQgZGVsU3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoKSwgJGN1cnNvci5hZnRlcigpLCBTbGljZS5lbXB0eSk7XG4gICAgICAgIGlmIChkZWxTdGVwICYmIGRlbFN0ZXAuc2xpY2Uuc2l6ZSA8IGRlbFN0ZXAudG8gLSBkZWxTdGVwLmZyb20pIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpID8gU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSksIDEpXG4gICAgICAgICAgICAgICAgICAgIDogTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcykpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgaXMgYW4gYXRvbSwgZGVsZXRlIGl0XG4gICAgaWYgKGFmdGVyLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkY3V0LnBvcywgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2ssIHNlbGVjdFxudGhlIG5vZGUgY29taW5nIGFmdGVyIHRoYXQgdGV4dGJsb2NrLCBpZiBwb3NzaWJsZS4gVGhpcyBpcyBpbnRlbmRlZFxudG8gYmUgYm91bmQgdG8ga2V5cyBsaWtlIGRlbGV0ZSwgYWZ0ZXJcbltgam9pbkZvcndhcmRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuam9pbkZvcndhcmQpIGFuZCBzaW1pbGFyIGRlbGV0aW5nXG5jb21tYW5kcywgdG8gcHJvdmlkZSBhIGZhbGwtYmFjayBiZWhhdmlvciB3aGVuIHRoZSBzY2hlbWEgZG9lc24ndFxuYWxsb3cgZGVsZXRpb24gYXQgdGhlIHNlbGVjdGVkIHBvaW50LlxuKi9cbmNvbnN0IHNlbGVjdE5vZGVGb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCB7ICRoZWFkLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uLCAkY3V0ID0gJGhlYWQ7XG4gICAgaWYgKCFlbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkaGVhZC5wYXJlbnQuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgaWYgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0IDwgJGhlYWQucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRBZnRlcigkaGVhZCk7XG4gICAgfVxuICAgIGxldCBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVBZnRlcjtcbiAgICBpZiAoIW5vZGUgfHwgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCAkY3V0LnBvcykpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRBZnRlcigkcG9zKSB7XG4gICAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGkpO1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgKyAxIDwgcGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5hZnRlcihpICsgMSkpO1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbkpvaW4gdGhlIHNlbGVjdGVkIGJsb2NrIG9yLCBpZiB0aGVyZSBpcyBhIHRleHQgc2VsZWN0aW9uLCB0aGVcbmNsb3Nlc3QgYW5jZXN0b3IgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbiB0aGF0IGNhbiBiZSBqb2luZWQsIHdpdGhcbnRoZSBzaWJsaW5nIGFib3ZlIGl0LlxuKi9cbmNvbnN0IGpvaW5VcCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCBub2RlU2VsID0gc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiwgcG9pbnQ7XG4gICAgaWYgKG5vZGVTZWwpIHtcbiAgICAgICAgaWYgKHNlbC5ub2RlLmlzVGV4dGJsb2NrIHx8ICFjYW5Kb2luKHN0YXRlLmRvYywgc2VsLmZyb20pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb2ludCA9IHNlbC5mcm9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwuZnJvbSwgLTEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmpvaW4ocG9pbnQpO1xuICAgICAgICBpZiAobm9kZVNlbClcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHBvaW50IC0gc3RhdGUuZG9jLnJlc29sdmUocG9pbnQpLm5vZGVCZWZvcmUubm9kZVNpemUpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2ssIG9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIHRoZSBzZWxlY3Rpb25cbnRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aCB0aGUgc2libGluZyBhZnRlciBpdC5cbiovXG5jb25zdCBqb2luRG93biA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwudG8pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwb2ludCA9IHNlbC50bztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc2VsLnRvLCAxKTtcbiAgICAgICAgaWYgKHBvaW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuam9pbihwb2ludCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5MaWZ0IHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgYmxvY2sgb2YgdGhlXG5zZWxlY3Rpb24gdGhhdCBjYW4gYmUgbGlmdGVkLCBvdXQgb2YgaXRzIHBhcmVudCBub2RlLlxuKi9cbmNvbnN0IGxpZnQgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2hvc2UgdHlwZSBoYXMgYSB0cnV0aHlcbltgY29kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb2RlKSBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgcmVwbGFjZSB0aGVcbnNlbGVjdGlvbiB3aXRoIGEgbmV3bGluZSBjaGFyYWN0ZXIuXG4qL1xuY29uc3QgbmV3bGluZUluQ29kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnRUZXh0KFwiXFxuXCIpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgeyB0eXBlIH0gPSBtYXRjaC5lZGdlKGkpO1xuICAgICAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpXG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBpbiBhIG5vZGUgd2l0aCBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCBjcmVhdGUgYVxuZGVmYXVsdCBibG9jayBhZnRlciB0aGUgY29kZSBibG9jaywgYW5kIG1vdmUgdGhlIGN1cnNvciB0aGVyZS5cbiovXG5jb25zdCBleGl0Q29kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFib3ZlID0gJGhlYWQubm9kZSgtMSksIGFmdGVyID0gJGhlYWQuaW5kZXhBZnRlcigtMSksIHR5cGUgPSBkZWZhdWx0QmxvY2tBdChhYm92ZS5jb250ZW50TWF0Y2hBdChhZnRlcikpO1xuICAgIGlmICghdHlwZSB8fCAhYWJvdmUuY2FuUmVwbGFjZVdpdGgoYWZ0ZXIsIGFmdGVyLCB0eXBlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgcG9zID0gJGhlYWQuYWZ0ZXIoKSwgdHIgPSBzdGF0ZS50ci5yZXBsYWNlV2l0aChwb3MsIHBvcywgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUocG9zKSwgMSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiBhIGJsb2NrIG5vZGUgaXMgc2VsZWN0ZWQsIGNyZWF0ZSBhbiBlbXB0eSBwYXJhZ3JhcGggYmVmb3JlIChpZlxuaXQgaXMgaXRzIHBhcmVudCdzIGZpcnN0IGNoaWxkKSBvciBhZnRlciBpdC5cbiovXG5jb25zdCBjcmVhdGVQYXJhZ3JhcGhOZWFyID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHsgJGZyb20sICR0byB9ID0gc2VsO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24gfHwgJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgJHRvLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHR5cGUgPSBkZWZhdWx0QmxvY2tBdCgkdG8ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCR0by5pbmRleEFmdGVyKCkpKTtcbiAgICBpZiAoIXR5cGUgfHwgIXR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAoISRmcm9tLnBhcmVudE9mZnNldCAmJiAkdG8uaW5kZXgoKSA8ICR0by5wYXJlbnQuY2hpbGRDb3VudCA/ICRmcm9tIDogJHRvKS5wb3M7XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLmluc2VydChzaWRlLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHNpZGUgKyAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIHRoZSBjdXJzb3IgaXMgaW4gYW4gZW1wdHkgdGV4dGJsb2NrIHRoYXQgY2FuIGJlIGxpZnRlZCwgbGlmdCB0aGVcbmJsb2NrLlxuKi9cbmNvbnN0IGxpZnRFbXB0eUJsb2NrID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRjdXJzb3IuZGVwdGggPiAxICYmICRjdXJzb3IuYWZ0ZXIoKSAhPSAkY3Vyc29yLmVuZCgtMSkpIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9ICRjdXJzb3IuYmVmb3JlKCk7XG4gICAgICAgIGlmIChjYW5TcGxpdChzdGF0ZS5kb2MsIGJlZm9yZSkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdChiZWZvcmUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJhbmdlID0gJGN1cnNvci5ibG9ja1JhbmdlKCksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNyZWF0ZSBhIHZhcmlhbnQgb2YgW2BzcGxpdEJsb2NrYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0QmxvY2spIHRoYXQgdXNlc1xuYSBjdXN0b20gZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRoZSBuZXdseSBzcGxpdCBvZmYgYmxvY2suXG4qL1xuZnVuY3Rpb24gc3BsaXRCbG9ja0FzKHNwbGl0Tm9kZSkge1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc3RhdGUuc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgICAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnRPZmZzZXQgfHwgIWNhblNwbGl0KHN0YXRlLmRvYywgJGZyb20ucG9zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJGZyb20uZGVwdGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0eXBlcyA9IFtdO1xuICAgICAgICBsZXQgc3BsaXREZXB0aCwgZGVmbHQsIGF0RW5kID0gZmFsc2UsIGF0U3RhcnQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgZCA9ICRmcm9tLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICRmcm9tLm5vZGUoZCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgYXRFbmQgPSAkZnJvbS5lbmQoZCkgPT0gJGZyb20ucG9zICsgKCRmcm9tLmRlcHRoIC0gZCk7XG4gICAgICAgICAgICAgICAgYXRTdGFydCA9ICRmcm9tLnN0YXJ0KGQpID09ICRmcm9tLnBvcyAtICgkZnJvbS5kZXB0aCAtIGQpO1xuICAgICAgICAgICAgICAgIGRlZmx0ID0gZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZShkIC0gMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcihkIC0gMSkpKTtcbiAgICAgICAgICAgICAgICBsZXQgc3BsaXRUeXBlID0gc3BsaXROb2RlICYmIHNwbGl0Tm9kZSgkdG8ucGFyZW50LCBhdEVuZCwgJGZyb20pO1xuICAgICAgICAgICAgICAgIHR5cGVzLnVuc2hpZnQoc3BsaXRUeXBlIHx8IChhdEVuZCAmJiBkZWZsdCA/IHsgdHlwZTogZGVmbHQgfSA6IG51bGwpKTtcbiAgICAgICAgICAgICAgICBzcGxpdERlcHRoID0gZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkID09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB0eXBlcy51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiB8fCBzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24pXG4gICAgICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNwbGl0UG9zID0gdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKTtcbiAgICAgICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHR5cGVzLmxlbmd0aCwgdHlwZXMpO1xuICAgICAgICBpZiAoIWNhbikge1xuICAgICAgICAgICAgdHlwZXNbMF0gPSBkZWZsdCA/IHsgdHlwZTogZGVmbHQgfSA6IG51bGw7XG4gICAgICAgICAgICBjYW4gPSBjYW5TcGxpdCh0ci5kb2MsIHNwbGl0UG9zLCB0eXBlcy5sZW5ndGgsIHR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdHIuc3BsaXQoc3BsaXRQb3MsIHR5cGVzLmxlbmd0aCwgdHlwZXMpO1xuICAgICAgICBpZiAoIWF0RW5kICYmIGF0U3RhcnQgJiYgJGZyb20ubm9kZShzcGxpdERlcHRoKS50eXBlICE9IGRlZmx0KSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoc3BsaXREZXB0aCkpLCAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdCk7XG4gICAgICAgICAgICBpZiAoZGVmbHQgJiYgJGZyb20ubm9kZShzcGxpdERlcHRoIC0gMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKVxuICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKHNwbGl0RGVwdGgpKSwgZGVmbHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5TcGxpdCB0aGUgcGFyZW50IGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24uIElmIHRoZSBzZWxlY3Rpb24gaXMgYSB0ZXh0XG5zZWxlY3Rpb24sIGFsc28gZGVsZXRlIGl0cyBjb250ZW50LlxuKi9cbmNvbnN0IHNwbGl0QmxvY2sgPSBzcGxpdEJsb2NrQXMoKTtcbi8qKlxuQWN0cyBsaWtlIFtgc3BsaXRCbG9ja2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdEJsb2NrKSwgYnV0IHdpdGhvdXRcbnJlc2V0dGluZyB0aGUgc2V0IG9mIGFjdGl2ZSBtYXJrcyBhdCB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IHNwbGl0QmxvY2tLZWVwTWFya3MgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgcmV0dXJuIHNwbGl0QmxvY2soc3RhdGUsIGRpc3BhdGNoICYmICh0ciA9PiB7XG4gICAgICAgIGxldCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH0pKTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbm9kZSB3cmFwcGluZyB0aGUgY3VycmVudCBzZWxlY3Rpb24sIGlmXG5hbnkuIChXaWxsIG5vdCBzZWxlY3QgdGhlIGRvY3VtZW50IG5vZGUuKVxuKi9cbmNvbnN0IHNlbGVjdFBhcmVudE5vZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb24sIHBvcztcbiAgICBsZXQgc2FtZSA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKTtcbiAgICBpZiAoc2FtZSA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcG9zID0gJGZyb20uYmVmb3JlKHNhbWUpO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgcG9zKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2VsZWN0IHRoZSB3aG9sZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEFsbFNlbGVjdGlvbihzdGF0ZS5kb2MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gam9pbk1heWJlQ2xlYXIoc3RhdGUsICRwb3MsIGRpc3BhdGNoKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8ICFiZWZvcmUudHlwZS5jb21wYXRpYmxlQ29udGVudChhZnRlci50eXBlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghYmVmb3JlLmNvbnRlbnQuc2l6ZSAmJiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4IC0gMSwgaW5kZXgpKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZSgkcG9zLnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJHBvcy5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpIHx8ICEoYWZ0ZXIuaXNUZXh0YmxvY2sgfHwgY2FuSm9pbihzdGF0ZS5kb2MsICRwb3MucG9zKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmpvaW4oJHBvcy5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gsIGRpcikge1xuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmUsIGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsIGNvbm4sIG1hdGNoO1xuICAgIGxldCBpc29sYXRlZCA9IGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmc7XG4gICAgaWYgKCFpc29sYXRlZCAmJiBqb2luTWF5YmVDbGVhcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgY2FuRGVsQWZ0ZXIgPSAhaXNvbGF0ZWQgJiYgJGN1dC5wYXJlbnQuY2FuUmVwbGFjZSgkY3V0LmluZGV4KCksICRjdXQuaW5kZXgoKSArIDEpO1xuICAgIGlmIChjYW5EZWxBZnRlciAmJlxuICAgICAgICAoY29ubiA9IChtYXRjaCA9IGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpLmZpbmRXcmFwcGluZyhhZnRlci50eXBlKSkgJiZcbiAgICAgICAgbWF0Y2gubWF0Y2hUeXBlKGNvbm5bMF0gfHwgYWZ0ZXIudHlwZSkudmFsaWRFbmQpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNvbm4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oY29ubltpXS5jcmVhdGUobnVsbCwgd3JhcCkpO1xuICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oYmVmb3JlLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSAxLCBlbmQsICRjdXQucG9zLCBlbmQsIG5ldyBTbGljZSh3cmFwLCAxLCAwKSwgY29ubi5sZW5ndGgsIHRydWUpKTtcbiAgICAgICAgICAgIGxldCAkam9pbkF0ID0gdHIuZG9jLnJlc29sdmUoZW5kICsgMiAqIGNvbm4ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICgkam9pbkF0Lm5vZGVBZnRlciAmJiAkam9pbkF0Lm5vZGVBZnRlci50eXBlID09IGJlZm9yZS50eXBlICYmXG4gICAgICAgICAgICAgICAgY2FuSm9pbih0ci5kb2MsICRqb2luQXQucG9zKSlcbiAgICAgICAgICAgICAgICB0ci5qb2luKCRqb2luQXQucG9zKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgc2VsQWZ0ZXIgPSBhZnRlci50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IChkaXIgPiAwICYmIGlzb2xhdGVkKSA/IG51bGwgOiBTZWxlY3Rpb24uZmluZEZyb20oJGN1dCwgMSk7XG4gICAgbGV0IHJhbmdlID0gc2VsQWZ0ZXIgJiYgc2VsQWZ0ZXIuJGZyb20uYmxvY2tSYW5nZShzZWxBZnRlci4kdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0ID49ICRjdXQuZGVwdGgpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjYW5EZWxBZnRlciAmJiB0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiLCB0cnVlKSAmJiB0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpKSB7XG4gICAgICAgIGxldCBhdCA9IGJlZm9yZSwgd3JhcCA9IFtdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB3cmFwLnB1c2goYXQpO1xuICAgICAgICAgICAgaWYgKGF0LmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgYXQgPSBhdC5sYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFmdGVyVGV4dCA9IGFmdGVyLCBhZnRlckRlcHRoID0gMTtcbiAgICAgICAgZm9yICg7ICFhZnRlclRleHQuaXNUZXh0YmxvY2s7IGFmdGVyVGV4dCA9IGFmdGVyVGV4dC5maXJzdENoaWxkKVxuICAgICAgICAgICAgYWZ0ZXJEZXB0aCsrO1xuICAgICAgICBpZiAoYXQuY2FuUmVwbGFjZShhdC5jaGlsZENvdW50LCBhdC5jaGlsZENvdW50LCBhZnRlclRleHQuY29udGVudCkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gd3JhcC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gRnJhZ21lbnQuZnJvbSh3cmFwW2ldLmNvcHkoZW5kKSk7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSB3cmFwLmxlbmd0aCwgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSwgJGN1dC5wb3MgKyBhZnRlckRlcHRoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplIC0gYWZ0ZXJEZXB0aCwgbmV3IFNsaWNlKGVuZCwgd3JhcC5sZW5ndGgsIDApLCAwLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUZXh0YmxvY2tTaWRlKHNpZGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCAkcG9zID0gc2lkZSA8IDAgPyBzZWwuJGZyb20gOiBzZWwuJHRvO1xuICAgICAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoO1xuICAgICAgICB3aGlsZSAoJHBvcy5ub2RlKGRlcHRoKS5pc0lubGluZSkge1xuICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghJHBvcy5ub2RlKGRlcHRoKS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgc2lkZSA8IDAgPyAkcG9zLnN0YXJ0KGRlcHRoKSA6ICRwb3MuZW5kKGRlcHRoKSkpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgc3RhcnQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuKi9cbmNvbnN0IHNlbGVjdFRleHRibG9ja1N0YXJ0ID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgtMSk7XG4vKipcbk1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIGVuZCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrRW5kID0gc2VsZWN0VGV4dGJsb2NrU2lkZSgxKTtcbi8vIFBhcmFtZXRlcml6ZWQgY29tbWFuZHNcbi8qKlxuV3JhcCB0aGUgc2VsZWN0aW9uIGluIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSB3aXRoIHRoZSBnaXZlblxuYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiB3cmFwSW4obm9kZVR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB3cmFwcGluZyA9IHJhbmdlICYmIGZpbmRXcmFwcGluZyhyYW5nZSwgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICAgICAgaWYgKCF3cmFwcGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIud3JhcChyYW5nZSwgd3JhcHBpbmcpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5SZXR1cm5zIGEgY29tbWFuZCB0aGF0IHRyaWVzIHRvIHNldCB0aGUgc2VsZWN0ZWQgdGV4dGJsb2NrcyB0byB0aGVcbmdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHNldEJsb2NrVHlwZShub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IGFwcGxpY2FibGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCAmJiAhYXBwbGljYWJsZTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbGljYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLmhhc01hcmt1cChub2RlVHlwZSwgYXR0cnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PSBub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCAkcG9zID0gc3RhdGUuZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCBub2RlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcHBsaWNhYmxlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgJGZyb206IHsgcG9zOiBmcm9tIH0sICR0bzogeyBwb3M6IHRvIH0gfSA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgdHIuc2V0QmxvY2tUeXBlKGZyb20sIHRvLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcmtBcHBsaWVzKGRvYywgcmFuZ2VzLCB0eXBlLCBlbnRlckF0b21zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICBsZXQgY2FuID0gJGZyb20uZGVwdGggPT0gMCA/IGRvYy5pbmxpbmVDb250ZW50ICYmIGRvYy50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpIDogZmFsc2U7XG4gICAgICAgIGRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuIHx8ICFlbnRlckF0b21zICYmIG5vZGUuaXNBdG9tICYmIG5vZGUuaXNJbmxpbmUgJiYgcG9zID49ICRmcm9tLnBvcyAmJiBwb3MgKyBub2RlLm5vZGVTaXplIDw9ICR0by5wb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FuID0gbm9kZS5pbmxpbmVDb250ZW50ICYmIG5vZGUudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVtb3ZlSW5saW5lQXRvbXMocmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgJGZyb20uZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzQXRvbSAmJiBub2RlLmNvbnRlbnQuc2l6ZSAmJiBub2RlLmlzSW5saW5lICYmIHBvcyA+PSAkZnJvbS5wb3MgJiYgcG9zICsgbm9kZS5ub2RlU2l6ZSA8PSAkdG8ucG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyArIDEgPiAkZnJvbS5wb3MpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTZWxlY3Rpb25SYW5nZSgkZnJvbSwgJGZyb20uZG9jLnJlc29sdmUocG9zICsgMSkpKTtcbiAgICAgICAgICAgICAgICAkZnJvbSA9ICRmcm9tLmRvYy5yZXNvbHZlKHBvcyArIDEgKyBub2RlLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCRmcm9tLnBvcyA8ICR0by5wb3MpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU2VsZWN0aW9uUmFuZ2UoJGZyb20sICR0bykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5DcmVhdGUgYSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdG9nZ2xlcyB0aGUgZ2l2ZW4gbWFyayB3aXRoIHRoZVxuZ2l2ZW4gYXR0cmlidXRlcy4gV2lsbCByZXR1cm4gYGZhbHNlYCB3aGVuIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuZG9lc24ndCBzdXBwb3J0IHRoYXQgbWFyay4gVGhpcyB3aWxsIHJlbW92ZSB0aGUgbWFyayBpZiBhbnkgbWFya3Ncbm9mIHRoYXQgdHlwZSBleGlzdCBpbiB0aGUgc2VsZWN0aW9uLCBvciBhZGQgaXQgb3RoZXJ3aXNlLiBJZiB0aGVcbnNlbGVjdGlvbiBpcyBlbXB0eSwgdGhpcyBhcHBsaWVzIHRvIHRoZSBbc3RvcmVkXG5tYXJrc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnN0b3JlZE1hcmtzKSBpbnN0ZWFkIG9mIGEgcmFuZ2Ugb2YgdGhlXG5kb2N1bWVudC5cbiovXG5mdW5jdGlvbiB0b2dnbGVNYXJrKG1hcmtUeXBlLCBhdHRycyA9IG51bGwsIG9wdGlvbnMpIHtcbiAgICBsZXQgcmVtb3ZlV2hlblByZXNlbnQgPSAob3B0aW9ucyAmJiBvcHRpb25zLnJlbW92ZVdoZW5QcmVzZW50KSAhPT0gZmFsc2U7XG4gICAgbGV0IGVudGVyQXRvbXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLmVudGVySW5saW5lQXRvbXMpICE9PSBmYWxzZTtcbiAgICBsZXQgZHJvcFNwYWNlID0gIShvcHRpb25zICYmIG9wdGlvbnMuaW5jbHVkZVdoaXRlc3BhY2UpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7IGVtcHR5LCAkY3Vyc29yLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKChlbXB0eSAmJiAhJGN1cnNvcikgfHwgIW1hcmtBcHBsaWVzKHN0YXRlLmRvYywgcmFuZ2VzLCBtYXJrVHlwZSwgZW50ZXJBdG9tcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUuaXNJblNldChzdGF0ZS5zdG9yZWRNYXJrcyB8fCAkY3Vyc29yLm1hcmtzKCkpKVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5hZGRTdG9yZWRNYXJrKG1hcmtUeXBlLmNyZWF0ZShhdHRycykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBhZGQsIHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgaWYgKCFlbnRlckF0b21zKVxuICAgICAgICAgICAgICAgICAgICByYW5nZXMgPSByZW1vdmVJbmxpbmVBdG9tcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVXaGVuUHJlc2VudCkge1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSAhcmFuZ2VzLnNvbWUociA9PiBzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKHIuJGZyb20ucG9zLCByLiR0by5wb3MsIG1hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGQgPSAhcmFuZ2VzLmV2ZXJ5KHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oci4kZnJvbS5wb3MsIHIuJHRvLnBvcywgKG5vZGUsIHBvcywgcGFyZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pc3NpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nID0gIW1hcmtUeXBlLmlzSW5TZXQobm9kZS5tYXJrcykgJiYgISFwYXJlbnQgJiYgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobWFya1R5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICEobm9kZS5pc1RleHQgJiYgL15cXHMqJC8udGVzdChub2RlLnRleHRCZXR3ZWVuKE1hdGgubWF4KDAsIHIuJGZyb20ucG9zIC0gcG9zKSwgTWF0aC5taW4obm9kZS5ub2RlU2l6ZSwgci4kdG8ucG9zIC0gcG9zKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFtaXNzaW5nO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFkZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIucmVtb3ZlTWFyaygkZnJvbS5wb3MsICR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gJGZyb20ucG9zLCB0byA9ICR0by5wb3MsIHN0YXJ0ID0gJGZyb20ubm9kZUFmdGVyLCBlbmQgPSAkdG8ubm9kZUJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZVN0YXJ0ID0gZHJvcFNwYWNlICYmIHN0YXJ0ICYmIHN0YXJ0LmlzVGV4dCA/IC9eXFxzKi8uZXhlYyhzdGFydC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRW5kID0gZHJvcFNwYWNlICYmIGVuZCAmJiBlbmQuaXNUZXh0ID8gL1xccyokLy5leGVjKGVuZC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gKyBzcGFjZVN0YXJ0IDwgdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICs9IHNwYWNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gLT0gc3BhY2VFbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGZyb20sIHRvLCBtYXJrVHlwZS5jcmVhdGUoYXR0cnMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgaXNKb2luYWJsZSkge1xuICAgIHJldHVybiAodHIpID0+IHtcbiAgICAgICAgaWYgKCF0ci5pc0dlbmVyaWMpXG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2godHIpO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHIubWFwcGluZy5tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdHIubWFwcGluZy5tYXBzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gbWFwLm1hcChyYW5nZXNbal0pO1xuICAgICAgICAgICAgbWFwLmZvckVhY2goKF9zLCBfZSwgZnJvbSwgdG8pID0+IHJhbmdlcy5wdXNoKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlndXJlIG91dCB3aGljaCBqb2luYWJsZSBwb2ludHMgZXhpc3QgaW5zaWRlIHRob3NlIHJhbmdlcyxcbiAgICAgICAgLy8gYnkgY2hlY2tpbmcgYWxsIG5vZGUgYm91bmRhcmllcyBpbiB0aGVpciBwYXJlbnQgbm9kZXMuXG4gICAgICAgIGxldCBqb2luYWJsZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbaV0sIHRvID0gcmFuZ2VzW2kgKyAxXTtcbiAgICAgICAgICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCBkZXB0aCA9ICRmcm9tLnNoYXJlZERlcHRoKHRvKSwgcGFyZW50ID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9ICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpLCBwb3MgPSAkZnJvbS5hZnRlcihkZXB0aCArIDEpOyBwb3MgPD0gdG87ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICYmIGpvaW5hYmxlLmluZGV4T2YocG9zKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUudHlwZSA9PSBhZnRlci50eXBlICYmIGlzSm9pbmFibGUoYmVmb3JlLCBhZnRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luYWJsZS5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKb2luIHRoZSBqb2luYWJsZSBwb2ludHNcbiAgICAgICAgam9pbmFibGUuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgICAgICBmb3IgKGxldCBpID0gam9pbmFibGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbmFibGVbaV0pKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oam9pbmFibGVbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9O1xufVxuLyoqXG5XcmFwIGEgY29tbWFuZCBzbyB0aGF0LCB3aGVuIGl0IHByb2R1Y2VzIGEgdHJhbnNmb3JtIHRoYXQgY2F1c2VzXG50d28gam9pbmFibGUgbm9kZXMgdG8gZW5kIHVwIG5leHQgdG8gZWFjaCBvdGhlciwgdGhvc2UgYXJlIGpvaW5lZC5cbk5vZGVzIGFyZSBjb25zaWRlcmVkIGpvaW5hYmxlIHdoZW4gdGhleSBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmRcbndoZW4gdGhlIGBpc0pvaW5hYmxlYCBwcmVkaWNhdGUgcmV0dXJucyB0cnVlIGZvciB0aGVtIG9yLCBpZiBhblxuYXJyYXkgb2Ygc3RyaW5ncyB3YXMgcGFzc2VkLCBpZiB0aGVpciBub2RlIHR5cGUgbmFtZSBpcyBpbiB0aGF0XG5hcnJheS5cbiovXG5mdW5jdGlvbiBhdXRvSm9pbihjb21tYW5kLCBpc0pvaW5hYmxlKSB7XG4gICAgbGV0IGNhbkpvaW4gPSBBcnJheS5pc0FycmF5KGlzSm9pbmFibGUpID8gKG5vZGUpID0+IGlzSm9pbmFibGUuaW5kZXhPZihub2RlLnR5cGUubmFtZSkgPiAtMVxuICAgICAgICA6IGlzSm9pbmFibGU7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IGNvbW1hbmQoc3RhdGUsIGRpc3BhdGNoICYmIHdyYXBEaXNwYXRjaEZvckpvaW4oZGlzcGF0Y2gsIGNhbkpvaW4pLCB2aWV3KTtcbn1cbi8qKlxuQ29tYmluZSBhIG51bWJlciBvZiBjb21tYW5kIGZ1bmN0aW9ucyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uICh3aGljaFxuY2FsbHMgdGhlbSBvbmUgYnkgb25lIHVudGlsIG9uZSByZXR1cm5zIHRydWUpLlxuKi9cbmZ1bmN0aW9uIGNoYWluQ29tbWFuZHMoLi4uY29tbWFuZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbW1hbmRzW2ldKHN0YXRlLCBkaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxubGV0IGJhY2tzcGFjZSA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luQmFja3dhcmQsIHNlbGVjdE5vZGVCYWNrd2FyZCk7XG5sZXQgZGVsID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5Gb3J3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCk7XG4vKipcbkEgYmFzaWMga2V5bWFwIGNvbnRhaW5pbmcgYmluZGluZ3Mgbm90IHNwZWNpZmljIHRvIGFueSBzY2hlbWEuXG5CaW5kcyB0aGUgZm9sbG93aW5nIGtleXMgKHdoZW4gbXVsdGlwbGUgY29tbWFuZHMgYXJlIGxpc3RlZCwgdGhleVxuYXJlIGNoYWluZWQgd2l0aCBbYGNoYWluQ29tbWFuZHNgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuY2hhaW5Db21tYW5kcykpOlxuXG4qICoqRW50ZXIqKiB0byBgbmV3bGluZUluQ29kZWAsIGBjcmVhdGVQYXJhZ3JhcGhOZWFyYCwgYGxpZnRFbXB0eUJsb2NrYCwgYHNwbGl0QmxvY2tgXG4qICoqTW9kLUVudGVyKiogdG8gYGV4aXRDb2RlYFxuKiAqKkJhY2tzcGFjZSoqIGFuZCAqKk1vZC1CYWNrc3BhY2UqKiB0byBgZGVsZXRlU2VsZWN0aW9uYCwgYGpvaW5CYWNrd2FyZGAsIGBzZWxlY3ROb2RlQmFja3dhcmRgXG4qICoqRGVsZXRlKiogYW5kICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLURlbGV0ZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkZvcndhcmRgLCBgc2VsZWN0Tm9kZUZvcndhcmRgXG4qICoqTW9kLWEqKiB0byBgc2VsZWN0QWxsYFxuKi9cbmNvbnN0IHBjQmFzZUtleW1hcCA9IHtcbiAgICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICAgIFwiTW9kLUVudGVyXCI6IGV4aXRDb2RlLFxuICAgIFwiQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiU2hpZnQtQmFja3NwYWNlXCI6IGJhY2tzcGFjZSxcbiAgICBcIkRlbGV0ZVwiOiBkZWwsXG4gICAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgICBcIk1vZC1hXCI6IHNlbGVjdEFsbFxufTtcbi8qKlxuQSBjb3B5IG9mIGBwY0Jhc2VLZXltYXBgIHRoYXQgYWxzbyBiaW5kcyAqKkN0cmwtaCoqIGxpa2UgQmFja3NwYWNlLFxuKipDdHJsLWQqKiBsaWtlIERlbGV0ZSwgKipBbHQtQmFja3NwYWNlKiogbGlrZSBDdHJsLUJhY2tzcGFjZSwgYW5kXG4qKkN0cmwtQWx0LUJhY2tzcGFjZSoqLCAqKkFsdC1EZWxldGUqKiwgYW5kICoqQWx0LWQqKiBsaWtlXG5DdHJsLURlbGV0ZS5cbiovXG5jb25zdCBtYWNCYXNlS2V5bWFwID0ge1xuICAgIFwiQ3RybC1oXCI6IHBjQmFzZUtleW1hcFtcIkJhY2tzcGFjZVwiXSxcbiAgICBcIkFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLUJhY2tzcGFjZVwiXSxcbiAgICBcIkN0cmwtZFwiOiBwY0Jhc2VLZXltYXBbXCJEZWxldGVcIl0sXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1EZWxldGVcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkFsdC1kXCI6IHBjQmFzZUtleW1hcFtcIk1vZC1EZWxldGVcIl0sXG4gICAgXCJDdHJsLWFcIjogc2VsZWN0VGV4dGJsb2NrU3RhcnQsXG4gICAgXCJDdHJsLWVcIjogc2VsZWN0VGV4dGJsb2NrRW5kXG59O1xuZm9yIChsZXQga2V5IGluIHBjQmFzZUtleW1hcClcbiAgICBtYWNCYXNlS2V5bWFwW2tleV0gPSBwY0Jhc2VLZXltYXBba2V5XTtcbmNvbnN0IG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiA/IC9NYWN8aVAoaG9uZXxbb2FdZCkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICA6IHR5cGVvZiBvcyAhPSBcInVuZGVmaW5lZFwiICYmIG9zLnBsYXRmb3JtID8gb3MucGxhdGZvcm0oKSA9PSBcImRhcndpblwiIDogZmFsc2U7XG4vKipcbkRlcGVuZGluZyBvbiB0aGUgZGV0ZWN0ZWQgcGxhdGZvcm0sIHRoaXMgd2lsbCBob2xkXG5bYHBjQmFzZWtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5wY0Jhc2VLZXltYXApIG9yXG5bYG1hY0Jhc2VLZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMubWFjQmFzZUtleW1hcCkuXG4qL1xuY29uc3QgYmFzZUtleW1hcCA9IG1hYyA/IG1hY0Jhc2VLZXltYXAgOiBwY0Jhc2VLZXltYXA7XG5cbmV4cG9ydCB7IGF1dG9Kb2luLCBiYXNlS2V5bWFwLCBjaGFpbkNvbW1hbmRzLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBkZWxldGVTZWxlY3Rpb24sIGV4aXRDb2RlLCBqb2luQmFja3dhcmQsIGpvaW5Eb3duLCBqb2luRm9yd2FyZCwgam9pblRleHRibG9ja0JhY2t3YXJkLCBqb2luVGV4dGJsb2NrRm9yd2FyZCwgam9pblVwLCBsaWZ0LCBsaWZ0RW1wdHlCbG9jaywgbWFjQmFzZUtleW1hcCwgbmV3bGluZUluQ29kZSwgcGNCYXNlS2V5bWFwLCBzZWxlY3RBbGwsIHNlbGVjdE5vZGVCYWNrd2FyZCwgc2VsZWN0Tm9kZUZvcndhcmQsIHNlbGVjdFBhcmVudE5vZGUsIHNlbGVjdFRleHRibG9ja0VuZCwgc2VsZWN0VGV4dGJsb2NrU3RhcnQsIHNldEJsb2NrVHlwZSwgc3BsaXRCbG9jaywgc3BsaXRCbG9ja0FzLCBzcGxpdEJsb2NrS2VlcE1hcmtzLCB0b2dnbGVNYXJrLCB3cmFwSW4gfTtcbiIsICJpbXBvcnQgeyBmaW5kV3JhcHBpbmcsIFJlcGxhY2VBcm91bmRTdGVwLCBjYW5TcGxpdCwgbGlmdFRhcmdldCwgY2FuSm9pbiB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBOb2RlUmFuZ2UsIEZyYWdtZW50LCBTbGljZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuY29uc3Qgb2xET00gPSBbXCJvbFwiLCAwXSwgdWxET00gPSBbXCJ1bFwiLCAwXSwgbGlET00gPSBbXCJsaVwiLCAwXTtcbi8qKlxuQW4gb3JkZXJlZCBsaXN0IFtub2RlIHNwZWNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYykuIEhhcyBhIHNpbmdsZVxuYXR0cmlidXRlLCBgb3JkZXJgLCB3aGljaCBkZXRlcm1pbmVzIHRoZSBudW1iZXIgYXQgd2hpY2ggdGhlIGxpc3RcbnN0YXJ0cyBjb3VudGluZywgYW5kIGRlZmF1bHRzIHRvIDEuIFJlcHJlc2VudGVkIGFzIGFuIGA8b2w+YFxuZWxlbWVudC5cbiovXG5jb25zdCBvcmRlcmVkTGlzdCA9IHtcbiAgICBhdHRyczogeyBvcmRlcjogeyBkZWZhdWx0OiAxLCB2YWxpZGF0ZTogXCJudW1iZXJcIiB9IH0sXG4gICAgcGFyc2VET006IFt7IHRhZzogXCJvbFwiLCBnZXRBdHRycyhkb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvcmRlcjogZG9tLmhhc0F0dHJpYnV0ZShcInN0YXJ0XCIpID8gK2RvbS5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSA6IDEgfTtcbiAgICAgICAgICAgIH0gfV0sXG4gICAgdG9ET00obm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5hdHRycy5vcmRlciA9PSAxID8gb2xET00gOiBbXCJvbFwiLCB7IHN0YXJ0OiBub2RlLmF0dHJzLm9yZGVyIH0sIDBdO1xuICAgIH1cbn07XG4vKipcbkEgYnVsbGV0IGxpc3Qgbm9kZSBzcGVjLCByZXByZXNlbnRlZCBpbiB0aGUgRE9NIGFzIGA8dWw+YC5cbiovXG5jb25zdCBidWxsZXRMaXN0ID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwidWxcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIHVsRE9NOyB9XG59O1xuLyoqXG5BIGxpc3QgaXRlbSAoYDxsaT5gKSBzcGVjLlxuKi9cbmNvbnN0IGxpc3RJdGVtID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwibGlcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIGxpRE9NOyB9LFxuICAgIGRlZmluaW5nOiB0cnVlXG59O1xuZnVuY3Rpb24gYWRkKG9iaiwgcHJvcHMpIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpXG4gICAgICAgIGNvcHlbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8qKlxuQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFkZGluZyBsaXN0LXJlbGF0ZWQgbm9kZSB0eXBlcyB0byBhIG1hcFxuc3BlY2lmeWluZyB0aGUgbm9kZXMgZm9yIGEgc2NoZW1hLiBBZGRzXG5bYG9yZGVyZWRMaXN0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0Lm9yZGVyZWRMaXN0KSBhcyBgXCJvcmRlcmVkX2xpc3RcImAsXG5bYGJ1bGxldExpc3RgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3QuYnVsbGV0TGlzdCkgYXMgYFwiYnVsbGV0X2xpc3RcImAsIGFuZFxuW2BsaXN0SXRlbWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5saXN0SXRlbSkgYXMgYFwibGlzdF9pdGVtXCJgLlxuXG5gaXRlbUNvbnRlbnRgIGRldGVybWluZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbiBmb3IgdGhlIGxpc3QgaXRlbXMuXG5JZiB5b3Ugd2FudCB0aGUgY29tbWFuZHMgZGVmaW5lZCBpbiB0aGlzIG1vZHVsZSB0byBhcHBseSB0byB5b3VyXG5saXN0IHN0cnVjdHVyZSwgaXQgc2hvdWxkIGhhdmUgYSBzaGFwZSBsaWtlIGBcInBhcmFncmFwaCBibG9jaypcImAgb3JcbmBcInBhcmFncmFwaCAob3JkZXJlZF9saXN0IHwgYnVsbGV0X2xpc3QpKlwiYC4gYGxpc3RHcm91cGAgY2FuIGJlXG5naXZlbiB0byBhc3NpZ24gYSBncm91cCBuYW1lIHRvIHRoZSBsaXN0IG5vZGUgdHlwZXMsIGZvciBleGFtcGxlXG5gXCJibG9ja1wiYC5cbiovXG5mdW5jdGlvbiBhZGRMaXN0Tm9kZXMobm9kZXMsIGl0ZW1Db250ZW50LCBsaXN0R3JvdXApIHtcbiAgICByZXR1cm4gbm9kZXMuYXBwZW5kKHtcbiAgICAgICAgb3JkZXJlZF9saXN0OiBhZGQob3JkZXJlZExpc3QsIHsgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsIGdyb3VwOiBsaXN0R3JvdXAgfSksXG4gICAgICAgIGJ1bGxldF9saXN0OiBhZGQoYnVsbGV0TGlzdCwgeyBjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cCB9KSxcbiAgICAgICAgbGlzdF9pdGVtOiBhZGQobGlzdEl0ZW0sIHsgY29udGVudDogaXRlbUNvbnRlbnQgfSlcbiAgICB9KTtcbn1cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgc2VsZWN0aW9uIGluIGEgbGlzdCB3aXRoXG50aGUgZ2l2ZW4gdHlwZSBhbiBhdHRyaWJ1dGVzLiBJZiBgZGlzcGF0Y2hgIGlzIG51bGwsIG9ubHkgcmV0dXJuIGFcbnZhbHVlIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBpcyBwb3NzaWJsZSwgYnV0IGRvbid0IGFjdHVhbGx5XG5wZXJmb3JtIHRoZSBjaGFuZ2UuXG4qL1xuZnVuY3Rpb24gd3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGRpc3BhdGNoID8gc3RhdGUudHIgOiBudWxsO1xuICAgICAgICBpZiAoIXdyYXBSYW5nZUluTGlzdCh0ciwgcmFuZ2UsIGxpc3RUeXBlLCBhdHRycykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5UcnkgdG8gd3JhcCB0aGUgZ2l2ZW4gbm9kZSByYW5nZSBpbiBhIGxpc3Qgb2YgdGhlIGdpdmVuIHR5cGUuXG5SZXR1cm4gYHRydWVgIHdoZW4gdGhpcyBpcyBwb3NzaWJsZSwgYGZhbHNlYCBvdGhlcndpc2UuIFdoZW4gYHRyYFxuaXMgbm9uLW51bGwsIHRoZSB3cmFwcGluZyBpcyBhZGRlZCB0byB0aGF0IHRyYW5zYWN0aW9uLiBXaGVuIGl0IGlzXG5gbnVsbGAsIHRoZSBmdW5jdGlvbiBvbmx5IHF1ZXJpZXMgd2hldGhlciB0aGUgd3JhcHBpbmcgaXNcbnBvc3NpYmxlLlxuKi9cbmZ1bmN0aW9uIHdyYXBSYW5nZUluTGlzdCh0ciwgcmFuZ2UsIGxpc3RUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICBsZXQgZG9Kb2luID0gZmFsc2UsIG91dGVyUmFuZ2UgPSByYW5nZSwgZG9jID0gcmFuZ2UuJGZyb20uZG9jO1xuICAgIC8vIFRoaXMgaXMgYXQgdGhlIHRvcCBvZiBhbiBleGlzdGluZyBsaXN0IGl0ZW1cbiAgICBpZiAocmFuZ2UuZGVwdGggPj0gMiAmJiByYW5nZS4kZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZS5jb21wYXRpYmxlQ29udGVudChsaXN0VHlwZSkgJiYgcmFuZ2Uuc3RhcnRJbmRleCA9PSAwKSB7XG4gICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoaXMgaXMgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgICAgICBpZiAocmFuZ2UuJGZyb20uaW5kZXgocmFuZ2UuZGVwdGggLSAxKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgJGluc2VydCA9IGRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0IC0gMik7XG4gICAgICAgIG91dGVyUmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRpbnNlcnQsICRpbnNlcnQsIHJhbmdlLmRlcHRoKTtcbiAgICAgICAgaWYgKHJhbmdlLmVuZEluZGV4IDwgcmFuZ2UucGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UocmFuZ2UuJGZyb20sIGRvYy5yZXNvbHZlKHJhbmdlLiR0by5lbmQocmFuZ2UuZGVwdGgpKSwgcmFuZ2UuZGVwdGgpO1xuICAgICAgICBkb0pvaW4gPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgd3JhcCA9IGZpbmRXcmFwcGluZyhvdXRlclJhbmdlLCBsaXN0VHlwZSwgYXR0cnMsIHJhbmdlKTtcbiAgICBpZiAoIXdyYXApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHIpXG4gICAgICAgIGRvV3JhcEluTGlzdCh0ciwgcmFuZ2UsIHdyYXAsIGRvSm9pbiwgbGlzdFR5cGUpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZG9XcmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3RUeXBlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocmFuZ2Uuc3RhcnQgLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcmFuZ2UuZW5kLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuICAgIGxldCBmb3VuZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwcGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKHdyYXBwZXJzW2ldLnR5cGUgPT0gbGlzdFR5cGUpXG4gICAgICAgICAgICBmb3VuZCA9IGkgKyAxO1xuICAgIGxldCBzcGxpdERlcHRoID0gd3JhcHBlcnMubGVuZ3RoIC0gZm91bmQ7XG4gICAgbGV0IHNwbGl0UG9zID0gcmFuZ2Uuc3RhcnQgKyB3cmFwcGVycy5sZW5ndGggLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIGZvciAobGV0IGkgPSByYW5nZS5zdGFydEluZGV4LCBlID0gcmFuZ2UuZW5kSW5kZXgsIGZpcnN0ID0gdHJ1ZTsgaSA8IGU7IGkrKywgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWZpcnN0ICYmIGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHNwbGl0RGVwdGgpKSB7XG4gICAgICAgICAgICB0ci5zcGxpdChzcGxpdFBvcywgc3BsaXREZXB0aCk7XG4gICAgICAgICAgICBzcGxpdFBvcyArPSAyICogc3BsaXREZXB0aDtcbiAgICAgICAgfVxuICAgICAgICBzcGxpdFBvcyArPSBwYXJlbnQuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbi8qKlxuQnVpbGQgYSBjb21tYW5kIHRoYXQgc3BsaXRzIGEgbm9uLWVtcHR5IHRleHRibG9jayBhdCB0aGUgdG9wIGxldmVsXG5vZiBhIGxpc3QgaXRlbSBieSBhbHNvIHNwbGl0dGluZyB0aGF0IGxpc3QgaXRlbS5cbiovXG5mdW5jdGlvbiBzcGxpdExpc3RJdGVtKGl0ZW1UeXBlLCBpdGVtQXR0cnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvLCBub2RlIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICAgICAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT0gaXRlbVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgICAgICAgLy8gSW4gYW4gZW1wdHkgYmxvY2suIElmIHRoaXMgaXMgYSBuZXN0ZWQgbGlzdCwgdGhlIHdyYXBwaW5nXG4gICAgICAgICAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgICAgICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgICAgICAgIGlmICgkZnJvbS5kZXB0aCA9PSAzIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT0gaXRlbVR5cGUgfHxcbiAgICAgICAgICAgICAgICAkZnJvbS5pbmRleCgtMikgIT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXAgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhCZWZvcmUgPSAkZnJvbS5pbmRleCgtMSkgPyAxIDogJGZyb20uaW5kZXgoLTIpID8gMiA6IDM7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgYSBmcmFnbWVudCBjb250YWluaW5nIGVtcHR5IHZlcnNpb25zIG9mIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQtLSlcbiAgICAgICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogMztcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBzZWNvbmQgbGlzdCBpdGVtIHdpdGggYW4gZW1wdHkgZGVmYXVsdCBzdGFydCBub2RlXG4gICAgICAgICAgICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpO1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpO1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSAtMTtcbiAgICAgICAgICAgICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgbm9kZS5jb250ZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoc2VsKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRUeXBlID0gJHRvLnBvcyA9PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbDtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgICAgIGxldCB0eXBlcyA9IG5leHRUeXBlID8gW2l0ZW1BdHRycyA/IHsgdHlwZTogaXRlbVR5cGUsIGF0dHJzOiBpdGVtQXR0cnMgfSA6IG51bGwsIHsgdHlwZTogbmV4dFR5cGUgfV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghY2FuU3BsaXQodHIuZG9jLCAkZnJvbS5wb3MsIDIsIHR5cGVzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkFjdHMgbGlrZSBbYHNwbGl0TGlzdEl0ZW1gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3Quc3BsaXRMaXN0SXRlbSksIGJ1dFxud2l0aG91dCByZXNldHRpbmcgdGhlIHNldCBvZiBhY3RpdmUgbWFya3MgYXQgdGhlIGN1cnNvci5cbiovXG5mdW5jdGlvbiBzcGxpdExpc3RJdGVtS2VlcE1hcmtzKGl0ZW1UeXBlLCBpdGVtQXR0cnMpIHtcbiAgICBsZXQgc3BsaXQgPSBzcGxpdExpc3RJdGVtKGl0ZW1UeXBlLCBpdGVtQXR0cnMpO1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgICAgIHJldHVybiBzcGxpdChzdGF0ZSwgZGlzcGF0Y2ggJiYgKHRyID0+IHtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgICAgICBpZiAobWFya3MpXG4gICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tbWFuZCB0byBsaWZ0IHRoZSBsaXN0IGl0ZW0gYXJvdW5kIHRoZSBzZWxlY3Rpb24gdXAgaW50b1xuYSB3cmFwcGluZyBsaXN0LlxuKi9cbmZ1bmN0aW9uIGxpZnRMaXN0SXRlbShpdGVtVHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8sIG5vZGUgPT4gbm9kZS5jaGlsZENvdW50ID4gMCAmJiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PSBpdGVtVHlwZSk7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGlzcGF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlID09IGl0ZW1UeXBlKSAvLyBJbnNpZGUgYSBwYXJlbnQgbGlzdFxuICAgICAgICAgICAgcmV0dXJuIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSk7XG4gICAgICAgIGVsc2UgLy8gT3V0ZXIgbGlzdCBub2RlXG4gICAgICAgICAgICByZXR1cm4gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlmdFRvT3V0ZXJMaXN0KHN0YXRlLCBkaXNwYXRjaCwgaXRlbVR5cGUsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGVuZCA9IHJhbmdlLmVuZCwgZW5kT2ZMaXN0ID0gcmFuZ2UuJHRvLmVuZChyYW5nZS5kZXB0aCk7XG4gICAgaWYgKGVuZCA8IGVuZE9mTGlzdCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc2libGluZ3MgYWZ0ZXIgdGhlIGxpZnRlZCBpdGVtcywgd2hpY2ggbXVzdCBiZWNvbWVcbiAgICAgICAgLy8gY2hpbGRyZW4gb2YgdGhlIGxhc3QgaXRlbVxuICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChlbmQgLSAxLCBlbmRPZkxpc3QsIGVuZCwgZW5kT2ZMaXN0LCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGUobnVsbCwgcmFuZ2UucGFyZW50LmNvcHkoKSkpLCAxLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UodHIuZG9jLnJlc29sdmUocmFuZ2UuJGZyb20ucG9zKSwgdHIuZG9jLnJlc29sdmUoZW5kT2ZMaXN0KSwgcmFuZ2UuZGVwdGgpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0ci5saWZ0KHJhbmdlLCB0YXJnZXQpO1xuICAgIGxldCAkYWZ0ZXIgPSB0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcChlbmQsIC0xKSAtIDEpO1xuICAgIGlmIChjYW5Kb2luKHRyLmRvYywgJGFmdGVyLnBvcykgJiYgJGFmdGVyLm5vZGVCZWZvcmUudHlwZSA9PSAkYWZ0ZXIubm9kZUFmdGVyLnR5cGUpXG4gICAgICAgIHRyLmpvaW4oJGFmdGVyLnBvcyk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpIHtcbiAgICBsZXQgdHIgPSBzdGF0ZS50ciwgbGlzdCA9IHJhbmdlLnBhcmVudDtcbiAgICAvLyBNZXJnZSB0aGUgbGlzdCBpdGVtcyBpbnRvIGEgc2luZ2xlIGJpZyBpdGVtXG4gICAgZm9yIChsZXQgcG9zID0gcmFuZ2UuZW5kLCBpID0gcmFuZ2UuZW5kSW5kZXggLSAxLCBlID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGU7IGktLSkge1xuICAgICAgICBwb3MgLT0gbGlzdC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgdHIuZGVsZXRlKHBvcyAtIDEsIHBvcyArIDEpO1xuICAgIH1cbiAgICBsZXQgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQpLCBpdGVtID0gJHN0YXJ0Lm5vZGVBZnRlcjtcbiAgICBpZiAodHIubWFwcGluZy5tYXAocmFuZ2UuZW5kKSAhPSByYW5nZS5zdGFydCArICRzdGFydC5ub2RlQWZ0ZXIubm9kZVNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYXRTdGFydCA9IHJhbmdlLnN0YXJ0SW5kZXggPT0gMCwgYXRFbmQgPSByYW5nZS5lbmRJbmRleCA9PSBsaXN0LmNoaWxkQ291bnQ7XG4gICAgbGV0IHBhcmVudCA9ICRzdGFydC5ub2RlKC0xKSwgaW5kZXhCZWZvcmUgPSAkc3RhcnQuaW5kZXgoLTEpO1xuICAgIGlmICghcGFyZW50LmNhblJlcGxhY2UoaW5kZXhCZWZvcmUgKyAoYXRTdGFydCA/IDAgOiAxKSwgaW5kZXhCZWZvcmUgKyAxLCBpdGVtLmNvbnRlbnQuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QpKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc3RhcnQgPSAkc3RhcnQucG9zLCBlbmQgPSBzdGFydCArIGl0ZW0ubm9kZVNpemU7XG4gICAgLy8gU3RyaXAgb2ZmIHRoZSBzdXJyb3VuZGluZyBsaXN0LiBBdCB0aGUgc2lkZXMgd2hlcmUgd2UncmUgbm90IGF0XG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgbGlzdCwgdGhlIGV4aXN0aW5nIGxpc3QgaXMgY2xvc2VkLiBBdCBzaWRlcyB3aGVyZVxuICAgIC8vIHRoaXMgaXMgdGhlIGVuZCwgaXQgaXMgb3ZlcndyaXR0ZW4gdG8gaXRzIGVuZC5cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSwgbmV3IFNsaWNlKChhdFN0YXJ0ID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKVxuICAgICAgICAuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKSwgYXRTdGFydCA/IDAgOiAxLCBhdEVuZCA/IDAgOiAxKSwgYXRTdGFydCA/IDAgOiAxKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gc2luayB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGRvd25cbmludG8gYW4gaW5uZXIgbGlzdC5cbiovXG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBwYXJlbnQgPSByYW5nZS5wYXJlbnQsIG5vZGVCZWZvcmUgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpO1xuICAgICAgICBpZiAobm9kZUJlZm9yZS50eXBlICE9IGl0ZW1UeXBlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBuZXN0ZWRCZWZvcmUgPSBub2RlQmVmb3JlLmxhc3RDaGlsZCAmJiBub2RlQmVmb3JlLmxhc3RDaGlsZC50eXBlID09IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgbGV0IGlubmVyID0gRnJhZ21lbnQuZnJvbShuZXN0ZWRCZWZvcmUgPyBpdGVtVHlwZS5jcmVhdGUoKSA6IG51bGwpO1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20ocGFyZW50LnR5cGUuY3JlYXRlKG51bGwsIGlubmVyKSkpKSwgbmVzdGVkQmVmb3JlID8gMyA6IDEsIDApO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHJhbmdlLnN0YXJ0LCBhZnRlciA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKGJlZm9yZSAtIChuZXN0ZWRCZWZvcmUgPyAzIDogMSksIGFmdGVyLCBiZWZvcmUsIGFmdGVyLCBzbGljZSwgMSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGFkZExpc3ROb2RlcywgYnVsbGV0TGlzdCwgbGlmdExpc3RJdGVtLCBsaXN0SXRlbSwgb3JkZXJlZExpc3QsIHNpbmtMaXN0SXRlbSwgc3BsaXRMaXN0SXRlbSwgc3BsaXRMaXN0SXRlbUtlZXBNYXJrcywgd3JhcEluTGlzdCwgd3JhcFJhbmdlSW5MaXN0IH07XG4iLCAiaW1wb3J0IHR5cGUgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG4vKipcbiAqIFRha2VzIGEgVHJhbnNhY3Rpb24gJiBFZGl0b3IgU3RhdGUgYW5kIHR1cm5zIGl0IGludG8gYSBjaGFpbmFibGUgc3RhdGUgb2JqZWN0XG4gKiBAcGFyYW0gY29uZmlnIFRoZSB0cmFuc2FjdGlvbiBhbmQgc3RhdGUgdG8gY3JlYXRlIHRoZSBjaGFpbmFibGUgc3RhdGUgZnJvbVxuICogQHJldHVybnMgQSBjaGFpbmFibGUgRWRpdG9yIHN0YXRlIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoY29uZmlnOiB7IHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbjsgc3RhdGU6IEVkaXRvclN0YXRlIH0pOiBFZGl0b3JTdGF0ZSB7XG4gIGNvbnN0IHsgc3RhdGUsIHRyYW5zYWN0aW9uIH0gPSBjb25maWdcbiAgbGV0IHsgc2VsZWN0aW9uIH0gPSB0cmFuc2FjdGlvblxuICBsZXQgeyBkb2MgfSA9IHRyYW5zYWN0aW9uXG4gIGxldCB7IHN0b3JlZE1hcmtzIH0gPSB0cmFuc2FjdGlvblxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgYXBwbHk6IHN0YXRlLmFwcGx5LmJpbmQoc3RhdGUpLFxuICAgIGFwcGx5VHJhbnNhY3Rpb246IHN0YXRlLmFwcGx5VHJhbnNhY3Rpb24uYmluZChzdGF0ZSksXG4gICAgcGx1Z2luczogc3RhdGUucGx1Z2lucyxcbiAgICBzY2hlbWE6IHN0YXRlLnNjaGVtYSxcbiAgICByZWNvbmZpZ3VyZTogc3RhdGUucmVjb25maWd1cmUuYmluZChzdGF0ZSksXG4gICAgdG9KU09OOiBzdGF0ZS50b0pTT04uYmluZChzdGF0ZSksXG4gICAgZ2V0IHN0b3JlZE1hcmtzKCkge1xuICAgICAgcmV0dXJuIHN0b3JlZE1hcmtzXG4gICAgfSxcbiAgICBnZXQgc2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGlvblxuICAgIH0sXG4gICAgZ2V0IGRvYygpIHtcbiAgICAgIHJldHVybiBkb2NcbiAgICB9LFxuICAgIGdldCB0cigpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHRyYW5zYWN0aW9uLnNlbGVjdGlvblxuICAgICAgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gICAgICBzdG9yZWRNYXJrcyA9IHRyYW5zYWN0aW9uLnN0b3JlZE1hcmtzXG5cbiAgICAgIHJldHVybiB0cmFuc2FjdGlvblxuICAgIH0sXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IEVkaXRvclN0YXRlLCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB0eXBlIHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4vaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS5qcydcbmltcG9ydCB0eXBlIHsgQW55Q29tbWFuZHMsIENhbkNvbW1hbmRzLCBDaGFpbmVkQ29tbWFuZHMsIENvbW1hbmRQcm9wcywgU2luZ2xlQ29tbWFuZHMgfSBmcm9tICcuL3R5cGVzLmpzJ1xuXG5leHBvcnQgY2xhc3MgQ29tbWFuZE1hbmFnZXIge1xuICBlZGl0b3I6IEVkaXRvclxuXG4gIHJhd0NvbW1hbmRzOiBBbnlDb21tYW5kc1xuXG4gIGN1c3RvbVN0YXRlPzogRWRpdG9yU3RhdGVcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgc3RhdGU/OiBFZGl0b3JTdGF0ZSB9KSB7XG4gICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3JcbiAgICB0aGlzLnJhd0NvbW1hbmRzID0gdGhpcy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5jb21tYW5kc1xuICAgIHRoaXMuY3VzdG9tU3RhdGUgPSBwcm9wcy5zdGF0ZVxuICB9XG5cbiAgZ2V0IGhhc0N1c3RvbVN0YXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuY3VzdG9tU3RhdGVcbiAgfVxuXG4gIGdldCBzdGF0ZSgpOiBFZGl0b3JTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuY3VzdG9tU3RhdGUgfHwgdGhpcy5lZGl0b3Iuc3RhdGVcbiAgfVxuXG4gIGdldCBjb21tYW5kcygpOiBTaW5nbGVDb21tYW5kcyB7XG4gICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yXG4gICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0cilcblxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKVxuXG4gICAgICAgICAgaWYgKCF0ci5nZXRNZXRhKCdwcmV2ZW50RGlzcGF0Y2gnKSAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2tcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbmFtZSwgbWV0aG9kXVxuICAgICAgfSksXG4gICAgKSBhcyB1bmtub3duIGFzIFNpbmdsZUNvbW1hbmRzXG4gIH1cblxuICBnZXQgY2hhaW4oKTogKCkgPT4gQ2hhaW5lZENvbW1hbmRzIHtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5jcmVhdGVDaGFpbigpXG4gIH1cblxuICBnZXQgY2FuKCk6ICgpID0+IENhbkNvbW1hbmRzIHtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5jcmVhdGVDYW4oKVxuICB9XG5cbiAgcHVibGljIGNyZWF0ZUNoYWluKHN0YXJ0VHI/OiBUcmFuc2FjdGlvbiwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKTogQ2hhaW5lZENvbW1hbmRzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3JcbiAgICBjb25zdCBjYWxsYmFja3M6IGJvb2xlYW5bXSA9IFtdXG4gICAgY29uc3QgaGFzU3RhcnRUcmFuc2FjdGlvbiA9ICEhc3RhcnRUclxuICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50clxuXG4gICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgaWYgKCFoYXNTdGFydFRyYW5zYWN0aW9uICYmIHNob3VsZERpc3BhdGNoICYmICF0ci5nZXRNZXRhKCdwcmV2ZW50RGlzcGF0Y2gnKSAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZSkge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbGJhY2tzLmV2ZXJ5KGNhbGxiYWNrID0+IGNhbGxiYWNrID09PSB0cnVlKVxuICAgIH1cblxuICAgIGNvbnN0IGNoYWluID0ge1xuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICBjb25zdCBjaGFpbmVkQ29tbWFuZCA9ICguLi5hcmdzOiBuZXZlcltdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgc2hvdWxkRGlzcGF0Y2gpXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbW1hbmQoLi4uYXJncykocHJvcHMpXG5cbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKVxuXG4gICAgICAgICAgICByZXR1cm4gY2hhaW5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW25hbWUsIGNoYWluZWRDb21tYW5kXVxuICAgICAgICB9KSxcbiAgICAgICksXG4gICAgICBydW4sXG4gICAgfSBhcyB1bmtub3duIGFzIENoYWluZWRDb21tYW5kc1xuXG4gICAgcmV0dXJuIGNoYWluXG4gIH1cblxuICBwdWJsaWMgY3JlYXRlQ2FuKHN0YXJ0VHI/OiBUcmFuc2FjdGlvbik6IENhbkNvbW1hbmRzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBzdGF0ZSB9ID0gdGhpc1xuICAgIGNvbnN0IGRpc3BhdGNoID0gZmFsc2VcbiAgICBjb25zdCB0ciA9IHN0YXJ0VHIgfHwgc3RhdGUudHJcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgZGlzcGF0Y2gpXG4gICAgY29uc3QgZm9ybWF0dGVkQ29tbWFuZHMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJnczogbmV2ZXJbXSkgPT4gY29tbWFuZCguLi5hcmdzKSh7IC4uLnByb3BzLCBkaXNwYXRjaDogdW5kZWZpbmVkIH0pXVxuICAgICAgfSksXG4gICAgKSBhcyB1bmtub3duIGFzIFNpbmdsZUNvbW1hbmRzXG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZm9ybWF0dGVkQ29tbWFuZHMsXG4gICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgZGlzcGF0Y2gpLFxuICAgIH0gYXMgQ2FuQ29tbWFuZHNcbiAgfVxuXG4gIHB1YmxpYyBidWlsZFByb3BzKHRyOiBUcmFuc2FjdGlvbiwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKTogQ29tbWFuZFByb3BzIHtcbiAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzXG4gICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3JcblxuICAgIGNvbnN0IHByb3BzOiBDb21tYW5kUHJvcHMgPSB7XG4gICAgICB0cixcbiAgICAgIGVkaXRvcixcbiAgICAgIHZpZXcsXG4gICAgICBzdGF0ZTogY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgfSksXG4gICAgICBkaXNwYXRjaDogc2hvdWxkRGlzcGF0Y2ggPyAoKSA9PiB1bmRlZmluZWQgOiB1bmRlZmluZWQsXG4gICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgc2hvdWxkRGlzcGF0Y2gpLFxuICAgICAgY2FuOiAoKSA9PiB0aGlzLmNyZWF0ZUNhbih0ciksXG4gICAgICBnZXQgY29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gW25hbWUsICguLi5hcmdzOiBuZXZlcltdKSA9PiBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKV1cbiAgICAgICAgICB9KSxcbiAgICAgICAgKSBhcyB1bmtub3duIGFzIFNpbmdsZUNvbW1hbmRzXG4gICAgICB9LFxuICAgIH1cblxuICAgIHJldHVybiBwcm9wc1xuICB9XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LW9iamVjdC10eXBlICovXG5pbXBvcnQgdHlwZSB7IE1hcmtUeXBlLCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgTm9kZVR5cGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgdHlwZSB7IFBsdWdpbiwgUGx1Z2luS2V5LCBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5pbXBvcnQgeyBDb21tYW5kTWFuYWdlciB9IGZyb20gJy4vQ29tbWFuZE1hbmFnZXIuanMnXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL0V2ZW50RW1pdHRlci5qcydcbmltcG9ydCB7IEV4dGVuc2lvbk1hbmFnZXIgfSBmcm9tICcuL0V4dGVuc2lvbk1hbmFnZXIuanMnXG5pbXBvcnQge1xuICBDbGlwYm9hcmRUZXh0U2VyaWFsaXplcixcbiAgQ29tbWFuZHMsXG4gIERlbGV0ZSxcbiAgRHJvcCxcbiAgRWRpdGFibGUsXG4gIEZvY3VzRXZlbnRzLFxuICBLZXltYXAsXG4gIFBhc3RlLFxuICBUYWJpbmRleCxcbn0gZnJvbSAnLi9leHRlbnNpb25zL2luZGV4LmpzJ1xuaW1wb3J0IHsgY3JlYXRlRG9jdW1lbnQgfSBmcm9tICcuL2hlbHBlcnMvY3JlYXRlRG9jdW1lbnQuanMnXG5pbXBvcnQgeyBnZXRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9oZWxwZXJzL2dldEF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRIVE1MRnJvbUZyYWdtZW50IH0gZnJvbSAnLi9oZWxwZXJzL2dldEhUTUxGcm9tRnJhZ21lbnQuanMnXG5pbXBvcnQgeyBnZXRUZXh0IH0gZnJvbSAnLi9oZWxwZXJzL2dldFRleHQuanMnXG5pbXBvcnQgeyBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIH0gZnJvbSAnLi9oZWxwZXJzL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5pbXBvcnQgeyBpc0FjdGl2ZSB9IGZyb20gJy4vaGVscGVycy9pc0FjdGl2ZS5qcydcbmltcG9ydCB7IGlzTm9kZUVtcHR5IH0gZnJvbSAnLi9oZWxwZXJzL2lzTm9kZUVtcHR5LmpzJ1xuaW1wb3J0IHsgcmVzb2x2ZUZvY3VzUG9zaXRpb24gfSBmcm9tICcuL2hlbHBlcnMvcmVzb2x2ZUZvY3VzUG9zaXRpb24uanMnXG5pbXBvcnQgdHlwZSB7IFN0b3JhZ2UgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHsgTm9kZVBvcyB9IGZyb20gJy4vTm9kZVBvcy5qcydcbmltcG9ydCB7IHN0eWxlIH0gZnJvbSAnLi9zdHlsZS5qcydcbmltcG9ydCB0eXBlIHtcbiAgQ2FuQ29tbWFuZHMsXG4gIENoYWluZWRDb21tYW5kcyxcbiAgRG9jdW1lbnRUeXBlLFxuICBFZGl0b3JFdmVudHMsXG4gIEVkaXRvck9wdGlvbnMsXG4gIE5vZGVUeXBlIGFzIFROb2RlVHlwZSxcbiAgU2luZ2xlQ29tbWFuZHMsXG4gIFRleHRTZXJpYWxpemVyLFxuICBUZXh0VHlwZSBhcyBUVGV4dFR5cGUsXG59IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBjcmVhdGVTdHlsZVRhZyB9IGZyb20gJy4vdXRpbGl0aWVzL2NyZWF0ZVN0eWxlVGFnLmpzJ1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbGl0aWVzL2lzRnVuY3Rpb24uanMnXG5cbmV4cG9ydCAqIGFzIGV4dGVuc2lvbnMgZnJvbSAnLi9leHRlbnNpb25zL2luZGV4LmpzJ1xuXG4vLyBAdHMtaWdub3JlXG5leHBvcnQgaW50ZXJmYWNlIFRpcHRhcEVkaXRvckhUTUxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBlZGl0b3I/OiBFZGl0b3Jcbn1cblxuZXhwb3J0IGNsYXNzIEVkaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlcjxFZGl0b3JFdmVudHM+IHtcbiAgcHJpdmF0ZSBjb21tYW5kTWFuYWdlciE6IENvbW1hbmRNYW5hZ2VyXG5cbiAgcHVibGljIGV4dGVuc2lvbk1hbmFnZXIhOiBFeHRlbnNpb25NYW5hZ2VyXG5cbiAgcHJpdmF0ZSBjc3M6IEhUTUxTdHlsZUVsZW1lbnQgfCBudWxsID0gbnVsbFxuXG4gIHB1YmxpYyBzY2hlbWEhOiBTY2hlbWFcblxuICBwcml2YXRlIGVkaXRvclZpZXc6IEVkaXRvclZpZXcgfCBudWxsID0gbnVsbFxuXG4gIHB1YmxpYyBpc0ZvY3VzZWQgPSBmYWxzZVxuXG4gIHByaXZhdGUgZWRpdG9yU3RhdGUhOiBFZGl0b3JTdGF0ZVxuXG4gIC8qKlxuICAgKiBUaGUgZWRpdG9yIGlzIGNvbnNpZGVyZWQgaW5pdGlhbGl6ZWQgYWZ0ZXIgdGhlIGBjcmVhdGVgIGV2ZW50IGhhcyBiZWVuIGVtaXR0ZWQuXG4gICAqL1xuICBwdWJsaWMgaXNJbml0aWFsaXplZCA9IGZhbHNlXG5cbiAgcHVibGljIGV4dGVuc2lvblN0b3JhZ2U6IFN0b3JhZ2UgPSB7fSBhcyBTdG9yYWdlXG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIElEIGZvciB0aGlzIGVkaXRvciBpbnN0YW5jZS5cbiAgICovXG4gIHB1YmxpYyBpbnN0YW5jZUlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgOSlcblxuICBwdWJsaWMgb3B0aW9uczogRWRpdG9yT3B0aW9ucyA9IHtcbiAgICBlbGVtZW50OiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsLFxuICAgIGNvbnRlbnQ6ICcnLFxuICAgIGluamVjdENTUzogdHJ1ZSxcbiAgICBpbmplY3ROb25jZTogdW5kZWZpbmVkLFxuICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgIGF1dG9mb2N1czogZmFsc2UsXG4gICAgZWRpdGFibGU6IHRydWUsXG4gICAgZWRpdG9yUHJvcHM6IHt9LFxuICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgY29yZUV4dGVuc2lvbk9wdGlvbnM6IHt9LFxuICAgIGVuYWJsZUlucHV0UnVsZXM6IHRydWUsXG4gICAgZW5hYmxlUGFzdGVSdWxlczogdHJ1ZSxcbiAgICBlbmFibGVDb3JlRXh0ZW5zaW9uczogdHJ1ZSxcbiAgICBlbmFibGVDb250ZW50Q2hlY2s6IGZhbHNlLFxuICAgIGVtaXRDb250ZW50RXJyb3I6IGZhbHNlLFxuICAgIG9uQmVmb3JlQ3JlYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uQ3JlYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uU2VsZWN0aW9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgIG9uVHJhbnNhY3Rpb246ICgpID0+IG51bGwsXG4gICAgb25Gb2N1czogKCkgPT4gbnVsbCxcbiAgICBvbkJsdXI6ICgpID0+IG51bGwsXG4gICAgb25EZXN0cm95OiAoKSA9PiBudWxsLFxuICAgIG9uQ29udGVudEVycm9yOiAoeyBlcnJvciB9KSA9PiB7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH0sXG4gICAgb25QYXN0ZTogKCkgPT4gbnVsbCxcbiAgICBvbkRyb3A6ICgpID0+IG51bGwsXG4gICAgb25EZWxldGU6ICgpID0+IG51bGwsXG4gIH1cblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBQYXJ0aWFsPEVkaXRvck9wdGlvbnM+ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpXG4gICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKClcbiAgICB0aGlzLmNyZWF0ZUNvbW1hbmRNYW5hZ2VyKClcbiAgICB0aGlzLmNyZWF0ZVNjaGVtYSgpXG4gICAgdGhpcy5vbignYmVmb3JlQ3JlYXRlJywgdGhpcy5vcHRpb25zLm9uQmVmb3JlQ3JlYXRlKVxuICAgIHRoaXMuZW1pdCgnYmVmb3JlQ3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSlcbiAgICB0aGlzLm9uKCdjb250ZW50RXJyb3InLCB0aGlzLm9wdGlvbnMub25Db250ZW50RXJyb3IpXG4gICAgdGhpcy5vbignY3JlYXRlJywgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKVxuICAgIHRoaXMub24oJ3VwZGF0ZScsIHRoaXMub3B0aW9ucy5vblVwZGF0ZSlcbiAgICB0aGlzLm9uKCdzZWxlY3Rpb25VcGRhdGUnLCB0aGlzLm9wdGlvbnMub25TZWxlY3Rpb25VcGRhdGUpXG4gICAgdGhpcy5vbigndHJhbnNhY3Rpb24nLCB0aGlzLm9wdGlvbnMub25UcmFuc2FjdGlvbilcbiAgICB0aGlzLm9uKCdmb2N1cycsIHRoaXMub3B0aW9ucy5vbkZvY3VzKVxuICAgIHRoaXMub24oJ2JsdXInLCB0aGlzLm9wdGlvbnMub25CbHVyKVxuICAgIHRoaXMub24oJ2Rlc3Ryb3knLCB0aGlzLm9wdGlvbnMub25EZXN0cm95KVxuICAgIHRoaXMub24oJ2Ryb3AnLCAoeyBldmVudCwgc2xpY2UsIG1vdmVkIH0pID0+IHRoaXMub3B0aW9ucy5vbkRyb3AoZXZlbnQsIHNsaWNlLCBtb3ZlZCkpXG4gICAgdGhpcy5vbigncGFzdGUnLCAoeyBldmVudCwgc2xpY2UgfSkgPT4gdGhpcy5vcHRpb25zLm9uUGFzdGUoZXZlbnQsIHNsaWNlKSlcbiAgICB0aGlzLm9uKCdkZWxldGUnLCB0aGlzLm9wdGlvbnMub25EZWxldGUpXG5cbiAgICBjb25zdCBpbml0aWFsRG9jID0gdGhpcy5jcmVhdGVEb2MoKVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKGluaXRpYWxEb2MsIHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpXG5cbiAgICAvLyBTZXQgZWRpdG9yIHN0YXRlIGltbWVkaWF0ZWx5LCBzbyB0aGF0IGl0J3MgYXZhaWxhYmxlIGluZGVwZW5kZW50bHkgZnJvbSB0aGUgdmlld1xuICAgIHRoaXMuZWRpdG9yU3RhdGUgPSBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgZG9jOiBpbml0aWFsRG9jLFxuICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgIHNlbGVjdGlvbjogc2VsZWN0aW9uIHx8IHVuZGVmaW5lZCxcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICB0aGlzLm1vdW50KHRoaXMub3B0aW9ucy5lbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggdGhlIGVkaXRvciB0byB0aGUgRE9NLCBjcmVhdGluZyBhIG5ldyBlZGl0b3Igdmlldy5cbiAgICovXG4gIHB1YmxpYyBtb3VudChlbDogTm9uTnVsbGFibGU8RWRpdG9yT3B0aW9uc1snZWxlbWVudCddPiAmIHt9KSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFt0aXB0YXAgZXJyb3JdOiBUaGUgZWRpdG9yIGNhbm5vdCBiZSBtb3VudGVkIGJlY2F1c2UgdGhlcmUgaXMgbm8gJ2RvY3VtZW50JyBkZWZpbmVkIGluIHRoaXMgZW52aXJvbm1lbnQuYCxcbiAgICAgIClcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVWaWV3KGVsKVxuXG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29tbWFuZHMuZm9jdXModGhpcy5vcHRpb25zLmF1dG9mb2N1cylcbiAgICAgIHRoaXMuZW1pdCgnY3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSlcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWVcbiAgICB9LCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZWRpdG9yIGZyb20gdGhlIERPTSwgYnV0IHN0aWxsIGFsbG93IHJlbW91bnRpbmcgYXQgYSBkaWZmZXJlbnQgcG9pbnQgaW4gdGltZVxuICAgKi9cbiAgcHVibGljIHVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuZWRpdG9yVmlldykge1xuICAgICAgLy8gQ2xlYW51cCBvdXIgcmVmZXJlbmNlIHRvIHByZXZlbnQgY2lyY3VsYXIgcmVmZXJlbmNlcyB3aGljaCBjYXVzZWQgbWVtb3J5IGxlYWtzXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBkb20gPSB0aGlzLmVkaXRvclZpZXcuZG9tIGFzIFRpcHRhcEVkaXRvckhUTUxFbGVtZW50XG5cbiAgICAgIGlmIChkb20/LmVkaXRvcikge1xuICAgICAgICBkZWxldGUgZG9tLmVkaXRvclxuICAgICAgfVxuICAgICAgdGhpcy5lZGl0b3JWaWV3LmRlc3Ryb3koKVxuICAgIH1cbiAgICB0aGlzLmVkaXRvclZpZXcgPSBudWxsXG4gICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2VcbiAgICB0aGlzLmNzcz8ucmVtb3ZlKClcbiAgICB0aGlzLmNzcyA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RvcmFnZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RvcmFnZSgpOiBTdG9yYWdlIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25TdG9yYWdlXG4gIH1cblxuICAvKipcbiAgICogQW4gb2JqZWN0IG9mIGFsbCByZWdpc3RlcmVkIGNvbW1hbmRzLlxuICAgKi9cbiAgcHVibGljIGdldCBjb21tYW5kcygpOiBTaW5nbGVDb21tYW5kcyB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY29tbWFuZHNcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBjb21tYW5kIGNoYWluIHRvIGNhbGwgbXVsdGlwbGUgY29tbWFuZHMgYXQgb25jZS5cbiAgICovXG4gIHB1YmxpYyBjaGFpbigpOiBDaGFpbmVkQ29tbWFuZHMge1xuICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNoYWluKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGNvbW1hbmQgb3IgYSBjb21tYW5kIGNoYWluIGNhbiBiZSBleGVjdXRlZC4gV2l0aG91dCBleGVjdXRpbmcgaXQuXG4gICAqL1xuICBwdWJsaWMgY2FuKCk6IENhbkNvbW1hbmRzIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jYW4oKVxuICB9XG5cbiAgLyoqXG4gICAqIEluamVjdCBDU1Mgc3R5bGVzLlxuICAgKi9cbiAgcHJpdmF0ZSBpbmplY3RDU1MoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbmplY3RDU1MgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5jc3MgPSBjcmVhdGVTdHlsZVRhZyhzdHlsZSwgdGhpcy5vcHRpb25zLmluamVjdE5vbmNlKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZWRpdG9yIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIEEgbGlzdCBvZiBvcHRpb25zXG4gICAqL1xuICBwdWJsaWMgc2V0T3B0aW9ucyhvcHRpb25zOiBQYXJ0aWFsPEVkaXRvck9wdGlvbnM+ID0ge30pOiB2b2lkIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH1cblxuICAgIGlmICghdGhpcy5lZGl0b3JWaWV3IHx8ICF0aGlzLnN0YXRlIHx8IHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpIHtcbiAgICAgIHRoaXMudmlldy5zZXRQcm9wcyh0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpXG4gICAgfVxuXG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGVkaXRhYmxlIHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gICAqL1xuICBwdWJsaWMgc2V0RWRpdGFibGUoZWRpdGFibGU6IGJvb2xlYW4sIGVtaXRVcGRhdGUgPSB0cnVlKTogdm9pZCB7XG4gICAgdGhpcy5zZXRPcHRpb25zKHsgZWRpdGFibGUgfSlcblxuICAgIGlmIChlbWl0VXBkYXRlKSB7XG4gICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHsgZWRpdG9yOiB0aGlzLCB0cmFuc2FjdGlvbjogdGhpcy5zdGF0ZS50ciwgYXBwZW5kZWRUcmFuc2FjdGlvbnM6IFtdIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLlxuICAgKi9cbiAgcHVibGljIGdldCBpc0VkaXRhYmxlKCk6IGJvb2xlYW4ge1xuICAgIC8vIHNpbmNlIHBsdWdpbnMgYXJlIGFwcGxpZWQgYWZ0ZXIgY3JlYXRpbmcgdGhlIHZpZXdcbiAgICAvLyBgZWRpdGFibGVgIGlzIGFsd2F5cyBgdHJ1ZWAgZm9yIG9uZSB0aWNrLlxuICAgIC8vIHRoYXTigJlzIHdoeSB3ZSBhbHNvIGhhdmUgdG8gY2hlY2sgZm9yIGBvcHRpb25zLmVkaXRhYmxlYFxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZWRpdGFibGUgJiYgdGhpcy52aWV3ICYmIHRoaXMudmlldy5lZGl0YWJsZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgdmlldygpOiBFZGl0b3JWaWV3IHtcbiAgICBpZiAodGhpcy5lZGl0b3JWaWV3KSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3JWaWV3XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm94eShcbiAgICAgIHtcbiAgICAgICAgc3RhdGU6IHRoaXMuZWRpdG9yU3RhdGUsXG4gICAgICAgIHVwZGF0ZVN0YXRlOiAoc3RhdGU6IEVkaXRvclN0YXRlKTogUmV0dXJuVHlwZTxFZGl0b3JWaWV3Wyd1cGRhdGVTdGF0ZSddPiA9PiB7XG4gICAgICAgICAgdGhpcy5lZGl0b3JTdGF0ZSA9IHN0YXRlXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BhdGNoOiAodHI6IFRyYW5zYWN0aW9uKTogUmV0dXJuVHlwZTxFZGl0b3JWaWV3WydkaXNwYXRjaCddPiA9PiB7XG4gICAgICAgICAgdGhpcy5lZGl0b3JTdGF0ZSA9IHRoaXMuc3RhdGUuYXBwbHkodHIpXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU3R1YiBzb21lIGNvbW1vbmx5IGFjY2Vzc2VkIHByb3BlcnRpZXMgdG8gcHJldmVudCBlcnJvcnNcbiAgICAgICAgY29tcG9zaW5nOiBmYWxzZSxcbiAgICAgICAgZHJhZ2dpbmc6IG51bGwsXG4gICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICB9IGFzIEVkaXRvclZpZXcsXG4gICAgICB7XG4gICAgICAgIGdldDogKG9iaiwga2V5KSA9PiB7XG4gICAgICAgICAgLy8gU3BlY2lmaWNhbGx5IGFsd2F5cyByZXR1cm4gdGhlIG1vc3QgcmVjZW50IGVkaXRvclN0YXRlXG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3N0YXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yU3RhdGVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldChvYmosIGtleSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXZSB0aHJvdyBhbiBlcnJvciBoZXJlLCBiZWNhdXNlIHdlIGtub3cgdGhlIHZpZXcgaXMgbm90IGF2YWlsYWJsZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBbdGlwdGFwIGVycm9yXTogVGhlIGVkaXRvciB2aWV3IGlzIG5vdCBhdmFpbGFibGUuIENhbm5vdCBhY2Nlc3Mgdmlld1snJHtrZXkgYXMgc3RyaW5nfSddLiBUaGUgZWRpdG9yIG1heSBub3QgYmUgbW91bnRlZCB5ZXQuYCxcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICkgYXMgRWRpdG9yVmlld1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVkaXRvciBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhdGUoKTogRWRpdG9yU3RhdGUge1xuICAgIGlmICh0aGlzLmVkaXRvclZpZXcpIHtcbiAgICAgIHRoaXMuZWRpdG9yU3RhdGUgPSB0aGlzLnZpZXcuc3RhdGVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lZGl0b3JTdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgKlxuICAgKiBAcGFyYW0gcGx1Z2luIEEgUHJvc2VNaXJyb3IgcGx1Z2luXG4gICAqIEBwYXJhbSBoYW5kbGVQbHVnaW5zIENvbnRyb2wgaG93IHRvIG1lcmdlIHRoZSBwbHVnaW4gaW50byB0aGUgZXhpc3RpbmcgcGx1Z2lucy5cbiAgICogQHJldHVybnMgVGhlIG5ldyBlZGl0b3Igc3RhdGVcbiAgICovXG4gIHB1YmxpYyByZWdpc3RlclBsdWdpbihcbiAgICBwbHVnaW46IFBsdWdpbixcbiAgICBoYW5kbGVQbHVnaW5zPzogKG5ld1BsdWdpbjogUGx1Z2luLCBwbHVnaW5zOiBQbHVnaW5bXSkgPT4gUGx1Z2luW10sXG4gICk6IEVkaXRvclN0YXRlIHtcbiAgICBjb25zdCBwbHVnaW5zID0gaXNGdW5jdGlvbihoYW5kbGVQbHVnaW5zKVxuICAgICAgPyBoYW5kbGVQbHVnaW5zKHBsdWdpbiwgWy4uLnRoaXMuc3RhdGUucGx1Z2luc10pXG4gICAgICA6IFsuLi50aGlzLnN0YXRlLnBsdWdpbnMsIHBsdWdpbl1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7IHBsdWdpbnMgfSlcblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcblxuICAgIHJldHVybiBzdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYSBQcm9zZU1pcnJvciBwbHVnaW4uXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lT3JQbHVnaW5LZXlUb1JlbW92ZSBUaGUgcGx1Z2lucyBuYW1lXG4gICAqIEByZXR1cm5zIFRoZSBuZXcgZWRpdG9yIHN0YXRlIG9yIHVuZGVmaW5lZCBpZiB0aGUgZWRpdG9yIGlzIGRlc3Ryb3llZFxuICAgKi9cbiAgcHVibGljIHVucmVnaXN0ZXJQbHVnaW4oXG4gICAgbmFtZU9yUGx1Z2luS2V5VG9SZW1vdmU6IHN0cmluZyB8IFBsdWdpbktleSB8IChzdHJpbmcgfCBQbHVnaW5LZXkpW10sXG4gICk6IEVkaXRvclN0YXRlIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGNvbnN0IHByZXZQbHVnaW5zID0gdGhpcy5zdGF0ZS5wbHVnaW5zXG4gICAgbGV0IHBsdWdpbnMgPSBwcmV2UGx1Z2luc1xuXG4gICAgOyhbXSBhcyAoc3RyaW5nIHwgUGx1Z2luS2V5KVtdKS5jb25jYXQobmFtZU9yUGx1Z2luS2V5VG9SZW1vdmUpLmZvckVhY2gobmFtZU9yUGx1Z2luS2V5ID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yUGx1Z2luS2V5ID09PSAnc3RyaW5nJyA/IGAke25hbWVPclBsdWdpbktleX0kYCA6IG5hbWVPclBsdWdpbktleS5rZXlcblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcGx1Z2lucyA9IHBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiAhcGx1Z2luLmtleS5zdGFydHNXaXRoKG5hbWUpKVxuICAgIH0pXG5cbiAgICBpZiAocHJldlBsdWdpbnMubGVuZ3RoID09PSBwbHVnaW5zLmxlbmd0aCkge1xuICAgICAgLy8gTm8gcGx1Z2luIHdhcyByZW1vdmVkLCBzbyB3ZSBkb27igJl0IG5lZWQgdG8gdXBkYXRlIHRoZSBzdGF0ZVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7XG4gICAgICBwbHVnaW5zLFxuICAgIH0pXG5cbiAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpXG5cbiAgICByZXR1cm4gc3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGV4dGVuc2lvbiBtYW5hZ2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk6IHZvaWQge1xuICAgIGNvbnN0IGNvcmVFeHRlbnNpb25zID0gdGhpcy5vcHRpb25zLmVuYWJsZUNvcmVFeHRlbnNpb25zXG4gICAgICA/IFtcbiAgICAgICAgICBFZGl0YWJsZSxcbiAgICAgICAgICBDbGlwYm9hcmRUZXh0U2VyaWFsaXplci5jb25maWd1cmUoe1xuICAgICAgICAgICAgYmxvY2tTZXBhcmF0b3I6IHRoaXMub3B0aW9ucy5jb3JlRXh0ZW5zaW9uT3B0aW9ucz8uY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI/LmJsb2NrU2VwYXJhdG9yLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIENvbW1hbmRzLFxuICAgICAgICAgIEZvY3VzRXZlbnRzLFxuICAgICAgICAgIEtleW1hcCxcbiAgICAgICAgICBUYWJpbmRleCxcbiAgICAgICAgICBEcm9wLFxuICAgICAgICAgIFBhc3RlLFxuICAgICAgICAgIERlbGV0ZSxcbiAgICAgICAgXS5maWx0ZXIoZXh0ID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9uc1tleHQubmFtZSBhcyBrZXlvZiB0eXBlb2YgdGhpcy5vcHRpb25zLmVuYWJsZUNvcmVFeHRlbnNpb25zXSAhPT0gZmFsc2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSlcbiAgICAgIDogW11cbiAgICBjb25zdCBhbGxFeHRlbnNpb25zID0gWy4uLmNvcmVFeHRlbnNpb25zLCAuLi50aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc10uZmlsdGVyKGV4dGVuc2lvbiA9PiB7XG4gICAgICByZXR1cm4gWydleHRlbnNpb24nLCAnbm9kZScsICdtYXJrJ10uaW5jbHVkZXMoZXh0ZW5zaW9uPy50eXBlKVxuICAgIH0pXG5cbiAgICB0aGlzLmV4dGVuc2lvbk1hbmFnZXIgPSBuZXcgRXh0ZW5zaW9uTWFuYWdlcihhbGxFeHRlbnNpb25zLCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gY29tbWFuZCBtYW5hZ2VyLlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVDb21tYW5kTWFuYWdlcigpOiB2b2lkIHtcbiAgICB0aGlzLmNvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQcm9zZU1pcnJvciBzY2hlbWEuXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVNjaGVtYSgpOiB2b2lkIHtcbiAgICB0aGlzLnNjaGVtYSA9IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5zY2hlbWFcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBpbml0aWFsIGRvY3VtZW50LlxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVEb2MoKTogUHJvc2VNaXJyb3JOb2RlIHtcbiAgICBsZXQgZG9jOiBQcm9zZU1pcnJvck5vZGVcblxuICAgIHRyeSB7XG4gICAgICBkb2MgPSBjcmVhdGVEb2N1bWVudCh0aGlzLm9wdGlvbnMuY29udGVudCwgdGhpcy5zY2hlbWEsIHRoaXMub3B0aW9ucy5wYXJzZU9wdGlvbnMsIHtcbiAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiB0aGlzLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoXG4gICAgICAgICEoZSBpbnN0YW5jZW9mIEVycm9yKSB8fFxuICAgICAgICAhWydbdGlwdGFwIGVycm9yXTogSW52YWxpZCBKU09OIGNvbnRlbnQnLCAnW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSFRNTCBjb250ZW50J10uaW5jbHVkZXMoZS5tZXNzYWdlKVxuICAgICAgKSB7XG4gICAgICAgIC8vIE5vdCB0aGUgY29udGVudCBlcnJvciB3ZSB3ZXJlIGV4cGVjdGluZ1xuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ2NvbnRlbnRFcnJvcicsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICBlcnJvcjogZSBhcyBFcnJvcixcbiAgICAgICAgZGlzYWJsZUNvbGxhYm9yYXRpb246ICgpID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAnY29sbGFib3JhdGlvbicgaW4gdGhpcy5zdG9yYWdlICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5zdG9yYWdlLmNvbGxhYm9yYXRpb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuY29sbGFib3JhdGlvblxuICAgICAgICAgICkge1xuICAgICAgICAgICAgOyh0aGlzLnN0b3JhZ2UuY29sbGFib3JhdGlvbiBhcyBhbnkpLmlzRGlzYWJsZWQgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRvIGF2b2lkIHN5bmNpbmcgYmFjayBpbnZhbGlkIGNvbnRlbnQsIHJlaW5pdGlhbGl6ZSB0aGUgZXh0ZW5zaW9ucyB3aXRob3V0IHRoZSBjb2xsYWJvcmF0aW9uIGV4dGVuc2lvblxuICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24ubmFtZSAhPT0gJ2NvbGxhYm9yYXRpb24nKVxuXG4gICAgICAgICAgLy8gUmVzdGFydCB0aGUgaW5pdGlhbGl6YXRpb24gcHJvY2VzcyBieSByZWNyZWF0aW5nIHRoZSBleHRlbnNpb24gbWFuYWdlciB3aXRoIHRoZSBuZXcgc2V0IG9mIGV4dGVuc2lvbnNcbiAgICAgICAgICB0aGlzLmNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIoKVxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgLy8gQ29udGVudCBpcyBpbnZhbGlkLCBidXQgYXR0ZW1wdCB0byBjcmVhdGUgaXQgYW55d2F5LCBzdHJpcHBpbmcgb3V0IHRoZSBpbnZhbGlkIHBhcnRzXG4gICAgICBkb2MgPSBjcmVhdGVEb2N1bWVudCh0aGlzLm9wdGlvbnMuY29udGVudCwgdGhpcy5zY2hlbWEsIHRoaXMub3B0aW9ucy5wYXJzZU9wdGlvbnMsIHtcbiAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiBmYWxzZSxcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUHJvc2VNaXJyb3Igdmlldy5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlVmlldyhlbGVtZW50OiBOb25OdWxsYWJsZTxFZGl0b3JPcHRpb25zWydlbGVtZW50J10+ICYge30pOiB2b2lkIHtcbiAgICB0aGlzLmVkaXRvclZpZXcgPSBuZXcgRWRpdG9yVmlldyhlbGVtZW50LCB7XG4gICAgICAuLi50aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC8vIGFkZCBgcm9sZT1cInRleHRib3hcImAgdG8gdGhlIGVkaXRvciBlbGVtZW50XG4gICAgICAgIHJvbGU6ICd0ZXh0Ym94JyxcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmVkaXRvclByb3BzPy5hdHRyaWJ1dGVzLFxuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoVHJhbnNhY3Rpb246IHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgc3RhdGU6IHRoaXMuZWRpdG9yU3RhdGUsXG4gICAgfSlcblxuICAgIC8vIGBlZGl0b3Iudmlld2AgaXMgbm90IHlldCBhdmFpbGFibGUgYXQgdGhpcyB0aW1lLlxuICAgIC8vIFRoZXJlZm9yZSB3ZSB3aWxsIGFkZCBhbGwgcGx1Z2lucyBhbmQgbm9kZSB2aWV3cyBkaXJlY3RseSBhZnRlcndhcmRzLlxuICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7XG4gICAgICBwbHVnaW5zOiB0aGlzLmV4dGVuc2lvbk1hbmFnZXIucGx1Z2lucyxcbiAgICB9KVxuXG4gICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKG5ld1N0YXRlKVxuXG4gICAgdGhpcy5jcmVhdGVOb2RlVmlld3MoKVxuICAgIHRoaXMucHJlcGVuZENsYXNzKClcbiAgICB0aGlzLmluamVjdENTUygpXG5cbiAgICAvLyBMZXTigJlzIHN0b3JlIHRoZSBlZGl0b3IgaW5zdGFuY2UgaW4gdGhlIERPTSBlbGVtZW50LlxuICAgIC8vIFNvIHdl4oCZbGwgaGF2ZSBhY2Nlc3MgdG8gaXQgZm9yIHRlc3RzLlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBkb20gPSB0aGlzLnZpZXcuZG9tIGFzIFRpcHRhcEVkaXRvckhUTUxFbGVtZW50XG5cbiAgICBkb20uZWRpdG9yID0gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYWxsIG5vZGUgYW5kIG1hcmsgdmlld3MuXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlTm9kZVZpZXdzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnZpZXcuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMudmlldy5zZXRQcm9wcyh7XG4gICAgICBtYXJrVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5tYXJrVmlld3MsXG4gICAgICBub2RlVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5ub2RlVmlld3MsXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwZW5kIGNsYXNzIG5hbWUgdG8gZWxlbWVudC5cbiAgICovXG4gIHB1YmxpYyBwcmVwZW5kQ2xhc3MoKTogdm9pZCB7XG4gICAgdGhpcy52aWV3LmRvbS5jbGFzc05hbWUgPSBgdGlwdGFwICR7dGhpcy52aWV3LmRvbS5jbGFzc05hbWV9YFxuICB9XG5cbiAgcHVibGljIGlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZVxuXG4gIHByaXZhdGUgY2FwdHVyZWRUcmFuc2FjdGlvbjogVHJhbnNhY3Rpb24gfCBudWxsID0gbnVsbFxuXG4gIHB1YmxpYyBjYXB0dXJlVHJhbnNhY3Rpb24oZm46ICgpID0+IHZvaWQpIHtcbiAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSB0cnVlXG4gICAgZm4oKVxuICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlXG5cbiAgICBjb25zdCB0ciA9IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvblxuXG4gICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbFxuXG4gICAgcmV0dXJuIHRyXG4gIH1cblxuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIG92ZXIgd2hpY2ggdG8gc2VuZCB0cmFuc2FjdGlvbnMgKHN0YXRlIHVwZGF0ZXMpIHByb2R1Y2VkIGJ5IHRoZSB2aWV3LlxuICAgKlxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwcml2YXRlIGRpc3BhdGNoVHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgLy8gaWYgdGhlIGVkaXRvciAvIHRoZSB2aWV3IG9mIHRoZSBlZGl0b3Igd2FzIGRlc3Ryb3llZFxuICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgbm90IGJlIGRpc3BhdGNoZWQgYXMgdGhlcmUgaXMgbm8gdmlldyBhbnltb3JlLlxuICAgIGlmICh0aGlzLnZpZXcuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmICghdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24/LnN0ZXAoc3RlcCkpXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEFwcGx5IHRyYW5zYWN0aW9uIGFuZCBnZXQgcmVzdWx0aW5nIHN0YXRlIGFuZCB0cmFuc2FjdGlvbnNcbiAgICBjb25zdCB7IHN0YXRlLCB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcbiAgICBjb25zdCBzZWxlY3Rpb25IYXNDaGFuZ2VkID0gIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbilcbiAgICBjb25zdCByb290VHJXYXNBcHBsaWVkID0gdHJhbnNhY3Rpb25zLmluY2x1ZGVzKHRyYW5zYWN0aW9uKVxuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc3RhdGVcblxuICAgIHRoaXMuZW1pdCgnYmVmb3JlVHJhbnNhY3Rpb24nLCB7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIG5leHRTdGF0ZTogc3RhdGUsXG4gICAgfSlcblxuICAgIC8vIElmIHRyYW5zYWN0aW9uIHdhcyBmaWx0ZXJlZCBvdXQsIHdlIGNhbiByZXR1cm4gZWFybHlcbiAgICBpZiAoIXJvb3RUcldhc0FwcGxpZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSlcblxuICAgIC8vIEVtaXQgdHJhbnNhY3Rpb24gZXZlbnQgd2l0aCBhcHBlbmRlZCB0cmFuc2FjdGlvbnMgaW5mb1xuICAgIHRoaXMuZW1pdCgndHJhbnNhY3Rpb24nLCB7XG4gICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIGFwcGVuZGVkVHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbnMuc2xpY2UoMSksXG4gICAgfSlcblxuICAgIGlmIChzZWxlY3Rpb25IYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoJ3NlbGVjdGlvblVwZGF0ZScsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gT25seSBlbWl0IHRoZSBsYXRlc3QgYmV0d2VlbiBmb2N1cyBhbmQgYmx1ciBldmVudHNcbiAgICBjb25zdCBtb3N0UmVjZW50Rm9jdXNUciA9IHRyYW5zYWN0aW9ucy5maW5kTGFzdCh0ciA9PiB0ci5nZXRNZXRhKCdmb2N1cycpIHx8IHRyLmdldE1ldGEoJ2JsdXInKSlcbiAgICBjb25zdCBmb2N1cyA9IG1vc3RSZWNlbnRGb2N1c1RyPy5nZXRNZXRhKCdmb2N1cycpXG4gICAgY29uc3QgYmx1ciA9IG1vc3RSZWNlbnRGb2N1c1RyPy5nZXRNZXRhKCdibHVyJylcblxuICAgIGlmIChmb2N1cykge1xuICAgICAgdGhpcy5lbWl0KCdmb2N1cycsIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICBldmVudDogZm9jdXMuZXZlbnQsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHRyYW5zYWN0aW9uOiBtb3N0UmVjZW50Rm9jdXNUciEsXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChibHVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ2JsdXInLCB7XG4gICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgZXZlbnQ6IGJsdXIuZXZlbnQsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHRyYW5zYWN0aW9uOiBtb3N0UmVjZW50Rm9jdXNUciEsXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIENvbXBhcmUgc3RhdGVzIGZvciB1cGRhdGUgZXZlbnRcbiAgICBpZiAoXG4gICAgICB0cmFuc2FjdGlvbi5nZXRNZXRhKCdwcmV2ZW50VXBkYXRlJykgfHxcbiAgICAgICF0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5kb2NDaGFuZ2VkKSB8fFxuICAgICAgcHJldlN0YXRlLmRvYy5lcShzdGF0ZS5kb2MpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHtcbiAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgYXBwZW5kZWRUcmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9ucy5zbGljZSgxKSxcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhdHRyaWJ1dGVzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBvciBtYXJrLlxuICAgKi9cbiAgcHVibGljIGdldEF0dHJpYnV0ZXMobmFtZU9yVHlwZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzKHRoaXMuc3RhdGUsIG5hbWVPclR5cGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgb3IgbWFyayBpcyBhY3RpdmUuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIG5vZGUgb3IgbWFya1xuICAgKiBAcGFyYW0gYXR0cmlidXRlcyBBdHRyaWJ1dGVzIG9mIHRoZSBub2RlIG9yIG1hcmtcbiAgICovXG4gIHB1YmxpYyBpc0FjdGl2ZShuYW1lOiBzdHJpbmcsIGF0dHJpYnV0ZXM/OiB7fSk6IGJvb2xlYW5cbiAgcHVibGljIGlzQWN0aXZlKGF0dHJpYnV0ZXM6IHt9KTogYm9vbGVhblxuICBwdWJsaWMgaXNBY3RpdmUobmFtZU9yQXR0cmlidXRlczogc3RyaW5nLCBhdHRyaWJ1dGVzT3JVbmRlZmluZWQ/OiB7fSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gJ3N0cmluZycgPyBuYW1lT3JBdHRyaWJ1dGVzIDogbnVsbFxuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHR5cGVvZiBuYW1lT3JBdHRyaWJ1dGVzID09PSAnc3RyaW5nJyA/IGF0dHJpYnV0ZXNPclVuZGVmaW5lZCA6IG5hbWVPckF0dHJpYnV0ZXNcblxuICAgIHJldHVybiBpc0FjdGl2ZSh0aGlzLnN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSlNPTi5cbiAgICovXG4gIHB1YmxpYyBnZXRKU09OKCk6IERvY3VtZW50VHlwZTxcbiAgICBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkLFxuICAgIFROb2RlVHlwZTxzdHJpbmcsIHVuZGVmaW5lZCB8IFJlY29yZDxzdHJpbmcsIGFueT4sIGFueSwgKFROb2RlVHlwZSB8IFRUZXh0VHlwZSlbXT5bXVxuICA+IHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MudG9KU09OKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIEhUTUwuXG4gICAqL1xuICBwdWJsaWMgZ2V0SFRNTCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBnZXRIVE1MRnJvbUZyYWdtZW50KHRoaXMuc3RhdGUuZG9jLmNvbnRlbnQsIHRoaXMuc2NoZW1hKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgdGV4dC5cbiAgICovXG4gIHB1YmxpYyBnZXRUZXh0KG9wdGlvbnM/OiB7IGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nOyB0ZXh0U2VyaWFsaXplcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj4gfSk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgcmV0dXJuIGdldFRleHQodGhpcy5zdGF0ZS5kb2MsIHtcbiAgICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEodGhpcy5zY2hlbWEpLFxuICAgICAgICAuLi50ZXh0U2VyaWFsaXplcnMsXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlcmUgaXMgbm8gY29udGVudC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNOb2RlRW1wdHkodGhpcy5zdGF0ZS5kb2MpXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgZWRpdG9yLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JylcblxuICAgIHRoaXMudW5tb3VudCgpXG5cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBhbHJlYWR5IGRlc3Ryb3llZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgaXNEZXN0cm95ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yVmlldz8uaXNEZXN0cm95ZWQgPz8gdHJ1ZVxuICB9XG5cbiAgcHVibGljICRub2RlKHNlbGVjdG9yOiBzdHJpbmcsIGF0dHJpYnV0ZXM/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogTm9kZVBvcyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLiRkb2M/LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IsIGF0dHJpYnV0ZXMpIHx8IG51bGxcbiAgfVxuXG4gIHB1YmxpYyAkbm9kZXMoc2VsZWN0b3I6IHN0cmluZywgYXR0cmlidXRlcz86IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiBOb2RlUG9zW10gfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy4kZG9jPy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzKSB8fCBudWxsXG4gIH1cblxuICBwdWJsaWMgJHBvcyhwb3M6IG51bWJlcikge1xuICAgIGNvbnN0ICRwb3MgPSB0aGlzLnN0YXRlLmRvYy5yZXNvbHZlKHBvcylcblxuICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzKVxuICB9XG5cbiAgZ2V0ICRkb2MoKSB7XG4gICAgcmV0dXJuIHRoaXMuJHBvcygwKVxuICB9XG59XG4iLCAidHlwZSBTdHJpbmdLZXlPZjxUPiA9IEV4dHJhY3Q8a2V5b2YgVCwgc3RyaW5nPlxudHlwZSBDYWxsYmFja1R5cGU8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sIEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+PiA9IFRbRXZlbnROYW1lXSBleHRlbmRzIGFueVtdXG4gID8gVFtFdmVudE5hbWVdXG4gIDogW1RbRXZlbnROYW1lXV1cbnR5cGUgQ2FsbGJhY2tGdW5jdGlvbjxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiwgRXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4+ID0gKFxuICAuLi5wcm9wczogQ2FsbGJhY2tUeXBlPFQsIEV2ZW50TmFtZT5cbikgPT4gYW55XG5cbmV4cG9ydCBjbGFzcyBFdmVudEVtaXR0ZXI8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+IHtcbiAgcHJpdmF0ZSBjYWxsYmFja3M6IHsgW2tleTogc3RyaW5nXTogQXJyYXk8KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPiB9ID0ge31cblxuICBwdWJsaWMgb248RXZlbnROYW1lIGV4dGVuZHMgU3RyaW5nS2V5T2Y8VD4+KGV2ZW50OiBFdmVudE5hbWUsIGZuOiBDYWxsYmFja0Z1bmN0aW9uPFQsIEV2ZW50TmFtZT4pOiB0aGlzIHtcbiAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gW11cbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0ucHVzaChmbilcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgZW1pdDxFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPj4oZXZlbnQ6IEV2ZW50TmFtZSwgLi4uYXJnczogQ2FsbGJhY2tUeXBlPFQsIEV2ZW50TmFtZT4pOiB0aGlzIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF1cblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgb2ZmPEV2ZW50TmFtZSBleHRlbmRzIFN0cmluZ0tleU9mPFQ+PihldmVudDogRXZlbnROYW1lLCBmbj86IENhbGxiYWNrRnVuY3Rpb248VCwgRXZlbnROYW1lPik6IHRoaXMge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XVxuXG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoY2FsbGJhY2sgPT4gY2FsbGJhY2sgIT09IGZuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwdWJsaWMgb25jZTxFdmVudE5hbWUgZXh0ZW5kcyBTdHJpbmdLZXlPZjxUPj4oZXZlbnQ6IEV2ZW50TmFtZSwgZm46IENhbGxiYWNrRnVuY3Rpb248VCwgRXZlbnROYW1lPik6IHRoaXMge1xuICAgIGNvbnN0IG9uY2VGbiA9ICguLi5hcmdzOiBDYWxsYmFja1R5cGU8VCwgRXZlbnROYW1lPikgPT4ge1xuICAgICAgdGhpcy5vZmYoZXZlbnQsIG9uY2VGbilcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIG9uY2VGbilcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVBbGxMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fVxuICB9XG59XG4iLCAiaW1wb3J0IHsga2V5bWFwIH0gZnJvbSAnQHRpcHRhcC9wbS9rZXltYXAnXG5pbXBvcnQgdHlwZSB7IFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgdHlwZSB7IFBsdWdpbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgdHlwZSB7IE1hcmtWaWV3Q29uc3RydWN0b3IsIE5vZGVWaWV3Q29uc3RydWN0b3IgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB0eXBlIHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQge1xuICBmbGF0dGVuRXh0ZW5zaW9ucyxcbiAgZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zLFxuICBnZXRFeHRlbnNpb25GaWVsZCxcbiAgZ2V0Tm9kZVR5cGUsXG4gIGdldFJlbmRlcmVkQXR0cmlidXRlcyxcbiAgZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMsXG4gIGdldFNjaGVtYVR5cGVCeU5hbWUsXG4gIGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLFxuICByZXNvbHZlRXh0ZW5zaW9ucyxcbiAgc29ydEV4dGVuc2lvbnMsXG4gIHNwbGl0RXh0ZW5zaW9ucyxcbn0gZnJvbSAnLi9oZWxwZXJzL2luZGV4LmpzJ1xuaW1wb3J0IHsgdHlwZSBNYXJrQ29uZmlnLCB0eXBlIE5vZGVDb25maWcsIHR5cGUgU3RvcmFnZSwgZ2V0TWFya1R5cGUgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHR5cGUgeyBJbnB1dFJ1bGUgfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IGlucHV0UnVsZXNQbHVnaW4gfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IE1hcmsgfSBmcm9tICcuL01hcmsuanMnXG5pbXBvcnQgdHlwZSB7IFBhc3RlUnVsZSB9IGZyb20gJy4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHsgcGFzdGVSdWxlc1BsdWdpbiB9IGZyb20gJy4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHR5cGUgeyBBbnlDb25maWcsIEV4dGVuc2lvbnMsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuZXhwb3J0IGNsYXNzIEV4dGVuc2lvbk1hbmFnZXIge1xuICBlZGl0b3I6IEVkaXRvclxuXG4gIHNjaGVtYTogU2NoZW1hXG5cbiAgZXh0ZW5zaW9uczogRXh0ZW5zaW9uc1xuXG4gIHNwbGl0dGFibGVNYXJrczogc3RyaW5nW10gPSBbXVxuXG4gIGNvbnN0cnVjdG9yKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMsIGVkaXRvcjogRWRpdG9yKSB7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSByZXNvbHZlRXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICAgIHRoaXMuc2NoZW1hID0gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zLCBlZGl0b3IpXG4gICAgdGhpcy5zZXR1cEV4dGVuc2lvbnMoKVxuICB9XG5cbiAgc3RhdGljIHJlc29sdmUgPSByZXNvbHZlRXh0ZW5zaW9uc1xuXG4gIHN0YXRpYyBzb3J0ID0gc29ydEV4dGVuc2lvbnNcblxuICBzdGF0aWMgZmxhdHRlbiA9IGZsYXR0ZW5FeHRlbnNpb25zXG5cbiAgLyoqXG4gICAqIEdldCBhbGwgY29tbWFuZHMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYWxsIGNvbW1hbmRzIHdoZXJlIHRoZSBrZXkgaXMgdGhlIGNvbW1hbmQgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIHRoZSBjb21tYW5kIGZ1bmN0aW9uXG4gICAqL1xuICBnZXQgY29tbWFuZHMoKTogUmF3Q29tbWFuZHMge1xuICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnMucmVkdWNlKChjb21tYW5kcywgZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgIHN0b3JhZ2U6IHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWUgYXMga2V5b2YgU3RvcmFnZV0sXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWRkQ29tbWFuZHMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZENvbW1hbmRzJ10+KGV4dGVuc2lvbiwgJ2FkZENvbW1hbmRzJywgY29udGV4dClcblxuICAgICAgaWYgKCFhZGRDb21tYW5kcykge1xuICAgICAgICByZXR1cm4gY29tbWFuZHNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgIC4uLmFkZENvbW1hbmRzKCksXG4gICAgICB9XG4gICAgfSwge30gYXMgUmF3Q29tbWFuZHMpXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCByZWdpc3RlcmVkIFByb3NlbWlycm9yIHBsdWdpbnMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgUHJvc2VtaXJyb3IgcGx1Z2luc1xuICAgKi9cbiAgZ2V0IHBsdWdpbnMoKTogUGx1Z2luW10ge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG5cbiAgICAvLyBXaXRoIFByb3NlTWlycm9yLCBmaXJzdCBwbHVnaW5zIHdpdGhpbiBhbiBhcnJheSBhcmUgZXhlY3V0ZWQgZmlyc3QuXG4gICAgLy8gSW4gVGlwdGFwLCB3ZSBwcm92aWRlIHRoZSBhYmlsaXR5IHRvIG92ZXJyaWRlIHBsdWdpbnMsXG4gICAgLy8gc28gaXQgZmVlbHMgbW9yZSBuYXR1cmFsIHRvIHJ1biBwbHVnaW5zIGF0IHRoZSBlbmQgb2YgYW4gYXJyYXkgZmlyc3QuXG4gICAgLy8gVGhhdOKAmXMgd2h5IHdlIGhhdmUgdG8gcmV2ZXJzZSB0aGUgYGV4dGVuc2lvbnNgIGFycmF5IGFuZCBzb3J0IGFnYWluXG4gICAgLy8gYmFzZWQgb24gdGhlIGBwcmlvcml0eWAgb3B0aW9uLlxuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBzb3J0RXh0ZW5zaW9ucyhbLi4udGhpcy5leHRlbnNpb25zXS5yZXZlcnNlKCkpXG5cbiAgICBjb25zdCBpbnB1dFJ1bGVzOiBJbnB1dFJ1bGVbXSA9IFtdXG4gICAgY29uc3QgcGFzdGVSdWxlczogUGFzdGVSdWxlW10gPSBbXVxuXG4gICAgY29uc3QgYWxsUGx1Z2lucyA9IGV4dGVuc2lvbnNcbiAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICBzdG9yYWdlOiB0aGlzLmVkaXRvci5leHRlbnNpb25TdG9yYWdlW2V4dGVuc2lvbi5uYW1lIGFzIGtleW9mIFN0b3JhZ2VdLFxuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwbHVnaW5zOiBQbHVnaW5bXSA9IFtdXG5cbiAgICAgICAgY29uc3QgYWRkS2V5Ym9hcmRTaG9ydGN1dHMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2FkZEtleWJvYXJkU2hvcnRjdXRzJ10+KFxuICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIClcblxuICAgICAgICBsZXQgZGVmYXVsdEJpbmRpbmdzOiBSZWNvcmQ8c3RyaW5nLCAoKSA9PiBib29sZWFuPiA9IHt9XG5cbiAgICAgICAgLy8gYmluZCBleGl0IGhhbmRsaW5nXG4gICAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnICYmIGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2V4aXRhYmxlJ10+KGV4dGVuc2lvbiwgJ2V4aXRhYmxlJywgY29udGV4dCkpIHtcbiAgICAgICAgICBkZWZhdWx0QmluZGluZ3MuQXJyb3dSaWdodCA9ICgpID0+IE1hcmsuaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyazogZXh0ZW5zaW9uIGFzIE1hcmsgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGRLZXlib2FyZFNob3J0Y3V0cykge1xuICAgICAgICAgIGNvbnN0IGJpbmRpbmdzID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSkubWFwKChbc2hvcnRjdXQsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtzaG9ydGN1dCwgKCkgPT4gbWV0aG9kKHsgZWRpdG9yIH0pXVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgZGVmYXVsdEJpbmRpbmdzID0geyAuLi5kZWZhdWx0QmluZGluZ3MsIC4uLmJpbmRpbmdzIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGtleU1hcFBsdWdpbiA9IGtleW1hcChkZWZhdWx0QmluZGluZ3MpXG5cbiAgICAgICAgcGx1Z2lucy5wdXNoKGtleU1hcFBsdWdpbilcblxuICAgICAgICBjb25zdCBhZGRJbnB1dFJ1bGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRJbnB1dFJ1bGVzJ10+KGV4dGVuc2lvbiwgJ2FkZElucHV0UnVsZXMnLCBjb250ZXh0KVxuXG4gICAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZUlucHV0UnVsZXMpICYmIGFkZElucHV0UnVsZXMpIHtcbiAgICAgICAgICBpbnB1dFJ1bGVzLnB1c2goLi4uYWRkSW5wdXRSdWxlcygpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWRkUGFzdGVSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkUGFzdGVSdWxlcyddPihleHRlbnNpb24sICdhZGRQYXN0ZVJ1bGVzJywgY29udGV4dClcblxuICAgICAgICBpZiAoaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlZGl0b3Iub3B0aW9ucy5lbmFibGVQYXN0ZVJ1bGVzKSAmJiBhZGRQYXN0ZVJ1bGVzKSB7XG4gICAgICAgICAgcGFzdGVSdWxlcy5wdXNoKC4uLmFkZFBhc3RlUnVsZXMoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFkZFByb3NlTWlycm9yUGx1Z2lucyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkUHJvc2VNaXJyb3JQbHVnaW5zJ10+KFxuICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGFkZFByb3NlTWlycm9yUGx1Z2lucykge1xuICAgICAgICAgIGNvbnN0IHByb3NlTWlycm9yUGx1Z2lucyA9IGFkZFByb3NlTWlycm9yUGx1Z2lucygpXG5cbiAgICAgICAgICBwbHVnaW5zLnB1c2goLi4ucHJvc2VNaXJyb3JQbHVnaW5zKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBsdWdpbnNcbiAgICAgIH0pXG4gICAgICAuZmxhdCgpXG5cbiAgICByZXR1cm4gW1xuICAgICAgaW5wdXRSdWxlc1BsdWdpbih7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgcnVsZXM6IGlucHV0UnVsZXMsXG4gICAgICB9KSxcbiAgICAgIC4uLnBhc3RlUnVsZXNQbHVnaW4oe1xuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHJ1bGVzOiBwYXN0ZVJ1bGVzLFxuICAgICAgfSksXG4gICAgICAuLi5hbGxQbHVnaW5zLFxuICAgIF1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYXR0cmlidXRlc1xuICAgKi9cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMpXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBub2RlIHZpZXdzIGZyb20gdGhlIGV4dGVuc2lvbnMuXG4gICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFsbCBub2RlIHZpZXdzIHdoZXJlIHRoZSBrZXkgaXMgdGhlIG5vZGUgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIHRoZSBub2RlIHZpZXcgZnVuY3Rpb25cbiAgICovXG4gIGdldCBub2RlVmlld3MoKTogUmVjb3JkPHN0cmluZywgTm9kZVZpZXdDb25zdHJ1Y3Rvcj4ge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucylcblxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBub2RlRXh0ZW5zaW9uc1xuICAgICAgICAuZmlsdGVyKGV4dGVuc2lvbiA9PiAhIWdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE5vZGVWaWV3JykpXG4gICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcihhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lKVxuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZVtleHRlbnNpb24ubmFtZSBhcyBrZXlvZiBTdG9yYWdlXSxcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHR5cGU6IGdldE5vZGVUeXBlKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFkZE5vZGVWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snYWRkTm9kZVZpZXcnXT4oZXh0ZW5zaW9uLCAnYWRkTm9kZVZpZXcnLCBjb250ZXh0KVxuXG4gICAgICAgICAgaWYgKCFhZGROb2RlVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgbm9kZXZpZXc6IE5vZGVWaWV3Q29uc3RydWN0b3IgPSAobm9kZSwgdmlldywgZ2V0UG9zLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcylcblxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVWaWV3KCkoe1xuICAgICAgICAgICAgICAvLyBwYXNzLXRocm91Z2hcbiAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgICAgZ2V0UG9zOiBnZXRQb3MgYXMgKCkgPT4gbnVtYmVyLFxuICAgICAgICAgICAgICBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgaW5uZXJEZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgLy8gdGlwdGFwLXNwZWNpZmljXG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICAgICBIVE1MQXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgbm9kZXZpZXddXG4gICAgICAgIH0pLFxuICAgIClcbiAgfVxuXG4gIGdldCBtYXJrVmlld3MoKTogUmVjb3JkPHN0cmluZywgTWFya1ZpZXdDb25zdHJ1Y3Rvcj4ge1xuICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG4gICAgY29uc3QgeyBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucylcblxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBtYXJrRXh0ZW5zaW9uc1xuICAgICAgICAuZmlsdGVyKGV4dGVuc2lvbiA9PiAhIWdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE1hcmtWaWV3JykpXG4gICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcihhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lKVxuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZVtleHRlbnNpb24ubmFtZSBhcyBrZXlvZiBTdG9yYWdlXSxcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHR5cGU6IGdldE1hcmtUeXBlKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFkZE1hcmtWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snYWRkTWFya1ZpZXcnXT4oZXh0ZW5zaW9uLCAnYWRkTWFya1ZpZXcnLCBjb250ZXh0KVxuXG4gICAgICAgICAgaWYgKCFhZGRNYXJrVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbWFya1ZpZXc6IE1hcmtWaWV3Q29uc3RydWN0b3IgPSAobWFyaywgdmlldywgaW5saW5lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBIVE1MQXR0cmlidXRlcyA9IGdldFJlbmRlcmVkQXR0cmlidXRlcyhtYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkTWFya1ZpZXcoKSh7XG4gICAgICAgICAgICAgIC8vIHBhc3MtdGhyb3VnaFxuICAgICAgICAgICAgICBtYXJrLFxuICAgICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgICBpbmxpbmUsXG4gICAgICAgICAgICAgIC8vIHRpcHRhcC1zcGVjaWZpY1xuICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIG1hcmtWaWV3XVxuICAgICAgICB9KSxcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogR28gdGhyb3VnaCBhbGwgZXh0ZW5zaW9ucywgY3JlYXRlIGV4dGVuc2lvbiBzdG9yYWdlcyAmIHNldHVwIG1hcmtzXG4gICAqICYgYmluZCBlZGl0b3IgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBwcml2YXRlIHNldHVwRXh0ZW5zaW9ucygpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zXG4gICAgLy8gcmUtaW5pdGlhbGl6ZSB0aGUgZXh0ZW5zaW9uIHN0b3JhZ2Ugb2JqZWN0IGluc3RhbmNlXG4gICAgdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZSA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIGV4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiBbZXh0ZW5zaW9uLm5hbWUsIGV4dGVuc2lvbi5zdG9yYWdlXSksXG4gICAgKSBhcyB1bmtub3duIGFzIFN0b3JhZ2VcblxuICAgIGV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiB0aGlzLmVkaXRvci5leHRlbnNpb25TdG9yYWdlW2V4dGVuc2lvbi5uYW1lIGFzIGtleW9mIFN0b3JhZ2VdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICB9XG5cbiAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgICAgIGNvbnN0IGtlZXBPblNwbGl0ID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2tlZXBPblNwbGl0JywgY29udGV4dCkpID8/IHRydWVcblxuICAgICAgICBpZiAoa2VlcE9uU3BsaXQpIHtcbiAgICAgICAgICB0aGlzLnNwbGl0dGFibGVNYXJrcy5wdXNoKGV4dGVuc2lvbi5uYW1lKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uQmVmb3JlQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkJlZm9yZUNyZWF0ZSddPihleHRlbnNpb24sICdvbkJlZm9yZUNyZWF0ZScsIGNvbnRleHQpXG4gICAgICBjb25zdCBvbkNyZWF0ZSA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25DcmVhdGUnXT4oZXh0ZW5zaW9uLCAnb25DcmVhdGUnLCBjb250ZXh0KVxuICAgICAgY29uc3Qgb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uVXBkYXRlJ10+KGV4dGVuc2lvbiwgJ29uVXBkYXRlJywgY29udGV4dClcbiAgICAgIGNvbnN0IG9uU2VsZWN0aW9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvblNlbGVjdGlvblVwZGF0ZSddPihcbiAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAnb25TZWxlY3Rpb25VcGRhdGUnLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuICAgICAgY29uc3Qgb25UcmFuc2FjdGlvbiA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snb25UcmFuc2FjdGlvbiddPihleHRlbnNpb24sICdvblRyYW5zYWN0aW9uJywgY29udGV4dClcbiAgICAgIGNvbnN0IG9uRm9jdXMgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uRm9jdXMnXT4oZXh0ZW5zaW9uLCAnb25Gb2N1cycsIGNvbnRleHQpXG4gICAgICBjb25zdCBvbkJsdXIgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ29uQmx1ciddPihleHRlbnNpb24sICdvbkJsdXInLCBjb250ZXh0KVxuICAgICAgY29uc3Qgb25EZXN0cm95ID0gZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydvbkRlc3Ryb3knXT4oZXh0ZW5zaW9uLCAnb25EZXN0cm95JywgY29udGV4dClcblxuICAgICAgaWYgKG9uQmVmb3JlQ3JlYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdiZWZvcmVDcmVhdGUnLCBvbkJlZm9yZUNyZWF0ZSlcbiAgICAgIH1cblxuICAgICAgaWYgKG9uQ3JlYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdjcmVhdGUnLCBvbkNyZWF0ZSlcbiAgICAgIH1cblxuICAgICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCd1cGRhdGUnLCBvblVwZGF0ZSlcbiAgICAgIH1cblxuICAgICAgaWYgKG9uU2VsZWN0aW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdzZWxlY3Rpb25VcGRhdGUnLCBvblNlbGVjdGlvblVwZGF0ZSlcbiAgICAgIH1cblxuICAgICAgaWYgKG9uVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3RyYW5zYWN0aW9uJywgb25UcmFuc2FjdGlvbilcbiAgICAgIH1cblxuICAgICAgaWYgKG9uRm9jdXMpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgb25Gb2N1cylcbiAgICAgIH1cblxuICAgICAgaWYgKG9uQmx1cikge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIG9uQmx1cilcbiAgICAgIH1cblxuICAgICAgaWYgKG9uRGVzdHJveSkge1xuICAgICAgICB0aGlzLmVkaXRvci5vbignZGVzdHJveScsIG9uRGVzdHJveSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgdHlwZSB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYFRyYW5zZm9ybWAgYmFzZWQgb24gYWxsIHN0ZXBzIG9mIHRoZSBwYXNzZWQgdHJhbnNhY3Rpb25zLlxuICogQHBhcmFtIG9sZERvYyBUaGUgUHJvc2VtaXJyb3Igbm9kZSB0byBzdGFydCBmcm9tXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25zIFRoZSB0cmFuc2FjdGlvbnMgdG8gY29tYmluZVxuICogQHJldHVybnMgQSBuZXcgYFRyYW5zZm9ybWAgd2l0aCBhbGwgc3RlcHMgb2YgdGhlIHBhc3NlZCB0cmFuc2FjdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKG9sZERvYzogUHJvc2VNaXJyb3JOb2RlLCB0cmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uW10pOiBUcmFuc2Zvcm0ge1xuICBjb25zdCB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKG9sZERvYylcblxuICB0cmFuc2FjdGlvbnMuZm9yRWFjaCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICAgIHRyYW5zZm9ybS5zdGVwKHN0ZXApXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gdHJhbnNmb3JtXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBQYXJzZU9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgRE9NUGFyc2VyLCBGcmFnbWVudCwgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB0eXBlIHsgQ29udGVudCB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgZWxlbWVudEZyb21TdHJpbmcgfSBmcm9tICcuLi91dGlsaXRpZXMvZWxlbWVudEZyb21TdHJpbmcuanMnXG5cbmV4cG9ydCB0eXBlIENyZWF0ZU5vZGVGcm9tQ29udGVudE9wdGlvbnMgPSB7XG4gIHNsaWNlPzogYm9vbGVhblxuICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcbiAgZXJyb3JPbkludmFsaWRDb250ZW50PzogYm9vbGVhblxufVxuXG4vKipcbiAqIFRha2VzIGEgSlNPTiBvciBIVE1MIGNvbnRlbnQgYW5kIGNyZWF0ZXMgYSBQcm9zZW1pcnJvciBub2RlIG9yIGZyYWdtZW50IGZyb20gaXQuXG4gKiBAcGFyYW0gY29udGVudCBUaGUgSlNPTiBvciBIVE1MIGNvbnRlbnQgdG8gY3JlYXRlIHRoZSBub2RlIGZyb21cbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFByb3NlbWlycm9yIHNjaGVtYSB0byB1c2UgZm9yIHRoZSBub2RlXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgcGFyc2VyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBQcm9zZW1pcnJvciBub2RlIG9yIGZyYWdtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoXG4gIGNvbnRlbnQ6IENvbnRlbnQgfCBQcm9zZU1pcnJvck5vZGUgfCBGcmFnbWVudCxcbiAgc2NoZW1hOiBTY2hlbWEsXG4gIG9wdGlvbnM/OiBDcmVhdGVOb2RlRnJvbUNvbnRlbnRPcHRpb25zLFxuKTogUHJvc2VNaXJyb3JOb2RlIHwgRnJhZ21lbnQge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFByb3NlTWlycm9yTm9kZSB8fCBjb250ZW50IGluc3RhbmNlb2YgRnJhZ21lbnQpIHtcbiAgICByZXR1cm4gY29udGVudFxuICB9XG4gIG9wdGlvbnMgPSB7XG4gICAgc2xpY2U6IHRydWUsXG4gICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICAuLi5vcHRpb25zLFxuICB9XG5cbiAgY29uc3QgaXNKU09OQ29udGVudCA9IHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0JyAmJiBjb250ZW50ICE9PSBudWxsXG4gIGNvbnN0IGlzVGV4dENvbnRlbnQgPSB0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZydcblxuICBpZiAoaXNKU09OQ29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpc0FycmF5Q29udGVudCA9IEFycmF5LmlzQXJyYXkoY29udGVudCkgJiYgY29udGVudC5sZW5ndGggPiAwXG5cbiAgICAgIC8vIGlmIHRoZSBKU09OIENvbnRlbnQgaXMgYW4gYXJyYXkgb2Ygbm9kZXMsIGNyZWF0ZSBhIGZyYWdtZW50IGZvciBlYWNoIG5vZGVcbiAgICAgIGlmIChpc0FycmF5Q29udGVudCkge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KGNvbnRlbnQubWFwKGl0ZW0gPT4gc2NoZW1hLm5vZGVGcm9tSlNPTihpdGVtKSkpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBzY2hlbWEubm9kZUZyb21KU09OKGNvbnRlbnQpXG5cbiAgICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkge1xuICAgICAgICBub2RlLmNoZWNrKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSlNPTiBjb250ZW50JywgeyBjYXVzZTogZXJyb3IgYXMgRXJyb3IgfSlcbiAgICAgIH1cblxuICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBJbnZhbGlkIGNvbnRlbnQuJywgJ1Bhc3NlZCB2YWx1ZTonLCBjb250ZW50LCAnRXJyb3I6JywgZXJyb3IpXG5cbiAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoJycsIHNjaGVtYSwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICBpZiAoaXNUZXh0Q29udGVudCkge1xuICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIGNvbnRlbnRcbiAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpIHtcbiAgICAgIGxldCBoYXNJbnZhbGlkQ29udGVudCA9IGZhbHNlXG4gICAgICBsZXQgaW52YWxpZENvbnRlbnQgPSAnJ1xuXG4gICAgICAvLyBBIGNvcHkgb2YgdGhlIGN1cnJlbnQgc2NoZW1hIHdpdGggYSBjYXRjaC1hbGwgbm9kZSBhdCB0aGUgZW5kXG4gICAgICBjb25zdCBjb250ZW50Q2hlY2tTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAgICAgICAgdG9wTm9kZTogc2NoZW1hLnNwZWMudG9wTm9kZSxcbiAgICAgICAgbWFya3M6IHNjaGVtYS5zcGVjLm1hcmtzLFxuICAgICAgICAvLyBQcm9zZW1pcnJvcidzIHNjaGVtYXMgYXJlIGV4ZWN1dGVkIHN1Y2ggdGhhdDogdGhlIGxhc3QgdG8gZXhlY3V0ZSwgbWF0Y2hlcyBsYXN0XG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB3ZSBjYW4gYWRkIGEgY2F0Y2gtYWxsIG5vZGUgYXQgdGhlIGVuZCBvZiB0aGUgc2NoZW1hIHRvIGNhdGNoIGFueSBjb250ZW50IHRoYXQgd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlXG4gICAgICAgIG5vZGVzOiBzY2hlbWEuc3BlYy5ub2Rlcy5hcHBlbmQoe1xuICAgICAgICAgIF9fdGlwdGFwX19wcml2YXRlX191bmtub3duX19jYXRjaF9fYWxsX19ub2RlOiB7XG4gICAgICAgICAgICBjb250ZW50OiAnaW5saW5lKicsXG4gICAgICAgICAgICBncm91cDogJ2Jsb2NrJyxcbiAgICAgICAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICcqJyxcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogZSA9PiB7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGV2ZXIgY2FsbGVkLCB3ZSBrbm93IHRoYXQgdGhlIGNvbnRlbnQgaGFzIHNvbWV0aGluZyB0aGF0IHdlIGRvbid0IGtub3cgaG93IHRvIGhhbmRsZSBpbiB0aGUgc2NoZW1hXG4gICAgICAgICAgICAgICAgICBoYXNJbnZhbGlkQ29udGVudCA9IHRydWVcbiAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBzdHJpbmdpZnkgdGhlIGVsZW1lbnQgZm9yIGEgbW9yZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgIGludmFsaWRDb250ZW50ID0gdHlwZW9mIGUgPT09ICdzdHJpbmcnID8gZSA6IGUub3V0ZXJIVE1MXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgfSlcblxuICAgICAgaWYgKG9wdGlvbnMuc2xpY2UpIHtcbiAgICAgICAgRE9NUGFyc2VyLmZyb21TY2hlbWEoY29udGVudENoZWNrU2NoZW1hKS5wYXJzZVNsaWNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERPTVBhcnNlci5mcm9tU2NoZW1hKGNvbnRlbnRDaGVja1NjaGVtYSkucGFyc2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQgJiYgaGFzSW52YWxpZENvbnRlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbdGlwdGFwIGVycm9yXTogSW52YWxpZCBIVE1MIGNvbnRlbnQnLCB7XG4gICAgICAgICAgY2F1c2U6IG5ldyBFcnJvcihgSW52YWxpZCBlbGVtZW50IGZvdW5kOiAke2ludmFsaWRDb250ZW50fWApLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlciA9IERPTVBhcnNlci5mcm9tU2NoZW1hKHNjaGVtYSlcblxuICAgIGlmIChvcHRpb25zLnNsaWNlKSB7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKS5jb250ZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KCcnLCBzY2hlbWEsIG9wdGlvbnMpXG59XG4iLCAiY29uc3QgcmVtb3ZlV2hpdGVzcGFjZXMgPSAobm9kZTogSFRNTEVsZW1lbnQpID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXNcblxuICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDMgJiYgY2hpbGQubm9kZVZhbHVlICYmIC9eKFxcblxcc1xcc3xcXG4pJC8udGVzdChjaGlsZC5ub2RlVmFsdWUpKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKVxuICAgIH0gZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIHJlbW92ZVdoaXRlc3BhY2VzKGNoaWxkIGFzIEhUTUxFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50RnJvbVN0cmluZyh2YWx1ZTogc3RyaW5nKTogSFRNTEVsZW1lbnQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1t0aXB0YXAgZXJyb3JdOiB0aGVyZSBpcyBubyB3aW5kb3cgb2JqZWN0IGF2YWlsYWJsZSwgc28gdGhpcyBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCcpXG4gIH1cbiAgLy8gYWRkIGEgd3JhcHBlciB0byBwcmVzZXJ2ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gIGNvbnN0IHdyYXBwZWRWYWx1ZSA9IGA8Ym9keT4ke3ZhbHVlfTwvYm9keT5gXG5cbiAgY29uc3QgaHRtbCA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHdyYXBwZWRWYWx1ZSwgJ3RleHQvaHRtbCcpLmJvZHlcblxuICByZXR1cm4gcmVtb3ZlV2hpdGVzcGFjZXMoaHRtbClcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEZyYWdtZW50LCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgUGFyc2VPcHRpb25zLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgdHlwZSB7IENvbnRlbnQgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNyZWF0ZU5vZGVGcm9tQ29udGVudCB9IGZyb20gJy4vY3JlYXRlTm9kZUZyb21Db250ZW50LmpzJ1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBQcm9zZW1pcnJvciBkb2N1bWVudCBub2RlIGZyb20gY29udGVudC5cbiAqIEBwYXJhbSBjb250ZW50IFRoZSBKU09OIG9yIEhUTUwgY29udGVudCB0byBjcmVhdGUgdGhlIGRvY3VtZW50IGZyb21cbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFByb3NlbWlycm9yIHNjaGVtYSB0byB1c2UgZm9yIHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHBhcnNlT3B0aW9ucyBPcHRpb25zIGZvciB0aGUgcGFyc2VyXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBQcm9zZW1pcnJvciBkb2N1bWVudCBub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEb2N1bWVudChcbiAgY29udGVudDogQ29udGVudCB8IFByb3NlTWlycm9yTm9kZSB8IEZyYWdtZW50LFxuICBzY2hlbWE6IFNjaGVtYSxcbiAgcGFyc2VPcHRpb25zOiBQYXJzZU9wdGlvbnMgPSB7fSxcbiAgb3B0aW9uczogeyBlcnJvck9uSW52YWxpZENvbnRlbnQ/OiBib29sZWFuIH0gPSB7fSxcbik6IFByb3NlTWlycm9yTm9kZSB7XG4gIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoY29udGVudCwgc2NoZW1hLCB7XG4gICAgc2xpY2U6IGZhbHNlLFxuICAgIHBhcnNlT3B0aW9ucyxcbiAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50LFxuICB9KSBhcyBQcm9zZU1pcnJvck5vZGVcbn1cbiIsICJpbXBvcnQgdHlwZSB7IENvbnRlbnRNYXRjaCwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG4vKipcbiAqIEdldHMgdGhlIGRlZmF1bHQgYmxvY2sgdHlwZSBhdCBhIGdpdmVuIG1hdGNoXG4gKiBAcGFyYW0gbWF0Y2ggVGhlIGNvbnRlbnQgbWF0Y2ggdG8gZ2V0IHRoZSBkZWZhdWx0IGJsb2NrIHR5cGUgZnJvbVxuICogQHJldHVybnMgVGhlIGRlZmF1bHQgYmxvY2sgdHlwZSBvciBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0QmxvY2tBdChtYXRjaDogQ29udGVudE1hdGNoKTogTm9kZVR5cGUgfCBudWxsIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkgKz0gMSkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gbWF0Y2guZWRnZShpKVxuXG4gICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSB7XG4gICAgICByZXR1cm4gdHlwZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB0eXBlIHsgTm9kZVdpdGhQb3MsIFByZWRpY2F0ZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG4vKipcbiAqIEZpbmQgY2hpbGRyZW4gaW5zaWRlIGEgUHJvc2VtaXJyb3Igbm9kZSB0aGF0IG1hdGNoIGEgcHJlZGljYXRlLlxuICogQHBhcmFtIG5vZGUgVGhlIFByb3NlbWlycm9yIG5vZGUgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbWF0Y2hcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIHdpdGggdGhlaXIgcG9zaXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ2hpbGRyZW4obm9kZTogUHJvc2VNaXJyb3JOb2RlLCBwcmVkaWNhdGU6IFByZWRpY2F0ZSk6IE5vZGVXaXRoUG9zW10ge1xuICBjb25zdCBub2Rlc1dpdGhQb3M6IE5vZGVXaXRoUG9zW10gPSBbXVxuXG4gIG5vZGUuZGVzY2VuZGFudHMoKGNoaWxkLCBwb3MpID0+IHtcbiAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgcG9zLFxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG5vZGVzV2l0aFBvc1xufVxuIiwgImltcG9ydCB0eXBlIHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgdHlwZSB7IE5vZGVXaXRoUG9zLCBQcmVkaWNhdGUsIFJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbi8qKlxuICogU2FtZSBhcyBgZmluZENoaWxkcmVuYCBidXQgc2VhcmNoZXMgb25seSB3aXRoaW4gYSBgcmFuZ2VgLlxuICogQHBhcmFtIG5vZGUgVGhlIFByb3NlbWlycm9yIG5vZGUgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB3aXRoIHRoZWlyIHBvc2l0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZENoaWxkcmVuSW5SYW5nZShub2RlOiBQcm9zZU1pcnJvck5vZGUsIHJhbmdlOiBSYW5nZSwgcHJlZGljYXRlOiBQcmVkaWNhdGUpOiBOb2RlV2l0aFBvc1tdIHtcbiAgY29uc3Qgbm9kZXNXaXRoUG9zOiBOb2RlV2l0aFBvc1tdID0gW11cblxuICAvLyBpZiAocmFuZ2UuZnJvbSA9PT0gcmFuZ2UudG8pIHtcbiAgLy8gICBjb25zdCBub2RlQXQgPSBub2RlLm5vZGVBdChyYW5nZS5mcm9tKVxuXG4gIC8vICAgaWYgKG5vZGVBdCkge1xuICAvLyAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAvLyAgICAgICBub2RlOiBub2RlQXQsXG4gIC8vICAgICAgIHBvczogcmFuZ2UuZnJvbSxcbiAgLy8gICAgIH0pXG4gIC8vICAgfVxuICAvLyB9XG5cbiAgbm9kZS5ub2Rlc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIChjaGlsZCwgcG9zKSA9PiB7XG4gICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIHBvcyxcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBub2Rlc1dpdGhQb3Ncbn1cbiIsICJpbXBvcnQgdHlwZSB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB0eXBlIHsgUHJlZGljYXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbi8qKlxuICogRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdG8gYSByZXNvbHZlZCBwb3NpdGlvbiB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gJHBvcyBUaGUgcmVzb2x2ZWQgcG9zaXRpb24gdG8gc2VhcmNoIGZyb21cbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBtYXRjaFxuICogQHJldHVybnMgVGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdG8gdGhlIHJlc29sdmVkIHBvc2l0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlXG4gKiBAZXhhbXBsZSBgYGBqc1xuICogZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoJGZyb20sIG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyhcbiAgJHBvczogUmVzb2x2ZWRQb3MsXG4gIHByZWRpY2F0ZTogUHJlZGljYXRlLFxuKTpcbiAgfCB7XG4gICAgICBwb3M6IG51bWJlclxuICAgICAgc3RhcnQ6IG51bWJlclxuICAgICAgZGVwdGg6IG51bWJlclxuICAgICAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG4gICAgfVxuICB8IHVuZGVmaW5lZCB7XG4gIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShpKVxuXG4gICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBpID4gMCA/ICRwb3MuYmVmb3JlKGkpIDogMCxcbiAgICAgICAgc3RhcnQ6ICRwb3Muc3RhcnQoaSksXG4gICAgICAgIGRlcHRoOiBpLFxuICAgICAgICBub2RlLFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHR5cGUgeyBQcmVkaWNhdGUgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zIH0gZnJvbSAnLi9maW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcy5qcydcblxuLyoqXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gdGhhdCBtYXRjaGVzIGEgcHJlZGljYXRlLlxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBBIGNvbW1hbmQgdGhhdCBmaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gdGhhdCBtYXRjaGVzIHRoZSBwcmVkaWNhdGVcbiAqIEBleGFtcGxlIGBgYGpzXG4gKiBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZS5uYW1lID09PSAncGFyYWdyYXBoJylcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFBhcmVudE5vZGUoXG4gIHByZWRpY2F0ZTogUHJlZGljYXRlLFxuKTogKHNlbGVjdGlvbjogU2VsZWN0aW9uKSA9PiBSZXR1cm5UeXBlPHR5cGVvZiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1Bvcz4ge1xuICByZXR1cm4gKHNlbGVjdGlvbjogU2VsZWN0aW9uKSA9PiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyhzZWxlY3Rpb24uJGZyb20sIHByZWRpY2F0ZSlcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEV4dGVuc2lvbkNvbmZpZyB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcbmltcG9ydCB0eXBlIHsgTWFya0NvbmZpZyB9IGZyb20gJy4uL01hcmsuanMnXG5pbXBvcnQgdHlwZSB7IE5vZGVDb25maWcgfSBmcm9tICcuLi9Ob2RlLmpzJ1xuaW1wb3J0IHR5cGUgeyBBbnlFeHRlbnNpb24sIE1heWJlVGhpc1BhcmFtZXRlclR5cGUsIFJlbW92ZVRoaXMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuLyoqXG4gKiBSZXR1cm5zIGEgZmllbGQgZnJvbSBhbiBleHRlbnNpb25cbiAqIEBwYXJhbSBleHRlbnNpb24gVGhlIFRpcHRhcCBleHRlbnNpb25cbiAqIEBwYXJhbSBmaWVsZCBUaGUgZmllbGQsIGZvciBleGFtcGxlIGByZW5kZXJIVE1MYCBvciBgcHJpb3JpdHlgXG4gKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCBvYmplY3QgdGhhdCBzaG91bGQgYmUgcGFzc2VkIGFzIGB0aGlzYCBpbnRvIHRoZSBmdW5jdGlvblxuICogQHJldHVybnMgVGhlIGZpZWxkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlbnNpb25GaWVsZDxUID0gYW55LCBFIGV4dGVuZHMgQW55RXh0ZW5zaW9uID0gYW55PihcbiAgZXh0ZW5zaW9uOiBFLFxuICBmaWVsZDoga2V5b2YgRXh0ZW5zaW9uQ29uZmlnIHwga2V5b2YgTWFya0NvbmZpZyB8IGtleW9mIE5vZGVDb25maWcsXG4gIGNvbnRleHQ/OiBPbWl0PE1heWJlVGhpc1BhcmFtZXRlclR5cGU8VD4sICdwYXJlbnQnPixcbik6IFJlbW92ZVRoaXM8VD4ge1xuICBpZiAoZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZCBhcyBrZXlvZiB0eXBlb2YgZXh0ZW5zaW9uLmNvbmZpZ10gPT09IHVuZGVmaW5lZCAmJiBleHRlbnNpb24ucGFyZW50KSB7XG4gICAgcmV0dXJuIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBleHRlbnNpb24uY29uZmlnW2ZpZWxkIGFzIGtleW9mIHR5cGVvZiBleHRlbnNpb24uY29uZmlnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHZhbHVlID0gKGV4dGVuc2lvbi5jb25maWdbZmllbGQgYXMga2V5b2YgdHlwZW9mIGV4dGVuc2lvbi5jb25maWddIGFzIGFueSkuYmluZCh7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAgcGFyZW50OiBleHRlbnNpb24ucGFyZW50ID8gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLnBhcmVudCwgZmllbGQsIGNvbnRleHQpIDogbnVsbCxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByZXR1cm4gZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZCBhcyBrZXlvZiB0eXBlb2YgZXh0ZW5zaW9uLmNvbmZpZ10gYXMgUmVtb3ZlVGhpczxUPlxufVxuIiwgImltcG9ydCB0eXBlIHsgQW55Q29uZmlnLCBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5cbi8qKlxuICogQ3JlYXRlIGEgZmxhdHRlbmVkIGFycmF5IG9mIGV4dGVuc2lvbnMgYnkgdHJhdmVyc2luZyB0aGUgYGFkZEV4dGVuc2lvbnNgIGZpZWxkLlxuICogQHBhcmFtIGV4dGVuc2lvbnMgQW4gYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnNcbiAqIEByZXR1cm5zIEEgZmxhdHRlbmVkIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuRXh0ZW5zaW9ucyhleHRlbnNpb25zOiBFeHRlbnNpb25zKTogRXh0ZW5zaW9ucyB7XG4gIHJldHVybiAoXG4gICAgZXh0ZW5zaW9uc1xuICAgICAgLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWRkRXh0ZW5zaW9ucyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkRXh0ZW5zaW9ucyddPihleHRlbnNpb24sICdhZGRFeHRlbnNpb25zJywgY29udGV4dClcblxuICAgICAgICBpZiAoYWRkRXh0ZW5zaW9ucykge1xuICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLCAuLi5mbGF0dGVuRXh0ZW5zaW9ucyhhZGRFeHRlbnNpb25zKCkpXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvblxuICAgICAgfSlcbiAgICAgIC8vIGBJbmZpbml0eWAgd2lsbCBicmVhayBUeXBlU2NyaXB0IHNvIHdlIHNldCBhIG51bWJlciB0aGF0IGlzIHByb2JhYmx5IGhpZ2ggZW5vdWdoXG4gICAgICAuZmxhdCgxMClcbiAgKVxufVxuIiwgImltcG9ydCB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgdHlwZSB7IEV4dGVuc2lvbnMsIEpTT05Db250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRIVE1MRnJvbUZyYWdtZW50IH0gZnJvbSAnLi9nZXRIVE1MRnJvbUZyYWdtZW50LmpzJ1xuaW1wb3J0IHsgZ2V0U2NoZW1hIH0gZnJvbSAnLi9nZXRTY2hlbWEuanMnXG5cbi8qKlxuICogR2VuZXJhdGUgSFRNTCBmcm9tIGEgSlNPTkNvbnRlbnRcbiAqIEBwYXJhbSBkb2MgVGhlIEpTT05Db250ZW50IHRvIGdlbmVyYXRlIEhUTUwgZnJvbVxuICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGV4dGVuc2lvbnMgdG8gdXNlIGZvciB0aGUgc2NoZW1hXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIEhUTUxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSFRNTChkb2M6IEpTT05Db250ZW50LCBleHRlbnNpb25zOiBFeHRlbnNpb25zKTogc3RyaW5nIHtcbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGNvbnRlbnROb2RlID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIGRvYylcblxuICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudChjb250ZW50Tm9kZS5jb250ZW50LCBzY2hlbWEpXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBGcmFnbWVudCwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IERPTVNlcmlhbGl6ZXIgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SFRNTEZyb21GcmFnbWVudChmcmFnbWVudDogRnJhZ21lbnQsIHNjaGVtYTogU2NoZW1hKTogc3RyaW5nIHtcbiAgY29uc3QgZG9jdW1lbnRGcmFnbWVudCA9IERPTVNlcmlhbGl6ZXIuZnJvbVNjaGVtYShzY2hlbWEpLnNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50KVxuXG4gIGNvbnN0IHRlbXBvcmFyeURvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KClcbiAgY29uc3QgY29udGFpbmVyID0gdGVtcG9yYXJ5RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnRGcmFnbWVudClcblxuICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxufVxuIiwgImltcG9ydCB0eXBlIHsgTWFya1NwZWMsIE5vZGVTcGVjLCBUYWdQYXJzZVJ1bGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHR5cGUgeyBFZGl0b3IsIE1hcmtDb25maWcsIE5vZGVDb25maWcgfSBmcm9tICcuLi9pbmRleC5qcydcbmltcG9ydCB0eXBlIHsgQW55Q29uZmlnLCBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuaW1wb3J0IHsgaXNFbXB0eU9iamVjdCB9IGZyb20gJy4uL3V0aWxpdGllcy9pc0VtcHR5T2JqZWN0LmpzJ1xuaW1wb3J0IHsgZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zIH0gZnJvbSAnLi9nZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMgfSBmcm9tICcuL2dldFJlbmRlcmVkQXR0cmlidXRlcy5qcydcbmltcG9ydCB7IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZSB9IGZyb20gJy4vaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlLmpzJ1xuaW1wb3J0IHsgc3BsaXRFeHRlbnNpb25zIH0gZnJvbSAnLi9zcGxpdEV4dGVuc2lvbnMuanMnXG5cbmZ1bmN0aW9uIGNsZWFuVXBTY2hlbWFJdGVtPFQ+KGRhdGE6IFQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZmlsdGVyKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdhdHRycycgJiYgaXNFbXB0eU9iamVjdCh2YWx1ZSBhcyBvYmplY3QgfCB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgIH0pLFxuICApIGFzIFRcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFByb3NlbWlycm9yIHNjaGVtYSBiYXNlZCBvbiB0aGUgZ2l2ZW4gZXh0ZW5zaW9ucy5cbiAqIEBwYXJhbSBleHRlbnNpb25zIEFuIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXG4gKiBAcGFyYW0gZWRpdG9yIFRoZSBlZGl0b3IgaW5zdGFuY2VcbiAqIEByZXR1cm5zIEEgUHJvc2VtaXJyb3Igc2NoZW1hXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhleHRlbnNpb25zOiBFeHRlbnNpb25zLCBlZGl0b3I/OiBFZGl0b3IpOiBTY2hlbWEge1xuICBjb25zdCBhbGxBdHRyaWJ1dGVzID0gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMsIG1hcmtFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucylcbiAgY29uc3QgdG9wTm9kZSA9IG5vZGVFeHRlbnNpb25zLmZpbmQoZXh0ZW5zaW9uID0+IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3RvcE5vZGUnKSk/Lm5hbWVcblxuICBjb25zdCBub2RlcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBub2RlRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcihhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lKVxuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRyYU5vZGVGaWVsZHMgPSBleHRlbnNpb25zLnJlZHVjZSgoZmllbGRzLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE5vZGVTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2V4dGVuZE5vZGVTY2hlbWEnXT4oZSwgJ2V4dGVuZE5vZGVTY2hlbWEnLCBjb250ZXh0KVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgIC4uLihleHRlbmROb2RlU2NoZW1hID8gZXh0ZW5kTm9kZVNjaGVtYShleHRlbnNpb24pIDoge30pLFxuICAgICAgICB9XG4gICAgICB9LCB7fSlcblxuICAgICAgY29uc3Qgc2NoZW1hOiBOb2RlU3BlYyA9IGNsZWFuVXBTY2hlbWFJdGVtKHtcbiAgICAgICAgLi4uZXh0cmFOb2RlRmllbGRzLFxuICAgICAgICBjb250ZW50OiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snY29udGVudCddPihleHRlbnNpb24sICdjb250ZW50JywgY29udGV4dCkpLFxuICAgICAgICBtYXJrczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ21hcmtzJ10+KGV4dGVuc2lvbiwgJ21hcmtzJywgY29udGV4dCkpLFxuICAgICAgICBncm91cDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2dyb3VwJ10+KGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpLFxuICAgICAgICBpbmxpbmU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydpbmxpbmUnXT4oZXh0ZW5zaW9uLCAnaW5saW5lJywgY29udGV4dCkpLFxuICAgICAgICBhdG9tOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snYXRvbSddPihleHRlbnNpb24sICdhdG9tJywgY29udGV4dCkpLFxuICAgICAgICBzZWxlY3RhYmxlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snc2VsZWN0YWJsZSddPihleHRlbnNpb24sICdzZWxlY3RhYmxlJywgY29udGV4dCkpLFxuICAgICAgICBkcmFnZ2FibGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydkcmFnZ2FibGUnXT4oZXh0ZW5zaW9uLCAnZHJhZ2dhYmxlJywgY29udGV4dCkpLFxuICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snY29kZSddPihleHRlbnNpb24sICdjb2RlJywgY29udGV4dCkpLFxuICAgICAgICB3aGl0ZXNwYWNlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snd2hpdGVzcGFjZSddPihleHRlbnNpb24sICd3aGl0ZXNwYWNlJywgY29udGV4dCkpLFxuICAgICAgICBsaW5lYnJlYWtSZXBsYWNlbWVudDogY2FsbE9yUmV0dXJuKFxuICAgICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2xpbmVicmVha1JlcGxhY2VtZW50J10+KGV4dGVuc2lvbiwgJ2xpbmVicmVha1JlcGxhY2VtZW50JywgY29udGV4dCksXG4gICAgICAgICksXG4gICAgICAgIGRlZmluaW5nOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snZGVmaW5pbmcnXT4oZXh0ZW5zaW9uLCAnZGVmaW5pbmcnLCBjb250ZXh0KSksXG4gICAgICAgIGlzb2xhdGluZzogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ2lzb2xhdGluZyddPihleHRlbnNpb24sICdpc29sYXRpbmcnLCBjb250ZXh0KSksXG4gICAgICAgIGF0dHJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5tYXAoZXh0ZW5zaW9uQXR0cmlidXRlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZS5uYW1lLFxuICAgICAgICAgICAgICB7IGRlZmF1bHQ6IGV4dGVuc2lvbkF0dHJpYnV0ZT8uYXR0cmlidXRlPy5kZWZhdWx0LCB2YWxpZGF0ZTogZXh0ZW5zaW9uQXR0cmlidXRlPy5hdHRyaWJ1dGU/LnZhbGlkYXRlIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSksXG4gICAgICAgICksXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1sncGFyc2VIVE1MJ10+KGV4dGVuc2lvbiwgJ3BhcnNlSFRNTCcsIGNvbnRleHQpKVxuXG4gICAgICBpZiAocGFyc2VIVE1MKSB7XG4gICAgICAgIHNjaGVtYS5wYXJzZURPTSA9IHBhcnNlSFRNTC5tYXAocGFyc2VSdWxlID0+XG4gICAgICAgICAgaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyksXG4gICAgICAgICkgYXMgVGFnUGFyc2VSdWxlW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkPE5vZGVDb25maWdbJ3JlbmRlckhUTUwnXT4oZXh0ZW5zaW9uLCAncmVuZGVySFRNTCcsIGNvbnRleHQpXG5cbiAgICAgIGlmIChyZW5kZXJIVE1MKSB7XG4gICAgICAgIHNjaGVtYS50b0RPTSA9IG5vZGUgPT5cbiAgICAgICAgICByZW5kZXJIVE1MKHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczogZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpLFxuICAgICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlbmRlclRleHQgPSBnZXRFeHRlbnNpb25GaWVsZDxOb2RlQ29uZmlnWydyZW5kZXJUZXh0J10+KGV4dGVuc2lvbiwgJ3JlbmRlclRleHQnLCBjb250ZXh0KVxuXG4gICAgICBpZiAocmVuZGVyVGV4dCkge1xuICAgICAgICBzY2hlbWEudG9UZXh0ID0gcmVuZGVyVGV4dFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBzY2hlbWFdXG4gICAgfSksXG4gIClcblxuICBjb25zdCBtYXJrcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBtYXJrRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcihhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lKVxuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgZWRpdG9yLFxuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRyYU1hcmtGaWVsZHMgPSBleHRlbnNpb25zLnJlZHVjZSgoZmllbGRzLCBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuZE1hcmtTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ2V4dGVuZE1hcmtTY2hlbWEnXT4oZSwgJ2V4dGVuZE1hcmtTY2hlbWEnLCBjb250ZXh0KVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgIC4uLihleHRlbmRNYXJrU2NoZW1hID8gZXh0ZW5kTWFya1NjaGVtYShleHRlbnNpb24gYXMgYW55KSA6IHt9KSxcbiAgICAgICAgfVxuICAgICAgfSwge30pXG5cbiAgICAgIGNvbnN0IHNjaGVtYTogTWFya1NwZWMgPSBjbGVhblVwU2NoZW1hSXRlbSh7XG4gICAgICAgIC4uLmV4dHJhTWFya0ZpZWxkcyxcbiAgICAgICAgaW5jbHVzaXZlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1snaW5jbHVzaXZlJ10+KGV4dGVuc2lvbiwgJ2luY2x1c2l2ZScsIGNvbnRleHQpKSxcbiAgICAgICAgZXhjbHVkZXM6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydleGNsdWRlcyddPihleHRlbnNpb24sICdleGNsdWRlcycsIGNvbnRleHQpKSxcbiAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydncm91cCddPihleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKSxcbiAgICAgICAgc3Bhbm5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydzcGFubmluZyddPihleHRlbnNpb24sICdzcGFubmluZycsIGNvbnRleHQpKSxcbiAgICAgICAgY29kZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkPE1hcmtDb25maWdbJ2NvZGUnXT4oZXh0ZW5zaW9uLCAnY29kZScsIGNvbnRleHQpKSxcbiAgICAgICAgYXR0cnM6IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLm1hcChleHRlbnNpb25BdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsXG4gICAgICAgICAgICAgIHsgZGVmYXVsdDogZXh0ZW5zaW9uQXR0cmlidXRlPy5hdHRyaWJ1dGU/LmRlZmF1bHQsIHZhbGlkYXRlOiBleHRlbnNpb25BdHRyaWJ1dGU/LmF0dHJpYnV0ZT8udmFsaWRhdGUgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KSxcbiAgICAgICAgKSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZDxNYXJrQ29uZmlnWydwYXJzZUhUTUwnXT4oZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCkpXG5cbiAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChwYXJzZVJ1bGUgPT5cbiAgICAgICAgICBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW5kZXJIVE1MID0gZ2V0RXh0ZW5zaW9uRmllbGQ8TWFya0NvbmZpZ1sncmVuZGVySFRNTCddPihleHRlbnNpb24sICdyZW5kZXJIVE1MJywgY29udGV4dClcblxuICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgc2NoZW1hLnRvRE9NID0gbWFyayA9PlxuICAgICAgICAgIHJlbmRlckhUTUwoe1xuICAgICAgICAgICAgbWFyayxcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobWFyaywgZXh0ZW5zaW9uQXR0cmlidXRlcyksXG4gICAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgc2NoZW1hXVxuICAgIH0pLFxuICApXG5cbiAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgIHRvcE5vZGUsXG4gICAgbm9kZXMsXG4gICAgbWFya3MsXG4gIH0pXG59XG4iLCAiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZnVuY3Rpb24tdHlwZVxuZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWU6IGFueSk6IHZhbHVlIGlzIEZ1bmN0aW9uIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuIiwgImltcG9ydCB0eXBlIHsgTWF5YmVSZXR1cm5UeXBlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJ1xuXG4vKipcbiAqIE9wdGlvbmFsbHkgY2FsbHMgYHZhbHVlYCBhcyBhIGZ1bmN0aW9uLlxuICogT3RoZXJ3aXNlIGl0IGlzIHJldHVybmVkIGRpcmVjdGx5LlxuICogQHBhcmFtIHZhbHVlIEZ1bmN0aW9uIG9yIGFueSB2YWx1ZS5cbiAqIEBwYXJhbSBjb250ZXh0IE9wdGlvbmFsIGNvbnRleHQgdG8gYmluZCB0byBmdW5jdGlvbi5cbiAqIEBwYXJhbSBwcm9wcyBPcHRpb25hbCBwcm9wcyB0byBwYXNzIHRvIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsbE9yUmV0dXJuPFQ+KHZhbHVlOiBULCBjb250ZXh0OiBhbnkgPSB1bmRlZmluZWQsIC4uLnByb3BzOiBhbnlbXSk6IE1heWJlUmV0dXJuVHlwZTxUPiB7XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdmFsdWUuYmluZChjb250ZXh0KSguLi5wcm9wcylcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUoLi4ucHJvcHMpXG4gIH1cblxuICByZXR1cm4gdmFsdWUgYXMgTWF5YmVSZXR1cm5UeXBlPFQ+XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlPYmplY3QodmFsdWUgPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5pbXBvcnQgdHlwZSB7IE1hcmsgfSBmcm9tICcuLi9NYXJrLmpzJ1xuaW1wb3J0IHR5cGUgeyBOb2RlIH0gZnJvbSAnLi4vTm9kZS5qcydcbmltcG9ydCB0eXBlIHsgRXh0ZW5zaW9ucyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpIHtcbiAgY29uc3QgYmFzZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdleHRlbnNpb24nKSBhcyBFeHRlbnNpb25bXVxuICBjb25zdCBub2RlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ25vZGUnKSBhcyBOb2RlW11cbiAgY29uc3QgbWFya0V4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJykgYXMgTWFya1tdXG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlRXh0ZW5zaW9ucyxcbiAgICBub2RlRXh0ZW5zaW9ucyxcbiAgICBtYXJrRXh0ZW5zaW9ucyxcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgTWFya0NvbmZpZywgTm9kZUNvbmZpZyB9IGZyb20gJy4uL2luZGV4LmpzJ1xuaW1wb3J0IHR5cGUgeyBBbnlDb25maWcsIEF0dHJpYnV0ZSwgQXR0cmlidXRlcywgRXh0ZW5zaW9uQXR0cmlidXRlLCBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5pbXBvcnQgeyBzcGxpdEV4dGVuc2lvbnMgfSBmcm9tICcuL3NwbGl0RXh0ZW5zaW9ucy5qcydcblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIGFsbCBleHRlbnNpb24gYXR0cmlidXRlcyBkZWZpbmVkIGluIGBhZGRBdHRyaWJ1dGVgIGFuZCBgYWRkR2xvYmFsQXR0cmlidXRlYC5cbiAqIEBwYXJhbSBleHRlbnNpb25zIExpc3Qgb2YgZXh0ZW5zaW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSB7XG4gIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXM6IEV4dGVuc2lvbkF0dHJpYnV0ZVtdID0gW11cbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKVxuICBjb25zdCBub2RlQW5kTWFya0V4dGVuc2lvbnMgPSBbLi4ubm9kZUV4dGVuc2lvbnMsIC4uLm1hcmtFeHRlbnNpb25zXVxuICBjb25zdCBkZWZhdWx0QXR0cmlidXRlOiBSZXF1aXJlZDxPbWl0PEF0dHJpYnV0ZSwgJ3ZhbGlkYXRlJz4+ICYgUGljazxBdHRyaWJ1dGUsICd2YWxpZGF0ZSc+ID0ge1xuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgdmFsaWRhdGU6IHVuZGVmaW5lZCxcbiAgICByZW5kZXJlZDogdHJ1ZSxcbiAgICByZW5kZXJIVE1MOiBudWxsLFxuICAgIHBhcnNlSFRNTDogbnVsbCxcbiAgICBrZWVwT25TcGxpdDogdHJ1ZSxcbiAgICBpc1JlcXVpcmVkOiBmYWxzZSxcbiAgfVxuXG4gIGV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICBleHRlbnNpb25zOiBub2RlQW5kTWFya0V4dGVuc2lvbnMsXG4gICAgfVxuXG4gICAgY29uc3QgYWRkR2xvYmFsQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkR2xvYmFsQXR0cmlidXRlcyddPihcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgICdhZGRHbG9iYWxBdHRyaWJ1dGVzJyxcbiAgICAgIGNvbnRleHQsXG4gICAgKVxuXG4gICAgaWYgKCFhZGRHbG9iYWxBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBnbG9iYWxBdHRyaWJ1dGVzID0gYWRkR2xvYmFsQXR0cmlidXRlcygpXG5cbiAgICBnbG9iYWxBdHRyaWJ1dGVzLmZvckVhY2goZ2xvYmFsQXR0cmlidXRlID0+IHtcbiAgICAgIGdsb2JhbEF0dHJpYnV0ZS50eXBlcy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICBPYmplY3QuZW50cmllcyhnbG9iYWxBdHRyaWJ1dGUuYXR0cmlidXRlcykuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6IHtcbiAgICAgICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgLi4uYXR0cmlidXRlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIG5vZGVBbmRNYXJrRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICB9XG5cbiAgICBjb25zdCBhZGRBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snYWRkQXR0cmlidXRlcyddIHwgTWFya0NvbmZpZ1snYWRkQXR0cmlidXRlcyddPihcbiAgICAgIGV4dGVuc2lvbixcbiAgICAgICdhZGRBdHRyaWJ1dGVzJyxcbiAgICAgIGNvbnRleHQsXG4gICAgKVxuXG4gICAgaWYgKCFhZGRBdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgYGFzIEF0dHJpYnV0ZXNgXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGFkZEF0dHJpYnV0ZXMoKSBhcyBBdHRyaWJ1dGVzXG5cbiAgICBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChbbmFtZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgY29uc3QgbWVyZ2VkQXR0ciA9IHtcbiAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcbiAgICAgICAgLi4uYXR0cmlidXRlLFxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG1lcmdlZEF0dHI/LmRlZmF1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWVyZ2VkQXR0ci5kZWZhdWx0ID0gbWVyZ2VkQXR0ci5kZWZhdWx0KClcbiAgICAgIH1cblxuICAgICAgaWYgKG1lcmdlZEF0dHI/LmlzUmVxdWlyZWQgJiYgbWVyZ2VkQXR0cj8uZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBtZXJnZWRBdHRyLmRlZmF1bHRcbiAgICAgIH1cblxuICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgdHlwZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZTogbWVyZ2VkQXR0cixcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlc1xufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZXMoLi4ub2JqZWN0czogUmVjb3JkPHN0cmluZywgYW55PltdKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIHJldHVybiBvYmplY3RzXG4gICAgLmZpbHRlcihpdGVtID0+ICEhaXRlbSlcbiAgICAucmVkdWNlKChpdGVtcywgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgbWVyZ2VkQXR0cmlidXRlcyA9IHsgLi4uaXRlbXMgfVxuXG4gICAgICBPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgZXhpc3RzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldXG5cbiAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVDbGFzc2VzOiBzdHJpbmdbXSA9IHZhbHVlID8gU3RyaW5nKHZhbHVlKS5zcGxpdCgnICcpIDogW11cbiAgICAgICAgICBjb25zdCBleGlzdGluZ0NsYXNzZXM6IHN0cmluZ1tdID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KCcgJykgOiBbXVxuXG4gICAgICAgICAgY29uc3QgaW5zZXJ0Q2xhc3NlcyA9IHZhbHVlQ2xhc3Nlcy5maWx0ZXIodmFsdWVDbGFzcyA9PiAhZXhpc3RpbmdDbGFzc2VzLmluY2x1ZGVzKHZhbHVlQ2xhc3MpKVxuXG4gICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gWy4uLmV4aXN0aW5nQ2xhc3NlcywgLi4uaW5zZXJ0Q2xhc3Nlc10uam9pbignICcpXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgY29uc3QgbmV3U3R5bGVzOiBzdHJpbmdbXSA9IHZhbHVlXG4gICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICAgICAgLnNwbGl0KCc7JylcbiAgICAgICAgICAgICAgICAubWFwKChzdHlsZTogc3RyaW5nKSA9PiBzdHlsZS50cmltKCkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgOiBbXVxuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3R5bGVzOiBzdHJpbmdbXSA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XVxuICAgICAgICAgICAgPyBtZXJnZWRBdHRyaWJ1dGVzW2tleV1cbiAgICAgICAgICAgICAgICAuc3BsaXQoJzsnKVxuICAgICAgICAgICAgICAgIC5tYXAoKHN0eWxlOiBzdHJpbmcpID0+IHN0eWxlLnRyaW0oKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICA6IFtdXG5cbiAgICAgICAgICBjb25zdCBzdHlsZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KClcblxuICAgICAgICAgIGV4aXN0aW5nU3R5bGVzLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3Byb3BlcnR5LCB2YWxdID0gc3R5bGUuc3BsaXQoJzonKS5tYXAocGFydCA9PiBwYXJ0LnRyaW0oKSlcblxuICAgICAgICAgICAgc3R5bGVNYXAuc2V0KHByb3BlcnR5LCB2YWwpXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIG5ld1N0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsXSA9IHN0eWxlLnNwbGl0KCc6JykubWFwKHBhcnQgPT4gcGFydC50cmltKCkpXG5cbiAgICAgICAgICAgIHN0eWxlTWFwLnNldChwcm9wZXJ0eSwgdmFsKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSBBcnJheS5mcm9tKHN0eWxlTWFwLmVudHJpZXMoKSlcbiAgICAgICAgICAgIC5tYXAoKFtwcm9wZXJ0eSwgdmFsXSkgPT4gYCR7cHJvcGVydHl9OiAke3ZhbH1gKVxuICAgICAgICAgICAgLmpvaW4oJzsgJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gbWVyZ2VkQXR0cmlidXRlc1xuICAgIH0sIHt9KVxufVxuIiwgImltcG9ydCB0eXBlIHsgTWFyaywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB0eXBlIHsgRXh0ZW5zaW9uQXR0cmlidXRlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICcuLi91dGlsaXRpZXMvbWVyZ2VBdHRyaWJ1dGVzLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKFxuICBub2RlT3JNYXJrOiBOb2RlIHwgTWFyayxcbiAgZXh0ZW5zaW9uQXR0cmlidXRlczogRXh0ZW5zaW9uQXR0cmlidXRlW10sXG4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXNcbiAgICAuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gbm9kZU9yTWFyay50eXBlLm5hbWUpXG4gICAgLmZpbHRlcihpdGVtID0+IGl0ZW0uYXR0cmlidXRlLnJlbmRlcmVkKVxuICAgIC5tYXAoaXRlbSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uYXR0cmlidXRlLnJlbmRlckhUTUwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBbaXRlbS5uYW1lXTogbm9kZU9yTWFyay5hdHRyc1tpdGVtLm5hbWVdLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKG5vZGVPck1hcmsuYXR0cnMpIHx8IHt9XG4gICAgfSlcbiAgICAucmVkdWNlKChhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpID0+IG1lcmdlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpLCB7fSlcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZTogYW55KTogYW55IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIGlmICh2YWx1ZS5tYXRjaCgvXlsrLV0/KD86XFxkKlxcLik/XFxkKyQvKSkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuIiwgImltcG9ydCB0eXBlIHsgUGFyc2VSdWxlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25BdHRyaWJ1dGUgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGZyb21TdHJpbmcgfSBmcm9tICcuLi91dGlsaXRpZXMvZnJvbVN0cmluZy5qcydcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1lcmdlcyBleHRlbnNpb24gYXR0cmlidXRlcyBpbnRvIHBhcnNlcnVsZSBhdHRyaWJ1dGVzIChgYXR0cnNgIG9yIGBnZXRBdHRyc2ApLlxuICogQ2FuY2VscyB3aGVuIGBnZXRBdHRyc2AgcmV0dXJuZWQgYGZhbHNlYC5cbiAqIEBwYXJhbSBwYXJzZVJ1bGUgUHJvc2VNaXJyb3IgUGFyc2VSdWxlXG4gKiBAcGFyYW0gZXh0ZW5zaW9uQXR0cmlidXRlcyBMaXN0IG9mIGF0dHJpYnV0ZXMgdG8gaW5qZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUoXG4gIHBhcnNlUnVsZTogUGFyc2VSdWxlLFxuICBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSxcbik6IFBhcnNlUnVsZSB7XG4gIGlmICgnc3R5bGUnIGluIHBhcnNlUnVsZSkge1xuICAgIHJldHVybiBwYXJzZVJ1bGVcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucGFyc2VSdWxlLFxuICAgIGdldEF0dHJzOiAobm9kZTogSFRNTEVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBwYXJzZVJ1bGUuZ2V0QXR0cnMgPyBwYXJzZVJ1bGUuZ2V0QXR0cnMobm9kZSkgOiBwYXJzZVJ1bGUuYXR0cnNcblxuICAgICAgaWYgKG9sZEF0dHJpYnV0ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXRlbS5hdHRyaWJ1dGUucGFyc2VIVE1MXG4gICAgICAgICAgPyBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwobm9kZSlcbiAgICAgICAgICA6IGZyb21TdHJpbmcobm9kZS5nZXRBdHRyaWJ1dGUoaXRlbS5uYW1lKSlcblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBpdGVtc1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5pdGVtcyxcbiAgICAgICAgICBbaXRlbS5uYW1lXTogdmFsdWUsXG4gICAgICAgIH1cbiAgICAgIH0sIHt9KVxuXG4gICAgICByZXR1cm4geyAuLi5vbGRBdHRyaWJ1dGVzLCAuLi5uZXdBdHRyaWJ1dGVzIH1cbiAgICB9LFxuICB9XG59XG4iLCAiLyoqXG4gKiBGaW5kIGR1cGxpY2F0ZXMgaW4gYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRHVwbGljYXRlczxUPihpdGVtczogVFtdKTogVFtdIHtcbiAgY29uc3QgZmlsdGVyZWQgPSBpdGVtcy5maWx0ZXIoKGVsLCBpbmRleCkgPT4gaXRlbXMuaW5kZXhPZihlbCkgIT09IGluZGV4KVxuXG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoZmlsdGVyZWQpKVxufVxuIiwgImltcG9ydCB0eXBlIHsgQW55Q29uZmlnLCBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJy4vZ2V0RXh0ZW5zaW9uRmllbGQuanMnXG5cbi8qKlxuICogU29ydCBleHRlbnNpb25zIGJ5IHByaW9yaXR5LlxuICogQHBhcmFtIGV4dGVuc2lvbnMgQW4gYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnNcbiAqIEByZXR1cm5zIEEgc29ydGVkIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zIGJ5IHByaW9yaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0RXh0ZW5zaW9ucyhleHRlbnNpb25zOiBFeHRlbnNpb25zKTogRXh0ZW5zaW9ucyB7XG4gIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMFxuXG4gIHJldHVybiBleHRlbnNpb25zLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCBwcmlvcml0eUEgPSBnZXRFeHRlbnNpb25GaWVsZDxBbnlDb25maWdbJ3ByaW9yaXR5J10+KGEsICdwcmlvcml0eScpIHx8IGRlZmF1bHRQcmlvcml0eVxuICAgIGNvbnN0IHByaW9yaXR5QiA9IGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1sncHJpb3JpdHknXT4oYiwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5XG5cbiAgICBpZiAocHJpb3JpdHlBID4gcHJpb3JpdHlCKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBpZiAocHJpb3JpdHlBIDwgcHJpb3JpdHlCKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHJldHVybiAwXG4gIH0pXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBmaW5kRHVwbGljYXRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9maW5kRHVwbGljYXRlcy5qcydcbmltcG9ydCB7IGZsYXR0ZW5FeHRlbnNpb25zIH0gZnJvbSAnLi9mbGF0dGVuRXh0ZW5zaW9ucy5qcydcbmltcG9ydCB7IHNvcnRFeHRlbnNpb25zIH0gZnJvbSAnLi9zb3J0RXh0ZW5zaW9ucy5qcydcblxuLyoqXG4gKiBSZXR1cm5zIGEgZmxhdHRlbmVkIGFuZCBzb3J0ZWQgZXh0ZW5zaW9uIGxpc3Qgd2hpbGVcbiAqIGFsc28gY2hlY2tpbmcgZm9yIGR1cGxpY2F0ZWQgZXh0ZW5zaW9ucyBhbmQgd2FybnMgdGhlIHVzZXIuXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICogQHJldHVybnMgQW4gZmxhdHRlbmVkIGFuZCBzb3J0ZWQgYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVFeHRlbnNpb25zKGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBFeHRlbnNpb25zIHtcbiAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gc29ydEV4dGVuc2lvbnMoZmxhdHRlbkV4dGVuc2lvbnMoZXh0ZW5zaW9ucykpXG4gIGNvbnN0IGR1cGxpY2F0ZWROYW1lcyA9IGZpbmREdXBsaWNhdGVzKHJlc29sdmVkRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5uYW1lKSlcblxuICBpZiAoZHVwbGljYXRlZE5hbWVzLmxlbmd0aCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBbdGlwdGFwIHdhcm5dOiBEdXBsaWNhdGUgZXh0ZW5zaW9uIG5hbWVzIGZvdW5kOiBbJHtkdXBsaWNhdGVkTmFtZXNcbiAgICAgICAgLm1hcChpdGVtID0+IGAnJHtpdGVtfSdgKVxuICAgICAgICAuam9pbignLCAnKX1dLiBUaGlzIGNhbiBsZWFkIHRvIGlzc3Vlcy5gLFxuICAgIClcbiAgfVxuXG4gIHJldHVybiByZXNvbHZlZEV4dGVuc2lvbnNcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB0eXBlIHsgRWRpdG9yIH0gZnJvbSAnLi4vRWRpdG9yLmpzJ1xuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyB9IGZyb20gJy4vZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMuanMnXG5pbXBvcnQgeyByZXNvbHZlRXh0ZW5zaW9ucyB9IGZyb20gJy4vcmVzb2x2ZUV4dGVuc2lvbnMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWEoZXh0ZW5zaW9uczogRXh0ZW5zaW9ucywgZWRpdG9yPzogRWRpdG9yKTogU2NoZW1hIHtcbiAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gcmVzb2x2ZUV4dGVuc2lvbnMoZXh0ZW5zaW9ucylcblxuICByZXR1cm4gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMocmVzb2x2ZWRFeHRlbnNpb25zLCBlZGl0b3IpXG59XG4iLCAiaW1wb3J0IHsgRE9NUGFyc2VyIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25zIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBlbGVtZW50RnJvbVN0cmluZyB9IGZyb20gJy4uL3V0aWxpdGllcy9lbGVtZW50RnJvbVN0cmluZy5qcydcbmltcG9ydCB7IGdldFNjaGVtYSB9IGZyb20gJy4vZ2V0U2NoZW1hLmpzJ1xuXG4vKipcbiAqIEdlbmVyYXRlIEpTT05Db250ZW50IGZyb20gSFRNTFxuICogQHBhcmFtIGh0bWwgVGhlIEhUTUwgdG8gZ2VuZXJhdGUgSlNPTkNvbnRlbnQgZnJvbVxuICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGV4dGVuc2lvbnMgdG8gdXNlIGZvciB0aGUgc2NoZW1hXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIEpTT05Db250ZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUpTT04oaHRtbDogc3RyaW5nLCBleHRlbnNpb25zOiBFeHRlbnNpb25zKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKVxuICBjb25zdCBkb20gPSBlbGVtZW50RnJvbVN0cmluZyhodG1sKVxuXG4gIHJldHVybiBET01QYXJzZXIuZnJvbVNjaGVtYShzY2hlbWEpLnBhcnNlKGRvbSkudG9KU09OKClcbn1cbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25zLCBKU09OQ29udGVudCwgVGV4dFNlcmlhbGl6ZXIgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldFNjaGVtYSB9IGZyb20gJy4vZ2V0U2NoZW1hLmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dCB9IGZyb20gJy4vZ2V0VGV4dC5qcydcbmltcG9ydCB7IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEgfSBmcm9tICcuL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5cbi8qKlxuICogR2VuZXJhdGUgcmF3IHRleHQgZnJvbSBhIEpTT05Db250ZW50XG4gKiBAcGFyYW0gZG9jIFRoZSBKU09OQ29udGVudCB0byBnZW5lcmF0ZSB0ZXh0IGZyb21cbiAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb25zIHRvIHVzZSBmb3IgdGhlIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHRleHQgZ2VuZXJhdGlvbiBmLmUuIGJsb2NrU2VwYXJhdG9yIG9yIHRleHRTZXJpYWxpemVyc1xuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCB0ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRleHQoXG4gIGRvYzogSlNPTkNvbnRlbnQsXG4gIGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMsXG4gIG9wdGlvbnM/OiB7XG4gICAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmdcbiAgICB0ZXh0U2VyaWFsaXplcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZXh0U2VyaWFsaXplcj5cbiAgfSxcbik6IHN0cmluZyB7XG4gIGNvbnN0IHsgYmxvY2tTZXBhcmF0b3IgPSAnXFxuXFxuJywgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge31cbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGNvbnRlbnROb2RlID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIGRvYylcblxuICByZXR1cm4gZ2V0VGV4dChjb250ZW50Tm9kZSwge1xuICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgIHRleHRTZXJpYWxpemVyczoge1xuICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpLFxuICAgICAgLi4udGV4dFNlcmlhbGl6ZXJzLFxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB0eXBlIHsgUmFuZ2UsIFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbi8qKlxuICogR2V0cyB0aGUgdGV4dCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMgaW4gYSBQcm9zZW1pcnJvciBub2RlXG4gKiBhbmQgc2VyaWFsaXplcyBpdCB1c2luZyB0aGUgZ2l2ZW4gdGV4dCBzZXJpYWxpemVycyBhbmQgYmxvY2sgc2VwYXJhdG9yIChzZWUgZ2V0VGV4dClcbiAqIEBwYXJhbSBzdGFydE5vZGUgVGhlIFByb3NlbWlycm9yIG5vZGUgdG8gc3RhcnQgZnJvbVxuICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgdGV4dCB0byBnZXRcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0ZXh0IHNlcmlhbGl6ZXIgJiBibG9jayBzZXBhcmF0b3JcbiAqIEByZXR1cm5zIFRoZSB0ZXh0IGJldHdlZW4gdGhlIHR3byBwb3NpdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHRCZXR3ZWVuKFxuICBzdGFydE5vZGU6IFByb3NlTWlycm9yTm9kZSxcbiAgcmFuZ2U6IFJhbmdlLFxuICBvcHRpb25zPzoge1xuICAgIGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nXG4gICAgdGV4dFNlcmlhbGl6ZXJzPzogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+XG4gIH0sXG4pOiBzdHJpbmcge1xuICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZVxuICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9XG4gIGxldCB0ZXh0ID0gJydcblxuICBzdGFydE5vZGUubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gICAgaWYgKG5vZGUuaXNCbG9jayAmJiBwb3MgPiBmcm9tKSB7XG4gICAgICB0ZXh0ICs9IGJsb2NrU2VwYXJhdG9yXG4gICAgfVxuXG4gICAgY29uc3QgdGV4dFNlcmlhbGl6ZXIgPSB0ZXh0U2VyaWFsaXplcnM/Lltub2RlLnR5cGUubmFtZV1cblxuICAgIGlmICh0ZXh0U2VyaWFsaXplcikge1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICB0ZXh0ICs9IHRleHRTZXJpYWxpemVyKHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHBvcyxcbiAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcmFuZ2UsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICAvLyBkbyBub3QgZGVzY2VuZCBpbnRvIGNoaWxkIG5vZGVzIHdoZW4gdGhlcmUgZXhpc3RzIGEgc2VyaWFsaXplclxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICB0ZXh0ICs9IG5vZGU/LnRleHQ/LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB0ZXh0XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB0eXBlIHsgVGV4dFNlcmlhbGl6ZXIgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGdldFRleHRCZXR3ZWVuIH0gZnJvbSAnLi9nZXRUZXh0QmV0d2Vlbi5qcydcblxuLyoqXG4gKiBHZXRzIHRoZSB0ZXh0IG9mIGEgUHJvc2VtaXJyb3Igbm9kZVxuICogQHBhcmFtIG5vZGUgVGhlIFByb3NlbWlycm9yIG5vZGVcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0ZXh0IHNlcmlhbGl6ZXIgJiBibG9jayBzZXBhcmF0b3JcbiAqIEByZXR1cm5zIFRoZSB0ZXh0IG9mIHRoZSBub2RlXG4gKiBAZXhhbXBsZSBgYGBqc1xuICogY29uc3QgdGV4dCA9IGdldFRleHQobm9kZSwgeyBibG9ja1NlcGFyYXRvcjogJ1xcbicgfSlcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dChcbiAgbm9kZTogUHJvc2VNaXJyb3JOb2RlLFxuICBvcHRpb25zPzoge1xuICAgIGJsb2NrU2VwYXJhdG9yPzogc3RyaW5nXG4gICAgdGV4dFNlcmlhbGl6ZXJzPzogUmVjb3JkPHN0cmluZywgVGV4dFNlcmlhbGl6ZXI+XG4gIH0sXG4pIHtcbiAgY29uc3QgcmFuZ2UgPSB7XG4gICAgZnJvbTogMCxcbiAgICB0bzogbm9kZS5jb250ZW50LnNpemUsXG4gIH1cblxuICByZXR1cm4gZ2V0VGV4dEJldHdlZW4obm9kZSwgcmFuZ2UsIG9wdGlvbnMpXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgdHlwZSB7IFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbi8qKlxuICogRmluZCB0ZXh0IHNlcmlhbGl6ZXJzIGB0b1RleHRgIGluIGEgUHJvc2VtaXJyb3Igc2NoZW1hXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBQcm9zZW1pcnJvciBzY2hlbWEgdG8gc2VhcmNoIGluXG4gKiBAcmV0dXJucyBBIHJlY29yZCBvZiB0ZXh0IHNlcmlhbGl6ZXJzIGJ5IG5vZGUgbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWE6IFNjaGVtYSk6IFJlY29yZDxzdHJpbmcsIFRleHRTZXJpYWxpemVyPiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLm5vZGVzKVxuICAgICAgLmZpbHRlcigoWywgbm9kZV0pID0+IG5vZGUuc3BlYy50b1RleHQpXG4gICAgICAubWFwKChbbmFtZSwgbm9kZV0pID0+IFtuYW1lLCBub2RlLnNwZWMudG9UZXh0XSksXG4gIClcbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1hcmtUeXBlLCBTY2hlbWEgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFya1R5cGUobmFtZU9yVHlwZTogc3RyaW5nIHwgTWFya1R5cGUsIHNjaGVtYTogU2NoZW1hKTogTWFya1R5cGUge1xuICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFzY2hlbWEubWFya3NbbmFtZU9yVHlwZV0pIHtcbiAgICAgIHRocm93IEVycm9yKGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgbmFtZWQgJyR7bmFtZU9yVHlwZX0nLiBNYXliZSB5b3UgZm9yZ290IHRvIGFkZCB0aGUgZXh0ZW5zaW9uP2ApXG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXVxuICB9XG5cbiAgcmV0dXJuIG5hbWVPclR5cGVcbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1hcmssIE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB0eXBlIHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4vZ2V0TWFya1R5cGUuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZTogRWRpdG9yU3RhdGUsIHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3QgbWFya3M6IE1hcmtbXSA9IFtdXG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgaWYgKHN0YXRlLnN0b3JlZE1hcmtzKSB7XG4gICAgICBtYXJrcy5wdXNoKC4uLnN0YXRlLnN0b3JlZE1hcmtzKVxuICAgIH1cblxuICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpXG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICBtYXJrcy5wdXNoKC4uLm5vZGUubWFya3MpXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IG1hcmsgPSBtYXJrcy5maW5kKG1hcmtJdGVtID0+IG1hcmtJdGVtLnR5cGUubmFtZSA9PT0gdHlwZS5uYW1lKVxuXG4gIGlmICghbWFyaykge1xuICAgIHJldHVybiB7fVxuICB9XG5cbiAgcmV0dXJuIHsgLi4ubWFyay5hdHRycyB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlVHlwZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVUeXBlKG5hbWVPclR5cGU6IHN0cmluZyB8IE5vZGVUeXBlLCBzY2hlbWE6IFNjaGVtYSk6IE5vZGVUeXBlIHtcbiAgaWYgKHR5cGVvZiBuYW1lT3JUeXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmICghc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdKSB7XG4gICAgICB0aHJvdyBFcnJvcihgVGhlcmUgaXMgbm8gbm9kZSB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gKVxuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV1cbiAgfVxuXG4gIHJldHVybiBuYW1lT3JUeXBlXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgdHlwZSB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuL2dldE5vZGVUeXBlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZUF0dHJpYnV0ZXMoc3RhdGU6IEVkaXRvclN0YXRlLCB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICBjb25zdCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb25cbiAgY29uc3Qgbm9kZXM6IE5vZGVbXSA9IFtdXG5cbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgbm9kZXMucHVzaChub2RlKVxuICB9KVxuXG4gIGNvbnN0IG5vZGUgPSBub2Rlcy5yZXZlcnNlKCkuZmluZChub2RlSXRlbSA9PiBub2RlSXRlbS50eXBlLm5hbWUgPT09IHR5cGUubmFtZSlcblxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIHJldHVybiB7IC4uLm5vZGUuYXR0cnMgfVxufVxuIiwgImltcG9ydCB0eXBlIHsgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgYSBzY2hlbWEgaXRlbSBieSBpdHMgbmFtZS5cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzY2hlbWEgaXRlbVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJvciBzY2hlbWEgdG8gc2VhcmNoIGluXG4gKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgc2NoZW1hIGl0ZW0gKGBub2RlYCBvciBgbWFya2ApLCBvciBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKG5hbWU6IHN0cmluZywgc2NoZW1hOiBTY2hlbWEpOiAnbm9kZScgfCAnbWFyaycgfCBudWxsIHtcbiAgaWYgKHNjaGVtYS5ub2Rlc1tuYW1lXSkge1xuICAgIHJldHVybiAnbm9kZSdcbiAgfVxuXG4gIGlmIChzY2hlbWEubWFya3NbbmFtZV0pIHtcbiAgICByZXR1cm4gJ21hcmsnXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwgImltcG9ydCB0eXBlIHsgTWFya1R5cGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB0eXBlIHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrQXR0cmlidXRlcyB9IGZyb20gJy4vZ2V0TWFya0F0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXROb2RlQXR0cmlidXRlcyB9IGZyb20gJy4vZ2V0Tm9kZUF0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4vZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5cbi8qKlxuICogR2V0IG5vZGUgb3IgbWFyayBhdHRyaWJ1dGVzIGJ5IHR5cGUgb3IgbmFtZSBvbiB0aGUgY3VycmVudCBlZGl0b3Igc3RhdGVcbiAqIEBwYXJhbSBzdGF0ZSBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGVcbiAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSBub2RlIG9yIG1hcmsgdHlwZSBvciBuYW1lXG4gKiBAcmV0dXJucyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgbm9kZSBvciBtYXJrIG9yIGFuIGVtcHR5IG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhzdGF0ZTogRWRpdG9yU3RhdGUsIHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlIHwgTWFya1R5cGUpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsXG4gICAgc3RhdGUuc2NoZW1hLFxuICApXG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIHJldHVybiBnZXROb2RlQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSBhcyBOb2RlVHlwZSlcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICByZXR1cm4gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUgYXMgTWFya1R5cGUpXG4gIH1cblxuICByZXR1cm4ge31cbn1cbiIsICIvKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlZCB2YWx1ZXMgd2l0aGluIGFuIGFycmF5LlxuICogU3VwcG9ydHMgbnVtYmVycywgc3RyaW5ncyBhbmQgb2JqZWN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZXM8VD4oYXJyYXk6IFRbXSwgYnkgPSBKU09OLnN0cmluZ2lmeSk6IFRbXSB7XG4gIGNvbnN0IHNlZW46IFJlY29yZDxhbnksIGFueT4gPSB7fVxuXG4gIHJldHVybiBhcnJheS5maWx0ZXIoaXRlbSA9PiB7XG4gICAgY29uc3Qga2V5ID0gYnkoaXRlbSlcblxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2Vlbiwga2V5KSA/IGZhbHNlIDogKHNlZW5ba2V5XSA9IHRydWUpXG4gIH0pXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTdGVwLCBUcmFuc2Zvcm0gfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHR5cGUgeyBSYW5nZSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgcmVtb3ZlRHVwbGljYXRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9yZW1vdmVEdXBsaWNhdGVzLmpzJ1xuXG5leHBvcnQgdHlwZSBDaGFuZ2VkUmFuZ2UgPSB7XG4gIG9sZFJhbmdlOiBSYW5nZVxuICBuZXdSYW5nZTogUmFuZ2Vcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZWQgcmFuZ2VzIGFuZCByYW5nZXMgdGhhdCBhcmVcbiAqIGZ1bGx5IGNhcHR1cmVkIGJ5IG90aGVyIHJhbmdlcy5cbiAqL1xuZnVuY3Rpb24gc2ltcGxpZnlDaGFuZ2VkUmFuZ2VzKGNoYW5nZXM6IENoYW5nZWRSYW5nZVtdKTogQ2hhbmdlZFJhbmdlW10ge1xuICBjb25zdCB1bmlxdWVDaGFuZ2VzID0gcmVtb3ZlRHVwbGljYXRlcyhjaGFuZ2VzKVxuXG4gIHJldHVybiB1bmlxdWVDaGFuZ2VzLmxlbmd0aCA9PT0gMVxuICAgID8gdW5pcXVlQ2hhbmdlc1xuICAgIDogdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdCA9IHVuaXF1ZUNoYW5nZXMuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleClcblxuICAgICAgICByZXR1cm4gIXJlc3Quc29tZShvdGhlckNoYW5nZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGNoYW5nZS5vbGRSYW5nZS5mcm9tID49IG90aGVyQ2hhbmdlLm9sZFJhbmdlLmZyb20gJiZcbiAgICAgICAgICAgIGNoYW5nZS5vbGRSYW5nZS50byA8PSBvdGhlckNoYW5nZS5vbGRSYW5nZS50byAmJlxuICAgICAgICAgICAgY2hhbmdlLm5ld1JhbmdlLmZyb20gPj0gb3RoZXJDaGFuZ2UubmV3UmFuZ2UuZnJvbSAmJlxuICAgICAgICAgICAgY2hhbmdlLm5ld1JhbmdlLnRvIDw9IG90aGVyQ2hhbmdlLm5ld1JhbmdlLnRvXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgfSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBjaGFuZ2VkIHJhbmdlc1xuICogYmFzZWQgb24gdGhlIGZpcnN0IGFuZCBsYXN0IHN0YXRlIG9mIGFsbCBzdGVwcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENoYW5nZWRSYW5nZXModHJhbnNmb3JtOiBUcmFuc2Zvcm0pOiBDaGFuZ2VkUmFuZ2VbXSB7XG4gIGNvbnN0IHsgbWFwcGluZywgc3RlcHMgfSA9IHRyYW5zZm9ybVxuICBjb25zdCBjaGFuZ2VzOiBDaGFuZ2VkUmFuZ2VbXSA9IFtdXG5cbiAgbWFwcGluZy5tYXBzLmZvckVhY2goKHN0ZXBNYXAsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcmFuZ2VzOiBSYW5nZVtdID0gW11cblxuICAgIC8vIFRoaXMgYWNjb3VudHMgZm9yIHN0ZXAgY2hhbmdlcyB3aGVyZSBubyByYW5nZSB3YXMgYWN0dWFsbHkgYWx0ZXJlZFxuICAgIC8vIGUuZy4gd2hlbiBzZXR0aW5nIGEgbWFyaywgbm9kZSBhdHRyaWJ1dGUsIGV0Yy5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKCFzdGVwTWFwLnJhbmdlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0ZXBzW2luZGV4XSBhcyBTdGVwICYge1xuICAgICAgICBmcm9tPzogbnVtYmVyXG4gICAgICAgIHRvPzogbnVtYmVyXG4gICAgICB9XG5cbiAgICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQgfHwgdG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwTWFwLmZvckVhY2goKGZyb20sIHRvKSA9PiB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmFuZ2VzLmZvckVhY2goKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoZnJvbSwgLTEpXG4gICAgICBjb25zdCBuZXdFbmQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAodG8pXG4gICAgICBjb25zdCBvbGRTdGFydCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld1N0YXJ0LCAtMSlcbiAgICAgIGNvbnN0IG9sZEVuZCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld0VuZClcblxuICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgb2xkUmFuZ2U6IHtcbiAgICAgICAgICBmcm9tOiBvbGRTdGFydCxcbiAgICAgICAgICB0bzogb2xkRW5kLFxuICAgICAgICB9LFxuICAgICAgICBuZXdSYW5nZToge1xuICAgICAgICAgIGZyb206IG5ld1N0YXJ0LFxuICAgICAgICAgIHRvOiBuZXdFbmQsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKVxufVxuIiwgImltcG9ydCB0eXBlIHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgdHlwZSB7IEpTT05Db250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmludGVyZmFjZSBEZWJ1Z0pTT05Db250ZW50IGV4dGVuZHMgSlNPTkNvbnRlbnQge1xuICBmcm9tOiBudW1iZXJcbiAgdG86IG51bWJlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVidWdKU09OKG5vZGU6IFByb3NlTWlycm9yTm9kZSwgc3RhcnRPZmZzZXQgPSAwKTogRGVidWdKU09OQ29udGVudCB7XG4gIGNvbnN0IGlzVG9wTm9kZSA9IG5vZGUudHlwZSA9PT0gbm9kZS50eXBlLnNjaGVtYS50b3BOb2RlVHlwZVxuICBjb25zdCBpbmNyZW1lbnQgPSBpc1RvcE5vZGUgPyAwIDogMVxuICBjb25zdCBmcm9tID0gc3RhcnRPZmZzZXRcbiAgY29uc3QgdG8gPSBmcm9tICsgbm9kZS5ub2RlU2l6ZVxuICBjb25zdCBtYXJrcyA9IG5vZGUubWFya3MubWFwKG1hcmsgPT4ge1xuICAgIGNvbnN0IG91dHB1dDogeyB0eXBlOiBzdHJpbmc7IGF0dHJzPzogUmVjb3JkPHN0cmluZywgYW55PiB9ID0ge1xuICAgICAgdHlwZTogbWFyay50eXBlLm5hbWUsXG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKG1hcmsuYXR0cnMpLmxlbmd0aCkge1xuICAgICAgb3V0cHV0LmF0dHJzID0geyAuLi5tYXJrLmF0dHJzIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH0pXG4gIGNvbnN0IGF0dHJzID0geyAuLi5ub2RlLmF0dHJzIH1cbiAgY29uc3Qgb3V0cHV0OiBEZWJ1Z0pTT05Db250ZW50ID0ge1xuICAgIHR5cGU6IG5vZGUudHlwZS5uYW1lLFxuICAgIGZyb20sXG4gICAgdG8sXG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCkge1xuICAgIG91dHB1dC5hdHRycyA9IGF0dHJzXG4gIH1cblxuICBpZiAobWFya3MubGVuZ3RoKSB7XG4gICAgb3V0cHV0Lm1hcmtzID0gbWFya3NcbiAgfVxuXG4gIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCkge1xuICAgIG91dHB1dC5jb250ZW50ID0gW11cblxuICAgIG5vZGUuZm9yRWFjaCgoY2hpbGQsIG9mZnNldCkgPT4ge1xuICAgICAgb3V0cHV0LmNvbnRlbnQ/LnB1c2goZ2V0RGVidWdKU09OKGNoaWxkLCBzdGFydE9mZnNldCArIG9mZnNldCArIGluY3JlbWVudCkpXG4gICAgfSlcbiAgfVxuXG4gIGlmIChub2RlLnRleHQpIHtcbiAgICBvdXRwdXQudGV4dCA9IG5vZGUudGV4dFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVnRXhwIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG4iLCAiaW1wb3J0IHsgaXNSZWdFeHAgfSBmcm9tICcuL2lzUmVnRXhwLmpzJ1xuXG4vKipcbiAqIENoZWNrIGlmIG9iamVjdDEgaW5jbHVkZXMgb2JqZWN0MlxuICogQHBhcmFtIG9iamVjdDEgT2JqZWN0XG4gKiBAcGFyYW0gb2JqZWN0MiBPYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdEluY2x1ZGVzKFxuICBvYmplY3QxOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBvYmplY3QyOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBvcHRpb25zOiB7IHN0cmljdDogYm9vbGVhbiB9ID0geyBzdHJpY3Q6IHRydWUgfSxcbik6IGJvb2xlYW4ge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0MilcblxuICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBrZXlzLmV2ZXJ5KGtleSA9PiB7XG4gICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV1cbiAgICB9XG5cbiAgICBpZiAoaXNSZWdFeHAob2JqZWN0MltrZXldKSkge1xuICAgICAgcmV0dXJuIG9iamVjdDJba2V5XS50ZXN0KG9iamVjdDFba2V5XSlcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV1cbiAgfSlcbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1hcmsgYXMgUHJvc2VNaXJyb3JNYXJrLCBNYXJrVHlwZSwgUmVzb2x2ZWRQb3MgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgdHlwZSB7IFJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBvYmplY3RJbmNsdWRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy5qcydcblxuZnVuY3Rpb24gZmluZE1hcmtJblNldChcbiAgbWFya3M6IFByb3NlTWlycm9yTWFya1tdLFxuICB0eXBlOiBNYXJrVHlwZSxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9LFxuKTogUHJvc2VNaXJyb3JNYXJrIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIG1hcmtzLmZpbmQoaXRlbSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIGl0ZW0udHlwZSA9PT0gdHlwZSAmJlxuICAgICAgb2JqZWN0SW5jbHVkZXMoXG4gICAgICAgIC8vIE9ubHkgY2hlY2sgZXF1YWxpdHkgZm9yIHRoZSBhdHRyaWJ1dGVzIHRoYXQgYXJlIHByb3ZpZGVkXG4gICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoayA9PiBbaywgaXRlbS5hdHRyc1trXV0pKSxcbiAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgIClcbiAgICApXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzTWFya0luU2V0KG1hcmtzOiBQcm9zZU1pcnJvck1hcmtbXSwgdHlwZTogTWFya1R5cGUsIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSk6IGJvb2xlYW4ge1xuICByZXR1cm4gISFmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzKVxufVxuXG4vKipcbiAqIEdldCB0aGUgcmFuZ2Ugb2YgYSBtYXJrIGF0IGEgcmVzb2x2ZWQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXJrUmFuZ2UoXG4gIC8qKlxuICAgKiBUaGUgcG9zaXRpb24gdG8gZ2V0IHRoZSBtYXJrIHJhbmdlIGZvci5cbiAgICovXG4gICRwb3M6IFJlc29sdmVkUG9zLFxuICAvKipcbiAgICogVGhlIG1hcmsgdHlwZSB0byBnZXQgdGhlIHJhbmdlIGZvci5cbiAgICovXG4gIHR5cGU6IE1hcmtUeXBlLFxuICAvKipcbiAgICogVGhlIGF0dHJpYnV0ZXMgdG8gbWF0Y2ggYWdhaW5zdC5cbiAgICogSWYgbm90IHByb3ZpZGVkLCBvbmx5IHRoZSBmaXJzdCBtYXJrIGF0IHRoZSBwb3NpdGlvbiB3aWxsIGJlIG1hdGNoZWQuXG4gICAqL1xuICBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55Pixcbik6IFJhbmdlIHwgdm9pZCB7XG4gIGlmICghJHBvcyB8fCAhdHlwZSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBzdGFydCA9ICRwb3MucGFyZW50LmNoaWxkQWZ0ZXIoJHBvcy5wYXJlbnRPZmZzZXQpXG5cbiAgLy8gSWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGUgdGhhdCBkb2VzIG5vdCBoYXZlIHRoZSBtYXJrLCBsb29rIGJhY2t3YXJkXG4gIGlmICghc3RhcnQubm9kZSB8fCAhc3RhcnQubm9kZS5tYXJrcy5zb21lKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKSkge1xuICAgIHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRCZWZvcmUoJHBvcy5wYXJlbnRPZmZzZXQpXG4gIH1cblxuICAvLyBJZiB0aGVyZSBpcyBubyB0ZXh0IG5vZGUgd2l0aCB0aGUgbWFyayBldmVuIGJhY2t3YXJkLCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghc3RhcnQubm9kZSB8fCAhc3RhcnQubm9kZS5tYXJrcy5zb21lKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gRGVmYXVsdCB0byBvbmx5IG1hdGNoaW5nIGFnYWluc3QgdGhlIGZpcnN0IG1hcmsncyBhdHRyaWJ1dGVzXG4gIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHN0YXJ0Lm5vZGUubWFya3NbMF0/LmF0dHJzXG5cbiAgLy8gV2Ugbm93IGtub3cgdGhhdCB0aGUgY3Vyc29yIGlzIGVpdGhlciBhdCB0aGUgc3RhcnQsIG1pZGRsZSBvciBlbmQgb2YgYSB0ZXh0IG5vZGUgd2l0aCB0aGUgc3BlY2lmaWVkIG1hcmtcbiAgLy8gc28gd2UgY2FuIGxvb2sgaXQgdXAgb24gdGhlIHRhcmdldGVkIG1hcmtcbiAgY29uc3QgbWFyayA9IGZpbmRNYXJrSW5TZXQoWy4uLnN0YXJ0Lm5vZGUubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gIGlmICghbWFyaykge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydC5pbmRleFxuICBsZXQgc3RhcnRQb3MgPSAkcG9zLnN0YXJ0KCkgKyBzdGFydC5vZmZzZXRcbiAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIDFcbiAgbGV0IGVuZFBvcyA9IHN0YXJ0UG9zICsgc3RhcnQubm9kZS5ub2RlU2l6ZVxuXG4gIHdoaWxlIChzdGFydEluZGV4ID4gMCAmJiBpc01hcmtJblNldChbLi4uJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcykpIHtcbiAgICBzdGFydEluZGV4IC09IDFcbiAgICBzdGFydFBvcyAtPSAkcG9zLnBhcmVudC5jaGlsZChzdGFydEluZGV4KS5ub2RlU2l6ZVxuICB9XG5cbiAgd2hpbGUgKGVuZEluZGV4IDwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCAmJiBpc01hcmtJblNldChbLi4uJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcykpIHtcbiAgICBlbmRQb3MgKz0gJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm5vZGVTaXplXG4gICAgZW5kSW5kZXggKz0gMVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBzdGFydFBvcyxcbiAgICB0bzogZW5kUG9zLFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB0eXBlIHsgTWFya1JhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBnZXRNYXJrUmFuZ2UgfSBmcm9tICcuL2dldE1hcmtSYW5nZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtzQmV0d2Vlbihmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIGRvYzogUHJvc2VNaXJyb3JOb2RlKTogTWFya1JhbmdlW10ge1xuICBjb25zdCBtYXJrczogTWFya1JhbmdlW10gPSBbXVxuXG4gIC8vIGdldCBhbGwgaW5jbHVzaXZlIG1hcmtzIG9uIGVtcHR5IHNlbGVjdGlvblxuICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICBkb2NcbiAgICAgIC5yZXNvbHZlKGZyb20pXG4gICAgICAubWFya3MoKVxuICAgICAgLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgIGNvbnN0ICRwb3MgPSBkb2MucmVzb2x2ZShmcm9tKVxuICAgICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkcG9zLCBtYXJrLnR5cGUpXG5cbiAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbWFyayxcbiAgICAgICAgICAuLi5yYW5nZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgaWYgKCFub2RlIHx8IG5vZGU/Lm5vZGVTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIG1hcmtzLnB1c2goXG4gICAgICAgIC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcbiAgICAgICAgICBmcm9tOiBwb3MsXG4gICAgICAgICAgdG86IHBvcyArIG5vZGUubm9kZVNpemUsXG4gICAgICAgICAgbWFyayxcbiAgICAgICAgfSkpLFxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gbWFya3Ncbn1cbiIsICJpbXBvcnQgdHlwZSB7IE5vZGUsIE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB0eXBlIHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBub2RlIG9mIGEgZ2l2ZW4gdHlwZSBvciBuYW1lIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBzdGF0ZSBUaGUgZWRpdG9yIHN0YXRlLlxuICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG5vZGUgdHlwZSBvciBuYW1lLlxuICogQHBhcmFtIHBvcyBUaGUgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uXG4gKiBAcGFyYW0gbWF4RGVwdGggVGhlIG1heGltdW0gZGVwdGggdG8gc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5vZGUgYW5kIHRoZSBkZXB0aCBhcyBhbiBhcnJheS5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldE5vZGVBdFBvc2l0aW9uID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSwgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIHBvczogbnVtYmVyLCBtYXhEZXB0aCA9IDIwKSA9PiB7XG4gIGNvbnN0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpXG5cbiAgbGV0IGN1cnJlbnREZXB0aCA9IG1heERlcHRoXG4gIGxldCBub2RlOiBOb2RlIHwgbnVsbCA9IG51bGxcblxuICB3aGlsZSAoY3VycmVudERlcHRoID4gMCAmJiBub2RlID09PSBudWxsKSB7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSAkcG9zLm5vZGUoY3VycmVudERlcHRoKVxuXG4gICAgaWYgKGN1cnJlbnROb2RlPy50eXBlLm5hbWUgPT09IHR5cGVPck5hbWUpIHtcbiAgICAgIG5vZGUgPSBjdXJyZW50Tm9kZVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RGVwdGggLT0gMVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbm9kZSwgY3VycmVudERlcHRoXSBhcyBbTm9kZSB8IG51bGwsIG51bWJlcl1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1hcmtUeXBlLCBOb2RlVHlwZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuLyoqXG4gKiBUcmllcyB0byBnZXQgYSBub2RlIG9yIG1hcmsgdHlwZSBieSBpdHMgbmFtZS5cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBub2RlIG9yIG1hcmsgdHlwZVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJvciBzY2hlbWEgdG8gc2VhcmNoIGluXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBvciBtYXJrIHR5cGUsIG9yIG51bGwgaWYgaXQgZG9lc24ndCBleGlzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZUJ5TmFtZShuYW1lOiBzdHJpbmcsIHNjaGVtYTogU2NoZW1hKTogTm9kZVR5cGUgfCBNYXJrVHlwZSB8IG51bGwge1xuICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVdIHx8IHNjaGVtYS5tYXJrc1tuYW1lXSB8fCBudWxsXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25BdHRyaWJ1dGUgfSBmcm9tICcuLi90eXBlcy5qcydcblxuLyoqXG4gKiBSZXR1cm4gYXR0cmlidXRlcyBvZiBhbiBleHRlbnNpb24gdGhhdCBzaG91bGQgYmUgc3BsaXR0ZWQgYnkga2VlcE9uU3BsaXQgZmxhZ1xuICogQHBhcmFtIGV4dGVuc2lvbkF0dHJpYnV0ZXMgQXJyYXkgb2YgZXh0ZW5zaW9uIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB0eXBlTmFtZSBUaGUgdHlwZSBvZiB0aGUgZXh0ZW5zaW9uXG4gKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgZXh0ZW5zaW9uXG4gKiBAcmV0dXJucyBUaGUgc3BsaXR0ZWQgYXR0cmlidXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKFxuICBleHRlbnNpb25BdHRyaWJ1dGVzOiBFeHRlbnNpb25BdHRyaWJ1dGVbXSxcbiAgdHlwZU5hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55Pixcbik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpLmZpbHRlcigoW25hbWVdKSA9PiB7XG4gICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGUgPSBleHRlbnNpb25BdHRyaWJ1dGVzLmZpbmQoaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGVOYW1lICYmIGl0ZW0ubmFtZSA9PT0gbmFtZVxuICAgICAgfSlcblxuICAgICAgaWYgKCFleHRlbnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlLmtlZXBPblNwbGl0XG4gICAgfSksXG4gIClcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFJlc29sdmVkUG9zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSByZXNvbHZlZCBwcm9zZW1pcnJvciBwb3NpdGlvblxuICogQHBhcmFtICRmcm9tIFRoZSByZXNvbHZlZCBwb3NpdGlvbiB0byBnZXQgdGhlIHRleHQgY29udGVudCBmcm9tXG4gKiBAcGFyYW0gbWF4TWF0Y2ggVGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gbWF0Y2hcbiAqIEByZXR1cm5zIFRoZSB0ZXh0IGNvbnRlbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFRleHRDb250ZW50RnJvbU5vZGVzID0gKCRmcm9tOiBSZXNvbHZlZFBvcywgbWF4TWF0Y2ggPSA1MDApID0+IHtcbiAgbGV0IHRleHRCZWZvcmUgPSAnJ1xuXG4gIGNvbnN0IHNsaWNlRW5kUG9zID0gJGZyb20ucGFyZW50T2Zmc2V0XG5cbiAgJGZyb20ucGFyZW50Lm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIG1heE1hdGNoKSwgc2xpY2VFbmRQb3MsIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjaHVuayA9XG4gICAgICBub2RlLnR5cGUuc3BlYy50b1RleHQ/Lih7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIHBvcyxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpbmRleCxcbiAgICAgIH0pIHx8XG4gICAgICBub2RlLnRleHRDb250ZW50IHx8XG4gICAgICAnJWxlYWYlJ1xuXG4gICAgdGV4dEJlZm9yZSArPSBub2RlLmlzQXRvbSAmJiAhbm9kZS5pc1RleHQgPyBjaHVuayA6IGNodW5rLnNsaWNlKDAsIE1hdGgubWF4KDAsIHNsaWNlRW5kUG9zIC0gcG9zKSlcbiAgfSlcblxuICByZXR1cm4gdGV4dEJlZm9yZVxufVxuIiwgImltcG9ydCB0eXBlIHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHR5cGUgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB0eXBlIHsgTWFya1JhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBvYmplY3RJbmNsdWRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy5qcydcbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi9nZXRNYXJrVHlwZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTWFya0FjdGl2ZShcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBNYXJrVHlwZSB8IHN0cmluZyB8IG51bGwsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IGJvb2xlYW4ge1xuICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvblxuICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsXG5cbiAgaWYgKGVtcHR5KSB7XG4gICAgcmV0dXJuICEhKHN0YXRlLnN0b3JlZE1hcmtzIHx8IHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuICAgICAgLmZpbHRlcihtYXJrID0+IHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG1hcmsudHlwZS5uYW1lXG4gICAgICB9KVxuICAgICAgLmZpbmQobWFyayA9PiBvYmplY3RJbmNsdWRlcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpXG4gIH1cblxuICBsZXQgc2VsZWN0aW9uUmFuZ2UgPSAwXG4gIGNvbnN0IG1hcmtSYW5nZXM6IE1hcmtSYW5nZVtdID0gW11cblxuICByYW5nZXMuZm9yRWFjaCgoeyAkZnJvbSwgJHRvIH0pID0+IHtcbiAgICBjb25zdCBmcm9tID0gJGZyb20ucG9zXG4gICAgY29uc3QgdG8gPSAkdG8ucG9zXG5cbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICBpZiAoIW5vZGUuaXNUZXh0ICYmICFub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKVxuICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKVxuICAgICAgY29uc3QgcmFuZ2UgPSByZWxhdGl2ZVRvIC0gcmVsYXRpdmVGcm9tXG5cbiAgICAgIHNlbGVjdGlvblJhbmdlICs9IHJhbmdlXG5cbiAgICAgIG1hcmtSYW5nZXMucHVzaChcbiAgICAgICAgLi4ubm9kZS5tYXJrcy5tYXAobWFyayA9PiAoe1xuICAgICAgICAgIG1hcmssXG4gICAgICAgICAgZnJvbTogcmVsYXRpdmVGcm9tLFxuICAgICAgICAgIHRvOiByZWxhdGl2ZVRvLFxuICAgICAgICB9KSksXG4gICAgICApXG4gICAgfSlcbiAgfSlcblxuICBpZiAoc2VsZWN0aW9uUmFuZ2UgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSByYW5nZSBvZiBtYXRjaGVkIG1hcmtcbiAgY29uc3QgbWF0Y2hlZFJhbmdlID0gbWFya1Jhbmdlc1xuICAgIC5maWx0ZXIobWFya1JhbmdlID0+IHtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrUmFuZ2UubWFyay50eXBlLm5hbWVcbiAgICB9KVxuICAgIC5maWx0ZXIobWFya1JhbmdlID0+IG9iamVjdEluY2x1ZGVzKG1hcmtSYW5nZS5tYXJrLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpXG4gICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKVxuXG4gIC8vIGNhbGN1bGF0ZSByYW5nZSBvZiBtYXJrcyB0aGF0IGV4Y2x1ZGVzIHRoZSBzZWFyY2hlZCBtYXJrXG4gIC8vIGZvciBleGFtcGxlIGBjb2RlYCBkb2VzbuKAmXQgYWxsb3cgYW55IG90aGVyIG1hcmtzXG4gIGNvbnN0IGV4Y2x1ZGVkUmFuZ2UgPSBtYXJrUmFuZ2VzXG4gICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrUmFuZ2UubWFyay50eXBlICE9PSB0eXBlICYmIG1hcmtSYW5nZS5tYXJrLnR5cGUuZXhjbHVkZXModHlwZSlcbiAgICB9KVxuICAgIC5yZWR1Y2UoKHN1bSwgbWFya1JhbmdlKSA9PiBzdW0gKyBtYXJrUmFuZ2UudG8gLSBtYXJrUmFuZ2UuZnJvbSwgMClcblxuICAvLyB3ZSBvbmx5IGluY2x1ZGUgdGhlIHJlc3VsdCBvZiBgZXhjbHVkZWRSYW5nZWBcbiAgLy8gaWYgdGhlcmUgaXMgYSBtYXRjaCBhdCBhbGxcbiAgY29uc3QgcmFuZ2UgPSBtYXRjaGVkUmFuZ2UgPiAwID8gbWF0Y2hlZFJhbmdlICsgZXhjbHVkZWRSYW5nZSA6IG1hdGNoZWRSYW5nZVxuXG4gIHJldHVybiByYW5nZSA+PSBzZWxlY3Rpb25SYW5nZVxufVxuIiwgImltcG9ydCB0eXBlIHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHR5cGUgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB0eXBlIHsgTm9kZVJhbmdlIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBvYmplY3RJbmNsdWRlcyB9IGZyb20gJy4uL3V0aWxpdGllcy9vYmplY3RJbmNsdWRlcy5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi9nZXROb2RlVHlwZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZUFjdGl2ZShcbiAgc3RhdGU6IEVkaXRvclN0YXRlLFxuICB0eXBlT3JOYW1lOiBOb2RlVHlwZSB8IHN0cmluZyB8IG51bGwsXG4gIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbik6IGJvb2xlYW4ge1xuICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uXG4gIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGxcblxuICBjb25zdCBub2RlUmFuZ2VzOiBOb2RlUmFuZ2VbXSA9IFtdXG5cbiAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKVxuICAgIGNvbnN0IHJlbGF0aXZlVG8gPSBNYXRoLm1pbih0bywgcG9zICsgbm9kZS5ub2RlU2l6ZSlcblxuICAgIG5vZGVSYW5nZXMucHVzaCh7XG4gICAgICBub2RlLFxuICAgICAgZnJvbTogcmVsYXRpdmVGcm9tLFxuICAgICAgdG86IHJlbGF0aXZlVG8sXG4gICAgfSlcbiAgfSlcblxuICBjb25zdCBzZWxlY3Rpb25SYW5nZSA9IHRvIC0gZnJvbVxuICBjb25zdCBtYXRjaGVkTm9kZVJhbmdlcyA9IG5vZGVSYW5nZXNcbiAgICAuZmlsdGVyKG5vZGVSYW5nZSA9PiB7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGUubmFtZSA9PT0gbm9kZVJhbmdlLm5vZGUudHlwZS5uYW1lXG4gICAgfSlcbiAgICAuZmlsdGVyKG5vZGVSYW5nZSA9PiBvYmplY3RJbmNsdWRlcyhub2RlUmFuZ2Uubm9kZS5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuXG4gIGlmIChlbXB0eSkge1xuICAgIHJldHVybiAhIW1hdGNoZWROb2RlUmFuZ2VzLmxlbmd0aFxuICB9XG5cbiAgY29uc3QgcmFuZ2UgPSBtYXRjaGVkTm9kZVJhbmdlcy5yZWR1Y2UoKHN1bSwgbm9kZVJhbmdlKSA9PiBzdW0gKyBub2RlUmFuZ2UudG8gLSBub2RlUmFuZ2UuZnJvbSwgMClcblxuICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2Vcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUgfSBmcm9tICcuL2dldFNjaGVtYVR5cGVOYW1lQnlOYW1lLmpzJ1xuaW1wb3J0IHsgaXNNYXJrQWN0aXZlIH0gZnJvbSAnLi9pc01hcmtBY3RpdmUuanMnXG5pbXBvcnQgeyBpc05vZGVBY3RpdmUgfSBmcm9tICcuL2lzTm9kZUFjdGl2ZS5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQWN0aXZlKHN0YXRlOiBFZGl0b3JTdGF0ZSwgbmFtZTogc3RyaW5nIHwgbnVsbCwgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9KTogYm9vbGVhbiB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpIHx8IGlzTWFya0FjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcylcbiAgfVxuXG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpXG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgcmV0dXJuIGlzTWFya0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcylcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB0eXBlIHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBmaW5kUGFyZW50Tm9kZSB9IGZyb20gJy4vZmluZFBhcmVudE5vZGUuanMnXG5cbmV4cG9ydCBjb25zdCBpc0F0RW5kT2ZOb2RlID0gKHN0YXRlOiBFZGl0b3JTdGF0ZSwgbm9kZVR5cGU/OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgeyAkZnJvbSwgJHRvLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb25cblxuICBpZiAobm9kZVR5cGUpIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUubmFtZSA9PT0gbm9kZVR5cGUpKHN0YXRlLnNlbGVjdGlvbilcblxuICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgJHBhcmVudFBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBhcmVudE5vZGUucG9zICsgMSlcblxuICAgIGlmICgkYW5jaG9yLnBvcyArIDEgPT09ICRwYXJlbnRQb3MuZW5kKCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoJHRvLnBhcmVudE9mZnNldCA8ICR0by5wYXJlbnQubm9kZVNpemUgLSAyIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGNvbnN0IGlzQXRTdGFydE9mTm9kZSA9IChzdGF0ZTogRWRpdG9yU3RhdGUpID0+IHtcbiAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb25cblxuICBpZiAoJGZyb20ucGFyZW50T2Zmc2V0ID4gMCB8fCAkZnJvbS5wb3MgIT09ICR0by5wb3MpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBBbnlFeHRlbnNpb24sIEVuYWJsZVJ1bGVzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb246IEFueUV4dGVuc2lvbiwgZW5hYmxlZDogRW5hYmxlUnVsZXMpOiBib29sZWFuIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZW5hYmxlZCkpIHtcbiAgICByZXR1cm4gZW5hYmxlZC5zb21lKGVuYWJsZWRFeHRlbnNpb24gPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBlbmFibGVkRXh0ZW5zaW9uID09PSAnc3RyaW5nJyA/IGVuYWJsZWRFeHRlbnNpb24gOiBlbmFibGVkRXh0ZW5zaW9uLm5hbWVcblxuICAgICAgcmV0dXJuIG5hbWUgPT09IGV4dGVuc2lvbi5uYW1lXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBlbmFibGVkXG59XG4iLCAiaW1wb3J0IHsgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICcuLi9oZWxwZXJzL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHR5cGUgeyBOb2RlQ29uZmlnIH0gZnJvbSAnLi4vaW5kZXguanMnXG5pbXBvcnQgdHlwZSB7IEV4dGVuc2lvbnMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4uL3V0aWxpdGllcy9jYWxsT3JSZXR1cm4uanMnXG5pbXBvcnQgeyBzcGxpdEV4dGVuc2lvbnMgfSBmcm9tICcuL3NwbGl0RXh0ZW5zaW9ucy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGlzdChuYW1lOiBzdHJpbmcsIGV4dGVuc2lvbnM6IEV4dGVuc2lvbnMpOiBib29sZWFuIHtcbiAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpXG4gIGNvbnN0IGV4dGVuc2lvbiA9IG5vZGVFeHRlbnNpb25zLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09IG5hbWUpXG5cbiAgaWYgKCFleHRlbnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gIH1cbiAgY29uc3QgZ3JvdXAgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQ8Tm9kZUNvbmZpZ1snZ3JvdXAnXT4oZXh0ZW5zaW9uLCAnZ3JvdXAnLCBjb250ZXh0KSlcblxuICBpZiAodHlwZW9mIGdyb3VwICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGdyb3VwLnNwbGl0KCcgJykuaW5jbHVkZXMoJ2xpc3QnKVxufVxuIiwgImltcG9ydCB0eXBlIHsgTm9kZSBhcyBQcm9zZU1pcnJvck5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcHJvc2VtaXJyb3Igbm9kZSBpcyBlbXB0eS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZUVtcHR5KFxuICBub2RlOiBQcm9zZU1pcnJvck5vZGUsXG4gIHtcbiAgICBjaGVja0NoaWxkcmVuID0gdHJ1ZSxcbiAgICBpZ25vcmVXaGl0ZXNwYWNlID0gZmFsc2UsXG4gIH06IHtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUgKGRlZmF1bHQpLCBpdCB3aWxsIGFsc28gY2hlY2sgaWYgYWxsIGNoaWxkcmVuIGFyZSBlbXB0eS5cbiAgICAgKi9cbiAgICBjaGVja0NoaWxkcmVuPzogYm9vbGVhblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgaXQgd2lsbCBpZ25vcmUgd2hpdGVzcGFjZSB3aGVuIGNoZWNraW5nIGZvciBlbXB0aW5lc3MuXG4gICAgICovXG4gICAgaWdub3JlV2hpdGVzcGFjZT86IGJvb2xlYW5cbiAgfSA9IHt9LFxuKTogYm9vbGVhbiB7XG4gIGlmIChpZ25vcmVXaGl0ZXNwYWNlKSB7XG4gICAgaWYgKG5vZGUudHlwZS5uYW1lID09PSAnaGFyZEJyZWFrJykge1xuICAgICAgLy8gSGFyZCBicmVha3MgYXJlIGNvbnNpZGVyZWQgZW1wdHlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgcmV0dXJuIC9eXFxzKiQvbS50ZXN0KG5vZGUudGV4dCA/PyAnJylcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICByZXR1cm4gIW5vZGUudGV4dFxuICB9XG5cbiAgaWYgKG5vZGUuaXNBdG9tIHx8IG5vZGUuaXNMZWFmKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobm9kZS5jb250ZW50LmNoaWxkQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGNoZWNrQ2hpbGRyZW4pIHtcbiAgICBsZXQgaXNDb250ZW50RW1wdHkgPSB0cnVlXG5cbiAgICBub2RlLmNvbnRlbnQuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgaWYgKGlzQ29udGVudEVtcHR5ID09PSBmYWxzZSkge1xuICAgICAgICAvLyBFeGl0IGVhcmx5IGZvciBwZXJmXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTm9kZUVtcHR5KGNoaWxkTm9kZSwgeyBpZ25vcmVXaGl0ZXNwYWNlLCBjaGVja0NoaWxkcmVuIH0pKSB7XG4gICAgICAgIGlzQ29udGVudEVtcHR5ID0gZmFsc2VcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGlzQ29udGVudEVtcHR5XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsICJpbXBvcnQgeyBOb2RlU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZVNlbGVjdGlvbih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIE5vZGVTZWxlY3Rpb24ge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uXG59XG4iLCAiaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RleHRTZWxlY3Rpb24odmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBUZXh0U2VsZWN0aW9uIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvblxufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBtaW5NYXgodmFsdWUgPSAwLCBtaW4gPSAwLCBtYXggPSAwKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5pbXBvcnQgeyBtaW5NYXggfSBmcm9tICcuLi91dGlsaXRpZXMvbWluTWF4LmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gcG9zVG9ET01SZWN0KHZpZXc6IEVkaXRvclZpZXcsIGZyb206IG51bWJlciwgdG86IG51bWJlcik6IERPTVJlY3Qge1xuICBjb25zdCBtaW5Qb3MgPSAwXG4gIGNvbnN0IG1heFBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZVxuICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpXG4gIGNvbnN0IHJlc29sdmVkRW5kID0gbWluTWF4KHRvLCBtaW5Qb3MsIG1heFBvcylcbiAgY29uc3Qgc3RhcnQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRnJvbSlcbiAgY29uc3QgZW5kID0gdmlldy5jb29yZHNBdFBvcyhyZXNvbHZlZEVuZCwgLTEpXG4gIGNvbnN0IHRvcCA9IE1hdGgubWluKHN0YXJ0LnRvcCwgZW5kLnRvcClcbiAgY29uc3QgYm90dG9tID0gTWF0aC5tYXgoc3RhcnQuYm90dG9tLCBlbmQuYm90dG9tKVxuICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oc3RhcnQubGVmdCwgZW5kLmxlZnQpXG4gIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoc3RhcnQucmlnaHQsIGVuZC5yaWdodClcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnRcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wXG4gIGNvbnN0IHggPSBsZWZ0XG4gIGNvbnN0IHkgPSB0b3BcbiAgY29uc3QgZGF0YSA9IHtcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeSxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICB0b0pTT046ICgpID0+IGRhdGEsXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB0eXBlIHsgRm9jdXNQb3NpdGlvbiB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgbWluTWF4IH0gZnJvbSAnLi4vdXRpbGl0aWVzL21pbk1heC5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVGb2N1c1Bvc2l0aW9uKGRvYzogUHJvc2VNaXJyb3JOb2RlLCBwb3NpdGlvbjogRm9jdXNQb3NpdGlvbiA9IG51bGwpOiBTZWxlY3Rpb24gfCBudWxsIHtcbiAgaWYgKCFwb3NpdGlvbikge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBzZWxlY3Rpb25BdFN0YXJ0ID0gU2VsZWN0aW9uLmF0U3RhcnQoZG9jKVxuICBjb25zdCBzZWxlY3Rpb25BdEVuZCA9IFNlbGVjdGlvbi5hdEVuZChkb2MpXG5cbiAgaWYgKHBvc2l0aW9uID09PSAnc3RhcnQnIHx8IHBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkF0U3RhcnRcbiAgfVxuXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uQXRFbmRcbiAgfVxuXG4gIGNvbnN0IG1pblBvcyA9IHNlbGVjdGlvbkF0U3RhcnQuZnJvbVxuICBjb25zdCBtYXhQb3MgPSBzZWxlY3Rpb25BdEVuZC50b1xuXG4gIGlmIChwb3NpdGlvbiA9PT0gJ2FsbCcpIHtcbiAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBtaW5NYXgoMCwgbWluUG9zLCBtYXhQb3MpLCBtaW5NYXgoZG9jLmNvbnRlbnQuc2l6ZSwgbWluUG9zLCBtYXhQb3MpKVxuICB9XG5cbiAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcyksIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpKVxufVxuIiwgImltcG9ydCB0eXBlIHsgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHR5cGUgeyBKU09OQ29udGVudCB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG50eXBlIFJld3JpdGVVbmtub3duQ29udGVudE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBJZiB0cnVlLCB1bmtub3duIG5vZGVzIHdpbGwgYmUgdHJlYXRlZCBhcyBwYXJhZ3JhcGhzXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGZhbGxiYWNrVG9QYXJhZ3JhcGg/OiBib29sZWFuXG59XG5cbnR5cGUgUmV3cml0dGVuQ29udGVudCA9IHtcbiAgLyoqXG4gICAqIFRoZSBvcmlnaW5hbCBKU09OIGNvbnRlbnQgdGhhdCB3YXMgcmV3cml0dGVuXG4gICAqL1xuICBvcmlnaW5hbDogSlNPTkNvbnRlbnRcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBub2RlIG9yIG1hcmsgdGhhdCB3YXMgdW5zdXBwb3J0ZWRcbiAgICovXG4gIHVuc3VwcG9ydGVkOiBzdHJpbmdcbn1bXVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIHJld3JpdGVVbmtub3duQ29udGVudCBmdW5jdGlvblxuICovXG5mdW5jdGlvbiByZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lcih7XG4gIGpzb24sXG4gIHZhbGlkTWFya3MsXG4gIHZhbGlkTm9kZXMsXG4gIG9wdGlvbnMsXG4gIHJld3JpdHRlbkNvbnRlbnQgPSBbXSxcbn06IHtcbiAganNvbjogSlNPTkNvbnRlbnRcbiAgdmFsaWRNYXJrczogU2V0PHN0cmluZz5cbiAgdmFsaWROb2RlczogU2V0PHN0cmluZz5cbiAgb3B0aW9ucz86IFJld3JpdGVVbmtub3duQ29udGVudE9wdGlvbnNcbiAgcmV3cml0dGVuQ29udGVudD86IFJld3JpdHRlbkNvbnRlbnRcbn0pOiB7XG4gIC8qKlxuICAgKiBUaGUgY2xlYW5lZCBKU09OIGNvbnRlbnRcbiAgICovXG4gIGpzb246IEpTT05Db250ZW50IHwgbnVsbFxuICAvKipcbiAgICogVGhlIGFycmF5IG9mIG5vZGVzIGFuZCBtYXJrcyB0aGF0IHdlcmUgcmV3cml0dGVuXG4gICAqL1xuICByZXdyaXR0ZW5Db250ZW50OiBSZXdyaXR0ZW5Db250ZW50XG59IHtcbiAgaWYgKGpzb24ubWFya3MgJiYgQXJyYXkuaXNBcnJheShqc29uLm1hcmtzKSkge1xuICAgIGpzb24ubWFya3MgPSBqc29uLm1hcmtzLmZpbHRlcihtYXJrID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbWFyayA9PT0gJ3N0cmluZycgPyBtYXJrIDogbWFyay50eXBlXG5cbiAgICAgIGlmICh2YWxpZE1hcmtzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICByZXdyaXR0ZW5Db250ZW50LnB1c2goe1xuICAgICAgICBvcmlnaW5hbDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtYXJrKSksXG4gICAgICAgIHVuc3VwcG9ydGVkOiBuYW1lLFxuICAgICAgfSlcbiAgICAgIC8vIEp1c3QgaWdub3JlIGFueSB1bmtub3duIG1hcmtzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KVxuICB9XG5cbiAgaWYgKGpzb24uY29udGVudCAmJiBBcnJheS5pc0FycmF5KGpzb24uY29udGVudCkpIHtcbiAgICBqc29uLmNvbnRlbnQgPSBqc29uLmNvbnRlbnRcbiAgICAgIC5tYXAoXG4gICAgICAgIHZhbHVlID0+XG4gICAgICAgICAgcmV3cml0ZVVua25vd25Db250ZW50SW5uZXIoe1xuICAgICAgICAgICAganNvbjogdmFsdWUsXG4gICAgICAgICAgICB2YWxpZE1hcmtzLFxuICAgICAgICAgICAgdmFsaWROb2RlcyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICByZXdyaXR0ZW5Db250ZW50LFxuICAgICAgICAgIH0pLmpzb24sXG4gICAgICApXG4gICAgICAuZmlsdGVyKGEgPT4gYSAhPT0gbnVsbCAmJiBhICE9PSB1bmRlZmluZWQpXG4gIH1cblxuICBpZiAoanNvbi50eXBlICYmICF2YWxpZE5vZGVzLmhhcyhqc29uLnR5cGUpKSB7XG4gICAgcmV3cml0dGVuQ29udGVudC5wdXNoKHtcbiAgICAgIG9yaWdpbmFsOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGpzb24pKSxcbiAgICAgIHVuc3VwcG9ydGVkOiBqc29uLnR5cGUsXG4gICAgfSlcblxuICAgIGlmIChqc29uLmNvbnRlbnQgJiYgQXJyYXkuaXNBcnJheShqc29uLmNvbnRlbnQpICYmIG9wdGlvbnM/LmZhbGxiYWNrVG9QYXJhZ3JhcGggIT09IGZhbHNlKSB7XG4gICAgICAvLyBKdXN0IHRyZWF0IGl0IGxpa2UgYSBwYXJhZ3JhcGggYW5kIGhvcGUgZm9yIHRoZSBiZXN0XG4gICAgICBqc29uLnR5cGUgPSAncGFyYWdyYXBoJ1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29uLFxuICAgICAgICByZXdyaXR0ZW5Db250ZW50LFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG9yIGp1c3Qgb21pdCBpdCBlbnRpcmVseVxuICAgIHJldHVybiB7XG4gICAgICBqc29uOiBudWxsLFxuICAgICAgcmV3cml0dGVuQ29udGVudCxcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBqc29uLCByZXdyaXR0ZW5Db250ZW50IH1cbn1cblxuLyoqXG4gKiBSZXdyaXRlIHVua25vd24gbm9kZXMgYW5kIG1hcmtzIHdpdGhpbiBKU09OIGNvbnRlbnRcbiAqIEFsbG93aW5nIGZvciB1c2VyIHdpdGhpbiB0aGUgZWRpdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXdyaXRlVW5rbm93bkNvbnRlbnQoXG4gIC8qKlxuICAgKiBUaGUgSlNPTiBjb250ZW50IHRvIGNsZWFuIG9mIHVua25vd24gbm9kZXMgYW5kIG1hcmtzXG4gICAqL1xuICBqc29uOiBKU09OQ29udGVudCxcbiAgLyoqXG4gICAqIFRoZSBzY2hlbWEgdG8gdXNlIGZvciB2YWxpZGF0aW9uXG4gICAqL1xuICBzY2hlbWE6IFNjaGVtYSxcbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIHRoZSBjbGVhbmluZyBwcm9jZXNzXG4gICAqL1xuICBvcHRpb25zPzogUmV3cml0ZVVua25vd25Db250ZW50T3B0aW9ucyxcbik6IHtcbiAgLyoqXG4gICAqIFRoZSBjbGVhbmVkIEpTT04gY29udGVudFxuICAgKi9cbiAganNvbjogSlNPTkNvbnRlbnQgfCBudWxsXG4gIC8qKlxuICAgKiBUaGUgYXJyYXkgb2Ygbm9kZXMgYW5kIG1hcmtzIHRoYXQgd2VyZSByZXdyaXR0ZW5cbiAgICovXG4gIHJld3JpdHRlbkNvbnRlbnQ6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JpZ2luYWwgSlNPTiBjb250ZW50IHRoYXQgd2FzIHJld3JpdHRlblxuICAgICAqL1xuICAgIG9yaWdpbmFsOiBKU09OQ29udGVudFxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBub2RlIG9yIG1hcmsgdGhhdCB3YXMgdW5zdXBwb3J0ZWRcbiAgICAgKi9cbiAgICB1bnN1cHBvcnRlZDogc3RyaW5nXG4gIH1bXVxufSB7XG4gIHJldHVybiByZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lcih7XG4gICAganNvbixcbiAgICB2YWxpZE5vZGVzOiBuZXcgU2V0KE9iamVjdC5rZXlzKHNjaGVtYS5ub2RlcykpLFxuICAgIHZhbGlkTWFya3M6IG5ldyBTZXQoT2JqZWN0LmtleXMoc2NoZW1hLm1hcmtzKSksXG4gICAgb3B0aW9ucyxcbiAgfSlcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBSZXBsYWNlQXJvdW5kU3RlcCwgUmVwbGFjZVN0ZXAgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itc3RhdGUvYmxvYi9tYXN0ZXIvc3JjL3NlbGVjdGlvbi5qcyNMNDY2XG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHI6IFRyYW5zYWN0aW9uLCBzdGFydExlbjogbnVtYmVyLCBiaWFzOiBudW1iZXIpIHtcbiAgY29uc3QgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDFcblxuICBpZiAobGFzdCA8IHN0YXJ0TGVuKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBzdGVwID0gdHIuc3RlcHNbbGFzdF1cblxuICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdXG4gIGxldCBlbmQgPSAwXG5cbiAgbWFwLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4ge1xuICAgIGlmIChlbmQgPT09IDApIHtcbiAgICAgIGVuZCA9IG5ld1RvXG4gICAgfVxuICB9KVxuXG4gIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShlbmQpLCBiaWFzKSlcbn1cbiIsICJpbXBvcnQgdHlwZSB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB0eXBlIHsgRWRpdG9yU3RhdGUsIFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgQ29tbWFuZE1hbmFnZXIgfSBmcm9tICcuL0NvbW1hbmRNYW5hZ2VyLmpzJ1xuaW1wb3J0IHR5cGUgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi9oZWxwZXJzL2NyZWF0ZUNoYWluYWJsZVN0YXRlLmpzJ1xuaW1wb3J0IHsgZ2V0SFRNTEZyb21GcmFnbWVudCB9IGZyb20gJy4vaGVscGVycy9nZXRIVE1MRnJvbUZyYWdtZW50LmpzJ1xuaW1wb3J0IHsgZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMgfSBmcm9tICcuL2hlbHBlcnMvZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMuanMnXG5pbXBvcnQgdHlwZSB7IENhbkNvbW1hbmRzLCBDaGFpbmVkQ29tbWFuZHMsIEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSwgUmFuZ2UsIFNpbmdsZUNvbW1hbmRzIH0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGlzUmVnRXhwIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNSZWdFeHAuanMnXG5cbmV4cG9ydCB0eXBlIElucHV0UnVsZU1hdGNoID0ge1xuICBpbmRleDogbnVtYmVyXG4gIHRleHQ6IHN0cmluZ1xuICByZXBsYWNlV2l0aD86IHN0cmluZ1xuICBtYXRjaD86IFJlZ0V4cE1hdGNoQXJyYXlcbiAgZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZXhwb3J0IHR5cGUgSW5wdXRSdWxlRmluZGVyID0gUmVnRXhwIHwgKCh0ZXh0OiBzdHJpbmcpID0+IElucHV0UnVsZU1hdGNoIHwgbnVsbClcblxuZXhwb3J0IGNsYXNzIElucHV0UnVsZSB7XG4gIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuXG4gIGhhbmRsZXI6IChwcm9wczoge1xuICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgIHJhbmdlOiBSYW5nZVxuICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICBjb21tYW5kczogU2luZ2xlQ29tbWFuZHNcbiAgICBjaGFpbjogKCkgPT4gQ2hhaW5lZENvbW1hbmRzXG4gICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICB9KSA9PiB2b2lkIHwgbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzoge1xuICAgIGZpbmQ6IElucHV0UnVsZUZpbmRlclxuICAgIGhhbmRsZXI6IChwcm9wczoge1xuICAgICAgc3RhdGU6IEVkaXRvclN0YXRlXG4gICAgICByYW5nZTogUmFuZ2VcbiAgICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICAgIGNvbW1hbmRzOiBTaW5nbGVDb21tYW5kc1xuICAgICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICAgIH0pID0+IHZvaWQgfCBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmZpbmQgPSBjb25maWcuZmluZFxuICAgIHRoaXMuaGFuZGxlciA9IGNvbmZpZy5oYW5kbGVyXG4gIH1cbn1cblxuY29uc3QgaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIgPSAodGV4dDogc3RyaW5nLCBmaW5kOiBJbnB1dFJ1bGVGaW5kZXIpOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkgfCBudWxsID0+IHtcbiAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgcmV0dXJuIGZpbmQuZXhlYyh0ZXh0KVxuICB9XG5cbiAgY29uc3QgaW5wdXRSdWxlTWF0Y2ggPSBmaW5kKHRleHQpXG5cbiAgaWYgKCFpbnB1dFJ1bGVNYXRjaCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCByZXN1bHQ6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSA9IFtpbnB1dFJ1bGVNYXRjaC50ZXh0XVxuXG4gIHJlc3VsdC5pbmRleCA9IGlucHV0UnVsZU1hdGNoLmluZGV4XG4gIHJlc3VsdC5pbnB1dCA9IHRleHRcbiAgcmVzdWx0LmRhdGEgPSBpbnB1dFJ1bGVNYXRjaC5kYXRhXG5cbiAgaWYgKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgaWYgKCFpbnB1dFJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xuICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcImlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoXCIgbXVzdCBiZSBwYXJ0IG9mIFwiaW5wdXRSdWxlTWF0Y2gudGV4dFwiLicpXG4gICAgfVxuXG4gICAgcmVzdWx0LnB1c2goaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHJ1bihjb25maWc6IHtcbiAgZWRpdG9yOiBFZGl0b3JcbiAgZnJvbTogbnVtYmVyXG4gIHRvOiBudW1iZXJcbiAgdGV4dDogc3RyaW5nXG4gIHJ1bGVzOiBJbnB1dFJ1bGVbXVxuICBwbHVnaW46IFBsdWdpblxufSk6IGJvb2xlYW4ge1xuICBjb25zdCB7IGVkaXRvciwgZnJvbSwgdG8sIHRleHQsIHJ1bGVzLCBwbHVnaW4gfSA9IGNvbmZpZ1xuICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvclxuXG4gIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgJGZyb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGZyb20pXG5cbiAgaWYgKFxuICAgIC8vIGNoZWNrIGZvciBjb2RlIG5vZGVcbiAgICAkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHxcbiAgICAvLyBjaGVjayBmb3IgY29kZSBtYXJrXG4gICAgISEoJGZyb20ubm9kZUJlZm9yZSB8fCAkZnJvbS5ub2RlQWZ0ZXIpPy5tYXJrcy5maW5kKG1hcmsgPT4gbWFyay50eXBlLnNwZWMuY29kZSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBsZXQgbWF0Y2hlZCA9IGZhbHNlXG5cbiAgY29uc3QgdGV4dEJlZm9yZSA9IGdldFRleHRDb250ZW50RnJvbU5vZGVzKCRmcm9tKSArIHRleHRcblxuICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IGlucHV0UnVsZU1hdGNoZXJIYW5kbGVyKHRleHRCZWZvcmUsIHJ1bGUuZmluZClcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRyID0gdmlldy5zdGF0ZS50clxuICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgc3RhdGU6IHZpZXcuc3RhdGUsXG4gICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgfSlcbiAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgIGZyb206IGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLFxuICAgICAgdG8sXG4gICAgfVxuXG4gICAgY29uc3QgeyBjb21tYW5kcywgY2hhaW4sIGNhbiB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgIGVkaXRvcixcbiAgICAgIHN0YXRlLFxuICAgIH0pXG5cbiAgICBjb25zdCBoYW5kbGVyID0gcnVsZS5oYW5kbGVyKHtcbiAgICAgIHN0YXRlLFxuICAgICAgcmFuZ2UsXG4gICAgICBtYXRjaCxcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgY2hhaW4sXG4gICAgICBjYW4sXG4gICAgfSlcblxuICAgIC8vIHN0b3AgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXNcbiAgICBpZiAoaGFuZGxlciA9PT0gbnVsbCB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBzdG9yZSB0cmFuc2Zvcm0gYXMgbWV0YSBkYXRhXG4gICAgLy8gc28gd2UgY2FuIHVuZG8gaW5wdXQgcnVsZXMgd2l0aGluIHRoZSBgdW5kb0lucHV0UnVsZXNgIGNvbW1hbmRcbiAgICB0ci5zZXRNZXRhKHBsdWdpbiwge1xuICAgICAgdHJhbnNmb3JtOiB0cixcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHRleHQsXG4gICAgfSlcblxuICAgIHZpZXcuZGlzcGF0Y2godHIpXG4gICAgbWF0Y2hlZCA9IHRydWVcbiAgfSlcblxuICByZXR1cm4gbWF0Y2hlZFxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnB1dCBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSB0ZXh0XG4gKiBpbnB1dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xuICogYWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5wdXRSdWxlc1BsdWdpbihwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgcnVsZXM6IElucHV0UnVsZVtdIH0pOiBQbHVnaW4ge1xuICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzXG4gIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIHN0YXRlOiB7XG4gICAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfSxcbiAgICAgIGFwcGx5KHRyLCBwcmV2LCBzdGF0ZSkge1xuICAgICAgICBjb25zdCBzdG9yZWQgPSB0ci5nZXRNZXRhKHBsdWdpbilcblxuICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHN0b3JlZFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgSW5wdXRSdWxlIGlzIHRyaWdnZXJlZCBieSBpbnNlcnRDb250ZW50KClcbiAgICAgICAgY29uc3Qgc2ltdWxhdGVkSW5wdXRNZXRhID0gdHIuZ2V0TWV0YSgnYXBwbHlJbnB1dFJ1bGVzJykgYXNcbiAgICAgICAgICB8IHVuZGVmaW5lZFxuICAgICAgICAgIHwge1xuICAgICAgICAgICAgICBmcm9tOiBudW1iZXJcbiAgICAgICAgICAgICAgdGV4dDogc3RyaW5nIHwgUHJvc2VNaXJyb3JOb2RlIHwgRnJhZ21lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNTaW11bGF0ZWRJbnB1dCA9ICEhc2ltdWxhdGVkSW5wdXRNZXRhXG5cbiAgICAgICAgaWYgKGlzU2ltdWxhdGVkSW5wdXQpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHRleHQgfSA9IHNpbXVsYXRlZElucHV0TWV0YVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0IGFzIHN0cmluZ1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGV4dCA9IGdldEhUTUxGcm9tRnJhZ21lbnQoRnJhZ21lbnQuZnJvbSh0ZXh0KSwgc3RhdGUuc2NoZW1hKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IGZyb20gfSA9IHNpbXVsYXRlZElucHV0TWV0YVxuICAgICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGV4dC5sZW5ndGhcblxuICAgICAgICAgICAgcnVuKHtcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2XG4gICAgICB9LFxuICAgIH0sXG5cbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlVGV4dElucHV0KHZpZXcsIGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiBydW4oe1xuICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgcGx1Z2luLFxuICAgICAgICB9KVxuICAgICAgfSxcblxuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIGNvbXBvc2l0aW9uZW5kOiB2aWV3ID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvblxuXG4gICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICBydW4oe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgIH0sXG5cbiAgICAgIC8vIGFkZCBzdXBwb3J0IGZvciBpbnB1dCBydWxlcyB0byB0cmlnZ2VyIG9uIGVudGVyXG4gICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgZXhhbXBsZSBmb3IgY29kZSBibG9ja3NcbiAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gJ0VudGVyJykge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbiBhcyBUZXh0U2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKCRjdXJzb3IpIHtcbiAgICAgICAgICByZXR1cm4gcnVuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIGZyb206ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgdGV4dDogJ1xcbicsXG4gICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9LFxuICAgIH0sXG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXNJbnB1dFJ1bGVzOiB0cnVlLFxuICB9KSBhcyBQbHVnaW5cblxuICByZXR1cm4gcGx1Z2luXG59XG4iLCAiLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWVzcXVlZWIvaXMtd2hhdC9ibG9iLzg4ZDZlNGNhOTJmYjJiYWFiNjAwM2M1NGUwMmVlZGY0ZTcyOWU1YWIvc3JjL2luZGV4LnRzXG5cbmZ1bmN0aW9uIGdldFR5cGUodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZTogYW55KTogdmFsdWUgaXMgUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ09iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IE9iamVjdC5wcm90b3R5cGVcbn1cbiIsICJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi9pc1BsYWluT2JqZWN0LmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VEZWVwKHRhcmdldDogUmVjb3JkPHN0cmluZywgYW55Piwgc291cmNlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IG91dHB1dCA9IHsgLi4udGFyZ2V0IH1cblxuICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pICYmIGlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gbWVyZ2VEZWVwKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuIiwgImltcG9ydCB0eXBlIHsgUGx1Z2luIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHR5cGUgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB7IGdldEV4dGVuc2lvbkZpZWxkIH0gZnJvbSAnLi9oZWxwZXJzL2dldEV4dGVuc2lvbkZpZWxkLmpzJ1xuaW1wb3J0IHR5cGUgeyBFeHRlbnNpb25Db25maWcsIE1hcmtDb25maWcsIE5vZGVDb25maWcgfSBmcm9tICcuL2luZGV4LmpzJ1xuaW1wb3J0IHR5cGUgeyBJbnB1dFJ1bGUgfSBmcm9tICcuL0lucHV0UnVsZS5qcydcbmltcG9ydCB0eXBlIHsgTWFyayB9IGZyb20gJy4vTWFyay5qcydcbmltcG9ydCB0eXBlIHsgTm9kZSB9IGZyb20gJy4vTm9kZS5qcydcbmltcG9ydCB0eXBlIHsgUGFzdGVSdWxlIH0gZnJvbSAnLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQgdHlwZSB7XG4gIEFueUNvbmZpZyxcbiAgRWRpdG9yRXZlbnRzLFxuICBFeHRlbnNpb25zLFxuICBHbG9iYWxBdHRyaWJ1dGVzLFxuICBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZCxcbiAgUGFyZW50Q29uZmlnLFxuICBSYXdDb21tYW5kcyxcbn0gZnJvbSAnLi90eXBlcy5qcydcbmltcG9ydCB7IGNhbGxPclJldHVybiB9IGZyb20gJy4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcbmltcG9ydCB7IG1lcmdlRGVlcCB9IGZyb20gJy4vdXRpbGl0aWVzL21lcmdlRGVlcC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBFeHRlbmRhYmxlQ29uZmlnPFxuICBPcHRpb25zID0gYW55LFxuICBTdG9yYWdlID0gYW55LFxuICBDb25maWcgZXh0ZW5kc1xuICAgIHwgRXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+XG4gICAgfCBOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+XG4gICAgfCBNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+XG4gICAgfCBFeHRlbmRhYmxlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+ID0gRXh0ZW5kYWJsZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlLCBhbnksIGFueT4sXG4gIFBNVHlwZSA9IGFueSxcbj4ge1xuICAvKipcbiAgICogVGhlIGV4dGVuc2lvbiBuYW1lIC0gdGhpcyBtdXN0IGJlIHVuaXF1ZS5cbiAgICogSXQgd2lsbCBiZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSBleHRlbnNpb24uXG4gICAqXG4gICAqIEBleGFtcGxlICdteUV4dGVuc2lvbidcbiAgICovXG4gIG5hbWU6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgcHJpb3JpdHkgb2YgeW91ciBleHRlbnNpb24uIFRoZSBoaWdoZXIsIHRoZSBlYXJsaWVyIGl0IHdpbGwgYmUgY2FsbGVkXG4gICAqIGFuZCB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyIG90aGVyIGV4dGVuc2lvbnMgd2l0aCBhIGxvd2VyIHByaW9yaXR5LlxuICAgKiBAZGVmYXVsdCAxMDBcbiAgICogQGV4YW1wbGUgMTAxXG4gICAqL1xuICBwcmlvcml0eT86IG51bWJlclxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBvcHRpb25zIHRvIHRoaXMgZXh0ZW5zaW9uXG4gICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI3NldHRpbmdzXG4gICAqIEBleGFtcGxlXG4gICAqIGFkZE9wdGlvbnMoKSB7XG4gICAqICByZXR1cm4ge1xuICAgKiAgICBteU9wdGlvbjogJ2ZvbycsXG4gICAqICAgIG15T3RoZXJPcHRpb246IDEwLFxuICAgKiB9XG4gICAqL1xuICBhZGRPcHRpb25zPzogKHRoaXM6IHsgbmFtZTogc3RyaW5nOyBwYXJlbnQ6IFBhcmVudENvbmZpZzxDb25maWc+WydhZGRPcHRpb25zJ10gfSkgPT4gT3B0aW9uc1xuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBzdG9yYWdlIHRoaXMgZXh0ZW5zaW9uIGNhbiBzYXZlIGRhdGEgdG8uXG4gICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI3N0b3JhZ2VcbiAgICogQGV4YW1wbGVcbiAgICogZGVmYXVsdFN0b3JhZ2U6IHtcbiAgICogICBwcmVmZXRjaGVkVXNlcnM6IFtdLFxuICAgKiAgIGxvYWRpbmc6IGZhbHNlLFxuICAgKiB9XG4gICAqL1xuICBhZGRTdG9yYWdlPzogKHRoaXM6IHsgbmFtZTogc3RyaW5nOyBvcHRpb25zOiBPcHRpb25zOyBwYXJlbnQ6IFBhcmVudENvbmZpZzxDb25maWc+WydhZGRTdG9yYWdlJ10gfSkgPT4gU3RvcmFnZVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgZ2xvYmFsQXR0cmlidXRlcyB0byBzcGVjaWZpYyBub2Rlcy5cbiAgICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMjZ2xvYmFsLWF0dHJpYnV0ZXNcbiAgICogQGV4YW1wbGVcbiAgICogYWRkR2xvYmFsQXR0cmlidXRlcygpIHtcbiAgICogICByZXR1cm4gW1xuICAgKiAgICAge1xuICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGZvbGxvd2luZyBleHRlbnNpb25zXG4gICAqICAgICAgIHR5cGVzOiBbXG4gICAqICAgICAgICAgJ2hlYWRpbmcnLFxuICAgKiAgICAgICAgICdwYXJhZ3JhcGgnLFxuICAgKiAgICAgICBdLFxuICAgKiAgICAgICAvLyDigKYgd2l0aCB0aG9zZSBhdHRyaWJ1dGVzXG4gICAqICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICogICAgICAgICB0ZXh0QWxpZ246IHtcbiAgICogICAgICAgICAgIGRlZmF1bHQ6ICdsZWZ0JyxcbiAgICogICAgICAgICAgIHJlbmRlckhUTUw6IGF0dHJpYnV0ZXMgPT4gKHtcbiAgICogICAgICAgICAgICAgc3R5bGU6IGB0ZXh0LWFsaWduOiAke2F0dHJpYnV0ZXMudGV4dEFsaWdufWAsXG4gICAqICAgICAgICAgICB9KSxcbiAgICogICAgICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiBlbGVtZW50LnN0eWxlLnRleHRBbGlnbiB8fCAnbGVmdCcsXG4gICAqICAgICAgICAgfSxcbiAgICogICAgICAgfSxcbiAgICogICAgIH0sXG4gICAqICAgXVxuICAgKiB9XG4gICAqL1xuICBhZGRHbG9iYWxBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgc3RvcmFnZTogU3RvcmFnZVxuICAgIGV4dGVuc2lvbnM6IChOb2RlIHwgTWFyaylbXVxuICAgIHBhcmVudDogUGFyZW50Q29uZmlnPENvbmZpZz5bJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnXVxuICB9KSA9PiBHbG9iYWxBdHRyaWJ1dGVzXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBjb21tYW5kcyB0byB0aGUgZWRpdG9yXG4gICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI2NvbW1hbmRzXG4gICAqIEBleGFtcGxlXG4gICAqIGFkZENvbW1hbmRzKCkge1xuICAgKiAgIHJldHVybiB7XG4gICAqICAgICBteUNvbW1hbmQ6ICgpID0+ICh7IGNoYWluIH0pID0+IGNoYWluKCkuc2V0TWFyaygndHlwZScsICdmb28nKS5ydW4oKSxcbiAgICogICB9XG4gICAqIH1cbiAgICovXG4gIGFkZENvbW1hbmRzPzogKHRoaXM6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgc3RvcmFnZTogU3RvcmFnZVxuICAgIGVkaXRvcjogRWRpdG9yXG4gICAgdHlwZTogUE1UeXBlXG4gICAgcGFyZW50OiBQYXJlbnRDb25maWc8Q29uZmlnPlsnYWRkQ29tbWFuZHMnXVxuICB9KSA9PiBQYXJ0aWFsPFJhd0NvbW1hbmRzPlxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJlZ2lzdGVycyBrZXlib2FyZCBzaG9ydGN1dHMuXG4gICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI2tleWJvYXJkLXNob3J0Y3V0c1xuICAgKiBAZXhhbXBsZVxuICAgKiBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICogICByZXR1cm4ge1xuICAgKiAgICAgJ01vZC1sJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQnVsbGV0TGlzdCgpLFxuICAgKiAgIH1cbiAgICogfSxcbiAgICovXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzPzogKHRoaXM6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgc3RvcmFnZTogU3RvcmFnZVxuICAgIGVkaXRvcjogRWRpdG9yXG4gICAgdHlwZTogUE1UeXBlXG4gICAgcGFyZW50OiBQYXJlbnRDb25maWc8Q29uZmlnPlsnYWRkS2V5Ym9hcmRTaG9ydGN1dHMnXVxuICB9KSA9PiB7XG4gICAgW2tleTogc3RyaW5nXTogS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmRcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgaW5wdXQgcnVsZXMgdG8gdGhlIGVkaXRvci5cbiAgICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMjaW5wdXQtcnVsZXNcbiAgICogQGV4YW1wbGVcbiAgICogYWRkSW5wdXRSdWxlcygpIHtcbiAgICogICByZXR1cm4gW1xuICAgKiAgICAgbWFya0lucHV0UnVsZSh7XG4gICAqICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAqICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICogICAgIH0pLFxuICAgKiAgIF1cbiAgICogfSxcbiAgICovXG4gIGFkZElucHV0UnVsZXM/OiAodGhpczoge1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgZWRpdG9yOiBFZGl0b3JcbiAgICB0eXBlOiBQTVR5cGVcbiAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxDb25maWc+WydhZGRJbnB1dFJ1bGVzJ11cbiAgfSkgPT4gSW5wdXRSdWxlW11cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIHBhc3RlIHJ1bGVzIHRvIHRoZSBlZGl0b3IuXG4gICAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2d1aWRlL2N1c3RvbS1leHRlbnNpb25zI3Bhc3RlLXJ1bGVzXG4gICAqIEBleGFtcGxlXG4gICAqIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAqICAgcmV0dXJuIFtcbiAgICogICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgKiAgICAgICBmaW5kOiBwYXN0ZVJlZ2V4LFxuICAgKiAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAqICAgICB9KSxcbiAgICogICBdXG4gICAqIH0sXG4gICAqL1xuICBhZGRQYXN0ZVJ1bGVzPzogKHRoaXM6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgc3RvcmFnZTogU3RvcmFnZVxuICAgIGVkaXRvcjogRWRpdG9yXG4gICAgdHlwZTogUE1UeXBlXG4gICAgcGFyZW50OiBQYXJlbnRDb25maWc8Q29uZmlnPlsnYWRkUGFzdGVSdWxlcyddXG4gIH0pID0+IFBhc3RlUnVsZVtdXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBQcm9zZW1pcnJvciBwbHVnaW5zIHRvIHRoZSBlZGl0b3JcbiAgICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZ3VpZGUvY3VzdG9tLWV4dGVuc2lvbnMjcHJvc2VtaXJyb3ItcGx1Z2luc1xuICAgKiBAZXhhbXBsZVxuICAgKiBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAqICAgcmV0dXJuIFtcbiAgICogICAgIGN1c3RvbVBsdWdpbigpLFxuICAgKiAgIF1cbiAgICogfVxuICAgKi9cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zPzogKHRoaXM6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgc3RvcmFnZTogU3RvcmFnZVxuICAgIGVkaXRvcjogRWRpdG9yXG4gICAgdHlwZTogUE1UeXBlXG4gICAgcGFyZW50OiBQYXJlbnRDb25maWc8Q29uZmlnPlsnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJ11cbiAgfSkgPT4gUGx1Z2luW11cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGFkZGl0aW9uYWwgZXh0ZW5zaW9ucyB0byB0aGUgZWRpdG9yLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogYnVpbGRpbmcgZXh0ZW5zaW9uIGtpdHMuXG4gICAqIEBleGFtcGxlXG4gICAqIGFkZEV4dGVuc2lvbnMoKSB7XG4gICAqICAgcmV0dXJuIFtcbiAgICogICAgIEJ1bGxldExpc3QsXG4gICAqICAgICBPcmRlcmVkTGlzdCxcbiAgICogICAgIExpc3RJdGVtXG4gICAqICAgXVxuICAgKiB9XG4gICAqL1xuICBhZGRFeHRlbnNpb25zPzogKHRoaXM6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgc3RvcmFnZTogU3RvcmFnZVxuICAgIHBhcmVudDogUGFyZW50Q29uZmlnPENvbmZpZz5bJ2FkZEV4dGVuc2lvbnMnXVxuICB9KSA9PiBFeHRlbnNpb25zXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gZXh0ZW5kcyB0aGUgc2NoZW1hIG9mIHRoZSBub2RlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBleHRlbmROb2RlU2NoZW1hKCkge1xuICAgKiAgIHJldHVybiB7XG4gICAqICAgICBncm91cDogJ2lubGluZScsXG4gICAqICAgICBzZWxlY3RhYmxlOiBmYWxzZSxcbiAgICogICB9XG4gICAqIH1cbiAgICovXG4gIGV4dGVuZE5vZGVTY2hlbWE/OlxuICAgIHwgKChcbiAgICAgICAgdGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Q29uZmlnPlsnZXh0ZW5kTm9kZVNjaGVtYSddXG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuc2lvbjogTm9kZSxcbiAgICAgICkgPT4gUmVjb3JkPHN0cmluZywgYW55PilcbiAgICB8IG51bGxcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBleHRlbmRzIHRoZSBzY2hlbWEgb2YgdGhlIG1hcmsuXG4gICAqIEBleGFtcGxlXG4gICAqIGV4dGVuZE1hcmtTY2hlbWEoKSB7XG4gICAqICAgcmV0dXJuIHtcbiAgICogICAgIGdyb3VwOiAnaW5saW5lJyxcbiAgICogICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgKiAgIH1cbiAgICogfVxuICAgKi9cbiAgZXh0ZW5kTWFya1NjaGVtYT86XG4gICAgfCAoKFxuICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxDb25maWc+WydleHRlbmRNYXJrU2NoZW1hJ11cbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZW5zaW9uOiBNYXJrLFxuICAgICAgKSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIHwgbnVsbFxuXG4gIC8qKlxuICAgKiBUaGUgZWRpdG9yIGlzIG5vdCByZWFkeSB5ZXQuXG4gICAqL1xuICBvbkJlZm9yZUNyZWF0ZT86XG4gICAgfCAoKFxuICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IFBNVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPENvbmZpZz5bJ29uQmVmb3JlQ3JlYXRlJ11cbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnQ6IEVkaXRvckV2ZW50c1snYmVmb3JlQ3JlYXRlJ10sXG4gICAgICApID0+IHZvaWQpXG4gICAgfCBudWxsXG5cbiAgLyoqXG4gICAqIFRoZSBlZGl0b3IgaXMgcmVhZHkuXG4gICAqL1xuICBvbkNyZWF0ZT86XG4gICAgfCAoKFxuICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IFBNVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPENvbmZpZz5bJ29uQ3JlYXRlJ11cbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnQ6IEVkaXRvckV2ZW50c1snY3JlYXRlJ10sXG4gICAgICApID0+IHZvaWQpXG4gICAgfCBudWxsXG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZW50IGhhcyBjaGFuZ2VkLlxuICAgKi9cbiAgb25VcGRhdGU/OlxuICAgIHwgKChcbiAgICAgICAgdGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBQTVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxDb25maWc+WydvblVwZGF0ZSddXG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50OiBFZGl0b3JFdmVudHNbJ3VwZGF0ZSddLFxuICAgICAgKSA9PiB2b2lkKVxuICAgIHwgbnVsbFxuXG4gIC8qKlxuICAgKiBUaGUgc2VsZWN0aW9uIGhhcyBjaGFuZ2VkLlxuICAgKi9cbiAgb25TZWxlY3Rpb25VcGRhdGU/OlxuICAgIHwgKChcbiAgICAgICAgdGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBQTVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxDb25maWc+WydvblNlbGVjdGlvblVwZGF0ZSddXG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50OiBFZGl0b3JFdmVudHNbJ3NlbGVjdGlvblVwZGF0ZSddLFxuICAgICAgKSA9PiB2b2lkKVxuICAgIHwgbnVsbFxuXG4gIC8qKlxuICAgKiBUaGUgZWRpdG9yIHN0YXRlIGhhcyBjaGFuZ2VkLlxuICAgKi9cbiAgb25UcmFuc2FjdGlvbj86XG4gICAgfCAoKFxuICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICAgIHR5cGU6IFBNVHlwZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPENvbmZpZz5bJ29uVHJhbnNhY3Rpb24nXVxuICAgICAgICB9LFxuICAgICAgICBldmVudDogRWRpdG9yRXZlbnRzWyd0cmFuc2FjdGlvbiddLFxuICAgICAgKSA9PiB2b2lkKVxuICAgIHwgbnVsbFxuXG4gIC8qKlxuICAgKiBUaGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAqL1xuICBvbkZvY3VzPzpcbiAgICB8ICgoXG4gICAgICAgIHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogUE1UeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Q29uZmlnPlsnb25Gb2N1cyddXG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50OiBFZGl0b3JFdmVudHNbJ2ZvY3VzJ10sXG4gICAgICApID0+IHZvaWQpXG4gICAgfCBudWxsXG5cbiAgLyoqXG4gICAqIFRoZSBlZGl0b3IgaXNu4oCZdCBmb2N1c2VkIGFueW1vcmUuXG4gICAqL1xuICBvbkJsdXI/OlxuICAgIHwgKChcbiAgICAgICAgdGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgICB0eXBlOiBQTVR5cGVcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxDb25maWc+WydvbkJsdXInXVxuICAgICAgICB9LFxuICAgICAgICBldmVudDogRWRpdG9yRXZlbnRzWydibHVyJ10sXG4gICAgICApID0+IHZvaWQpXG4gICAgfCBudWxsXG5cbiAgLyoqXG4gICAqIFRoZSBlZGl0b3IgaXMgZGVzdHJveWVkLlxuICAgKi9cbiAgb25EZXN0cm95PzpcbiAgICB8ICgoXG4gICAgICAgIHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIGVkaXRvcjogRWRpdG9yXG4gICAgICAgICAgdHlwZTogUE1UeXBlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Q29uZmlnPlsnb25EZXN0cm95J11cbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnQ6IEVkaXRvckV2ZW50c1snZGVzdHJveSddLFxuICAgICAgKSA9PiB2b2lkKVxuICAgIHwgbnVsbFxufVxuXG5leHBvcnQgY2xhc3MgRXh0ZW5kYWJsZTxcbiAgT3B0aW9ucyA9IGFueSxcbiAgU3RvcmFnZSA9IGFueSxcbiAgQ29uZmlnID0gRXh0ZW5zaW9uQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+IHwgTm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPiB8IE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4sXG4+IHtcbiAgdHlwZSA9ICdleHRlbmRhYmxlJ1xuICBwYXJlbnQ6IEV4dGVuZGFibGUgfCBudWxsID0gbnVsbFxuXG4gIGNoaWxkOiBFeHRlbmRhYmxlIHwgbnVsbCA9IG51bGxcblxuICBuYW1lID0gJydcblxuICBjb25maWc6IENvbmZpZyA9IHtcbiAgICBuYW1lOiB0aGlzLm5hbWUsXG4gIH0gYXMgQ29uZmlnXG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBQYXJ0aWFsPENvbmZpZz4gPSB7fSkge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAuLi5jb25maWcsXG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gKHRoaXMuY29uZmlnIGFzIGFueSkubmFtZVxuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKTogT3B0aW9ucyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLihjYWxsT3JSZXR1cm4oXG4gICAgICAgIGdldEV4dGVuc2lvbkZpZWxkPEFueUNvbmZpZ1snYWRkT3B0aW9ucyddPih0aGlzIGFzIGFueSwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB9KSxcbiAgICAgICkgfHwge30pLFxuICAgIH1cbiAgfVxuXG4gIGdldCBzdG9yYWdlKCk6IFJlYWRvbmx5PFN0b3JhZ2U+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uKGNhbGxPclJldHVybihcbiAgICAgICAgZ2V0RXh0ZW5zaW9uRmllbGQ8QW55Q29uZmlnWydhZGRTdG9yYWdlJ10+KHRoaXMgYXMgYW55LCAnYWRkU3RvcmFnZScsIHtcbiAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICB9KSxcbiAgICAgICkgfHwge30pLFxuICAgIH1cbiAgfVxuXG4gIGNvbmZpZ3VyZShvcHRpb25zOiBQYXJ0aWFsPE9wdGlvbnM+ID0ge30pIHtcbiAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZDxPcHRpb25zLCBTdG9yYWdlLCBDb25maWc+KHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgYWRkT3B0aW9uczogKCkgPT4ge1xuICAgICAgICByZXR1cm4gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucyBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBvcHRpb25zKSBhcyBPcHRpb25zXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBleHRlbnNpb24ubmFtZSA9IHRoaXMubmFtZVxuICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzLnBhcmVudFxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG5cbiAgZXh0ZW5kPFxuICAgIEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsXG4gICAgRXh0ZW5kZWRTdG9yYWdlID0gU3RvcmFnZSxcbiAgICBFeHRlbmRlZENvbmZpZyA9XG4gICAgICB8IEV4dGVuc2lvbkNvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT5cbiAgICAgIHwgTm9kZUNvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT5cbiAgICAgIHwgTWFya0NvbmZpZzxFeHRlbmRlZE9wdGlvbnMsIEV4dGVuZGVkU3RvcmFnZT4sXG4gID4oZXh0ZW5kZWRDb25maWc6IFBhcnRpYWw8RXh0ZW5kZWRDb25maWc+ID0ge30pOiBFeHRlbmRhYmxlPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPiB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yIGFzIGFueSkoeyAuLi50aGlzLmNvbmZpZywgLi4uZXh0ZW5kZWRDb25maWcgfSlcblxuICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzXG4gICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvblxuICAgIGV4dGVuc2lvbi5uYW1lID0gJ25hbWUnIGluIGV4dGVuZGVkQ29uZmlnID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvblxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBET01PdXRwdXRTcGVjLCBNYXJrIGFzIFByb3NlTWlycm9yTWFyaywgTWFya1NwZWMsIE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHR5cGUgeyBFZGl0b3IgfSBmcm9tICcuL0VkaXRvci5qcydcbmltcG9ydCB0eXBlIHsgRXh0ZW5kYWJsZUNvbmZpZyB9IGZyb20gJy4vRXh0ZW5kYWJsZS5qcydcbmltcG9ydCB7IEV4dGVuZGFibGUgfSBmcm9tICcuL0V4dGVuZGFibGUuanMnXG5pbXBvcnQgdHlwZSB7IEF0dHJpYnV0ZXMsIE1hcmtWaWV3UmVuZGVyZXIsIFBhcmVudENvbmZpZyB9IGZyb20gJy4vdHlwZXMuanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFya0NvbmZpZzxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PlxuICBleHRlbmRzIEV4dGVuZGFibGVDb25maWc8T3B0aW9ucywgU3RvcmFnZSwgTWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPiwgTWFya1R5cGU+IHtcbiAgLyoqXG4gICAqIE1hcmsgVmlld1xuICAgKi9cbiAgYWRkTWFya1ZpZXc/OlxuICAgIHwgKCh0aGlzOiB7XG4gICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgdHlwZTogTWFya1R5cGVcbiAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZE1hcmtWaWV3J11cbiAgICAgIH0pID0+IE1hcmtWaWV3UmVuZGVyZXIpXG4gICAgfCBudWxsXG5cbiAgLyoqXG4gICAqIEtlZXAgbWFyayBhZnRlciBzcGxpdCBub2RlXG4gICAqL1xuICBrZWVwT25TcGxpdD86IGJvb2xlYW4gfCAoKCkgPT4gYm9vbGVhbilcblxuICAvKipcbiAgICogSW5jbHVzaXZlXG4gICAqL1xuICBpbmNsdXNpdmU/OlxuICAgIHwgTWFya1NwZWNbJ2luY2x1c2l2ZSddXG4gICAgfCAoKHRoaXM6IHtcbiAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnaW5jbHVzaXZlJ11cbiAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICB9KSA9PiBNYXJrU3BlY1snaW5jbHVzaXZlJ10pXG5cbiAgLyoqXG4gICAqIEV4Y2x1ZGVzXG4gICAqL1xuICBleGNsdWRlcz86XG4gICAgfCBNYXJrU3BlY1snZXhjbHVkZXMnXVxuICAgIHwgKCh0aGlzOiB7XG4gICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2V4Y2x1ZGVzJ11cbiAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICB9KSA9PiBNYXJrU3BlY1snZXhjbHVkZXMnXSlcblxuICAvKipcbiAgICogTWFya3MgdGhpcyBNYXJrIGFzIGV4aXRhYmxlXG4gICAqL1xuICBleGl0YWJsZT86IGJvb2xlYW4gfCAoKCkgPT4gYm9vbGVhbilcblxuICAvKipcbiAgICogR3JvdXBcbiAgICovXG4gIGdyb3VwPzpcbiAgICB8IE1hcmtTcGVjWydncm91cCddXG4gICAgfCAoKHRoaXM6IHtcbiAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnZ3JvdXAnXVxuICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgIH0pID0+IE1hcmtTcGVjWydncm91cCddKVxuXG4gIC8qKlxuICAgKiBTcGFubmluZ1xuICAgKi9cbiAgc3Bhbm5pbmc/OlxuICAgIHwgTWFya1NwZWNbJ3NwYW5uaW5nJ11cbiAgICB8ICgodGhpczoge1xuICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydzcGFubmluZyddXG4gICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgfSkgPT4gTWFya1NwZWNbJ3NwYW5uaW5nJ10pXG5cbiAgLyoqXG4gICAqIENvZGVcbiAgICovXG4gIGNvZGU/OlxuICAgIHwgYm9vbGVhblxuICAgIHwgKCh0aGlzOiB7XG4gICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2NvZGUnXVxuICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgIH0pID0+IGJvb2xlYW4pXG5cbiAgLyoqXG4gICAqIFBhcnNlIEhUTUxcbiAgICovXG4gIHBhcnNlSFRNTD86ICh0aGlzOiB7XG4gICAgbmFtZTogc3RyaW5nXG4gICAgb3B0aW9uczogT3B0aW9uc1xuICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxNYXJrQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncGFyc2VIVE1MJ11cbiAgICBlZGl0b3I/OiBFZGl0b3JcbiAgfSkgPT4gTWFya1NwZWNbJ3BhcnNlRE9NJ11cblxuICAvKipcbiAgICogUmVuZGVyIEhUTUxcbiAgICovXG4gIHJlbmRlckhUTUw/OlxuICAgIHwgKChcbiAgICAgICAgdGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3JlbmRlckhUTUwnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9LFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIG1hcms6IFByb3NlTWlycm9yTWFya1xuICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgICAgIH0sXG4gICAgICApID0+IERPTU91dHB1dFNwZWMpXG4gICAgfCBudWxsXG5cbiAgLyoqXG4gICAqIEF0dHJpYnV0ZXNcbiAgICovXG4gIGFkZEF0dHJpYnV0ZXM/OiAodGhpczoge1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgcGFyZW50OiBQYXJlbnRDb25maWc8TWFya0NvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2FkZEF0dHJpYnV0ZXMnXVxuICAgIGVkaXRvcj86IEVkaXRvclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktb2JqZWN0LXR5cGVcbiAgfSkgPT4gQXR0cmlidXRlcyB8IHt9XG59XG5cbi8qKlxuICogVGhlIE1hcmsgY2xhc3MgaXMgdXNlZCB0byBjcmVhdGUgY3VzdG9tIG1hcmsgZXh0ZW5zaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zI2NyZWF0ZS1hLW5ldy1leHRlbnNpb25cbiAqL1xuZXhwb3J0IGNsYXNzIE1hcms8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT4gZXh0ZW5kcyBFeHRlbmRhYmxlPE9wdGlvbnMsIFN0b3JhZ2UsIE1hcmtDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+IHtcbiAgdHlwZSA9ICdtYXJrJ1xuXG4gIHN0YXRpYyBjcmVhdGU8TyA9IGFueSwgUyA9IGFueT4oY29uZmlnOiBQYXJ0aWFsPE1hcmtDb25maWc8TywgUz4+ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IE1hcms8TywgUz4oY29uZmlnKVxuICB9XG5cbiAgc3RhdGljIGhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcmsgfTogeyBlZGl0b3I6IEVkaXRvcjsgbWFyazogTWFyayB9KSB7XG4gICAgY29uc3QgeyB0ciB9ID0gZWRpdG9yLnN0YXRlXG4gICAgY29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJGZyb21cbiAgICBjb25zdCBpc0F0RW5kID0gY3VycmVudFBvcy5wb3MgPT09IGN1cnJlbnRQb3MuZW5kKClcblxuICAgIGlmIChpc0F0RW5kKSB7XG4gICAgICBjb25zdCBjdXJyZW50TWFya3MgPSBjdXJyZW50UG9zLm1hcmtzKClcbiAgICAgIGNvbnN0IGlzSW5NYXJrID0gISFjdXJyZW50TWFya3MuZmluZChtID0+IG0/LnR5cGUubmFtZSA9PT0gbWFyay5uYW1lKVxuXG4gICAgICBpZiAoIWlzSW5NYXJrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW1vdmVNYXJrID0gY3VycmVudE1hcmtzLmZpbmQobSA9PiBtPy50eXBlLm5hbWUgPT09IG1hcmsubmFtZSlcblxuICAgICAgaWYgKHJlbW92ZU1hcmspIHtcbiAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhyZW1vdmVNYXJrKVxuICAgICAgfVxuICAgICAgdHIuaW5zZXJ0VGV4dCgnICcsIGN1cnJlbnRQb3MucG9zKVxuXG4gICAgICBlZGl0b3Iudmlldy5kaXNwYXRjaCh0cilcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbmZpZ3VyZShvcHRpb25zPzogUGFydGlhbDxPcHRpb25zPikge1xuICAgIHJldHVybiBzdXBlci5jb25maWd1cmUob3B0aW9ucykgYXMgTWFyazxPcHRpb25zLCBTdG9yYWdlPlxuICB9XG5cbiAgZXh0ZW5kPFxuICAgIEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsXG4gICAgRXh0ZW5kZWRTdG9yYWdlID0gU3RvcmFnZSxcbiAgICBFeHRlbmRlZENvbmZpZyA9IE1hcmtDb25maWc8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+LFxuICA+KGV4dGVuZGVkQ29uZmlnPzogUGFydGlhbDxFeHRlbmRlZENvbmZpZz4pIHtcbiAgICByZXR1cm4gc3VwZXIuZXh0ZW5kKGV4dGVuZGVkQ29uZmlnKSBhcyBNYXJrPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPlxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgdHlwZSB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IENvbW1hbmRNYW5hZ2VyIH0gZnJvbSAnLi9Db21tYW5kTWFuYWdlci5qcydcbmltcG9ydCB0eXBlIHsgRWRpdG9yIH0gZnJvbSAnLi9FZGl0b3IuanMnXG5pbXBvcnQgeyBjcmVhdGVDaGFpbmFibGVTdGF0ZSB9IGZyb20gJy4vaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS5qcydcbmltcG9ydCB7IGdldEhUTUxGcm9tRnJhZ21lbnQgfSBmcm9tICcuL2hlbHBlcnMvZ2V0SFRNTEZyb21GcmFnbWVudC5qcydcbmltcG9ydCB0eXBlIHsgQ2FuQ29tbWFuZHMsIENoYWluZWRDb21tYW5kcywgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LCBSYW5nZSwgU2luZ2xlQ29tbWFuZHMgfSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuL3V0aWxpdGllcy9pc051bWJlci5qcydcbmltcG9ydCB7IGlzUmVnRXhwIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNSZWdFeHAuanMnXG5cbmV4cG9ydCB0eXBlIFBhc3RlUnVsZU1hdGNoID0ge1xuICBpbmRleDogbnVtYmVyXG4gIHRleHQ6IHN0cmluZ1xuICByZXBsYWNlV2l0aD86IHN0cmluZ1xuICBtYXRjaD86IFJlZ0V4cE1hdGNoQXJyYXlcbiAgZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZXhwb3J0IHR5cGUgUGFzdGVSdWxlRmluZGVyID1cbiAgfCBSZWdFeHBcbiAgfCAoKHRleHQ6IHN0cmluZywgZXZlbnQ/OiBDbGlwYm9hcmRFdmVudCB8IG51bGwpID0+IFBhc3RlUnVsZU1hdGNoW10gfCBudWxsIHwgdW5kZWZpbmVkKVxuXG4vKipcbiAqIFBhc3RlIHJ1bGVzIGFyZSB1c2VkIHRvIHJlYWN0IHRvIHBhc3RlZCBjb250ZW50LlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjcGFzdGUtcnVsZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFBhc3RlUnVsZSB7XG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlclxuXG4gIGhhbmRsZXI6IChwcm9wczoge1xuICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgIHJhbmdlOiBSYW5nZVxuICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICBjb21tYW5kczogU2luZ2xlQ29tbWFuZHNcbiAgICBjaGFpbjogKCkgPT4gQ2hhaW5lZENvbW1hbmRzXG4gICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICAgIHBhc3RlRXZlbnQ6IENsaXBib2FyZEV2ZW50IHwgbnVsbFxuICAgIGRyb3BFdmVudDogRHJhZ0V2ZW50IHwgbnVsbFxuICB9KSA9PiB2b2lkIHwgbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzoge1xuICAgIGZpbmQ6IFBhc3RlUnVsZUZpbmRlclxuICAgIGhhbmRsZXI6IChwcm9wczoge1xuICAgICAgY2FuOiAoKSA9PiBDYW5Db21tYW5kc1xuICAgICAgY2hhaW46ICgpID0+IENoYWluZWRDb21tYW5kc1xuICAgICAgY29tbWFuZHM6IFNpbmdsZUNvbW1hbmRzXG4gICAgICBkcm9wRXZlbnQ6IERyYWdFdmVudCB8IG51bGxcbiAgICAgIG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlcbiAgICAgIHBhc3RlRXZlbnQ6IENsaXBib2FyZEV2ZW50IHwgbnVsbFxuICAgICAgcmFuZ2U6IFJhbmdlXG4gICAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICB9KSA9PiB2b2lkIHwgbnVsbFxuICB9KSB7XG4gICAgdGhpcy5maW5kID0gY29uZmlnLmZpbmRcbiAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlclxuICB9XG59XG5cbmNvbnN0IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyID0gKFxuICB0ZXh0OiBzdHJpbmcsXG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlcixcbiAgZXZlbnQ/OiBDbGlwYm9hcmRFdmVudCB8IG51bGwsXG4pOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXlbXSA9PiB7XG4gIGlmIChpc1JlZ0V4cChmaW5kKSkge1xuICAgIHJldHVybiBbLi4udGV4dC5tYXRjaEFsbChmaW5kKV1cbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXMgPSBmaW5kKHRleHQsIGV2ZW50KVxuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXMubWFwKHBhc3RlUnVsZU1hdGNoID0+IHtcbiAgICBjb25zdCByZXN1bHQ6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSA9IFtwYXN0ZVJ1bGVNYXRjaC50ZXh0XVxuXG4gICAgcmVzdWx0LmluZGV4ID0gcGFzdGVSdWxlTWF0Y2guaW5kZXhcbiAgICByZXN1bHQuaW5wdXQgPSB0ZXh0XG4gICAgcmVzdWx0LmRhdGEgPSBwYXN0ZVJ1bGVNYXRjaC5kYXRhXG5cbiAgICBpZiAocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpIHtcbiAgICAgIGlmICghcGFzdGVSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcInBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoXCIgbXVzdCBiZSBwYXJ0IG9mIFwicGFzdGVSdWxlTWF0Y2gudGV4dFwiLicpXG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfSlcbn1cblxuZnVuY3Rpb24gcnVuKGNvbmZpZzoge1xuICBlZGl0b3I6IEVkaXRvclxuICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgZnJvbTogbnVtYmVyXG4gIHRvOiBudW1iZXJcbiAgcnVsZTogUGFzdGVSdWxlXG4gIHBhc3RlRXZlbnQ6IENsaXBib2FyZEV2ZW50IHwgbnVsbFxuICBkcm9wRXZlbnQ6IERyYWdFdmVudCB8IG51bGxcbn0pOiBib29sZWFuIHtcbiAgY29uc3QgeyBlZGl0b3IsIHN0YXRlLCBmcm9tLCB0bywgcnVsZSwgcGFzdGVFdmVudCwgZHJvcEV2ZW50IH0gPSBjb25maWdcblxuICBjb25zdCB7IGNvbW1hbmRzLCBjaGFpbiwgY2FuIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgIGVkaXRvcixcbiAgICBzdGF0ZSxcbiAgfSlcblxuICBjb25zdCBoYW5kbGVyczogKHZvaWQgfCBudWxsKVtdID0gW11cblxuICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUudHlwZS5zcGVjLmNvZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcylcbiAgICBjb25zdCByZXNvbHZlZFRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUuY29udGVudC5zaXplKVxuICAgIGNvbnN0IHRleHRUb01hdGNoID0gbm9kZS50ZXh0QmV0d2VlbihyZXNvbHZlZEZyb20gLSBwb3MsIHJlc29sdmVkVG8gLSBwb3MsIHVuZGVmaW5lZCwgJ1xcdWZmZmMnKVxuXG4gICAgY29uc3QgbWF0Y2hlcyA9IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyKHRleHRUb01hdGNoLCBydWxlLmZpbmQsIHBhc3RlRXZlbnQpXG5cbiAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmVzb2x2ZWRGcm9tICsgbWF0Y2guaW5kZXggKyAxXG4gICAgICBjb25zdCBlbmQgPSBzdGFydCArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgIGZyb206IHN0YXRlLnRyLm1hcHBpbmcubWFwKHN0YXJ0KSxcbiAgICAgICAgdG86IHN0YXRlLnRyLm1hcHBpbmcubWFwKGVuZCksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgY2hhaW4sXG4gICAgICAgIGNhbixcbiAgICAgICAgcGFzdGVFdmVudCxcbiAgICAgICAgZHJvcEV2ZW50LFxuICAgICAgfSlcblxuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKVxuICAgIH0pXG4gIH0pXG5cbiAgY29uc3Qgc3VjY2VzcyA9IGhhbmRsZXJzLmV2ZXJ5KGhhbmRsZXIgPT4gaGFuZGxlciAhPT0gbnVsbClcblxuICByZXR1cm4gc3VjY2Vzc1xufVxuXG4vLyBXaGVuIGRyYWdnaW5nIGFjcm9zcyBlZGl0b3JzLCBtdXN0IGdldCBhbm90aGVyIGVkaXRvciBpbnN0YW5jZSB0byBkZWxldGUgc2VsZWN0aW9uIGNvbnRlbnQuXG5sZXQgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvcjogRWRpdG9yIHwgbnVsbCA9IG51bGxcblxuY29uc3QgY3JlYXRlQ2xpcGJvYXJkUGFzdGVFdmVudCA9ICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgZXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcbiAgfSlcblxuICBldmVudC5jbGlwYm9hcmREYXRhPy5zZXREYXRhKCd0ZXh0L2h0bWwnLCB0ZXh0KVxuXG4gIHJldHVybiBldmVudFxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBwYXN0ZSBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSBwYXN0ZWRcbiAqIHRleHQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhc3RlUnVsZXNQbHVnaW4ocHJvcHM6IHsgZWRpdG9yOiBFZGl0b3I7IHJ1bGVzOiBQYXN0ZVJ1bGVbXSB9KTogUGx1Z2luW10ge1xuICBjb25zdCB7IGVkaXRvciwgcnVsZXMgfSA9IHByb3BzXG4gIGxldCBkcmFnU291cmNlRWxlbWVudDogRWxlbWVudCB8IG51bGwgPSBudWxsXG4gIGxldCBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlXG4gIGxldCBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBmYWxzZVxuICBsZXQgcGFzdGVFdmVudCA9IHR5cGVvZiBDbGlwYm9hcmRFdmVudCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJykgOiBudWxsXG4gIGxldCBkcm9wRXZlbnQ6IERyYWdFdmVudCB8IG51bGxcblxuICB0cnkge1xuICAgIGRyb3BFdmVudCA9IHR5cGVvZiBEcmFnRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IERyYWdFdmVudCgnZHJvcCcpIDogbnVsbFxuICB9IGNhdGNoIHtcbiAgICBkcm9wRXZlbnQgPSBudWxsXG4gIH1cblxuICBjb25zdCBwcm9jZXNzRXZlbnQgPSAoe1xuICAgIHN0YXRlLFxuICAgIGZyb20sXG4gICAgdG8sXG4gICAgcnVsZSxcbiAgICBwYXN0ZUV2dCxcbiAgfToge1xuICAgIHN0YXRlOiBFZGl0b3JTdGF0ZVxuICAgIGZyb206IG51bWJlclxuICAgIHRvOiB7IGI6IG51bWJlciB9XG4gICAgcnVsZTogUGFzdGVSdWxlXG4gICAgcGFzdGVFdnQ6IENsaXBib2FyZEV2ZW50IHwgbnVsbFxuICB9KSA9PiB7XG4gICAgY29uc3QgdHIgPSBzdGF0ZS50clxuICAgIGNvbnN0IGNoYWluYWJsZVN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgc3RhdGUsXG4gICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgfSlcblxuICAgIGNvbnN0IGhhbmRsZXIgPSBydW4oe1xuICAgICAgZWRpdG9yLFxuICAgICAgc3RhdGU6IGNoYWluYWJsZVN0YXRlLFxuICAgICAgZnJvbTogTWF0aC5tYXgoZnJvbSAtIDEsIDApLFxuICAgICAgdG86IHRvLmIgLSAxLFxuICAgICAgcnVsZSxcbiAgICAgIHBhc3RlRXZlbnQ6IHBhc3RlRXZ0LFxuICAgICAgZHJvcEV2ZW50LFxuICAgIH0pXG5cbiAgICBpZiAoIWhhbmRsZXIgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGRyb3BFdmVudCA9IHR5cGVvZiBEcmFnRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IERyYWdFdmVudCgnZHJvcCcpIDogbnVsbFxuICAgIH0gY2F0Y2gge1xuICAgICAgZHJvcEV2ZW50ID0gbnVsbFxuICAgIH1cbiAgICBwYXN0ZUV2ZW50ID0gdHlwZW9mIENsaXBib2FyZEV2ZW50ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnKSA6IG51bGxcblxuICAgIHJldHVybiB0clxuICB9XG5cbiAgY29uc3QgcGx1Z2lucyA9IHJ1bGVzLm1hcChydWxlID0+IHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAvLyB3ZSByZWdpc3RlciBhIGdsb2JhbCBkcmFnIGhhbmRsZXIgdG8gdHJhY2sgdGhlIGN1cnJlbnQgZHJhZyBzb3VyY2UgZWxlbWVudFxuICAgICAgdmlldyh2aWV3KSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZURyYWdzdGFydCA9IChldmVudDogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgICAgZHJhZ1NvdXJjZUVsZW1lbnQgPSB2aWV3LmRvbS5wYXJlbnRFbGVtZW50Py5jb250YWlucyhldmVudC50YXJnZXQgYXMgRWxlbWVudCkgPyB2aWV3LmRvbS5wYXJlbnRFbGVtZW50IDogbnVsbFxuXG4gICAgICAgICAgaWYgKGRyYWdTb3VyY2VFbGVtZW50KSB7XG4gICAgICAgICAgICB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yID0gZWRpdG9yXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ2VuZCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvcikge1xuICAgICAgICAgICAgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIGhhbmRsZURyYWdlbmQpXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZXN0cm95KCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdzdGFydClcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgaGFuZGxlRHJhZ2VuZClcbiAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBwcm9wczoge1xuICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICBkcm9wOiAodmlldywgZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBkcmFnU291cmNlRWxlbWVudCA9PT0gdmlldy5kb20ucGFyZW50RWxlbWVudFxuICAgICAgICAgICAgZHJvcEV2ZW50ID0gZXZlbnQgYXMgRHJhZ0V2ZW50XG5cbiAgICAgICAgICAgIGlmICghaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRyYWdGcm9tT3RoZXJFZGl0b3IgPSB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yXG5cbiAgICAgICAgICAgICAgaWYgKGRyYWdGcm9tT3RoZXJFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAvLyBzZXRUaW1lb3V0IHRvIGF2b2lkIHRoZSB3cm9uZyBjb250ZW50IGFmdGVyIGRyb3AsIHRpbWVvdXQgYXJnIGNhbid0IGJlIGVtcHR5IG9yIDBcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRyYWdGcm9tT3RoZXJFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uXG5cbiAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0Zyb21PdGhlckVkaXRvci5jb21tYW5kcy5kZWxldGVSYW5nZSh7IGZyb206IHNlbGVjdGlvbi5mcm9tLCB0bzogc2VsZWN0aW9uLnRvIH0pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMTApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBwYXN0ZTogKF92aWV3LCBldmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAoZXZlbnQgYXMgQ2xpcGJvYXJkRXZlbnQpLmNsaXBib2FyZERhdGE/LmdldERhdGEoJ3RleHQvaHRtbCcpXG5cbiAgICAgICAgICAgIHBhc3RlRXZlbnQgPSBldmVudCBhcyBDbGlwYm9hcmRFdmVudFxuXG4gICAgICAgICAgICBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9ICEhaHRtbD8uaW5jbHVkZXMoJ2RhdGEtcG0tc2xpY2UnKVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcblxuICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1swXVxuICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAncGFzdGUnICYmICFpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvclxuICAgICAgICBjb25zdCBpc0Ryb3AgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCd1aUV2ZW50JykgPT09ICdkcm9wJyAmJiAhaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yXG5cbiAgICAgICAgLy8gaWYgUGFzdGVSdWxlIGlzIHRyaWdnZXJlZCBieSBpbnNlcnRDb250ZW50KClcbiAgICAgICAgY29uc3Qgc2ltdWxhdGVkUGFzdGVNZXRhID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnYXBwbHlQYXN0ZVJ1bGVzJykgYXNcbiAgICAgICAgICB8IHVuZGVmaW5lZFxuICAgICAgICAgIHwgeyBmcm9tOiBudW1iZXI7IHRleHQ6IHN0cmluZyB8IFByb3NlTWlycm9yTm9kZSB8IEZyYWdtZW50IH1cbiAgICAgICAgY29uc3QgaXNTaW11bGF0ZWRQYXN0ZSA9ICEhc2ltdWxhdGVkUGFzdGVNZXRhXG5cbiAgICAgICAgaWYgKCFpc1Bhc3RlICYmICFpc0Ryb3AgJiYgIWlzU2ltdWxhdGVkUGFzdGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBzaW11bGF0ZWQgcGFzdGVcbiAgICAgICAgaWYgKGlzU2ltdWxhdGVkUGFzdGUpIHtcbiAgICAgICAgICBsZXQgeyB0ZXh0IH0gPSBzaW11bGF0ZWRQYXN0ZU1ldGFcblxuICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0IGFzIHN0cmluZ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0gZ2V0SFRNTEZyb21GcmFnbWVudChGcmFnbWVudC5mcm9tKHRleHQpLCBzdGF0ZS5zY2hlbWEpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBmcm9tIH0gPSBzaW11bGF0ZWRQYXN0ZU1ldGFcbiAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyB0ZXh0Lmxlbmd0aFxuXG4gICAgICAgICAgY29uc3QgcGFzdGVFdnQgPSBjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50KHRleHQpXG5cbiAgICAgICAgICByZXR1cm4gcHJvY2Vzc0V2ZW50KHtcbiAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0bzogeyBiOiB0byB9LFxuICAgICAgICAgICAgcGFzdGVFdnQsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBhY3R1YWwgcGFzdGUvZHJvcFxuICAgICAgICBjb25zdCBmcm9tID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZTdGFydChzdGF0ZS5kb2MuY29udGVudClcbiAgICAgICAgY29uc3QgdG8gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZkVuZChzdGF0ZS5kb2MuY29udGVudClcblxuICAgICAgICAvLyBzdG9wIGlmIHRoZXJlIGlzIG5vIGNoYW5nZWQgcmFuZ2VcbiAgICAgICAgaWYgKCFpc051bWJlcihmcm9tKSB8fCAhdG8gfHwgZnJvbSA9PT0gdG8uYikge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2Nlc3NFdmVudCh7XG4gICAgICAgICAgcnVsZSxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHBhc3RlRXZ0OiBwYXN0ZUV2ZW50LFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiBwbHVnaW5zXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBudW1iZXIge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuIiwgImV4cG9ydCB7IENsaXBib2FyZFRleHRTZXJpYWxpemVyIH0gZnJvbSAnLi9jbGlwYm9hcmRUZXh0U2VyaWFsaXplci5qcydcbmV4cG9ydCB7IENvbW1hbmRzIH0gZnJvbSAnLi9jb21tYW5kcy5qcydcbmV4cG9ydCB7IERlbGV0ZSB9IGZyb20gJy4vZGVsZXRlLmpzJ1xuZXhwb3J0IHsgRHJvcCB9IGZyb20gJy4vZHJvcC5qcydcbmV4cG9ydCB7IEVkaXRhYmxlIH0gZnJvbSAnLi9lZGl0YWJsZS5qcydcbmV4cG9ydCB7IEZvY3VzRXZlbnRzLCBmb2N1c0V2ZW50c1BsdWdpbktleSB9IGZyb20gJy4vZm9jdXNFdmVudHMuanMnXG5leHBvcnQgeyBLZXltYXAgfSBmcm9tICcuL2tleW1hcC5qcydcbmV4cG9ydCB7IFBhc3RlIH0gZnJvbSAnLi9wYXN0ZS5qcydcbmV4cG9ydCB7IFRhYmluZGV4IH0gZnJvbSAnLi90YWJpbmRleC5qcydcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcbmltcG9ydCB7IGdldFRleHRCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRUZXh0QmV0d2Vlbi5qcydcbmltcG9ydCB7IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEgfSBmcm9tICcuLi9oZWxwZXJzL2dldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEuanMnXG5cbmV4cG9ydCB0eXBlIENsaXBib2FyZFRleHRTZXJpYWxpemVyT3B0aW9ucyA9IHtcbiAgYmxvY2tTZXBhcmF0b3I/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGNvbnN0IENsaXBib2FyZFRleHRTZXJpYWxpemVyID0gRXh0ZW5zaW9uLmNyZWF0ZTxDbGlwYm9hcmRUZXh0U2VyaWFsaXplck9wdGlvbnM+KHtcbiAgbmFtZTogJ2NsaXBib2FyZFRleHRTZXJpYWxpemVyJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9ja1NlcGFyYXRvcjogdW5kZWZpbmVkLFxuICAgIH1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NsaXBib2FyZFRleHRTZXJpYWxpemVyJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzXG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlLCBzY2hlbWEgfSA9IGVkaXRvclxuICAgICAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLm1pbiguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiRmcm9tLnBvcykpXG4gICAgICAgICAgICBjb25zdCB0byA9IE1hdGgubWF4KC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJHRvLnBvcykpXG4gICAgICAgICAgICBjb25zdCB0ZXh0U2VyaWFsaXplcnMgPSBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSlcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBmcm9tLCB0byB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZXRUZXh0QmV0d2Vlbihkb2MsIHJhbmdlLCB7XG4gICAgICAgICAgICAgIC4uLih0aGlzLm9wdGlvbnMuYmxvY2tTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IHsgYmxvY2tTZXBhcmF0b3I6IHRoaXMub3B0aW9ucy5ibG9ja1NlcGFyYXRvciB9IDoge30pLFxuICAgICAgICAgICAgICB0ZXh0U2VyaWFsaXplcnMsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IHR5cGUgRXh0ZW5kYWJsZUNvbmZpZywgRXh0ZW5kYWJsZSB9IGZyb20gJy4vRXh0ZW5kYWJsZS5qcydcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1vYmplY3QtdHlwZVxuZXhwb3J0IGludGVyZmFjZSBFeHRlbnNpb25Db25maWc8T3B0aW9ucyA9IGFueSwgU3RvcmFnZSA9IGFueT5cbiAgZXh0ZW5kcyBFeHRlbmRhYmxlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2UsIEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPiwgbnVsbD4ge31cblxuLyoqXG4gKiBUaGUgRXh0ZW5zaW9uIGNsYXNzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgZXh0ZW5zaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zI2NyZWF0ZS1hLW5ldy1leHRlbnNpb25cbiAqL1xuZXhwb3J0IGNsYXNzIEV4dGVuc2lvbjxPcHRpb25zID0gYW55LCBTdG9yYWdlID0gYW55PiBleHRlbmRzIEV4dGVuZGFibGU8XG4gIE9wdGlvbnMsXG4gIFN0b3JhZ2UsXG4gIEV4dGVuc2lvbkNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPlxuPiB7XG4gIHR5cGUgPSAnZXh0ZW5zaW9uJ1xuXG4gIHN0YXRpYyBjcmVhdGU8TyA9IGFueSwgUyA9IGFueT4oY29uZmlnOiBQYXJ0aWFsPEV4dGVuc2lvbkNvbmZpZzxPLCBTPj4gPSB7fSkge1xuICAgIHJldHVybiBuZXcgRXh0ZW5zaW9uPE8sIFM+KGNvbmZpZylcbiAgfVxuXG4gIGNvbmZpZ3VyZShvcHRpb25zPzogUGFydGlhbDxPcHRpb25zPikge1xuICAgIHJldHVybiBzdXBlci5jb25maWd1cmUob3B0aW9ucykgYXMgRXh0ZW5zaW9uPE9wdGlvbnMsIFN0b3JhZ2U+XG4gIH1cblxuICBleHRlbmQ8XG4gICAgRXh0ZW5kZWRPcHRpb25zID0gT3B0aW9ucyxcbiAgICBFeHRlbmRlZFN0b3JhZ2UgPSBTdG9yYWdlLFxuICAgIEV4dGVuZGVkQ29uZmlnID0gRXh0ZW5zaW9uQ29uZmlnPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPixcbiAgPihleHRlbmRlZENvbmZpZz86IFBhcnRpYWw8RXh0ZW5kZWRDb25maWc+KSB7XG4gICAgcmV0dXJuIHN1cGVyLmV4dGVuZChleHRlbmRlZENvbmZpZykgYXMgRXh0ZW5zaW9uPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPlxuICB9XG59XG4iLCAiZXhwb3J0ICogZnJvbSAnLi9ibHVyLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9jbGVhckNvbnRlbnQuanMnXG5leHBvcnQgKiBmcm9tICcuL2NsZWFyTm9kZXMuanMnXG5leHBvcnQgKiBmcm9tICcuL2NvbW1hbmQuanMnXG5leHBvcnQgKiBmcm9tICcuL2NyZWF0ZVBhcmFncmFwaE5lYXIuanMnXG5leHBvcnQgKiBmcm9tICcuL2N1dC5qcydcbmV4cG9ydCAqIGZyb20gJy4vZGVsZXRlQ3VycmVudE5vZGUuanMnXG5leHBvcnQgKiBmcm9tICcuL2RlbGV0ZU5vZGUuanMnXG5leHBvcnQgKiBmcm9tICcuL2RlbGV0ZVJhbmdlLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9kZWxldGVTZWxlY3Rpb24uanMnXG5leHBvcnQgKiBmcm9tICcuL2VudGVyLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9leGl0Q29kZS5qcydcbmV4cG9ydCAqIGZyb20gJy4vZXh0ZW5kTWFya1JhbmdlLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9maXJzdC5qcydcbmV4cG9ydCAqIGZyb20gJy4vZm9jdXMuanMnXG5leHBvcnQgKiBmcm9tICcuL2ZvckVhY2guanMnXG5leHBvcnQgKiBmcm9tICcuL2luc2VydENvbnRlbnQuanMnXG5leHBvcnQgKiBmcm9tICcuL2luc2VydENvbnRlbnRBdC5qcydcbmV4cG9ydCAqIGZyb20gJy4vam9pbi5qcydcbmV4cG9ydCAqIGZyb20gJy4vam9pbkl0ZW1CYWNrd2FyZC5qcydcbmV4cG9ydCAqIGZyb20gJy4vam9pbkl0ZW1Gb3J3YXJkLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9qb2luVGV4dGJsb2NrQmFja3dhcmQuanMnXG5leHBvcnQgKiBmcm9tICcuL2pvaW5UZXh0YmxvY2tGb3J3YXJkLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9rZXlib2FyZFNob3J0Y3V0LmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9saWZ0LmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9saWZ0RW1wdHlCbG9jay5qcydcbmV4cG9ydCAqIGZyb20gJy4vbGlmdExpc3RJdGVtLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9uZXdsaW5lSW5Db2RlLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9yZXNldEF0dHJpYnV0ZXMuanMnXG5leHBvcnQgKiBmcm9tICcuL3Njcm9sbEludG9WaWV3LmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9zZWxlY3RBbGwuanMnXG5leHBvcnQgKiBmcm9tICcuL3NlbGVjdE5vZGVCYWNrd2FyZC5qcydcbmV4cG9ydCAqIGZyb20gJy4vc2VsZWN0Tm9kZUZvcndhcmQuanMnXG5leHBvcnQgKiBmcm9tICcuL3NlbGVjdFBhcmVudE5vZGUuanMnXG5leHBvcnQgKiBmcm9tICcuL3NlbGVjdFRleHRibG9ja0VuZC5qcydcbmV4cG9ydCAqIGZyb20gJy4vc2VsZWN0VGV4dGJsb2NrU3RhcnQuanMnXG5leHBvcnQgKiBmcm9tICcuL3NldENvbnRlbnQuanMnXG5leHBvcnQgKiBmcm9tICcuL3NldE1hcmsuanMnXG5leHBvcnQgKiBmcm9tICcuL3NldE1ldGEuanMnXG5leHBvcnQgKiBmcm9tICcuL3NldE5vZGUuanMnXG5leHBvcnQgKiBmcm9tICcuL3NldE5vZGVTZWxlY3Rpb24uanMnXG5leHBvcnQgKiBmcm9tICcuL3NldFRleHRTZWxlY3Rpb24uanMnXG5leHBvcnQgKiBmcm9tICcuL3NpbmtMaXN0SXRlbS5qcydcbmV4cG9ydCAqIGZyb20gJy4vc3BsaXRCbG9jay5qcydcbmV4cG9ydCAqIGZyb20gJy4vc3BsaXRMaXN0SXRlbS5qcydcbmV4cG9ydCAqIGZyb20gJy4vdG9nZ2xlTGlzdC5qcydcbmV4cG9ydCAqIGZyb20gJy4vdG9nZ2xlTWFyay5qcydcbmV4cG9ydCAqIGZyb20gJy4vdG9nZ2xlTm9kZS5qcydcbmV4cG9ydCAqIGZyb20gJy4vdG9nZ2xlV3JhcC5qcydcbmV4cG9ydCAqIGZyb20gJy4vdW5kb0lucHV0UnVsZS5qcydcbmV4cG9ydCAqIGZyb20gJy4vdW5zZXRBbGxNYXJrcy5qcydcbmV4cG9ydCAqIGZyb20gJy4vdW5zZXRNYXJrLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi91cGRhdGVBdHRyaWJ1dGVzLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi93cmFwSW4uanMnXG5leHBvcnQgKiBmcm9tICcuL3dyYXBJbkxpc3QuanMnXG4iLCAiaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYmx1cjoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGZvY3VzIGZyb20gdGhlIGVkaXRvci5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5ibHVyKClcbiAgICAgICAqL1xuICAgICAgYmx1cjogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYmx1cjogUmF3Q29tbWFuZHNbJ2JsdXInXSA9XG4gICgpID0+XG4gICh7IGVkaXRvciwgdmlldyB9KSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIDsodmlldy5kb20gYXMgSFRNTEVsZW1lbnQpLmJsdXIoKVxuXG4gICAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCByZW1vdmUgdGhlIGNhcmV0IG9uIGJsdXIgYnV0IHNhZmFyaSBkb2VzIG5vdC5cbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI0MDVcbiAgICAgICAgd2luZG93Py5nZXRTZWxlY3Rpb24oKT8ucmVtb3ZlQWxsUmFuZ2VzKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuIiwgImltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNsZWFyQ29udGVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBDbGVhciB0aGUgd2hvbGUgZG9jdW1lbnQuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuY2xlYXJDb250ZW50KClcbiAgICAgICAqL1xuICAgICAgY2xlYXJDb250ZW50OiAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIGVtaXQgYW4gdXBkYXRlIGV2ZW50LlxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICBlbWl0VXBkYXRlPzogYm9vbGVhbixcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2xlYXJDb250ZW50OiBSYXdDb21tYW5kc1snY2xlYXJDb250ZW50J10gPVxuICAoZW1pdFVwZGF0ZSA9IHRydWUpID0+XG4gICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0Q29udGVudCgnJywgeyBlbWl0VXBkYXRlIH0pXG4gIH1cbiIsICJpbXBvcnQgeyBsaWZ0VGFyZ2V0IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNsZWFyTm9kZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogTm9ybWFsaXplIG5vZGVzIHRvIGEgc2ltcGxlIHBhcmFncmFwaC5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgICAqL1xuICAgICAgY2xlYXJOb2RlczogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2xlYXJOb2RlczogUmF3Q29tbWFuZHNbJ2NsZWFyTm9kZXMnXSA9XG4gICgpID0+XG4gICh7IHN0YXRlLCB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cblxuICAgIGlmICghZGlzcGF0Y2gpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZS50eXBlLmlzVGV4dCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBkb2MsIG1hcHBpbmcgfSA9IHRyXG4gICAgICAgIGNvbnN0ICRtYXBwZWRGcm9tID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zKSlcbiAgICAgICAgY29uc3QgJG1hcHBlZFRvID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSkpXG4gICAgICAgIGNvbnN0IG5vZGVSYW5nZSA9ICRtYXBwZWRGcm9tLmJsb2NrUmFuZ2UoJG1hcHBlZFRvKVxuXG4gICAgICAgIGlmICghbm9kZVJhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXRMaWZ0RGVwdGggPSBsaWZ0VGFyZ2V0KG5vZGVSYW5nZSlcblxuICAgICAgICBpZiAobm9kZS50eXBlLmlzVGV4dGJsb2NrKSB7XG4gICAgICAgICAgY29uc3QgeyBkZWZhdWx0VHlwZSB9ID0gJG1hcHBlZEZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRtYXBwZWRGcm9tLmluZGV4KCkpXG5cbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKG5vZGVSYW5nZS5zdGFydCwgZGVmYXVsdFR5cGUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0TGlmdERlcHRoIHx8IHRhcmdldExpZnREZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHRyLmxpZnQobm9kZVJhbmdlLCB0YXJnZXRMaWZ0RGVwdGgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiB0cnVlXG4gIH1cbiIsICJpbXBvcnQgdHlwZSB7IENvbW1hbmQsIFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjb21tYW5kOiB7XG4gICAgICAvKipcbiAgICAgICAqIERlZmluZSBhIGNvbW1hbmQgaW5saW5lLlxuICAgICAgICogQHBhcmFtIGZuIFRoZSBjb21tYW5kIGZ1bmN0aW9uLlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyLCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgKiAgIC4uLlxuICAgICAgICogICByZXR1cm4gdHJ1ZVxuICAgICAgICogfSlcbiAgICAgICAqL1xuICAgICAgY29tbWFuZDogKGZuOiAocHJvcHM6IFBhcmFtZXRlcnM8Q29tbWFuZD5bMF0pID0+IGJvb2xlYW4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNvbW1hbmQ6IFJhd0NvbW1hbmRzWydjb21tYW5kJ10gPSBmbiA9PiBwcm9wcyA9PiB7XG4gIHJldHVybiBmbihwcm9wcylcbn1cbiIsICJpbXBvcnQgeyBjcmVhdGVQYXJhZ3JhcGhOZWFyIGFzIG9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhciB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNyZWF0ZVBhcmFncmFwaE5lYXI6IHtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGEgcGFyYWdyYXBoIG5lYXJieS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKClcbiAgICAgICAqL1xuICAgICAgY3JlYXRlUGFyYWdyYXBoTmVhcjogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlUGFyYWdyYXBoTmVhcjogUmF3Q29tbWFuZHNbJ2NyZWF0ZVBhcmFncmFwaE5lYXInXSA9XG4gICgpID0+XG4gICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIG9yaWdpbmFsQ3JlYXRlUGFyYWdyYXBoTmVhcihzdGF0ZSwgZGlzcGF0Y2gpXG4gIH1cbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgY3V0OiB7XG4gICAgICAvKipcbiAgICAgICAqIEN1dHMgY29udGVudCBmcm9tIGEgcmFuZ2UgYW5kIGluc2VydHMgaXQgYXQgYSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdG8gY3V0LlxuICAgICAgICogQHBhcmFtIHJhbmdlLmZyb20gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByYW5nZS5cbiAgICAgICAqIEBwYXJhbSByYW5nZS50byBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByYW5nZS5cbiAgICAgICAqIEBwYXJhbSB0YXJnZXRQb3MgVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgY29udGVudCBhdC5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5jdXQoeyBmcm9tOiAxLCB0bzogMyB9LCA1KVxuICAgICAgICovXG4gICAgICBjdXQ6ICh7IGZyb20sIHRvIH06IHsgZnJvbTogbnVtYmVyOyB0bzogbnVtYmVyIH0sIHRhcmdldFBvczogbnVtYmVyKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBjdXQ6IFJhd0NvbW1hbmRzWydjdXQnXSA9XG4gIChvcmlnaW5SYW5nZSwgdGFyZ2V0UG9zKSA9PlxuICAoeyBlZGl0b3IsIHRyIH0pID0+IHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3JcblxuICAgIGNvbnN0IGNvbnRlbnRTbGljZSA9IHN0YXRlLmRvYy5zbGljZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50bylcblxuICAgIHRyLmRlbGV0ZVJhbmdlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKVxuICAgIGNvbnN0IG5ld1BvcyA9IHRyLm1hcHBpbmcubWFwKHRhcmdldFBvcylcblxuICAgIHRyLmluc2VydChuZXdQb3MsIGNvbnRlbnRTbGljZS5jb250ZW50KVxuXG4gICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBUZXh0U2VsZWN0aW9uKHRyLmRvYy5yZXNvbHZlKG5ld1BvcyAtIDEpKSlcblxuICAgIHJldHVybiB0cnVlXG4gIH1cbiIsICJpbXBvcnQgdHlwZSB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBkZWxldGVDdXJyZW50Tm9kZToge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgdGhlIG5vZGUgdGhhdCBjdXJyZW50bHkgaGFzIHRoZSBzZWxlY3Rpb24gYW5jaG9yLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZUN1cnJlbnROb2RlKClcbiAgICAgICAqL1xuICAgICAgZGVsZXRlQ3VycmVudE5vZGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZUN1cnJlbnROb2RlOiBSYXdDb21tYW5kc1snZGVsZXRlQ3VycmVudE5vZGUnXSA9XG4gICgpID0+XG4gICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gICAgY29uc3QgY3VycmVudE5vZGUgPSBzZWxlY3Rpb24uJGFuY2hvci5ub2RlKClcblxuICAgIC8vIGlmIHRoZXJlIGlzIGNvbnRlbnQgaW5zaWRlIHRoZSBjdXJyZW50IG5vZGUsIGJyZWFrIG91dCBvZiB0aGlzIGNvbW1hbmRcbiAgICBpZiAoY3VycmVudE5vZGUuY29udGVudC5zaXplID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yXG5cbiAgICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShkZXB0aClcblxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gY3VycmVudE5vZGUudHlwZSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpXG4gICAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKVxuXG4gICAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGRlbGV0ZU5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIGEgbm9kZSB3aXRoIGEgZ2l2ZW4gdHlwZSBvciBuYW1lLlxuICAgICAgICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbm9kZS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5kZWxldGVOb2RlKCdwYXJhZ3JhcGgnKVxuICAgICAgICovXG4gICAgICBkZWxldGVOb2RlOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlbGV0ZU5vZGU6IFJhd0NvbW1hbmRzWydkZWxldGVOb2RlJ10gPVxuICB0eXBlT3JOYW1lID0+XG4gICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gICAgY29uc3QgJHBvcyA9IHRyLnNlbGVjdGlvbi4kYW5jaG9yXG5cbiAgICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShkZXB0aClcblxuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gJHBvcy5iZWZvcmUoZGVwdGgpXG4gICAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKVxuXG4gICAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKS5zY3JvbGxJbnRvVmlldygpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4iLCAiaW1wb3J0IHR5cGUgeyBSYW5nZSwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGRlbGV0ZVJhbmdlOiB7XG4gICAgICAvKipcbiAgICAgICAqIERlbGV0ZSBhIGdpdmVuIHJhbmdlLlxuICAgICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSB0byBkZWxldGUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UoeyBmcm9tOiAxLCB0bzogMyB9KVxuICAgICAgICovXG4gICAgICBkZWxldGVSYW5nZTogKHJhbmdlOiBSYW5nZSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlUmFuZ2U6IFJhd0NvbW1hbmRzWydkZWxldGVSYW5nZSddID1cbiAgcmFuZ2UgPT5cbiAgKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICB0ci5kZWxldGUoZnJvbSwgdG8pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuIiwgImltcG9ydCB7IGRlbGV0ZVNlbGVjdGlvbiBhcyBvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGRlbGV0ZVNlbGVjdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgdGhlIHNlbGVjdGlvbiwgaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpXG4gICAgICAgKi9cbiAgICAgIGRlbGV0ZVNlbGVjdGlvbjogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVsZXRlU2VsZWN0aW9uOiBSYXdDb21tYW5kc1snZGVsZXRlU2VsZWN0aW9uJ10gPVxuICAoKSA9PlxuICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBvcmlnaW5hbERlbGV0ZVNlbGVjdGlvbihzdGF0ZSwgZGlzcGF0Y2gpXG4gIH1cbiIsICJpbXBvcnQgdHlwZSB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBlbnRlcjoge1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyIGVudGVyLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmVudGVyKClcbiAgICAgICAqL1xuICAgICAgZW50ZXI6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGVudGVyOiBSYXdDb21tYW5kc1snZW50ZXInXSA9XG4gICgpID0+XG4gICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICByZXR1cm4gY29tbWFuZHMua2V5Ym9hcmRTaG9ydGN1dCgnRW50ZXInKVxuICB9XG4iLCAiaW1wb3J0IHsgZXhpdENvZGUgYXMgb3JpZ2luYWxFeGl0Q29kZSB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGV4aXRDb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEV4aXQgZnJvbSBhIGNvZGUgYmxvY2suXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuZXhpdENvZGUoKVxuICAgICAgICovXG4gICAgICBleGl0Q29kZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZXhpdENvZGU6IFJhd0NvbW1hbmRzWydleGl0Q29kZSddID1cbiAgKCkgPT5cbiAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gb3JpZ2luYWxFeGl0Q29kZShzdGF0ZSwgZGlzcGF0Y2gpXG4gIH1cbiIsICJpbXBvcnQgdHlwZSB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrUmFuZ2UgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtSYW5nZS5qcydcbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrVHlwZS5qcydcbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGV4dGVuZE1hcmtSYW5nZToge1xuICAgICAgLyoqXG4gICAgICAgKiBFeHRlbmRzIHRoZSB0ZXh0IHNlbGVjdGlvbiB0byB0aGUgY3VycmVudCBtYXJrIGJ5IHR5cGUgb3IgbmFtZS5cbiAgICAgICAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSB0eXBlIG9yIG5hbWUgb2YgdGhlIG1hcmsuXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgbWFyay5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5leHRlbmRNYXJrUmFuZ2UoJ2JvbGQnKVxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmV4dGVuZE1hcmtSYW5nZSgnbWVudGlvbicsIHsgdXNlcklkOiBcIjFcIiB9KVxuICAgICAgICovXG4gICAgICBleHRlbmRNYXJrUmFuZ2U6IChcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9yIG5hbWUgb2YgdGhlIG1hcmsuXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1hcmsuXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICAgICkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZXh0ZW5kTWFya1JhbmdlOiBSYXdDb21tYW5kc1snZXh0ZW5kTWFya1JhbmdlJ10gPVxuICAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PlxuICAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHRyXG4gICAgY29uc3QgeyAkZnJvbSwgZnJvbSwgdG8gfSA9IHNlbGVjdGlvblxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cmlidXRlcylcblxuICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLmZyb20gPD0gZnJvbSAmJiByYW5nZS50byA+PSB0bykge1xuICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuXG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuIiwgImltcG9ydCB0eXBlIHsgQ29tbWFuZCwgQ29tbWFuZFByb3BzLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZmlyc3Q6IHtcbiAgICAgIC8qKlxuICAgICAgICogUnVucyBvbmUgY29tbWFuZCBhZnRlciB0aGUgb3RoZXIgYW5kIHN0b3BzIGF0IHRoZSBmaXJzdCB3aGljaCByZXR1cm5zIHRydWUuXG4gICAgICAgKiBAcGFyYW0gY29tbWFuZHMgVGhlIGNvbW1hbmRzIHRvIHJ1bi5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5maXJzdChbY29tbWFuZDEsIGNvbW1hbmQyXSlcbiAgICAgICAqL1xuICAgICAgZmlyc3Q6IChjb21tYW5kczogQ29tbWFuZFtdIHwgKChwcm9wczogQ29tbWFuZFByb3BzKSA9PiBDb21tYW5kW10pKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmaXJzdDogUmF3Q29tbWFuZHNbJ2ZpcnN0J10gPSBjb21tYW5kcyA9PiBwcm9wcyA9PiB7XG4gIGNvbnN0IGl0ZW1zID0gdHlwZW9mIGNvbW1hbmRzID09PSAnZnVuY3Rpb24nID8gY29tbWFuZHMocHJvcHMpIDogY29tbWFuZHNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGl0ZW1zW2ldKHByb3BzKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gaXNBbmRyb2lkKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtID09PSAnQW5kcm9pZCcgfHwgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzaU9TKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIFsnaVBhZCBTaW11bGF0b3InLCAnaVBob25lIFNpbXVsYXRvcicsICdpUG9kIFNpbXVsYXRvcicsICdpUGFkJywgJ2lQaG9uZScsICdpUG9kJ10uaW5jbHVkZXMobmF2aWdhdG9yLnBsYXRmb3JtKSB8fFxuICAgIC8vIGlQYWQgb24gaU9TIDEzIGRldGVjdGlvblxuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdNYWMnKSAmJiAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQpXG4gIClcbn1cbiIsICJpbXBvcnQgeyBpc1RleHRTZWxlY3Rpb24gfSBmcm9tICcuLi9oZWxwZXJzL2lzVGV4dFNlbGVjdGlvbi5qcydcbmltcG9ydCB7IHJlc29sdmVGb2N1c1Bvc2l0aW9uIH0gZnJvbSAnLi4vaGVscGVycy9yZXNvbHZlRm9jdXNQb3NpdGlvbi5qcydcbmltcG9ydCB0eXBlIHsgRm9jdXNQb3NpdGlvbiwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGlzQW5kcm9pZCB9IGZyb20gJy4uL3V0aWxpdGllcy9pc0FuZHJvaWQuanMnXG5pbXBvcnQgeyBpc2lPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc2lPUy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGZvY3VzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEZvY3VzIHRoZSBlZGl0b3IgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBmb2N1cyBhdC5cbiAgICAgICAqIEBwYXJhbSBvcHRpb25zLnNjcm9sbEludG9WaWV3IFNjcm9sbCB0aGUgZm9jdXNlZCBwb3NpdGlvbiBpbnRvIHZpZXcgYWZ0ZXIgZm9jdXNpbmdcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5mb2N1cygpXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuZm9jdXMoMzIsIHsgc2Nyb2xsSW50b1ZpZXc6IGZhbHNlIH0pXG4gICAgICAgKi9cbiAgICAgIGZvY3VzOiAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcG9zaXRpb24gdG8gZm9jdXMgYXQuXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvbj86IEZvY3VzUG9zaXRpb24sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIG9wdGlvbnNcbiAgICAgICAgICogQGRlZmF1bHQgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9XG4gICAgICAgICAqL1xuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIHNjcm9sbEludG9WaWV3PzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmb2N1czogUmF3Q29tbWFuZHNbJ2ZvY3VzJ10gPVxuICAocG9zaXRpb24gPSBudWxsLCBvcHRpb25zID0ge30pID0+XG4gICh7IGVkaXRvciwgdmlldywgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH1cblxuICAgIGNvbnN0IGRlbGF5ZWRGb2N1cyA9ICgpID0+IHtcbiAgICAgIC8vIGZvY3VzIHdpdGhpbiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBicmVha3MgZm9jdXMgb24gaU9TIGFuZCBBbmRyb2lkXG4gICAgICAvLyBzbyB3ZSBoYXZlIHRvIGNhbGwgdGhpc1xuICAgICAgaWYgKGlzaU9TKCkgfHwgaXNBbmRyb2lkKCkpIHtcbiAgICAgICAgOyh2aWV3LmRvbSBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKVxuICAgICAgfVxuXG4gICAgICAvLyBGb3IgUmVhY3Qgd2UgaGF2ZSB0byBmb2N1cyBhc3luY2hyb25vdXNseS4gT3RoZXJ3aXNlIHdpbGQgdGhpbmdzIGhhcHBlbi5cbiAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xNTIwXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHZpZXcuZm9jdXMoKVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnM/LnNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICBlZGl0b3IuY29tbWFuZHMuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoKHZpZXcuaGFzRm9jdXMoKSAmJiBwb3NpdGlvbiA9PT0gbnVsbCkgfHwgcG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIHdlIGRvbuKAmXQgdHJ5IHRvIHJlc29sdmUgYSBOb2RlU2VsZWN0aW9uIG9yIENlbGxTZWxlY3Rpb25cbiAgICBpZiAoZGlzcGF0Y2ggJiYgcG9zaXRpb24gPT09IG51bGwgJiYgIWlzVGV4dFNlbGVjdGlvbihlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgZGVsYXllZEZvY3VzKClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gcGFzcyB0aHJvdWdoIHRyLmRvYyBpbnN0ZWFkIG9mIGVkaXRvci5zdGF0ZS5kb2NcbiAgICAvLyBzaW5jZSB0cmFuc2FjdGlvbnMgY291bGQgY2hhbmdlIHRoZSBlZGl0b3JzIHN0YXRlIGJlZm9yZSB0aGlzIGNvbW1hbmQgaGFzIGJlZW4gcnVuXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24odHIuZG9jLCBwb3NpdGlvbikgfHwgZWRpdG9yLnN0YXRlLnNlbGVjdGlvblxuICAgIGNvbnN0IGlzU2FtZVNlbGVjdGlvbiA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoIWlzU2FtZVNlbGVjdGlvbikge1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICAgICAgfVxuXG4gICAgICAvLyBgdHIuc2V0U2VsZWN0aW9uYCByZXNldHMgdGhlIHN0b3JlZCBtYXJrc1xuICAgICAgLy8gc28gd2XigJlsbCByZXN0b3JlIHRoZW0gaWYgdGhlIHNlbGVjdGlvbiBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcbiAgICAgIGlmIChpc1NhbWVTZWxlY3Rpb24gJiYgdHIuc3RvcmVkTWFya3MpIHtcbiAgICAgICAgdHIuc2V0U3RvcmVkTWFya3ModHIuc3RvcmVkTWFya3MpXG4gICAgICB9XG5cbiAgICAgIGRlbGF5ZWRGb2N1cygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuIiwgImltcG9ydCB0eXBlIHsgQ29tbWFuZFByb3BzLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgZm9yRWFjaDoge1xuICAgICAgLyoqXG4gICAgICAgKiBMb29wIHRocm91Z2ggYW4gYXJyYXkgb2YgaXRlbXMuXG4gICAgICAgKi9cbiAgICAgIGZvckVhY2g6IDxUPihcbiAgICAgICAgaXRlbXM6IFRbXSxcbiAgICAgICAgZm46IChcbiAgICAgICAgICBpdGVtOiBULFxuICAgICAgICAgIHByb3BzOiBDb21tYW5kUHJvcHMgJiB7XG4gICAgICAgICAgICBpbmRleDogbnVtYmVyXG4gICAgICAgICAgfSxcbiAgICAgICAgKSA9PiBib29sZWFuLFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmb3JFYWNoOiBSYXdDb21tYW5kc1snZm9yRWFjaCddID0gKGl0ZW1zLCBmbikgPT4gcHJvcHMgPT4ge1xuICByZXR1cm4gaXRlbXMuZXZlcnkoKGl0ZW0sIGluZGV4KSA9PiBmbihpdGVtLCB7IC4uLnByb3BzLCBpbmRleCB9KSlcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEZyYWdtZW50LCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHR5cGUgeyBDb250ZW50LCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaW5zZXJ0Q29udGVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBJbnNlcnQgYSBub2RlIG9yIHN0cmluZyBvZiBIVE1MIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmluc2VydENvbnRlbnQoJzxoMT5FeGFtcGxlPC9oMT4nKVxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmluc2VydENvbnRlbnQoJzxoMT5FeGFtcGxlPC9oMT4nLCB7IHVwZGF0ZVNlbGVjdGlvbjogZmFsc2UgfSlcbiAgICAgICAqL1xuICAgICAgaW5zZXJ0Q29udGVudDogKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFByb3NlTWlycm9yIGNvbnRlbnQgdG8gaW5zZXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IENvbnRlbnQgfCBQcm9zZU1pcnJvck5vZGUgfCBGcmFnbWVudCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9uYWwgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgb3B0aW9ucz86IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBPcHRpb25zIGZvciBwYXJzaW5nIHRoZSBjb250ZW50LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHBhcnNlT3B0aW9ucz86IFBhcnNlT3B0aW9uc1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2hldGhlciB0byB1cGRhdGUgdGhlIHNlbGVjdGlvbiBhZnRlciBpbnNlcnRpbmcgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdXBkYXRlU2VsZWN0aW9uPzogYm9vbGVhblxuICAgICAgICAgIGFwcGx5SW5wdXRSdWxlcz86IGJvb2xlYW5cbiAgICAgICAgICBhcHBseVBhc3RlUnVsZXM/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGluc2VydENvbnRlbnQ6IFJhd0NvbW1hbmRzWydpbnNlcnRDb250ZW50J10gPVxuICAodmFsdWUsIG9wdGlvbnMpID0+XG4gICh7IHRyLCBjb21tYW5kcyB9KSA9PiB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnRBdCh7IGZyb206IHRyLnNlbGVjdGlvbi5mcm9tLCB0bzogdHIuc2VsZWN0aW9uLnRvIH0sIHZhbHVlLCBvcHRpb25zKVxuICB9XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgY3JlYXRlTm9kZUZyb21Db250ZW50IH0gZnJvbSAnLi4vaGVscGVycy9jcmVhdGVOb2RlRnJvbUNvbnRlbnQuanMnXG5pbXBvcnQgeyBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCB9IGZyb20gJy4uL2hlbHBlcnMvc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQuanMnXG5pbXBvcnQgdHlwZSB7IENvbnRlbnQsIFJhbmdlLCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaW5zZXJ0Q29udGVudEF0OiB7XG4gICAgICAvKipcbiAgICAgICAqIEluc2VydCBhIG5vZGUgb3Igc3RyaW5nIG9mIEhUTUwgYXQgYSBzcGVjaWZpYyBwb3NpdGlvbi5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5pbnNlcnRDb250ZW50QXQoMCwgJzxoMT5FeGFtcGxlPC9oMT4nKVxuICAgICAgICovXG4gICAgICBpbnNlcnRDb250ZW50QXQ6IChcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIGNvbnRlbnQgYXQuXG4gICAgICAgICAqL1xuICAgICAgICBwb3NpdGlvbjogbnVtYmVyIHwgUmFuZ2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBQcm9zZU1pcnJvciBjb250ZW50IHRvIGluc2VydC5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBDb250ZW50IHwgUHJvc2VNaXJyb3JOb2RlIHwgRnJhZ21lbnQsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbmFsIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogT3B0aW9ucyBmb3IgcGFyc2luZyB0aGUgY29udGVudC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZXRoZXIgdG8gdXBkYXRlIHRoZSBzZWxlY3Rpb24gYWZ0ZXIgaW5zZXJ0aW5nIHRoZSBjb250ZW50LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbj86IGJvb2xlYW5cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZXRoZXIgdG8gYXBwbHkgaW5wdXQgcnVsZXMgYWZ0ZXIgaW5zZXJ0aW5nIHRoZSBjb250ZW50LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGFwcGx5SW5wdXRSdWxlcz86IGJvb2xlYW5cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZXRoZXIgdG8gYXBwbHkgcGFzdGUgcnVsZXMgYWZ0ZXIgaW5zZXJ0aW5nIHRoZSBjb250ZW50LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGFwcGx5UGFzdGVSdWxlcz86IGJvb2xlYW5cblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZXRoZXIgdG8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGNvbnRlbnQgaXMgaW52YWxpZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNGcmFnbWVudCA9IChub2RlT3JGcmFnbWVudDogUHJvc2VNaXJyb3JOb2RlIHwgRnJhZ21lbnQpOiBub2RlT3JGcmFnbWVudCBpcyBGcmFnbWVudCA9PiB7XG4gIHJldHVybiAhKCd0eXBlJyBpbiBub2RlT3JGcmFnbWVudClcbn1cblxuZXhwb3J0IGNvbnN0IGluc2VydENvbnRlbnRBdDogUmF3Q29tbWFuZHNbJ2luc2VydENvbnRlbnRBdCddID1cbiAgKHBvc2l0aW9uLCB2YWx1ZSwgb3B0aW9ucykgPT5cbiAgKHsgdHIsIGRpc3BhdGNoLCBlZGl0b3IgfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcGFyc2VPcHRpb25zOiBlZGl0b3Iub3B0aW9ucy5wYXJzZU9wdGlvbnMsXG4gICAgICAgIHVwZGF0ZVNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgYXBwbHlJbnB1dFJ1bGVzOiBmYWxzZSxcbiAgICAgICAgYXBwbHlQYXN0ZVJ1bGVzOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIH1cblxuICAgICAgbGV0IGNvbnRlbnQ6IEZyYWdtZW50IHwgUHJvc2VNaXJyb3JOb2RlXG4gICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gZWRpdG9yLnN0YXRlXG5cbiAgICAgIGNvbnN0IGVtaXRDb250ZW50RXJyb3IgPSAoZXJyb3I6IEVycm9yKSA9PiB7XG4gICAgICAgIGVkaXRvci5lbWl0KCdjb250ZW50RXJyb3InLCB7XG4gICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGRpc2FibGVDb2xsYWJvcmF0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICdjb2xsYWJvcmF0aW9uJyBpbiBlZGl0b3Iuc3RvcmFnZSAmJlxuICAgICAgICAgICAgICB0eXBlb2YgZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIDsoZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbiBhcyBhbnkpLmlzRGlzYWJsZWQgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyc2VPcHRpb25zOiBQYXJzZU9wdGlvbnMgPSB7XG4gICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLFxuICAgICAgICAuLi5vcHRpb25zLnBhcnNlT3B0aW9ucyxcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYGVtaXRDb250ZW50RXJyb3JgIGlzIGVuYWJsZWQsIHdlIHdhbnQgdG8gY2hlY2sgdGhlIGNvbnRlbnQgZm9yIGVycm9yc1xuICAgICAgLy8gYnV0IGlnbm9yZSB0aGVtIChkbyBub3QgcmVtb3ZlIHRoZSBpbnZhbGlkIGNvbnRlbnQgZnJvbSB0aGUgZG9jdW1lbnQpXG4gICAgICBpZiAoIW9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50ICYmICFlZGl0b3Iub3B0aW9ucy5lbmFibGVDb250ZW50Q2hlY2sgJiYgZWRpdG9yLm9wdGlvbnMuZW1pdENvbnRlbnRFcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNyZWF0ZU5vZGVGcm9tQ29udGVudCh2YWx1ZSwgZWRpdG9yLnNjaGVtYSwge1xuICAgICAgICAgICAgcGFyc2VPcHRpb25zLFxuICAgICAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiB0cnVlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlbWl0Q29udGVudEVycm9yKGUgYXMgRXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGVudCA9IGNyZWF0ZU5vZGVGcm9tQ29udGVudCh2YWx1ZSwgZWRpdG9yLnNjaGVtYSwge1xuICAgICAgICAgIHBhcnNlT3B0aW9ucyxcbiAgICAgICAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50ID8/IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayxcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZW1pdENvbnRlbnRFcnJvcihlIGFzIEVycm9yKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9XG4gICAgICAgIHR5cGVvZiBwb3NpdGlvbiA9PT0gJ251bWJlcicgPyB7IGZyb206IHBvc2l0aW9uLCB0bzogcG9zaXRpb24gfSA6IHsgZnJvbTogcG9zaXRpb24uZnJvbSwgdG86IHBvc2l0aW9uLnRvIH1cblxuICAgICAgbGV0IGlzT25seVRleHRDb250ZW50ID0gdHJ1ZVxuICAgICAgbGV0IGlzT25seUJsb2NrQ29udGVudCA9IHRydWVcbiAgICAgIGNvbnN0IG5vZGVzID0gaXNGcmFnbWVudChjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF1cblxuICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgLy8gY2hlY2sgaWYgYWRkZWQgbm9kZSBpcyB2YWxpZFxuICAgICAgICBub2RlLmNoZWNrKClcblxuICAgICAgICBpc09ubHlUZXh0Q29udGVudCA9IGlzT25seVRleHRDb250ZW50ID8gbm9kZS5pc1RleHQgJiYgbm9kZS5tYXJrcy5sZW5ndGggPT09IDAgOiBmYWxzZVxuXG4gICAgICAgIGlzT25seUJsb2NrQ29udGVudCA9IGlzT25seUJsb2NrQ29udGVudCA/IG5vZGUuaXNCbG9jayA6IGZhbHNlXG4gICAgICB9KVxuXG4gICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVwbGFjZSB0aGUgd3JhcHBpbmcgbm9kZSBieVxuICAgICAgLy8gdGhlIG5ld2x5IGluc2VydGVkIGNvbnRlbnRcbiAgICAgIC8vIGV4YW1wbGU6XG4gICAgICAvLyByZXBsYWNlIGFuIGVtcHR5IHBhcmFncmFwaCBieSBhbiBpbnNlcnRlZCBpbWFnZVxuICAgICAgLy8gaW5zdGVhZCBvZiBpbnNlcnRpbmcgdGhlIGltYWdlIGJlbG93IHRoZSBwYXJhZ3JhcGhcbiAgICAgIGlmIChmcm9tID09PSB0byAmJiBpc09ubHlCbG9ja0NvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgeyBwYXJlbnQgfSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pXG4gICAgICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSBwYXJlbnQuaXNUZXh0YmxvY2sgJiYgIXBhcmVudC50eXBlLnNwZWMuY29kZSAmJiAhcGFyZW50LmNoaWxkQ291bnRcblxuICAgICAgICBpZiAoaXNFbXB0eVRleHRCbG9jaykge1xuICAgICAgICAgIGZyb20gLT0gMVxuICAgICAgICAgIHRvICs9IDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgbmV3Q29udGVudFxuXG4gICAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IHBsYWluIHRleHQgd2UgaGF2ZSB0byB1c2UgYGluc2VydFRleHRgXG4gICAgICAvLyBiZWNhdXNlIHRoaXMgd2lsbCBrZWVwIHRoZSBjdXJyZW50IG1hcmtzXG4gICAgICBpZiAoaXNPbmx5VGV4dENvbnRlbnQpIHtcbiAgICAgICAgLy8gaWYgdmFsdWUgaXMgc3RyaW5nLCB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIC8vIG90aGVyd2lzZSBpZiBpdCBpcyBhbiBhcnJheSwgd2UgaGF2ZSB0byBqb2luIGl0XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZS5tYXAodiA9PiB2LnRleHQgfHwgJycpLmpvaW4oJycpXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBGcmFnbWVudCkge1xuICAgICAgICAgIGxldCB0ZXh0ID0gJydcblxuICAgICAgICAgIHZhbHVlLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS50ZXh0KSB7XG4gICAgICAgICAgICAgIHRleHQgKz0gbm9kZS50ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIG5ld0NvbnRlbnQgPSB0ZXh0XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhIXZhbHVlICYmICEhdmFsdWUudGV4dCkge1xuICAgICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZS50ZXh0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Q29udGVudCA9IHZhbHVlIGFzIHN0cmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgdHIuaW5zZXJ0VGV4dChuZXdDb250ZW50LCBmcm9tLCB0bylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0NvbnRlbnQgPSBjb250ZW50XG5cbiAgICAgICAgY29uc3QgZnJvbVNlbGVjdGlvbkF0U3RhcnQgPSBzZWxlY3Rpb24uJGZyb20ucGFyZW50T2Zmc2V0ID09PSAwXG4gICAgICAgIGNvbnN0IGlzVGV4dFNlbGVjdGlvbiA9IHNlbGVjdGlvbi4kZnJvbS5ub2RlKCkuaXNUZXh0IHx8IHNlbGVjdGlvbi4kZnJvbS5ub2RlKCkuaXNUZXh0YmxvY2tcblxuICAgICAgICBpZiAoZnJvbVNlbGVjdGlvbkF0U3RhcnQgJiYgaXNUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgZnJvbSA9IE1hdGgubWF4KDAsIGZyb20gLSAxKVxuICAgICAgICB9XG5cbiAgICAgICAgdHIucmVwbGFjZVdpdGgoZnJvbSwgdG8sIG5ld0NvbnRlbnQpXG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBjdXJzb3IgYXQgZW5kIG9mIGluc2VydGVkIGNvbnRlbnRcbiAgICAgIGlmIChvcHRpb25zLnVwZGF0ZVNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgdHIuc3RlcHMubGVuZ3RoIC0gMSwgLTEpXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFwcGx5SW5wdXRSdWxlcykge1xuICAgICAgICB0ci5zZXRNZXRhKCdhcHBseUlucHV0UnVsZXMnLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYXBwbHlQYXN0ZVJ1bGVzKSB7XG4gICAgICAgIHRyLnNldE1ldGEoJ2FwcGx5UGFzdGVSdWxlcycsIHsgZnJvbSwgdGV4dDogbmV3Q29udGVudCB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cbiIsICJpbXBvcnQge1xuICBqb2luQmFja3dhcmQgYXMgb3JpZ2luYWxKb2luQmFja3dhcmQsXG4gIGpvaW5Eb3duIGFzIG9yaWdpbmFsSm9pbkRvd24sXG4gIGpvaW5Gb3J3YXJkIGFzIG9yaWdpbmFsSm9pbkZvcndhcmQsXG4gIGpvaW5VcCBhcyBvcmlnaW5hbEpvaW5VcCxcbn0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgam9pblVwOiB7XG4gICAgICAvKipcbiAgICAgICAqIEpvaW4gdGhlIHNlbGVjdGVkIGJsb2NrIG9yLCBpZiB0aGVyZSBpcyBhIHRleHQgc2VsZWN0aW9uLCB0aGUgY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGUgc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aCB0aGUgc2libGluZyBhYm92ZSBpdC5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5qb2luVXAoKVxuICAgICAgICovXG4gICAgICBqb2luVXA6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gICAgam9pbkRvd246IHtcbiAgICAgIC8qKlxuICAgICAgICogSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2ssIG9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIHRoZSBzZWxlY3Rpb24gdGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoIHRoZSBzaWJsaW5nIGFmdGVyIGl0LlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmpvaW5Eb3duKClcbiAgICAgICAqL1xuICAgICAgam9pbkRvd246ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gICAgam9pbkJhY2t3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgdHJ5IHRvIHJlZHVjZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGF0IGJsb2NrIGFuZCB0aGUgb25lIGJlZm9yZSBpdOKAlGlmIHRoZXJlJ3MgYSBibG9jayBkaXJlY3RseSBiZWZvcmUgaXQgdGhhdCBjYW4gYmUgam9pbmVkLCBqb2luIHRoZW0uXG4gICAgICAgKiBJZiBub3QsIHRyeSB0byBtb3ZlIHRoZSBzZWxlY3RlZCBibG9jayBjbG9zZXIgdG8gdGhlIG5leHQgb25lIGluIHRoZSBkb2N1bWVudCBzdHJ1Y3R1cmUgYnkgbGlmdGluZyBpdCBvdXQgb2YgaXRzXG4gICAgICAgKiBwYXJlbnQgb3IgbW92aW5nIGl0IGludG8gYSBwYXJlbnQgb2YgdGhlIHByZXZpb3VzIGJsb2NrLiBXaWxsIHVzZSB0aGUgdmlldyBmb3IgYWNjdXJhdGUgKGJpZGktYXdhcmUpIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuam9pbkJhY2t3YXJkKClcbiAgICAgICAqL1xuICAgICAgam9pbkJhY2t3YXJkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICAgIGpvaW5Gb3J3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jaywgdHJ5IHRvIHJlZHVjZSBvciByZW1vdmUgdGhlIGJvdW5kYXJ5IGJldHdlZW4gdGhhdCBibG9jayBhbmQgdGhlIG9uZSBhZnRlciBpdCxcbiAgICAgICAqIGVpdGhlciBieSBqb2luaW5nIHRoZW0gb3IgYnkgbW92aW5nIHRoZSBvdGhlciBibG9jayBjbG9zZXIgdG8gdGhpcyBvbmUgaW4gdGhlIHRyZWUgc3RydWN0dXJlLlxuICAgICAgICogV2lsbCB1c2UgdGhlIHZpZXcgZm9yIGFjY3VyYXRlIHN0YXJ0LW9mLXRleHRibG9jayBkZXRlY3Rpb24gaWYgZ2l2ZW4uXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuam9pbkZvcndhcmQoKVxuICAgICAgICovXG4gICAgICBqb2luRm9yd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgam9pblVwOiBSYXdDb21tYW5kc1snam9pblVwJ10gPVxuICAoKSA9PlxuICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBvcmlnaW5hbEpvaW5VcChzdGF0ZSwgZGlzcGF0Y2gpXG4gIH1cblxuZXhwb3J0IGNvbnN0IGpvaW5Eb3duOiBSYXdDb21tYW5kc1snam9pbkRvd24nXSA9XG4gICgpID0+XG4gICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIG9yaWdpbmFsSm9pbkRvd24oc3RhdGUsIGRpc3BhdGNoKVxuICB9XG5cbmV4cG9ydCBjb25zdCBqb2luQmFja3dhcmQ6IFJhd0NvbW1hbmRzWydqb2luQmFja3dhcmQnXSA9XG4gICgpID0+XG4gICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIG9yaWdpbmFsSm9pbkJhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaClcbiAgfVxuXG5leHBvcnQgY29uc3Qgam9pbkZvcndhcmQ6IFJhd0NvbW1hbmRzWydqb2luRm9yd2FyZCddID1cbiAgKCkgPT5cbiAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gb3JpZ2luYWxKb2luRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG4gIH1cbiIsICJpbXBvcnQgeyBqb2luUG9pbnQgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgam9pbkl0ZW1CYWNrd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBpdGVtcyBiYWNrd2FyZC5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5qb2luSXRlbUJhY2t3YXJkKClcbiAgICAgICAqL1xuICAgICAgam9pbkl0ZW1CYWNrd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgam9pbkl0ZW1CYWNrd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5JdGVtQmFja3dhcmQnXSA9XG4gICgpID0+XG4gICh7IHN0YXRlLCBkaXNwYXRjaCwgdHIgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5wb3MsIC0xKVxuXG4gICAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgdHIuam9pbihwb2ludCwgMilcblxuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGRpc3BhdGNoKHRyKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4iLCAiaW1wb3J0IHsgam9pblBvaW50IH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGpvaW5JdGVtRm9yd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBKb2luIHR3byBpdGVtcyBGb3J3YXJkcy5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5qb2luSXRlbUZvcndhcmQoKVxuICAgICAgICovXG4gICAgICBqb2luSXRlbUZvcndhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGpvaW5JdGVtRm9yd2FyZDogUmF3Q29tbWFuZHNbJ2pvaW5JdGVtRm9yd2FyZCddID1cbiAgKCkgPT5cbiAgKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgKzEpXG5cbiAgICAgIGlmIChwb2ludCA9PT0gbnVsbCB8fCBwb2ludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICB0ci5qb2luKHBvaW50LCAyKVxuXG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgZGlzcGF0Y2godHIpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiIsICJpbXBvcnQgeyBqb2luVGV4dGJsb2NrQmFja3dhcmQgYXMgb3JpZ2luYWxDb21tYW5kIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgam9pblRleHRibG9ja0JhY2t3YXJkOiB7XG4gICAgICAvKipcbiAgICAgICAqIEEgbW9yZSBsaW1pdGVkIGZvcm0gb2Ygam9pbkJhY2t3YXJkIHRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGJlZm9yZSBpdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4gICAgICAgKi9cbiAgICAgIGpvaW5UZXh0YmxvY2tCYWNrd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgam9pblRleHRibG9ja0JhY2t3YXJkOiBSYXdDb21tYW5kc1snam9pblRleHRibG9ja0JhY2t3YXJkJ10gPVxuICAoKSA9PlxuICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBvcmlnaW5hbENvbW1hbmQoc3RhdGUsIGRpc3BhdGNoKVxuICB9XG4iLCAiaW1wb3J0IHsgam9pblRleHRibG9ja0ZvcndhcmQgYXMgb3JpZ2luYWxDb21tYW5kIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgam9pblRleHRibG9ja0ZvcndhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBqb2luRm9yd2FyZCB0aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBhZnRlciBpdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLlxuICAgICAgICovXG4gICAgICBqb2luVGV4dGJsb2NrRm9yd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgam9pblRleHRibG9ja0ZvcndhcmQ6IFJhd0NvbW1hbmRzWydqb2luVGV4dGJsb2NrRm9yd2FyZCddID1cbiAgKCkgPT5cbiAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gb3JpZ2luYWxDb21tYW5kKHN0YXRlLCBkaXNwYXRjaClcbiAgfVxuIiwgImV4cG9ydCBmdW5jdGlvbiBpc01hY09TKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZVxufVxuIiwgImltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IGlzaU9TIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuaW1wb3J0IHsgaXNNYWNPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc01hY09TLmpzJ1xuXG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWU6IHN0cmluZykge1xuICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pXG4gIGxldCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXVxuXG4gIGlmIChyZXN1bHQgPT09ICdTcGFjZScpIHtcbiAgICByZXN1bHQgPSAnICdcbiAgfVxuXG4gIGxldCBhbHRcbiAgbGV0IGN0cmxcbiAgbGV0IHNoaWZ0XG4gIGxldCBtZXRhXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXVxuXG4gICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkge1xuICAgICAgbWV0YSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSkge1xuICAgICAgYWx0ID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkge1xuICAgICAgY3RybCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKSB7XG4gICAgICBzaGlmdCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XG4gICAgICAgIG1ldGEgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHJsID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiAke21vZH1gKVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbHQpIHtcbiAgICByZXN1bHQgPSBgQWx0LSR7cmVzdWx0fWBcbiAgfVxuXG4gIGlmIChjdHJsKSB7XG4gICAgcmVzdWx0ID0gYEN0cmwtJHtyZXN1bHR9YFxuICB9XG5cbiAgaWYgKG1ldGEpIHtcbiAgICByZXN1bHQgPSBgTWV0YS0ke3Jlc3VsdH1gXG4gIH1cblxuICBpZiAoc2hpZnQpIHtcbiAgICByZXN1bHQgPSBgU2hpZnQtJHtyZXN1bHR9YFxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAga2V5Ym9hcmRTaG9ydGN1dDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUcmlnZ2VyIGEga2V5Ym9hcmQgc2hvcnRjdXQuXG4gICAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5Ym9hcmQgc2hvcnRjdXQuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMua2V5Ym9hcmRTaG9ydGN1dCgnTW9kLWInKVxuICAgICAgICovXG4gICAgICBrZXlib2FyZFNob3J0Y3V0OiAobmFtZTogc3RyaW5nKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBrZXlib2FyZFNob3J0Y3V0OiBSYXdDb21tYW5kc1sna2V5Ym9hcmRTaG9ydGN1dCddID1cbiAgbmFtZSA9PlxuICAoeyBlZGl0b3IsIHZpZXcsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3Qga2V5cyA9IG5vcm1hbGl6ZUtleU5hbWUobmFtZSkuc3BsaXQoLy0oPyEkKS8pXG4gICAgY29uc3Qga2V5ID0ga2V5cy5maW5kKGl0ZW0gPT4gIVsnQWx0JywgJ0N0cmwnLCAnTWV0YScsICdTaGlmdCddLmluY2x1ZGVzKGl0ZW0pKVxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7XG4gICAgICBrZXk6IGtleSA9PT0gJ1NwYWNlJyA/ICcgJyA6IGtleSxcbiAgICAgIGFsdEtleToga2V5cy5pbmNsdWRlcygnQWx0JyksXG4gICAgICBjdHJsS2V5OiBrZXlzLmluY2x1ZGVzKCdDdHJsJyksXG4gICAgICBtZXRhS2V5OiBrZXlzLmluY2x1ZGVzKCdNZXRhJyksXG4gICAgICBzaGlmdEtleToga2V5cy5pbmNsdWRlcygnU2hpZnQnKSxcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIH0pXG5cbiAgICBjb25zdCBjYXB0dXJlZFRyYW5zYWN0aW9uID0gZWRpdG9yLmNhcHR1cmVUcmFuc2FjdGlvbigoKSA9PiB7XG4gICAgICB2aWV3LnNvbWVQcm9wKCdoYW5kbGVLZXlEb3duJywgZiA9PiBmKHZpZXcsIGV2ZW50KSlcbiAgICB9KVxuXG4gICAgY2FwdHVyZWRUcmFuc2FjdGlvbj8uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICAgIGNvbnN0IG5ld1N0ZXAgPSBzdGVwLm1hcCh0ci5tYXBwaW5nKVxuXG4gICAgICBpZiAobmV3U3RlcCAmJiBkaXNwYXRjaCkge1xuICAgICAgICB0ci5tYXliZVN0ZXAobmV3U3RlcClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuIiwgImltcG9ydCB7IGxpZnQgYXMgb3JpZ2luYWxMaWZ0IH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcbmltcG9ydCB0eXBlIHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBpc05vZGVBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTm9kZUFjdGl2ZS5qcydcbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGxpZnQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBhbiBleGlzdGluZyB3cmFwIGlmIHBvc3NpYmxlIGxpZnRpbmcgdGhlIG5vZGUgb3V0IG9mIGl0XG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlLlxuICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMubGlmdCgncGFyYWdyYXBoJylcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5saWZ0KCdoZWFkaW5nJywgeyBsZXZlbDogMSB9KVxuICAgICAgICovXG4gICAgICBsaWZ0OiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBsaWZ0OiBSYXdDb21tYW5kc1snbGlmdCddID1cbiAgKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT5cbiAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdpbmFsTGlmdChzdGF0ZSwgZGlzcGF0Y2gpXG4gIH1cbiIsICJpbXBvcnQgeyBsaWZ0RW1wdHlCbG9jayBhcyBvcmlnaW5hbExpZnRFbXB0eUJsb2NrIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgbGlmdEVtcHR5QmxvY2s6IHtcbiAgICAgIC8qKlxuICAgICAgICogSWYgdGhlIGN1cnNvciBpcyBpbiBhbiBlbXB0eSB0ZXh0YmxvY2sgdGhhdCBjYW4gYmUgbGlmdGVkLCBsaWZ0IHRoZSBibG9jay5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpXG4gICAgICAgKi9cbiAgICAgIGxpZnRFbXB0eUJsb2NrOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBsaWZ0RW1wdHlCbG9jazogUmF3Q29tbWFuZHNbJ2xpZnRFbXB0eUJsb2NrJ10gPVxuICAoKSA9PlxuICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBvcmlnaW5hbExpZnRFbXB0eUJsb2NrKHN0YXRlLCBkaXNwYXRjaClcbiAgfVxuIiwgImltcG9ydCB0eXBlIHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgbGlmdExpc3RJdGVtIGFzIG9yaWdpbmFsTGlmdExpc3RJdGVtIH0gZnJvbSAnQHRpcHRhcC9wbS9zY2hlbWEtbGlzdCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgbGlmdExpc3RJdGVtOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBhIGNvbW1hbmQgdG8gbGlmdCB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIHVwIGludG8gYSB3cmFwcGluZyBsaXN0LlxuICAgICAgICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbm9kZS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0oJ2xpc3RJdGVtJylcbiAgICAgICAqL1xuICAgICAgbGlmdExpc3RJdGVtOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxpZnRMaXN0SXRlbTogUmF3Q29tbWFuZHNbJ2xpZnRMaXN0SXRlbSddID1cbiAgdHlwZU9yTmFtZSA9PlxuICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgICByZXR1cm4gb3JpZ2luYWxMaWZ0TGlzdEl0ZW0odHlwZSkoc3RhdGUsIGRpc3BhdGNoKVxuICB9XG4iLCAiaW1wb3J0IHsgbmV3bGluZUluQ29kZSBhcyBvcmlnaW5hbE5ld2xpbmVJbkNvZGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgdHlwZSB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBuZXdsaW5lSW5Db2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhIG5ld2xpbmUgY2hhcmFjdGVyIGluIGNvZGUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMubmV3bGluZUluQ29kZSgpXG4gICAgICAgKi9cbiAgICAgIG5ld2xpbmVJbkNvZGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG5ld2xpbmVJbkNvZGU6IFJhd0NvbW1hbmRzWyduZXdsaW5lSW5Db2RlJ10gPVxuICAoKSA9PlxuICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBvcmlnaW5hbE5ld2xpbmVJbkNvZGUoc3RhdGUsIGRpc3BhdGNoKVxuICB9XG4iLCAiLyoqXG4gKiBSZW1vdmUgYSBwcm9wZXJ0eSBvciBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzIGZyb20gYW4gb2JqZWN0XG4gKiBAcGFyYW0gb2JqIE9iamVjdFxuICogQHBhcmFtIGtleSBLZXkgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVQcm9wcyhvYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByb3BPclByb3BzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICBjb25zdCBwcm9wcyA9IHR5cGVvZiBwcm9wT3JQcm9wcyA9PT0gJ3N0cmluZycgPyBbcHJvcE9yUHJvcHNdIDogcHJvcE9yUHJvcHNcblxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoKG5ld09iajogUmVjb3JkPHN0cmluZywgYW55PiwgcHJvcCkgPT4ge1xuICAgIGlmICghcHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgIG5ld09ialtwcm9wXSA9IG9ialtwcm9wXVxuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmpcbiAgfSwge30pXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNYXJrVHlwZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUuanMnXG5pbXBvcnQgdHlwZSB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBkZWxldGVQcm9wcyB9IGZyb20gJy4uL3V0aWxpdGllcy9kZWxldGVQcm9wcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHJlc2V0QXR0cmlidXRlczoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXNldHMgc29tZSBub2RlIGF0dHJpYnV0ZXMgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlLlxuICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUgdG8gcmVzZXQuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMucmVzZXRBdHRyaWJ1dGVzKCdoZWFkaW5nJywgJ2xldmVsJylcbiAgICAgICAqL1xuICAgICAgcmVzZXRBdHRyaWJ1dGVzOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSwgYXR0cmlidXRlczogc3RyaW5nIHwgc3RyaW5nW10pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlc2V0QXR0cmlidXRlczogUmF3Q29tbWFuZHNbJ3Jlc2V0QXR0cmlidXRlcyddID1cbiAgKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMpID0+XG4gICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBub2RlVHlwZTogTm9kZVR5cGUgfCBudWxsID0gbnVsbFxuICAgIGxldCBtYXJrVHlwZTogTWFya1R5cGUgfCBudWxsID0gbnVsbFxuXG4gICAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKFxuICAgICAgdHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSxcbiAgICAgIHN0YXRlLnNjaGVtYSxcbiAgICApXG5cbiAgICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICAgIG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSBhcyBOb2RlVHlwZSwgc3RhdGUuc2NoZW1hKVxuICAgIH1cblxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSBhcyBNYXJrVHlwZSwgc3RhdGUuc2NoZW1hKVxuICAgIH1cblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgdHIuc2VsZWN0aW9uLnJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbihyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwgZGVsZXRlUHJvcHMobm9kZS5hdHRycywgYXR0cmlidXRlcykpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIG1hcmtUeXBlLmNyZWF0ZShkZWxldGVQcm9wcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzKSkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4iLCAiaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2Nyb2xsSW50b1ZpZXc6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIHRoZSBzZWxlY3Rpb24gaW50byB2aWV3LlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAqL1xuICAgICAgc2Nyb2xsSW50b1ZpZXc6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNjcm9sbEludG9WaWV3OiBSYXdDb21tYW5kc1snc2Nyb2xsSW50b1ZpZXcnXSA9XG4gICgpID0+XG4gICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICB0ci5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuIiwgImltcG9ydCB7IEFsbFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdEFsbDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgdGhlIHdob2xlIGRvY3VtZW50LlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNlbGVjdEFsbCgpXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdEFsbDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0QWxsOiBSYXdDb21tYW5kc1snc2VsZWN0QWxsJ10gPVxuICAoKSA9PlxuICAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbmV3IEFsbFNlbGVjdGlvbih0ci5kb2MpXG5cbiAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuIiwgImltcG9ydCB7IHNlbGVjdE5vZGVCYWNrd2FyZCBhcyBvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZCB9IGZyb20gJ0B0aXB0YXAvcG0vY29tbWFuZHMnXG5cbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNlbGVjdE5vZGVCYWNrd2FyZDoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZWxlY3QgYSBub2RlIGJhY2t3YXJkLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNlbGVjdE5vZGVCYWNrd2FyZCgpXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdE5vZGVCYWNrd2FyZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0Tm9kZUJhY2t3YXJkOiBSYXdDb21tYW5kc1snc2VsZWN0Tm9kZUJhY2t3YXJkJ10gPVxuICAoKSA9PlxuICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBvcmlnaW5hbFNlbGVjdE5vZGVCYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gpXG4gIH1cbiIsICJpbXBvcnQgeyBzZWxlY3ROb2RlRm9yd2FyZCBhcyBvcmlnaW5hbFNlbGVjdE5vZGVGb3J3YXJkIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0Tm9kZUZvcndhcmQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2VsZWN0IGEgbm9kZSBmb3J3YXJkLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNlbGVjdE5vZGVGb3J3YXJkKClcbiAgICAgICAqL1xuICAgICAgc2VsZWN0Tm9kZUZvcndhcmQ6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdE5vZGVGb3J3YXJkOiBSYXdDb21tYW5kc1snc2VsZWN0Tm9kZUZvcndhcmQnXSA9XG4gICgpID0+XG4gICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0Tm9kZUZvcndhcmQoc3RhdGUsIGRpc3BhdGNoKVxuICB9XG4iLCAiaW1wb3J0IHsgc2VsZWN0UGFyZW50Tm9kZSBhcyBvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgdHlwZSB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3RQYXJlbnROb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNlbGVjdCB0aGUgcGFyZW50IG5vZGUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2VsZWN0UGFyZW50Tm9kZSgpXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdFBhcmVudE5vZGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNlbGVjdFBhcmVudE5vZGU6IFJhd0NvbW1hbmRzWydzZWxlY3RQYXJlbnROb2RlJ10gPVxuICAoKSA9PlxuICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBvcmlnaW5hbFNlbGVjdFBhcmVudE5vZGUoc3RhdGUsIGRpc3BhdGNoKVxuICB9XG4iLCAiLy8gQHRzLWlnbm9yZVxuLy8gVE9ETzogYWRkIHR5cGVzIHRvIEB0eXBlcy9wcm9zZW1pcnJvci1jb21tYW5kc1xuaW1wb3J0IHsgc2VsZWN0VGV4dGJsb2NrRW5kIGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcblxuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2VsZWN0VGV4dGJsb2NrRW5kOiB7XG4gICAgICAvKipcbiAgICAgICAqIE1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIGVuZCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrRW5kKClcbiAgICAgICAqL1xuICAgICAgc2VsZWN0VGV4dGJsb2NrRW5kOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZWxlY3RUZXh0YmxvY2tFbmQ6IFJhd0NvbW1hbmRzWydzZWxlY3RUZXh0YmxvY2tFbmQnXSA9XG4gICgpID0+XG4gICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrRW5kKHN0YXRlLCBkaXNwYXRjaClcbiAgfVxuIiwgIi8vIEB0cy1pZ25vcmVcbi8vIFRPRE86IGFkZCB0eXBlcyB0byBAdHlwZXMvcHJvc2VtaXJyb3ItY29tbWFuZHNcbmltcG9ydCB7IHNlbGVjdFRleHRibG9ja1N0YXJ0IGFzIG9yaWdpbmFsU2VsZWN0VGV4dGJsb2NrU3RhcnQgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuXG5pbXBvcnQgdHlwZSB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZWxlY3RUZXh0YmxvY2tTdGFydDoge1xuICAgICAgLyoqXG4gICAgICAgKiBNb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKVxuICAgICAgICovXG4gICAgICBzZWxlY3RUZXh0YmxvY2tTdGFydDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6IFJhd0NvbW1hbmRzWydzZWxlY3RUZXh0YmxvY2tTdGFydCddID1cbiAgKCkgPT5cbiAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gb3JpZ2luYWxTZWxlY3RUZXh0YmxvY2tTdGFydChzdGF0ZSwgZGlzcGF0Y2gpXG4gIH1cbiIsICJpbXBvcnQgdHlwZSB7IEZyYWdtZW50LCBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgUGFyc2VPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgY3JlYXRlRG9jdW1lbnQgfSBmcm9tICcuLi9oZWxwZXJzL2NyZWF0ZURvY3VtZW50LmpzJ1xuaW1wb3J0IHR5cGUgeyBDb250ZW50LCBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0Q29udGVudDoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXBsYWNlIHRoZSB3aG9sZSBkb2N1bWVudCB3aXRoIG5ldyBjb250ZW50LlxuICAgICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIG5ldyBjb250ZW50LlxuICAgICAgICogQHBhcmFtIGVtaXRVcGRhdGUgV2hldGhlciB0byBlbWl0IGFuIHVwZGF0ZSBldmVudC5cbiAgICAgICAqIEBwYXJhbSBwYXJzZU9wdGlvbnMgT3B0aW9ucyBmb3IgcGFyc2luZyB0aGUgY29udGVudC5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5zZXRDb250ZW50KCc8cD5FeGFtcGxlIHRleHQ8L3A+JylcbiAgICAgICAqL1xuICAgICAgc2V0Q29udGVudDogKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5ldyBjb250ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgY29udGVudDogQ29udGVudCB8IEZyYWdtZW50IHwgUHJvc2VNaXJyb3JOb2RlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25zIGZvciBgc2V0Q29udGVudGAuXG4gICAgICAgICAqL1xuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIE9wdGlvbnMgZm9yIHBhcnNpbmcgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICogQGRlZmF1bHQge31cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBwYXJzZU9wdGlvbnM/OiBQYXJzZU9wdGlvbnNcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFdoZXRoZXIgdG8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGNvbnRlbnQgaXMgaW52YWxpZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ/OiBib29sZWFuXG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBXaGV0aGVyIHRvIGVtaXQgYW4gdXBkYXRlIGV2ZW50LlxuICAgICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBlbWl0VXBkYXRlPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXRDb250ZW50OiBSYXdDb21tYW5kc1snc2V0Q29udGVudCddID1cbiAgKGNvbnRlbnQsIHsgZXJyb3JPbkludmFsaWRDb250ZW50LCBlbWl0VXBkYXRlID0gdHJ1ZSwgcGFyc2VPcHRpb25zID0ge30gfSA9IHt9KSA9PlxuICAoeyBlZGl0b3IsIHRyLCBkaXNwYXRjaCwgY29tbWFuZHMgfSkgPT4ge1xuICAgIGNvbnN0IHsgZG9jIH0gPSB0clxuXG4gICAgLy8gVGhpcyBpcyB0byBrZWVwIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgcHJldmlvdXMgYmVoYXZpb3JcbiAgICAvLyBUT0RPIHJlbW92ZSB0aGlzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cbiAgICBpZiAocGFyc2VPcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gJ2Z1bGwnKSB7XG4gICAgICBjb25zdCBkb2N1bWVudCA9IGNyZWF0ZURvY3VtZW50KGNvbnRlbnQsIGVkaXRvci5zY2hlbWEsIHBhcnNlT3B0aW9ucywge1xuICAgICAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IGVycm9yT25JbnZhbGlkQ29udGVudCA/PyBlZGl0b3Iub3B0aW9ucy5lbmFibGVDb250ZW50Q2hlY2ssXG4gICAgICB9KVxuXG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdHIucmVwbGFjZVdpdGgoMCwgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jdW1lbnQpLnNldE1ldGEoJ3ByZXZlbnRVcGRhdGUnLCAhZW1pdFVwZGF0ZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICB0ci5zZXRNZXRhKCdwcmV2ZW50VXBkYXRlJywgIWVtaXRVcGRhdGUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnRBdCh7IGZyb206IDAsIHRvOiBkb2MuY29udGVudC5zaXplIH0sIGNvbnRlbnQsIHtcbiAgICAgIHBhcnNlT3B0aW9ucyxcbiAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogZXJyb3JPbkludmFsaWRDb250ZW50ID8/IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayxcbiAgICB9KVxuICB9XG4iLCAiaW1wb3J0IHR5cGUgeyBNYXJrVHlwZSwgUmVzb2x2ZWRQb3MgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHR5cGUgeyBFZGl0b3JTdGF0ZSwgVHJhbnNhY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBnZXRNYXJrQXR0cmlidXRlcyB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya0F0dHJpYnV0ZXMuanMnXG5pbXBvcnQgeyBnZXRNYXJrVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1R5cGUuanMnXG5pbXBvcnQgeyBpc1RleHRTZWxlY3Rpb24gfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJ1xuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2V0TWFyazoge1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYSBtYXJrIHdpdGggbmV3IGF0dHJpYnV0ZXMuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgbWFyayB0eXBlIG9yIG5hbWUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0TWFyaygnYm9sZCcsIHsgbGV2ZWw6IDEgfSlcbiAgICAgICAqL1xuICAgICAgc2V0TWFyazogKHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5TZXRNYXJrKHN0YXRlOiBFZGl0b3JTdGF0ZSwgdHI6IFRyYW5zYWN0aW9uLCBuZXdNYXJrVHlwZTogTWFya1R5cGUpIHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyXG4gIGxldCBjdXJzb3I6IFJlc29sdmVkUG9zIHwgbnVsbCA9IG51bGxcblxuICBpZiAoaXNUZXh0U2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjdXJzb3IgPSBzZWxlY3Rpb24uJGN1cnNvclxuICB9XG5cbiAgaWYgKGN1cnNvcikge1xuICAgIGNvbnN0IGN1cnJlbnRNYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzID8/IGN1cnNvci5tYXJrcygpXG5cbiAgICAvLyBUaGVyZSBjYW4gYmUgbm8gY3VycmVudCBtYXJrcyB0aGF0IGV4Y2x1ZGUgdGhlIG5ldyBtYXJrXG4gICAgcmV0dXJuICEhbmV3TWFya1R5cGUuaXNJblNldChjdXJyZW50TWFya3MpIHx8ICFjdXJyZW50TWFya3Muc29tZShtYXJrID0+IG1hcmsudHlwZS5leGNsdWRlcyhuZXdNYXJrVHlwZSkpXG4gIH1cblxuICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgcmV0dXJuIHJhbmdlcy5zb21lKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgIGxldCBzb21lTm9kZVN1cHBvcnRzTWFyayA9XG4gICAgICAkZnJvbS5kZXB0aCA9PT0gMCA/IHN0YXRlLmRvYy5pbmxpbmVDb250ZW50ICYmIHN0YXRlLmRvYy50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKSA6IGZhbHNlXG5cbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgKG5vZGUsIF9wb3MsIHBhcmVudCkgPT4ge1xuICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCBhIG1hcmsgdGhhdCB3ZSBjYW4gZW5hYmxlLCByZXR1cm4gZmFsc2UgdG8gYnlwYXNzIHRoZSByZW1haW5pbmcgc2VhcmNoXG4gICAgICBpZiAoc29tZU5vZGVTdXBwb3J0c01hcmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmlzSW5saW5lKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEFsbG93c01hcmtUeXBlID0gIXBhcmVudCB8fCBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShuZXdNYXJrVHlwZSlcbiAgICAgICAgY29uc3QgY3VycmVudE1hcmtzQWxsb3dNYXJrVHlwZSA9XG4gICAgICAgICAgISFuZXdNYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpIHx8ICFub2RlLm1hcmtzLnNvbWUob3RoZXJNYXJrID0+IG90aGVyTWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSlcblxuICAgICAgICBzb21lTm9kZVN1cHBvcnRzTWFyayA9IHBhcmVudEFsbG93c01hcmtUeXBlICYmIGN1cnJlbnRNYXJrc0FsbG93TWFya1R5cGVcbiAgICAgIH1cbiAgICAgIHJldHVybiAhc29tZU5vZGVTdXBwb3J0c01hcmtcbiAgICB9KVxuXG4gICAgcmV0dXJuIHNvbWVOb2RlU3VwcG9ydHNNYXJrXG4gIH0pXG59XG5leHBvcnQgY29uc3Qgc2V0TWFyazogUmF3Q29tbWFuZHNbJ3NldE1hcmsnXSA9XG4gICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+XG4gICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICAgIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uXG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBnZXRNYXJrQXR0cmlidXRlcyhzdGF0ZSwgdHlwZSlcblxuICAgICAgICB0ci5hZGRTdG9yZWRNYXJrKFxuICAgICAgICAgIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgIC4uLm9sZEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgIH0pLFxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvc1xuICAgICAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvc1xuXG4gICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pXG4gICAgICAgICAgICBjb25zdCB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0bylcbiAgICAgICAgICAgIGNvbnN0IHNvbWVIYXNNYXJrID0gbm9kZS5tYXJrcy5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgbWFyayBvZiB0aGlzIHR5cGVcbiAgICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCB3ZSBoYXZlIHRvIG1lcmdlIGl0cyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgYWRkIGEgZnJlc2ggbmV3IG1hcmtcbiAgICAgICAgICAgIGlmIChzb21lSGFzTWFyaykge1xuICAgICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayhcbiAgICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRyaW1tZWRUbyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHIuYWRkTWFyayh0cmltbWVkRnJvbSwgdHJpbW1lZFRvLCB0eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjYW5TZXRNYXJrKHN0YXRlLCB0ciwgdHlwZSlcbiAgfVxuIiwgImltcG9ydCB0eXBlIHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgdHlwZSB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXRNZXRhOiB7XG4gICAgICAvKipcbiAgICAgICAqIFN0b3JlIGEgbWV0YWRhdGEgcHJvcGVydHkgaW4gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24uXG4gICAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGFkYXRhIHByb3BlcnR5LlxuICAgICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzdG9yZS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5zZXRNZXRhKCdmb28nLCAnYmFyJylcbiAgICAgICAqL1xuICAgICAgc2V0TWV0YTogKGtleTogc3RyaW5nIHwgUGx1Z2luIHwgUGx1Z2luS2V5LCB2YWx1ZTogYW55KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzZXRNZXRhOiBSYXdDb21tYW5kc1snc2V0TWV0YSddID1cbiAgKGtleSwgdmFsdWUpID0+XG4gICh7IHRyIH0pID0+IHtcbiAgICB0ci5zZXRNZXRhKGtleSwgdmFsdWUpXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4iLCAiaW1wb3J0IHsgc2V0QmxvY2tUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcydcbmltcG9ydCB0eXBlIHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgdHlwZSB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXROb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlcGxhY2UgYSBnaXZlbiByYW5nZSB3aXRoIGEgbm9kZS5cbiAgICAgICAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSB0eXBlIG9yIG5hbWUgb2YgdGhlIG5vZGVcbiAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBub2RlXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0Tm9kZSgncGFyYWdyYXBoJylcbiAgICAgICAqL1xuICAgICAgc2V0Tm9kZTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2V0Tm9kZTogUmF3Q29tbWFuZHNbJ3NldE5vZGUnXSA9XG4gICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+XG4gICh7IHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4gfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgICBsZXQgYXR0cmlidXRlc1RvQ29weTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZFxuXG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnNhbWVQYXJlbnQoc3RhdGUuc2VsZWN0aW9uLiRoZWFkKSkge1xuICAgICAgLy8gb25seSBjb3B5IGF0dHJpYnV0ZXMgaWYgdGhlIHNlbGVjdGlvbiBpcyBwb2ludGluZyB0byBhIG5vZGUgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgYXR0cmlidXRlc1RvQ29weSA9IHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnBhcmVudC5hdHRyc1xuICAgIH1cblxuICAgIC8vIFRPRE86IHVzZSBhIGZhbGxiYWNrIGxpa2UgaW5zZXJ0Q29udGVudD9cbiAgICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogQ3VycmVudGx5IFwic2V0Tm9kZSgpXCIgb25seSBzdXBwb3J0cyB0ZXh0IGJsb2NrIG5vZGVzLicpXG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjaGFpbigpXG4gICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgICAuY29tbWFuZCgoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2FuU2V0QmxvY2sgPSBzZXRCbG9ja1R5cGUodHlwZSwgeyAuLi5hdHRyaWJ1dGVzVG9Db3B5LCAuLi5hdHRyaWJ1dGVzIH0pKHN0YXRlKVxuXG4gICAgICAgICAgaWYgKGNhblNldEJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNvbW1hbmQoKHsgc3RhdGU6IHVwZGF0ZWRTdGF0ZSB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHNldEJsb2NrVHlwZSh0eXBlLCB7IC4uLmF0dHJpYnV0ZXNUb0NvcHksIC4uLmF0dHJpYnV0ZXMgfSkodXBkYXRlZFN0YXRlLCBkaXNwYXRjaClcbiAgICAgICAgfSlcbiAgICAgICAgLnJ1bigpXG4gICAgKVxuICB9XG4iLCAiaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXROb2RlU2VsZWN0aW9uOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBOb2RlU2VsZWN0aW9uLlxuICAgICAgICogQHBhcmFtIHBvc2l0aW9uIC0gUG9zaXRpb24gb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0Tm9kZVNlbGVjdGlvbigxMClcbiAgICAgICAqL1xuICAgICAgc2V0Tm9kZVNlbGVjdGlvbjogKHBvc2l0aW9uOiBudW1iZXIpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldE5vZGVTZWxlY3Rpb246IFJhd0NvbW1hbmRzWydzZXROb2RlU2VsZWN0aW9uJ10gPVxuICBwb3NpdGlvbiA9PlxuICAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgY29uc3QgeyBkb2MgfSA9IHRyXG4gICAgICBjb25zdCBmcm9tID0gbWluTWF4KHBvc2l0aW9uLCAwLCBkb2MuY29udGVudC5zaXplKVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUoZG9jLCBmcm9tKVxuXG4gICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cbiIsICJpbXBvcnQgeyBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHR5cGUgeyBSYW5nZSwgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcbmltcG9ydCB7IG1pbk1heCB9IGZyb20gJy4uL3V0aWxpdGllcy9taW5NYXguanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzZXRUZXh0U2VsZWN0aW9uOiB7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBUZXh0U2VsZWN0aW9uLlxuICAgICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNldFRleHRTZWxlY3Rpb24oMTApXG4gICAgICAgKi9cbiAgICAgIHNldFRleHRTZWxlY3Rpb246IChwb3NpdGlvbjogbnVtYmVyIHwgUmFuZ2UpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldFRleHRTZWxlY3Rpb246IFJhd0NvbW1hbmRzWydzZXRUZXh0U2VsZWN0aW9uJ10gPVxuICBwb3NpdGlvbiA9PlxuICAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgY29uc3QgeyBkb2MgfSA9IHRyXG4gICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiBwb3NpdGlvblxuICAgICAgY29uc3QgbWluUG9zID0gVGV4dFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbVxuICAgICAgY29uc3QgbWF4UG9zID0gVGV4dFNlbGVjdGlvbi5hdEVuZChkb2MpLnRvXG4gICAgICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpXG4gICAgICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJlc29sdmVkRnJvbSwgcmVzb2x2ZWRFbmQpXG5cbiAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuIiwgImltcG9ydCB0eXBlIHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgc2lua0xpc3RJdGVtIGFzIG9yaWdpbmFsU2lua0xpc3RJdGVtIH0gZnJvbSAnQHRpcHRhcC9wbS9zY2hlbWEtbGlzdCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc2lua0xpc3RJdGVtOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNpbmsgdGhlIGxpc3QgaXRlbSBkb3duIGludG8gYW4gaW5uZXIgbGlzdC5cbiAgICAgICAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSB0eXBlIG9yIG5hbWUgb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKCdsaXN0SXRlbScpXG4gICAgICAgKi9cbiAgICAgIHNpbmtMaXN0SXRlbTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzaW5rTGlzdEl0ZW06IFJhd0NvbW1hbmRzWydzaW5rTGlzdEl0ZW0nXSA9XG4gIHR5cGVPck5hbWUgPT5cbiAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuXG4gICAgcmV0dXJuIG9yaWdpbmFsU2lua0xpc3RJdGVtKHR5cGUpKHN0YXRlLCBkaXNwYXRjaClcbiAgfVxuIiwgImltcG9ydCB0eXBlIHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBjYW5TcGxpdCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBkZWZhdWx0QmxvY2tBdCB9IGZyb20gJy4uL2hlbHBlcnMvZGVmYXVsdEJsb2NrQXQuanMnXG5pbXBvcnQgeyBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMgfSBmcm9tICcuLi9oZWxwZXJzL2dldFNwbGl0dGVkQXR0cmlidXRlcy5qcydcbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZnVuY3Rpb24gZW5zdXJlTWFya3Moc3RhdGU6IEVkaXRvclN0YXRlLCBzcGxpdHRhYmxlTWFya3M/OiBzdHJpbmdbXSkge1xuICBjb25zdCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICBpZiAobWFya3MpIHtcbiAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzPy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICBzdGF0ZS50ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuICB9XG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBzcGxpdEJsb2NrOiB7XG4gICAgICAvKipcbiAgICAgICAqIEZvcmtzIGEgbmV3IG5vZGUgZnJvbSBhbiBleGlzdGluZyBub2RlLlxuICAgICAgICogQHBhcmFtIG9wdGlvbnMua2VlcE1hcmtzIEtlZXAgbWFya3MgZnJvbSB0aGUgcHJldmlvdXMgbm9kZS5cbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5zcGxpdEJsb2NrKClcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5zcGxpdEJsb2NrKHsga2VlcE1hcmtzOiB0cnVlIH0pXG4gICAgICAgKi9cbiAgICAgIHNwbGl0QmxvY2s6IChvcHRpb25zPzogeyBrZWVwTWFya3M/OiBib29sZWFuIH0pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNwbGl0QmxvY2s6IFJhd0NvbW1hbmRzWydzcGxpdEJsb2NrJ10gPVxuICAoeyBrZWVwTWFya3MgPSB0cnVlIH0gPSB7fSkgPT5cbiAgKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCwgZWRpdG9yIH0pID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSB0clxuICAgIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uXG4gICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXNcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsICRmcm9tLm5vZGUoKS5hdHRycylcblxuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChkb2MsICRmcm9tLnBvcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBpZiAoa2VlcE1hcmtzKSB7XG4gICAgICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcylcbiAgICAgICAgfVxuXG4gICAgICAgIHRyLnNwbGl0KCRmcm9tLnBvcykuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICghJGZyb20ucGFyZW50LmlzQmxvY2spIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGF0RW5kID0gJHRvLnBhcmVudE9mZnNldCA9PT0gJHRvLnBhcmVudC5jb250ZW50LnNpemVcblxuICAgIGNvbnN0IGRlZmx0ID0gJGZyb20uZGVwdGggPT09IDAgPyB1bmRlZmluZWQgOiBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKC0xKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKC0xKSkpXG5cbiAgICBsZXQgdHlwZXMgPVxuICAgICAgYXRFbmQgJiYgZGVmbHRcbiAgICAgICAgPyBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IGRlZmx0LFxuICAgICAgICAgICAgICBhdHRyczogbmV3QXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXVxuICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpXG5cbiAgICBpZiAoIXR5cGVzICYmICFjYW4gJiYgY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCBkZWZsdCA/IFt7IHR5cGU6IGRlZmx0IH1dIDogdW5kZWZpbmVkKSkge1xuICAgICAgY2FuID0gdHJ1ZVxuICAgICAgdHlwZXMgPSBkZWZsdFxuICAgICAgICA/IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogZGVmbHQsXG4gICAgICAgICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdXG4gICAgICAgIDogdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoY2FuKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKVxuXG4gICAgICAgIGlmIChkZWZsdCAmJiAhYXRFbmQgJiYgISRmcm9tLnBhcmVudE9mZnNldCAmJiAkZnJvbS5wYXJlbnQudHlwZSAhPT0gZGVmbHQpIHtcbiAgICAgICAgICBjb25zdCBmaXJzdCA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKVxuICAgICAgICAgIGNvbnN0ICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KVxuXG4gICAgICAgICAgaWYgKCRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSkge1xuICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoa2VlcE1hcmtzKSB7XG4gICAgICAgIGVuc3VyZU1hcmtzKHN0YXRlLCBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5zcGxpdHRhYmxlTWFya3MpXG4gICAgICB9XG5cbiAgICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG5cbiAgICByZXR1cm4gY2FuXG4gIH1cbiIsICJpbXBvcnQgdHlwZSB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBGcmFnbWVudCwgU2xpY2UgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBjYW5TcGxpdCB9IGZyb20gJ0B0aXB0YXAvcG0vdHJhbnNmb3JtJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBnZXRTcGxpdHRlZEF0dHJpYnV0ZXMgfSBmcm9tICcuLi9oZWxwZXJzL2dldFNwbGl0dGVkQXR0cmlidXRlcy5qcydcbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHNwbGl0TGlzdEl0ZW06IHtcbiAgICAgIC8qKlxuICAgICAgICogU3BsaXRzIG9uZSBsaXN0IGl0ZW0gaW50byB0d28gbGlzdCBpdGVtcy5cbiAgICAgICAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSB0eXBlIG9yIG5hbWUgb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gb3ZlcnJpZGVBdHRycyBUaGUgYXR0cmlidXRlcyB0byBlbnN1cmUgb24gdGhlIG5ldyBub2RlLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0oJ2xpc3RJdGVtJylcbiAgICAgICAqL1xuICAgICAgc3BsaXRMaXN0SXRlbTogKHR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLCBvdmVycmlkZUF0dHJzPzogUmVjb3JkPHN0cmluZywgYW55PikgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3BsaXRMaXN0SXRlbTogUmF3Q29tbWFuZHNbJ3NwbGl0TGlzdEl0ZW0nXSA9XG4gICh0eXBlT3JOYW1lLCBvdmVycmlkZUF0dHJzID0ge30pID0+XG4gICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvblxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGNvbnN0IG5vZGU6IFByb3NlTWlycm9yTm9kZSA9IHN0YXRlLnNlbGVjdGlvbi5ub2RlXG5cbiAgICBpZiAoKG5vZGUgJiYgbm9kZS5pc0Jsb2NrKSB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKVxuXG4gICAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT09IHR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzXG5cbiAgICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgLy8gSW4gYW4gZW1wdHkgYmxvY2suIElmIHRoaXMgaXMgYSBuZXN0ZWQgbGlzdCwgdGhlIHdyYXBwaW5nXG4gICAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgIGlmICgkZnJvbS5kZXB0aCA9PT0gMiB8fCAkZnJvbS5ub2RlKC0zKS50eXBlICE9PSB0eXBlIHx8ICRmcm9tLmluZGV4KC0yKSAhPT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgd3JhcCA9IEZyYWdtZW50LmVtcHR5XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogM1xuXG4gICAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXG4gICAgICAgIC8vIGZyb20gdGhlIG91dGVyIGxpc3QgaXRlbSB0byB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIGN1cnNvclxuICAgICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQgLT0gMSkge1xuICAgICAgICAgIHdyYXAgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weSh3cmFwKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlcHRoQWZ0ZXIgPVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudFxuICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudFxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAzXG5cbiAgICAgICAgLy8gQWRkIGEgc2Vjb25kIGxpc3QgaXRlbSB3aXRoIGFuIGVtcHR5IGRlZmF1bHQgc3RhcnQgbm9kZVxuICAgICAgICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgLi4uZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsICRmcm9tLm5vZGUoKS5hdHRycyksXG4gICAgICAgICAgLi4ub3ZlcnJpZGVBdHRycyxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0VHlwZSA9IHR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlPy5jcmVhdGVBbmRGaWxsKG5ld05leHRUeXBlQXR0cmlidXRlcykgfHwgdW5kZWZpbmVkXG5cbiAgICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGVBbmRGaWxsKG51bGwsIG5leHRUeXBlKSB8fCB1bmRlZmluZWQpKVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpXG5cbiAgICAgICAgdHIucmVwbGFjZShzdGFydCwgJGZyb20uYWZ0ZXIoLWRlcHRoQWZ0ZXIpLCBuZXcgU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSlcblxuICAgICAgICBsZXQgc2VsID0gLTFcblxuICAgICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobiwgcG9zKSA9PiB7XG4gICAgICAgICAgaWYgKHNlbCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi5pc1RleHRibG9jayAmJiBuLmNvbnRlbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgc2VsID0gcG9zICsgMVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoc2VsID4gLTEpIHtcbiAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHNlbCkpKVxuICAgICAgICB9XG5cbiAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IG5leHRUeXBlID0gJHRvLnBvcyA9PT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGxcblxuICAgIGNvbnN0IG5ld1R5cGVBdHRyaWJ1dGVzID0ge1xuICAgICAgLi4uZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsIGdyYW5kUGFyZW50LnR5cGUubmFtZSwgZ3JhbmRQYXJlbnQuYXR0cnMpLFxuICAgICAgLi4ub3ZlcnJpZGVBdHRycyxcbiAgICB9XG4gICAgY29uc3QgbmV3TmV4dFR5cGVBdHRyaWJ1dGVzID0ge1xuICAgICAgLi4uZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsICRmcm9tLm5vZGUoKS5hdHRycyksXG4gICAgICAuLi5vdmVycmlkZUF0dHJzLFxuICAgIH1cblxuICAgIHRyLmRlbGV0ZSgkZnJvbS5wb3MsICR0by5wb3MpXG5cbiAgICBjb25zdCB0eXBlcyA9IG5leHRUeXBlXG4gICAgICA/IFtcbiAgICAgICAgICB7IHR5cGUsIGF0dHJzOiBuZXdUeXBlQXR0cmlidXRlcyB9LFxuICAgICAgICAgIHsgdHlwZTogbmV4dFR5cGUsIGF0dHJzOiBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICAgICAgXVxuICAgICAgOiBbeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfV1cblxuICAgIGlmICghY2FuU3BsaXQodHIuZG9jLCAkZnJvbS5wb3MsIDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGVcbiAgICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG5cbiAgICAgIHRyLnNwbGl0KCRmcm9tLnBvcywgMiwgdHlwZXMpLnNjcm9sbEludG9WaWV3KClcblxuICAgICAgaWYgKCFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuIiwgImltcG9ydCB0eXBlIHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHR5cGUgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBjYW5Kb2luIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB7IGZpbmRQYXJlbnROb2RlIH0gZnJvbSAnLi4vaGVscGVycy9maW5kUGFyZW50Tm9kZS5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGlzTGlzdCB9IGZyb20gJy4uL2hlbHBlcnMvaXNMaXN0LmpzJ1xuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5jb25zdCBqb2luTGlzdEJhY2t3YXJkcyA9ICh0cjogVHJhbnNhY3Rpb24sIGxpc3RUeXBlOiBOb2RlVHlwZSk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pXG5cbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KDAsIGxpc3QucG9zIC0gMSkpLmJlZm9yZShsaXN0LmRlcHRoKVxuXG4gIGlmIChiZWZvcmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBub2RlQmVmb3JlID0gdHIuZG9jLm5vZGVBdChiZWZvcmUpXG4gIGNvbnN0IGNhbkpvaW5CYWNrd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gbm9kZUJlZm9yZT8udHlwZSAmJiBjYW5Kb2luKHRyLmRvYywgbGlzdC5wb3MpXG5cbiAgaWYgKCFjYW5Kb2luQmFja3dhcmRzKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHRyLmpvaW4obGlzdC5wb3MpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuY29uc3Qgam9pbkxpc3RGb3J3YXJkcyA9ICh0cjogVHJhbnNhY3Rpb24sIGxpc3RUeXBlOiBOb2RlVHlwZSk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pXG5cbiAgaWYgKCFsaXN0KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IGFmdGVyID0gdHIuZG9jLnJlc29sdmUobGlzdC5zdGFydCkuYWZ0ZXIobGlzdC5kZXB0aClcblxuICBpZiAoYWZ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBub2RlQWZ0ZXIgPSB0ci5kb2Mubm9kZUF0KGFmdGVyKVxuICBjb25zdCBjYW5Kb2luRm9yd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gbm9kZUFmdGVyPy50eXBlICYmIGNhbkpvaW4odHIuZG9jLCBhZnRlcilcblxuICBpZiAoIWNhbkpvaW5Gb3J3YXJkcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB0ci5qb2luKGFmdGVyKVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVMaXN0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBsaXN0IHR5cGVzLlxuICAgICAgICogQHBhcmFtIGxpc3RUeXBlT3JOYW1lIFRoZSB0eXBlIG9yIG5hbWUgb2YgdGhlIGxpc3QuXG4gICAgICAgKiBAcGFyYW0gaXRlbVR5cGVPck5hbWUgVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbGlzdCBpdGVtLlxuICAgICAgICogQHBhcmFtIGtlZXBNYXJrcyBLZWVwIG1hcmtzIHdoZW4gdG9nZ2xpbmcuXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBBdHRyaWJ1dGVzIGZvciB0aGUgbmV3IGxpc3QuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudG9nZ2xlTGlzdCgnYnVsbGV0TGlzdCcsICdsaXN0SXRlbScpXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUxpc3Q6IChcbiAgICAgICAgbGlzdFR5cGVPck5hbWU6IHN0cmluZyB8IE5vZGVUeXBlLFxuICAgICAgICBpdGVtVHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsXG4gICAgICAgIGtlZXBNYXJrcz86IGJvb2xlYW4sXG4gICAgICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVMaXN0OiBSYXdDb21tYW5kc1sndG9nZ2xlTGlzdCddID1cbiAgKGxpc3RUeXBlT3JOYW1lLCBpdGVtVHlwZU9yTmFtZSwga2VlcE1hcmtzLCBhdHRyaWJ1dGVzID0ge30pID0+XG4gICh7IGVkaXRvciwgdHIsIHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4sIGNvbW1hbmRzLCBjYW4gfSkgPT4ge1xuICAgIGNvbnN0IHsgZXh0ZW5zaW9ucywgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgIGNvbnN0IGxpc3RUeXBlID0gZ2V0Tm9kZVR5cGUobGlzdFR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgICBjb25zdCBpdGVtVHlwZSA9IGdldE5vZGVUeXBlKGl0ZW1UeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uXG4gICAgY29uc3QgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bylcblxuICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKVxuXG4gICAgaWYgKCFyYW5nZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50TGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gaXNMaXN0KG5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSkoc2VsZWN0aW9uKVxuXG4gICAgaWYgKHJhbmdlLmRlcHRoID49IDEgJiYgcGFyZW50TGlzdCAmJiByYW5nZS5kZXB0aCAtIHBhcmVudExpc3QuZGVwdGggPD0gMSkge1xuICAgICAgLy8gcmVtb3ZlIGxpc3RcbiAgICAgIGlmIChwYXJlbnRMaXN0Lm5vZGUudHlwZSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnRMaXN0SXRlbShpdGVtVHlwZSlcbiAgICAgIH1cblxuICAgICAgLy8gY2hhbmdlIGxpc3QgdHlwZVxuICAgICAgaWYgKGlzTGlzdChwYXJlbnRMaXN0Lm5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSAmJiBsaXN0VHlwZS52YWxpZENvbnRlbnQocGFyZW50TGlzdC5ub2RlLmNvbnRlbnQpICYmIGRpc3BhdGNoKSB7XG4gICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwYXJlbnRMaXN0LnBvcywgbGlzdFR5cGUpXG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgICAucnVuKClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFrZWVwTWFya3MgfHwgIW1hcmtzIHx8ICFkaXNwYXRjaCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY2hhaW4oKVxuICAgICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgICAgIC5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgICAgICAgICBpZiAoY2FuV3JhcEluTGlzdCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcbiAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgICAucnVuKClcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgY2hhaW4oKVxuICAgICAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcbiAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpXG5cbiAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKVxuXG4gICAgICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKVxuICAgICAgICB9KVxuICAgICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcbiAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RGb3J3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgICAucnVuKClcbiAgICApXG4gIH1cbiIsICJpbXBvcnQgdHlwZSB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHsgaXNNYXJrQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc01hcmtBY3RpdmUuanMnXG5pbXBvcnQgdHlwZSB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVNYXJrOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIG1hcmsgb24gYW5kIG9mZi5cbiAgICAgICAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSBtYXJrIHR5cGUgb3IgbmFtZS5cbiAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtYXJrLlxuICAgICAgICogQHBhcmFtIG9wdGlvbnMuZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgUmVtb3ZlcyB0aGUgbWFyayBldmVuIGFjcm9zcyB0aGUgY3VycmVudCBzZWxlY3Rpb24uIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudG9nZ2xlTWFyaygnYm9sZCcpXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZU1hcms6IChcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtYXJrIHR5cGUgb3IgbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIHR5cGVPck5hbWU6IHN0cmluZyB8IE1hcmtUeXBlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXR0cmlidXRlcyBvZiB0aGUgbWFyay5cbiAgICAgICAgICovXG4gICAgICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuXG4gICAgICAgIG9wdGlvbnM/OiB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmVtb3ZlcyB0aGUgbWFyayBldmVuIGFjcm9zcyB0aGUgY3VycmVudCBzZWxlY3Rpb24uIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U/OiBib29sZWFuXG4gICAgICAgIH0sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvZ2dsZU1hcms6IFJhd0NvbW1hbmRzWyd0b2dnbGVNYXJrJ10gPVxuICAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9LCBvcHRpb25zID0ge30pID0+XG4gICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gICAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zXG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcylcblxuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0eXBlLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodHlwZSwgYXR0cmlidXRlcylcbiAgfVxuIiwgImltcG9ydCB0eXBlIHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBnZXROb2RlVHlwZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0Tm9kZVR5cGUuanMnXG5pbXBvcnQgeyBpc05vZGVBY3RpdmUgfSBmcm9tICcuLi9oZWxwZXJzL2lzTm9kZUFjdGl2ZS5qcydcbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHRvZ2dsZU5vZGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgbm9kZSB3aXRoIGFub3RoZXIgbm9kZS5cbiAgICAgICAqIEBwYXJhbSB0eXBlT3JOYW1lIFRoZSB0eXBlIG9yIG5hbWUgb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gdG9nZ2xlVHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlIHRvIHRvZ2dsZS5cbiAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBub2RlLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZU5vZGUoJ2hlYWRpbmcnLCAncGFyYWdyYXBoJylcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlTm9kZTogKFxuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSxcbiAgICAgICAgdG9nZ2xlVHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsXG4gICAgICAgIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVOb2RlOiBSYXdDb21tYW5kc1sndG9nZ2xlTm9kZSddID1cbiAgKHR5cGVPck5hbWUsIHRvZ2dsZVR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT5cbiAgKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICAgIGNvbnN0IHRvZ2dsZVR5cGUgPSBnZXROb2RlVHlwZSh0b2dnbGVUeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gICAgY29uc3QgaXNBY3RpdmUgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpXG5cbiAgICBsZXQgYXR0cmlidXRlc1RvQ29weTogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZFxuXG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnNhbWVQYXJlbnQoc3RhdGUuc2VsZWN0aW9uLiRoZWFkKSkge1xuICAgICAgLy8gb25seSBjb3B5IGF0dHJpYnV0ZXMgaWYgdGhlIHNlbGVjdGlvbiBpcyBwb2ludGluZyB0byBhIG5vZGUgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgYXR0cmlidXRlc1RvQ29weSA9IHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnBhcmVudC5hdHRyc1xuICAgIH1cblxuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodG9nZ2xlVHlwZSwgYXR0cmlidXRlc1RvQ29weSlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbm9kZSBpcyBub3QgYWN0aXZlLCB3ZSB3YW50IHRvIHNldCB0aGUgbmV3IG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzXG4gICAgLy8gQ29weWluZyBvdmVyIHRoZSBhdHRyaWJ1dGVzIGZyb20gdGhlIGN1cnJlbnQgbm9kZSBpZiB0aGUgc2VsZWN0aW9uIGlzIHBvaW50aW5nIHRvIGEgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodHlwZSwgeyAuLi5hdHRyaWJ1dGVzVG9Db3B5LCAuLi5hdHRyaWJ1dGVzIH0pXG4gIH1cbiIsICJpbXBvcnQgdHlwZSB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHsgaXNOb2RlQWN0aXZlIH0gZnJvbSAnLi4vaGVscGVycy9pc05vZGVBY3RpdmUuanMnXG5pbXBvcnQgdHlwZSB7IFJhd0NvbW1hbmRzIH0gZnJvbSAnLi4vdHlwZXMuanMnXG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0b2dnbGVXcmFwOiB7XG4gICAgICAvKipcbiAgICAgICAqIFdyYXBzIG5vZGVzIGluIGFub3RoZXIgbm9kZSwgb3IgcmVtb3ZlcyBhbiBleGlzdGluZyB3cmFwLlxuICAgICAgICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbm9kZS5cbiAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBub2RlLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVdyYXAoJ2Jsb2NrcXVvdGUnKVxuICAgICAgICovXG4gICAgICB0b2dnbGVXcmFwOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b2dnbGVXcmFwOiBSYXdDb21tYW5kc1sndG9nZ2xlV3JhcCddID1cbiAgKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT5cbiAgKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKVxuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKVxuXG4gICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICByZXR1cm4gY29tbWFuZHMubGlmdCh0eXBlKVxuICAgIH1cblxuICAgIHJldHVybiBjb21tYW5kcy53cmFwSW4odHlwZSwgYXR0cmlidXRlcylcbiAgfVxuIiwgImltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuZG9JbnB1dFJ1bGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogVW5kbyBhbiBpbnB1dCBydWxlLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnVuZG9JbnB1dFJ1bGUoKVxuICAgICAgICovXG4gICAgICB1bmRvSW5wdXRSdWxlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1bmRvSW5wdXRSdWxlOiBSYXdDb21tYW5kc1sndW5kb0lucHV0UnVsZSddID1cbiAgKCkgPT5cbiAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCBwbHVnaW5zID0gc3RhdGUucGx1Z2luc1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zW2ldXG4gICAgICBsZXQgdW5kb2FibGVcblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBpZiAocGx1Z2luLnNwZWMuaXNJbnB1dFJ1bGVzICYmICh1bmRvYWJsZSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSkpKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHJcbiAgICAgICAgICBjb25zdCB0b1VuZG8gPSB1bmRvYWJsZS50cmFuc2Zvcm1cblxuICAgICAgICAgIGZvciAobGV0IGogPSB0b1VuZG8uc3RlcHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqIC09IDEpIHtcbiAgICAgICAgICAgIHRyLnN0ZXAodG9VbmRvLnN0ZXBzW2pdLmludmVydCh0b1VuZG8uZG9jc1tqXSkpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHVuZG9hYmxlLnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gdHIuZG9jLnJlc29sdmUodW5kb2FibGUuZnJvbSkubWFya3MoKVxuXG4gICAgICAgICAgICB0ci5yZXBsYWNlV2l0aCh1bmRvYWJsZS5mcm9tLCB1bmRvYWJsZS50bywgc3RhdGUuc2NoZW1hLnRleHQodW5kb2FibGUudGV4dCwgbWFya3MpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ci5kZWxldGUodW5kb2FibGUuZnJvbSwgdW5kb2FibGUudG8pXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuIiwgImltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuc2V0QWxsTWFya3M6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIGFsbCBtYXJrcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudW5zZXRBbGxNYXJrcygpXG4gICAgICAgKi9cbiAgICAgIHVuc2V0QWxsTWFya3M6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVuc2V0QWxsTWFya3M6IFJhd0NvbW1hbmRzWyd1bnNldEFsbE1hcmtzJ10gPVxuICAoKSA9PlxuICAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICAgIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4iLCAiaW1wb3J0IHR5cGUgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE1hcmtSYW5nZSB9IGZyb20gJy4uL2hlbHBlcnMvZ2V0TWFya1JhbmdlLmpzJ1xuaW1wb3J0IHsgZ2V0TWFya1R5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE1hcmtUeXBlLmpzJ1xuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgdW5zZXRNYXJrOiB7XG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBhbGwgbWFya3MgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG1hcmsgdHlwZSBvciBuYW1lLlxuICAgICAgICogQHBhcmFtIG9wdGlvbnMuZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgUmVtb3ZlcyB0aGUgbWFyayBldmVuIGFjcm9zcyB0aGUgY3VycmVudCBzZWxlY3Rpb24uIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudW5zZXRNYXJrKCdib2xkJylcbiAgICAgICAqL1xuICAgICAgdW5zZXRNYXJrOiAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWFyayB0eXBlIG9yIG5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICB0eXBlT3JOYW1lOiBzdHJpbmcgfCBNYXJrVHlwZSxcblxuICAgICAgICBvcHRpb25zPzoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJlbW92ZXMgdGhlIG1hcmsgZXZlbiBhY3Jvc3MgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGV4dGVuZEVtcHR5TWFya1JhbmdlPzogYm9vbGVhblxuICAgICAgICB9LFxuICAgICAgKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB1bnNldE1hcms6IFJhd0NvbW1hbmRzWyd1bnNldE1hcmsnXSA9XG4gICh0eXBlT3JOYW1lLCBvcHRpb25zID0ge30pID0+XG4gICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0clxuICAgIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG4gICAgY29uc3QgeyAkZnJvbSwgZW1wdHksIHJhbmdlcyB9ID0gc2VsZWN0aW9uXG5cbiAgICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChlbXB0eSAmJiBleHRlbmRFbXB0eU1hcmtSYW5nZSkge1xuICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvblxuICAgICAgY29uc3QgYXR0cnMgPSAkZnJvbS5tYXJrcygpLmZpbmQobWFyayA9PiBtYXJrLnR5cGUgPT09IHR5cGUpPy5hdHRyc1xuICAgICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJGZyb20sIHR5cGUsIGF0dHJzKVxuXG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgZnJvbSA9IHJhbmdlLmZyb21cbiAgICAgICAgdG8gPSByYW5nZS50b1xuICAgICAgfVxuXG4gICAgICB0ci5yZW1vdmVNYXJrKGZyb20sIHRvLCB0eXBlKVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCB0eXBlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKHR5cGUpXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4iLCAiaW1wb3J0IHR5cGUgeyBNYXJrLCBNYXJrVHlwZSwgTm9kZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHR5cGUgeyBTZWxlY3Rpb25SYW5nZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGdldE1hcmtUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrVHlwZS5qcydcbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB7IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lIH0gZnJvbSAnLi4vaGVscGVycy9nZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZS5qcydcbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVwZGF0ZUF0dHJpYnV0ZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIGF0dHJpYnV0ZXMgb2YgYSBub2RlIG9yIG1hcmsuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlIG9yIG1hcmsuXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgYXR0cmlidXRlcyBvZiB0aGUgbm9kZSBvciBtYXJrLlxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnVwZGF0ZUF0dHJpYnV0ZXMoJ21lbnRpb24nLCB7IHVzZXJJZDogXCIyXCIgfSlcbiAgICAgICAqL1xuICAgICAgdXBkYXRlQXR0cmlidXRlczogKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb3IgbmFtZSBvZiB0aGUgbm9kZSBvciBtYXJrLlxuICAgICAgICAgKi9cbiAgICAgICAgdHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUgfCBNYXJrVHlwZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUgb3IgbWFyay5cbiAgICAgICAgICovXG4gICAgICAgIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgICApID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUF0dHJpYnV0ZXM6IFJhd0NvbW1hbmRzWyd1cGRhdGVBdHRyaWJ1dGVzJ10gPVxuICAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PlxuICAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgbm9kZVR5cGU6IE5vZGVUeXBlIHwgbnVsbCA9IG51bGxcbiAgICBsZXQgbWFya1R5cGU6IE1hcmtUeXBlIHwgbnVsbCA9IG51bGxcblxuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShcbiAgICAgIHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsXG4gICAgICBzdGF0ZS5zY2hlbWEsXG4gICAgKVxuXG4gICAgaWYgKCFzY2hlbWFUeXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUgYXMgTm9kZVR5cGUsIHN0YXRlLnNjaGVtYSlcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUgYXMgTWFya1R5cGUsIHN0YXRlLnNjaGVtYSlcbiAgICB9XG5cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaCgocmFuZ2U6IFNlbGVjdGlvblJhbmdlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZyb20gPSByYW5nZS4kZnJvbS5wb3NcbiAgICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zXG5cbiAgICAgICAgbGV0IGxhc3RQb3M6IG51bWJlciB8IHVuZGVmaW5lZFxuICAgICAgICBsZXQgbGFzdE5vZGU6IE5vZGUgfCB1bmRlZmluZWRcbiAgICAgICAgbGV0IHRyaW1tZWRGcm9tOiBudW1iZXJcbiAgICAgICAgbGV0IHRyaW1tZWRUbzogbnVtYmVyXG5cbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlOiBOb2RlLCBwb3M6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pXG4gICAgICAgICAgICAgIHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKVxuICAgICAgICAgICAgICBsYXN0UG9zID0gcG9zXG4gICAgICAgICAgICAgIGxhc3ROb2RlID0gbm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGU6IE5vZGUsIHBvczogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBpZiAocG9zIDwgZnJvbSAmJiBub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgIHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKVxuICAgICAgICAgICAgICB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0bylcbiAgICAgICAgICAgICAgbGFzdFBvcyA9IHBvc1xuICAgICAgICAgICAgICBsYXN0Tm9kZSA9IG5vZGVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykge1xuICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgIC4uLm5vZGUuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobWFya1R5cGUgJiYgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2goKG1hcms6IE1hcmspID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tMiA9IE1hdGgubWF4KHBvcywgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvMiA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKVxuXG4gICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20yLFxuICAgICAgICAgICAgICAgICAgICAgIHRyaW1tZWRUbzIsXG4gICAgICAgICAgICAgICAgICAgICAgbWFya1R5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdE5vZGUpIHtcbiAgICAgICAgICBpZiAobGFzdFBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKGxhc3RQb3MsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAuLi5sYXN0Tm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hcmtUeXBlICYmIGxhc3ROb2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdE5vZGUubWFya3MuZm9yRWFjaCgobWFyazogTWFyaykgPT4ge1xuICAgICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgICB0cmltbWVkRnJvbSxcbiAgICAgICAgICAgICAgICAgIHRyaW1tZWRUbyxcbiAgICAgICAgICAgICAgICAgIG1hcmtUeXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cbiIsICJpbXBvcnQgeyB3cmFwSW4gYXMgb3JpZ2luYWxXcmFwSW4gfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJ1xuaW1wb3J0IHR5cGUgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnLi4vaGVscGVycy9nZXROb2RlVHlwZS5qcydcbmltcG9ydCB0eXBlIHsgUmF3Q29tbWFuZHMgfSBmcm9tICcuLi90eXBlcy5qcydcblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHdyYXBJbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBub2RlcyBpbiBhbm90aGVyIG5vZGUuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlLlxuICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMud3JhcEluKCdibG9ja3F1b3RlJylcbiAgICAgICAqL1xuICAgICAgd3JhcEluOiAodHlwZU9yTmFtZTogc3RyaW5nIHwgTm9kZVR5cGUsIGF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3cmFwSW46IFJhd0NvbW1hbmRzWyd3cmFwSW4nXSA9XG4gICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+XG4gICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICAgIHJldHVybiBvcmlnaW5hbFdyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpXG4gIH1cbiIsICJpbXBvcnQgdHlwZSB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IHdyYXBJbkxpc3QgYXMgb3JpZ2luYWxXcmFwSW5MaXN0IH0gZnJvbSAnQHRpcHRhcC9wbS9zY2hlbWEtbGlzdCdcblxuaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICcuLi9oZWxwZXJzL2dldE5vZGVUeXBlLmpzJ1xuaW1wb3J0IHR5cGUgeyBSYXdDb21tYW5kcyB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgd3JhcEluTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwIGEgbm9kZSBpbiBhIGxpc3QuXG4gICAgICAgKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgdHlwZSBvciBuYW1lIG9mIHRoZSBub2RlLlxuICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUuXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMud3JhcEluTGlzdCgnYnVsbGV0TGlzdCcpXG4gICAgICAgKi9cbiAgICAgIHdyYXBJbkxpc3Q6ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHdyYXBJbkxpc3Q6IFJhd0NvbW1hbmRzWyd3cmFwSW5MaXN0J10gPVxuICAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PlxuICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgICByZXR1cm4gb3JpZ2luYWxXcmFwSW5MaXN0KHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlLCBkaXNwYXRjaClcbiAgfVxuIiwgImltcG9ydCAqIGFzIGNvbW1hbmRzIGZyb20gJy4uL2NvbW1hbmRzL2luZGV4LmpzJ1xuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgKiBmcm9tICcuLi9jb21tYW5kcy9pbmRleC5qcydcblxuZXhwb3J0IGNvbnN0IENvbW1hbmRzID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdjb21tYW5kcycsXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvbW1hbmRzLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUmVtb3ZlTWFya1N0ZXAgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuaW1wb3J0IHsgY29tYmluZVRyYW5zYWN0aW9uU3RlcHMsIGdldENoYW5nZWRSYW5nZXMgfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJ1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdXNlciBkZWxldGVzIGNvbnRlbnQgeW91IGFyZSBpbnRlcmVzdGVkIGluLlxuICovXG5leHBvcnQgY29uc3QgRGVsZXRlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdkZWxldGUnLFxuXG4gIG9uVXBkYXRlKHsgdHJhbnNhY3Rpb24sIGFwcGVuZGVkVHJhbnNhY3Rpb25zIH0pIHtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5lZGl0b3Iub3B0aW9ucy5jb3JlRXh0ZW5zaW9uT3B0aW9ucz8uZGVsZXRlPy5maWx0ZXJUcmFuc2FjdGlvbj8uKHRyYW5zYWN0aW9uKSA/P1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRNZXRhKCd5LXN5bmMkJylcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRUcmFuc2FjdGlvbiA9IGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKHRyYW5zYWN0aW9uLmJlZm9yZSwgW3RyYW5zYWN0aW9uLCAuLi5hcHBlbmRlZFRyYW5zYWN0aW9uc10pXG4gICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0Q2hhbmdlZFJhbmdlcyhuZXh0VHJhbnNhY3Rpb24pXG5cbiAgICAgIGNoYW5nZXMuZm9yRWFjaChjaGFuZ2UgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbmV4dFRyYW5zYWN0aW9uLm1hcHBpbmcubWFwUmVzdWx0KGNoYW5nZS5vbGRSYW5nZS5mcm9tKS5kZWxldGVkQWZ0ZXIgJiZcbiAgICAgICAgICBuZXh0VHJhbnNhY3Rpb24ubWFwcGluZy5tYXBSZXN1bHQoY2hhbmdlLm9sZFJhbmdlLnRvKS5kZWxldGVkQmVmb3JlXG4gICAgICAgICkge1xuICAgICAgICAgIG5leHRUcmFuc2FjdGlvbi5iZWZvcmUubm9kZXNCZXR3ZWVuKGNoYW5nZS5vbGRSYW5nZS5mcm9tLCBjaGFuZ2Uub2xkUmFuZ2UudG8sIChub2RlLCBmcm9tKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBub2RlLm5vZGVTaXplIC0gMlxuICAgICAgICAgICAgY29uc3QgaXNGdWxseVdpdGhpblJhbmdlID0gY2hhbmdlLm9sZFJhbmdlLmZyb20gPD0gZnJvbSAmJiB0byA8PSBjaGFuZ2Uub2xkUmFuZ2UudG9cblxuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdCgnZGVsZXRlJywge1xuICAgICAgICAgICAgICB0eXBlOiAnbm9kZScsXG4gICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICBuZXdGcm9tOiBuZXh0VHJhbnNhY3Rpb24ubWFwcGluZy5tYXAoZnJvbSksXG4gICAgICAgICAgICAgIG5ld1RvOiBuZXh0VHJhbnNhY3Rpb24ubWFwcGluZy5tYXAodG8pLFxuICAgICAgICAgICAgICBkZWxldGVkUmFuZ2U6IGNoYW5nZS5vbGRSYW5nZSxcbiAgICAgICAgICAgICAgbmV3UmFuZ2U6IGNoYW5nZS5uZXdSYW5nZSxcbiAgICAgICAgICAgICAgcGFydGlhbDogIWlzRnVsbHlXaXRoaW5SYW5nZSxcbiAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgIGNvbWJpbmVkVHJhbnNmb3JtOiBuZXh0VHJhbnNhY3Rpb24sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IG1hcHBpbmcgPSBuZXh0VHJhbnNhY3Rpb24ubWFwcGluZ1xuICAgICAgbmV4dFRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goKHN0ZXAsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChzdGVwIGluc3RhbmNlb2YgUmVtb3ZlTWFya1N0ZXApIHtcbiAgICAgICAgICBjb25zdCBuZXdTdGFydCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcChzdGVwLmZyb20sIC0xKVxuICAgICAgICAgIGNvbnN0IG5ld0VuZCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcChzdGVwLnRvKVxuICAgICAgICAgIGNvbnN0IG9sZFN0YXJ0ID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3U3RhcnQsIC0xKVxuICAgICAgICAgIGNvbnN0IG9sZEVuZCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld0VuZClcblxuICAgICAgICAgIGNvbnN0IGZvdW5kQmVmb3JlTWFyayA9IG5leHRUcmFuc2FjdGlvbi5kb2Mubm9kZUF0KG5ld1N0YXJ0IC0gMSk/Lm1hcmtzLnNvbWUobWFyayA9PiBtYXJrLmVxKHN0ZXAubWFyaykpXG4gICAgICAgICAgY29uc3QgZm91bmRBZnRlck1hcmsgPSBuZXh0VHJhbnNhY3Rpb24uZG9jLm5vZGVBdChuZXdFbmQpPy5tYXJrcy5zb21lKG1hcmsgPT4gbWFyay5lcShzdGVwLm1hcmspKVxuXG4gICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdCgnZGVsZXRlJywge1xuICAgICAgICAgICAgdHlwZTogJ21hcmsnLFxuICAgICAgICAgICAgbWFyazogc3RlcC5tYXJrLFxuICAgICAgICAgICAgZnJvbTogc3RlcC5mcm9tLFxuICAgICAgICAgICAgdG86IHN0ZXAudG8sXG4gICAgICAgICAgICBkZWxldGVkUmFuZ2U6IHtcbiAgICAgICAgICAgICAgZnJvbTogb2xkU3RhcnQsXG4gICAgICAgICAgICAgIHRvOiBvbGRFbmQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV3UmFuZ2U6IHtcbiAgICAgICAgICAgICAgZnJvbTogbmV3U3RhcnQsXG4gICAgICAgICAgICAgIHRvOiBuZXdFbmQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFydGlhbDogQm9vbGVhbihmb3VuZEFmdGVyTWFyayB8fCBmb3VuZEJlZm9yZU1hcmspLFxuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgY29tYmluZWRUcmFuc2Zvcm06IG5leHRUcmFuc2FjdGlvbixcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzLmVkaXRvci5vcHRpb25zLmNvcmVFeHRlbnNpb25PcHRpb25zPy5kZWxldGU/LmFzeW5jID8/IHRydWUpIHtcbiAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH0sXG59KVxuIiwgImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgY29uc3QgRHJvcCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnZHJvcCcsXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCd0aXB0YXBEcm9wJyksXG5cbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVEcm9wOiAoXywgZSwgc2xpY2UsIG1vdmVkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5lbWl0KCdkcm9wJywge1xuICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgc2xpY2UsXG4gICAgICAgICAgICAgIG1vdmVkLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcblxuZXhwb3J0IGNvbnN0IEVkaXRhYmxlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdlZGl0YWJsZScsXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdlZGl0YWJsZScpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIGVkaXRhYmxlOiAoKSA9PiB0aGlzLmVkaXRvci5vcHRpb25zLmVkaXRhYmxlLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcblxuZXhwb3J0IGNvbnN0IGZvY3VzRXZlbnRzUGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleSgnZm9jdXNFdmVudHMnKVxuXG5leHBvcnQgY29uc3QgRm9jdXNFdmVudHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ2ZvY3VzRXZlbnRzJyxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXNcblxuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBmb2N1c0V2ZW50c1BsdWdpbktleSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgIGZvY3VzOiAodmlldywgZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgIGVkaXRvci5pc0ZvY3VzZWQgPSB0cnVlXG5cbiAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBlZGl0b3Iuc3RhdGUudHIuc2V0TWV0YSgnZm9jdXMnLCB7IGV2ZW50IH0pLnNldE1ldGEoJ2FkZFRvSGlzdG9yeScsIGZhbHNlKVxuXG4gICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pXG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmx1cjogKHZpZXcsIGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuaXNGb2N1c2VkID0gZmFsc2VcblxuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGVkaXRvci5zdGF0ZS50ci5zZXRNZXRhKCdibHVyJywgeyBldmVudCB9KS5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSlcblxuICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKVxuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSwgU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgQ29tbWFuZE1hbmFnZXIgfSBmcm9tICcuLi9Db21tYW5kTWFuYWdlci5qcydcbmltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJy4uL0V4dGVuc2lvbi5qcydcbmltcG9ydCB7IGNyZWF0ZUNoYWluYWJsZVN0YXRlIH0gZnJvbSAnLi4vaGVscGVycy9jcmVhdGVDaGFpbmFibGVTdGF0ZS5qcydcbmltcG9ydCB7IGlzTm9kZUVtcHR5IH0gZnJvbSAnLi4vaGVscGVycy9pc05vZGVFbXB0eS5qcydcbmltcG9ydCB7IGlzaU9TIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2lzaU9TLmpzJ1xuaW1wb3J0IHsgaXNNYWNPUyB9IGZyb20gJy4uL3V0aWxpdGllcy9pc01hY09TLmpzJ1xuXG5leHBvcnQgY29uc3QgS2V5bWFwID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdrZXltYXAnLFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIGNvbnN0IGhhbmRsZUJhY2tzcGFjZSA9ICgpID0+XG4gICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAgICgpID0+IGNvbW1hbmRzLnVuZG9JbnB1dFJ1bGUoKSxcblxuICAgICAgICAvLyBtYXliZSBjb252ZXJ0IGZpcnN0IHRleHQgYmxvY2sgbm9kZSB0byBkZWZhdWx0IG5vZGVcbiAgICAgICAgKCkgPT5cbiAgICAgICAgICBjb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHRyXG4gICAgICAgICAgICBjb25zdCB7IGVtcHR5LCAkYW5jaG9yIH0gPSBzZWxlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHsgcG9zLCBwYXJlbnQgfSA9ICRhbmNob3JcbiAgICAgICAgICAgIGNvbnN0ICRwYXJlbnRQb3MgPSAkYW5jaG9yLnBhcmVudC5pc1RleHRibG9jayAmJiBwb3MgPiAwID8gdHIuZG9jLnJlc29sdmUocG9zIC0gMSkgOiAkYW5jaG9yXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRJc0lzb2xhdGluZyA9ICRwYXJlbnRQb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmdcblxuICAgICAgICAgICAgY29uc3QgcGFyZW50UG9zID0gJGFuY2hvci5wb3MgLSAkYW5jaG9yLnBhcmVudE9mZnNldFxuXG4gICAgICAgICAgICBjb25zdCBpc0F0U3RhcnQgPVxuICAgICAgICAgICAgICBwYXJlbnRJc0lzb2xhdGluZyAmJiAkcGFyZW50UG9zLnBhcmVudC5jaGlsZENvdW50ID09PSAxXG4gICAgICAgICAgICAgICAgPyBwYXJlbnRQb3MgPT09ICRhbmNob3IucG9zXG4gICAgICAgICAgICAgICAgOiBTZWxlY3Rpb24uYXRTdGFydChkb2MpLmZyb20gPT09IHBvc1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFlbXB0eSB8fFxuICAgICAgICAgICAgICAhcGFyZW50LnR5cGUuaXNUZXh0YmxvY2sgfHxcbiAgICAgICAgICAgICAgcGFyZW50LnRleHRDb250ZW50Lmxlbmd0aCB8fFxuICAgICAgICAgICAgICAhaXNBdFN0YXJ0IHx8XG4gICAgICAgICAgICAgIChpc0F0U3RhcnQgJiYgJGFuY2hvci5wYXJlbnQudHlwZS5uYW1lID09PSAncGFyYWdyYXBoJykgLy8gcHJldmVudCBjbGVhck5vZGVzIHdoZW4gbm8gbm9kZXMgdG8gY2xlYXIsIG90aGVyd2lzZSBoaXN0b3J5IHN0YWNrIGlzIGFwcGVuZGVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgICAgICB9KSxcblxuICAgICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVTZWxlY3Rpb24oKSxcbiAgICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkJhY2t3YXJkKCksXG4gICAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVCYWNrd2FyZCgpLFxuICAgICAgXSlcblxuICAgIGNvbnN0IGhhbmRsZURlbGV0ZSA9ICgpID0+XG4gICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVDdXJyZW50Tm9kZSgpLFxuICAgICAgICAoKSA9PiBjb21tYW5kcy5qb2luRm9yd2FyZCgpLFxuICAgICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlRm9yd2FyZCgpLFxuICAgICAgXSlcblxuICAgIGNvbnN0IGhhbmRsZUVudGVyID0gKCkgPT5cbiAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICAgKCkgPT4gY29tbWFuZHMubmV3bGluZUluQ29kZSgpLFxuICAgICAgICAoKSA9PiBjb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKCksXG4gICAgICAgICgpID0+IGNvbW1hbmRzLmxpZnRFbXB0eUJsb2NrKCksXG4gICAgICAgICgpID0+IGNvbW1hbmRzLnNwbGl0QmxvY2soKSxcbiAgICAgIF0pXG5cbiAgICBjb25zdCBiYXNlS2V5bWFwID0ge1xuICAgICAgRW50ZXI6IGhhbmRsZUVudGVyLFxuICAgICAgJ01vZC1FbnRlcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICBCYWNrc3BhY2U6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdNb2QtQmFja3NwYWNlJzogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgJ1NoaWZ0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgIERlbGV0ZTogaGFuZGxlRGVsZXRlLFxuICAgICAgJ01vZC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnTW9kLWEnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RBbGwoKSxcbiAgICB9XG5cbiAgICBjb25zdCBwY0tleW1hcCA9IHtcbiAgICAgIC4uLmJhc2VLZXltYXAsXG4gICAgfVxuXG4gICAgY29uc3QgbWFjS2V5bWFwID0ge1xuICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICAgICdDdHJsLWgnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAnQWx0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICdDdHJsLWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQ3RybC1BbHQtQmFja3NwYWNlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgJ0FsdC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQWx0LWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAnQ3RybC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKSxcbiAgICAgICdDdHJsLWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RUZXh0YmxvY2tFbmQoKSxcbiAgICB9XG5cbiAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcbiAgICAgIHJldHVybiBtYWNLZXltYXBcbiAgICB9XG5cbiAgICByZXR1cm4gcGNLZXltYXBcbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIFdpdGggdGhpcyBwbHVnaW4gd2UgY2hlY2sgaWYgdGhlIHdob2xlIGRvY3VtZW50IHdhcyBzZWxlY3RlZCBhbmQgZGVsZXRlZC5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGFkZGl0aW9uYWxseSBjYWxsIGBjbGVhck5vZGVzKClgIHRvIGNvbnZlcnQgZS5nLiBhIGhlYWRpbmdcbiAgICAgIC8vIHRvIGEgcGFyYWdyYXBoIGlmIG5lY2Vzc2FyeS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gUHJvc2VNaXJyb3IncyBgQWxsU2VsZWN0aW9uYCwgd2hpY2ggZG9lc27igJl0IHdvcmsgd2VsbFxuICAgICAgLy8gd2l0aCBtYW55IG90aGVyIGNvbW1hbmRzLlxuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY2xlYXJEb2N1bWVudCcpLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKHRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmdldE1ldGEoJ2NvbXBvc2l0aW9uJykpKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCkgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpXG5cbiAgICAgICAgICBjb25zdCBpZ25vcmVUciA9IHRyYW5zYWN0aW9ucy5zb21lKHRyYW5zYWN0aW9uID0+IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3ByZXZlbnRDbGVhckRvY3VtZW50JykpXG5cbiAgICAgICAgICBpZiAoIWRvY0NoYW5nZXMgfHwgaWdub3JlVHIpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgZW1wdHksIGZyb20sIHRvIH0gPSBvbGRTdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgICBjb25zdCBhbGxGcm9tID0gU2VsZWN0aW9uLmF0U3RhcnQob2xkU3RhdGUuZG9jKS5mcm9tXG4gICAgICAgICAgY29uc3QgYWxsRW5kID0gU2VsZWN0aW9uLmF0RW5kKG9sZFN0YXRlLmRvYykudG9cbiAgICAgICAgICBjb25zdCBhbGxXYXNTZWxlY3RlZCA9IGZyb20gPT09IGFsbEZyb20gJiYgdG8gPT09IGFsbEVuZFxuXG4gICAgICAgICAgaWYgKGVtcHR5IHx8ICFhbGxXYXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNFbXB0eSA9IGlzTm9kZUVtcHR5KG5ld1N0YXRlLmRvYylcblxuICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdHIgPSBuZXdTdGF0ZS50clxuICAgICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgY29uc3QgeyBjb21tYW5kcyB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29tbWFuZHMuY2xlYXJOb2RlcygpXG5cbiAgICAgICAgICBpZiAoIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRyXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnLi4vRXh0ZW5zaW9uLmpzJ1xuXG5leHBvcnQgY29uc3QgUGFzdGUgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgbmFtZTogJ3Bhc3RlJyxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ3RpcHRhcFBhc3RlJyksXG5cbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVQYXN0ZTogKF92aWV3LCBlLCBzbGljZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdCgncGFzdGUnLCB7XG4gICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgICAgICBzbGljZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICcuLi9FeHRlbnNpb24uanMnXG5cbmV4cG9ydCBjb25zdCBUYWJpbmRleCA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAndGFiaW5kZXgnLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgndGFiaW5kZXgnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBhdHRyaWJ1dGVzOiAoKTogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH0gPT4gKHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgPyB7IHRhYmluZGV4OiAnMCcgfSA6IHt9KSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHR5cGUgeyBGcmFnbWVudCwgTm9kZSwgUmVzb2x2ZWRQb3MgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgdHlwZSB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHR5cGUgeyBDb250ZW50LCBSYW5nZSB9IGZyb20gJy4vdHlwZXMuanMnXG5cbmV4cG9ydCBjbGFzcyBOb2RlUG9zIHtcbiAgcHJpdmF0ZSByZXNvbHZlZFBvczogUmVzb2x2ZWRQb3NcblxuICBwcml2YXRlIGlzQmxvY2s6IGJvb2xlYW5cblxuICBwcml2YXRlIGVkaXRvcjogRWRpdG9yXG5cbiAgcHJpdmF0ZSBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5vZGUudHlwZS5uYW1lXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwb3M6IFJlc29sdmVkUG9zLCBlZGl0b3I6IEVkaXRvciwgaXNCbG9jayA9IGZhbHNlLCBub2RlOiBOb2RlIHwgbnVsbCA9IG51bGwpIHtcbiAgICB0aGlzLmlzQmxvY2sgPSBpc0Jsb2NrXG4gICAgdGhpcy5yZXNvbHZlZFBvcyA9IHBvc1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGVcbiAgfVxuXG4gIHByaXZhdGUgY3VycmVudE5vZGU6IE5vZGUgfCBudWxsID0gbnVsbFxuXG4gIGdldCBub2RlKCk6IE5vZGUge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnROb2RlIHx8IHRoaXMucmVzb2x2ZWRQb3Mubm9kZSgpXG4gIH1cblxuICBnZXQgZWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tQXRQb3ModGhpcy5wb3MpLm5vZGUgYXMgSFRNTEVsZW1lbnRcbiAgfVxuXG4gIHB1YmxpYyBhY3R1YWxEZXB0aDogbnVtYmVyIHwgbnVsbCA9IG51bGxcblxuICBnZXQgZGVwdGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5hY3R1YWxEZXB0aCA/PyB0aGlzLnJlc29sdmVkUG9zLmRlcHRoXG4gIH1cblxuICBnZXQgcG9zKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3MucG9zXG4gIH1cblxuICBnZXQgY29udGVudCgpOiBGcmFnbWVudCB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5jb250ZW50XG4gIH1cblxuICBzZXQgY29udGVudChjb250ZW50OiBDb250ZW50KSB7XG4gICAgbGV0IGZyb20gPSB0aGlzLmZyb21cbiAgICBsZXQgdG8gPSB0aGlzLnRvXG5cbiAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICBpZiAodGhpcy5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgWW91IGNhbuKAmXQgc2V0IGNvbnRlbnQgb24gYSBibG9jayBub2RlLiBUcmllZCB0byBzZXQgY29udGVudCBvbiAke3RoaXMubmFtZX0gYXQgJHt0aGlzLnBvc31gKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgZnJvbSA9IHRoaXMuZnJvbSArIDFcbiAgICAgIHRvID0gdGhpcy50byAtIDFcbiAgICB9XG5cbiAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5pbnNlcnRDb250ZW50QXQoeyBmcm9tLCB0byB9LCBjb250ZW50KVxuICB9XG5cbiAgZ2V0IGF0dHJpYnV0ZXMoKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5hdHRyc1xuICB9XG5cbiAgZ2V0IHRleHRDb250ZW50KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS50ZXh0Q29udGVudFxuICB9XG5cbiAgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplXG4gIH1cblxuICBnZXQgZnJvbSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLmlzQmxvY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnBvc1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpXG4gIH1cblxuICBnZXQgcmFuZ2UoKTogUmFuZ2Uge1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICB0bzogdGhpcy50byxcbiAgICB9XG4gIH1cblxuICBnZXQgdG8oKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3MgKyB0aGlzLnNpemVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFBvcy5lbmQodGhpcy5yZXNvbHZlZFBvcy5kZXB0aCkgKyAodGhpcy5ub2RlLmlzVGV4dCA/IDAgOiAxKVxuICB9XG5cbiAgZ2V0IHBhcmVudCgpOiBOb2RlUG9zIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMuZGVwdGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50UG9zID0gdGhpcy5yZXNvbHZlZFBvcy5zdGFydCh0aGlzLnJlc29sdmVkUG9zLmRlcHRoIC0gMSlcbiAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZShwYXJlbnRQb3MpXG5cbiAgICByZXR1cm4gbmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IpXG4gIH1cblxuICBnZXQgYmVmb3JlKCk6IE5vZGVQb3MgfCBudWxsIHtcbiAgICBsZXQgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy5mcm9tIC0gKHRoaXMuaXNCbG9jayA/IDEgOiAyKSlcblxuICAgIGlmICgkcG9zLmRlcHRoICE9PSB0aGlzLmRlcHRoKSB7XG4gICAgICAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLmZyb20gLSAzKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcilcbiAgfVxuXG4gIGdldCBhZnRlcigpOiBOb2RlUG9zIHwgbnVsbCB7XG4gICAgbGV0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMudG8gKyAodGhpcy5pc0Jsb2NrID8gMiA6IDEpKVxuXG4gICAgaWYgKCRwb3MuZGVwdGggIT09IHRoaXMuZGVwdGgpIHtcbiAgICAgICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMudG8gKyAzKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcilcbiAgfVxuXG4gIGdldCBjaGlsZHJlbigpOiBOb2RlUG9zW10ge1xuICAgIGNvbnN0IGNoaWxkcmVuOiBOb2RlUG9zW10gPSBbXVxuXG4gICAgdGhpcy5ub2RlLmNvbnRlbnQuZm9yRWFjaCgobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBpc0Jsb2NrID0gbm9kZS5pc0Jsb2NrICYmICFub2RlLmlzVGV4dGJsb2NrXG4gICAgICBjb25zdCBpc05vblRleHRBdG9tID0gbm9kZS5pc0F0b20gJiYgIW5vZGUuaXNUZXh0XG5cbiAgICAgIGNvbnN0IHRhcmdldFBvcyA9IHRoaXMucG9zICsgb2Zmc2V0ICsgKGlzTm9uVGV4dEF0b20gPyAwIDogMSlcblxuICAgICAgLy8gQ2hlY2sgaWYgdGFyZ2V0UG9zIGlzIHdpdGhpbiB2YWxpZCBkb2N1bWVudCByYW5nZVxuICAgICAgaWYgKHRhcmdldFBvcyA8IDAgfHwgdGFyZ2V0UG9zID4gdGhpcy5yZXNvbHZlZFBvcy5kb2Mubm9kZVNpemUgLSAyKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0YXJnZXRQb3MpXG5cbiAgICAgIGlmICghaXNCbG9jayAmJiAkcG9zLmRlcHRoIDw9IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkTm9kZVBvcyA9IG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yLCBpc0Jsb2NrLCBpc0Jsb2NrID8gbm9kZSA6IG51bGwpXG5cbiAgICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgIGNoaWxkTm9kZVBvcy5hY3R1YWxEZXB0aCA9IHRoaXMuZGVwdGggKyAxXG4gICAgICB9XG5cbiAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IsIGlzQmxvY2ssIGlzQmxvY2sgPyBub2RlIDogbnVsbCkpXG4gICAgfSlcblxuICAgIHJldHVybiBjaGlsZHJlblxuICB9XG5cbiAgZ2V0IGZpcnN0Q2hpbGQoKTogTm9kZVBvcyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdIHx8IG51bGxcbiAgfVxuXG4gIGdldCBsYXN0Q2hpbGQoKTogTm9kZVBvcyB8IG51bGwge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlblxuXG4gICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIHx8IG51bGxcbiAgfVxuXG4gIGNsb3Nlc3Qoc2VsZWN0b3I6IHN0cmluZywgYXR0cmlidXRlczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9KTogTm9kZVBvcyB8IG51bGwge1xuICAgIGxldCBub2RlOiBOb2RlUG9zIHwgbnVsbCA9IG51bGxcbiAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLnBhcmVudFxuXG4gICAgd2hpbGUgKGN1cnJlbnROb2RlICYmICFub2RlKSB7XG4gICAgICBpZiAoY3VycmVudE5vZGUubm9kZS50eXBlLm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZUF0dHJpYnV0ZXMgPSBjdXJyZW50Tm9kZS5ub2RlLmF0dHJzXG4gICAgICAgICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKVxuXG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGF0dHJLZXlzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXR0cktleXNbaW5kZXhdXG5cbiAgICAgICAgICAgIGlmIChub2RlQXR0cmlidXRlc1trZXldICE9PSBhdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IGN1cnJlbnROb2RlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnRcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgcXVlcnlTZWxlY3RvcihzZWxlY3Rvcjogc3RyaW5nLCBhdHRyaWJ1dGVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge30pOiBOb2RlUG9zIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcywgdHJ1ZSlbMF0gfHwgbnVsbFxuICB9XG5cbiAgcXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcjogc3RyaW5nLCBhdHRyaWJ1dGVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9ID0ge30sIGZpcnN0SXRlbU9ubHkgPSBmYWxzZSk6IE5vZGVQb3NbXSB7XG4gICAgbGV0IG5vZGVzOiBOb2RlUG9zW10gPSBbXVxuXG4gICAgaWYgKCF0aGlzLmNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYWxsIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5IHRoYXQgbWF0Y2ggdGhlIHNlbGVjdG9yIGFuZCBhdHRyaWJ1dGVzXG4gICAgICogSWYgZmlyc3RJdGVtT25seSBpcyB0cnVlLCBpdCB3aWxsIHJldHVybiB0aGUgZmlyc3QgaXRlbSBmb3VuZFxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZFBvcyA9PiB7XG4gICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgbm9kZSBhbmQgd2Ugb25seSB3YW50IHRoZSBmaXJzdCBpdGVtLCB3ZSBkb250IG5lZWQgdG8ga2VlcCBnb2luZ1xuICAgICAgaWYgKGZpcnN0SXRlbU9ubHkgJiYgbm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkUG9zLm5vZGUudHlwZS5uYW1lID09PSBzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBkb2VzQWxsQXR0cmlidXRlc01hdGNoID0gYXR0cktleXMuZXZlcnkoa2V5ID0+IGF0dHJpYnV0ZXNba2V5XSA9PT0gY2hpbGRQb3Mubm9kZS5hdHRyc1trZXldKVxuXG4gICAgICAgIGlmIChkb2VzQWxsQXR0cmlidXRlc01hdGNoKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChjaGlsZFBvcylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgbm9kZSBhbmQgd2Ugb25seSB3YW50IHRoZSBmaXJzdCBpdGVtLCB3ZSBjYW4gc3RvcCBoZXJlIGFuZCBza2lwIHRoZSByZWN1cnNpb25cbiAgICAgIGlmIChmaXJzdEl0ZW1Pbmx5ICYmIG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGNoaWxkUG9zLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMsIGZpcnN0SXRlbU9ubHkpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gbm9kZXNcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSB7XG4gICAgY29uc3QgeyB0ciB9ID0gdGhpcy5lZGl0b3Iuc3RhdGVcblxuICAgIHRyLnNldE5vZGVNYXJrdXAodGhpcy5mcm9tLCB1bmRlZmluZWQsIHtcbiAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcbiAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgfSlcblxuICAgIHRoaXMuZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpXG4gIH1cbn1cbiIsICJleHBvcnQgY29uc3Qgc3R5bGUgPSBgLlByb3NlTWlycm9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uUHJvc2VNaXJyb3Ige1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlcztcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IFwibGlnYVwiIDA7IC8qIHRoZSBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBFZGdlICovXG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0ge1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4uUHJvc2VNaXJyb3IgcHJlIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG5pbWcuUHJvc2VNaXJyb3Itc2VwYXJhdG9yIHtcbiAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7XG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgd2lkdGg6IDAgIWltcG9ydGFudDtcbiAgaGVpZ2h0OiAwICFpbXBvcnRhbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBub25lO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBtYXJnaW46IDA7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3I6YWZ0ZXIge1xuICBjb250ZW50OiBcIlwiO1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IC0ycHg7XG4gIHdpZHRoOiAyMHB4O1xuICBib3JkZXItdG9wOiAxcHggc29saWQgYmxhY2s7XG4gIGFuaW1hdGlvbjogUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIDEuMXMgc3RlcHMoMiwgc3RhcnQpIGluZmluaXRlO1xufVxuXG5Aa2V5ZnJhbWVzIFByb3NlTWlycm9yLWN1cnNvci1ibGluayB7XG4gIHRvIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6c2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6Oi1tb3otc2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICoge1xuICBjYXJldC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1mb2N1c2VkIC5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBibG9jaztcbn1gXG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlVGFnKHN0eWxlOiBzdHJpbmcsIG5vbmNlPzogc3RyaW5nLCBzdWZmaXg/OiBzdHJpbmcpOiBIVE1MU3R5bGVFbGVtZW50IHtcbiAgY29uc3QgdGlwdGFwU3R5bGVUYWcgPSA8SFRNTFN0eWxlRWxlbWVudD4oXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS10aXB0YXAtc3R5bGUke3N1ZmZpeCA/IGAtJHtzdWZmaXh9YCA6ICcnfV1gKVxuICApXG5cbiAgaWYgKHRpcHRhcFN0eWxlVGFnICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRpcHRhcFN0eWxlVGFnXG4gIH1cblxuICBjb25zdCBzdHlsZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSlcbiAgfVxuXG4gIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoYGRhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJ31gLCAnJylcbiAgc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxlXG4gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGVOb2RlKVxuXG4gIHJldHVybiBzdHlsZU5vZGVcbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya3NCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrc0JldHdlZW4uanMnXG5pbXBvcnQgdHlwZSB7IElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IElucHV0UnVsZSB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB0eXBlIHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9kb2NzL2VkaXRvci9leHRlbnNpb25zL2N1c3RvbS1leHRlbnNpb25zL2V4dGVuZC1leGlzdGluZyNpbnB1dC1ydWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFya0lucHV0UnVsZShjb25maWc6IHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyXG4gIHR5cGU6IE1hcmtUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB8IGZhbHNlIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKVxuXG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZVxuICAgICAgY29uc3QgY2FwdHVyZUdyb3VwID0gbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV1cbiAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdXG5cbiAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRTcGFjZXMgPSBmdWxsTWF0Y2guc2VhcmNoKC9cXFMvKVxuICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKVxuICAgICAgICBjb25zdCB0ZXh0RW5kID0gdGV4dFN0YXJ0ICsgY2FwdHVyZUdyb3VwLmxlbmd0aFxuXG4gICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYylcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZCBhcyBNYXJrVHlwZVtdXG5cbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKHR5cGUgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS50byA+IHRleHRTdGFydClcblxuICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbmQgPCByYW5nZS50bykge1xuICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50bylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICB0ci5hZGRNYXJrKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgbWFya0VuZCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMgfHwge30pKVxuXG4gICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpXG4gICAgICB9XG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgdHlwZSB7IE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHR5cGUgeyBJbnB1dFJ1bGVGaW5kZXIgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgdHlwZSB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgYWRkcyBhIG5vZGUgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjaW5wdXQtcnVsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vZGVJbnB1dFJ1bGUoY29uZmlnOiB7XG4gIC8qKlxuICAgKiBUaGUgcmVnZXggdG8gbWF0Y2guXG4gICAqL1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcblxuICAvKipcbiAgICogVGhlIG5vZGUgdHlwZSB0byBhZGQuXG4gICAqL1xuICB0eXBlOiBOb2RlVHlwZVxuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIG5vZGVcbiAgICogY2FuIGFsc28gYmUgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB8IGZhbHNlIHwgbnVsbFxufSkge1xuICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fVxuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICAgIGNvbnN0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgbGV0IGVuZCA9IHJhbmdlLnRvXG5cbiAgICAgIGNvbnN0IG5ld05vZGUgPSBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcylcblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuICAgICAgICBsZXQgbWF0Y2hTdGFydCA9IHN0YXJ0ICsgb2Zmc2V0XG5cbiAgICAgICAgaWYgKG1hdGNoU3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICBtYXRjaFN0YXJ0ID0gZW5kXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gbWF0Y2hTdGFydCArIG1hdGNoWzFdLmxlbmd0aFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5zZXJ0IGxhc3QgdHlwZWQgY2hhcmFjdGVyXG4gICAgICAgIGNvbnN0IGxhc3RDaGFyID0gbWF0Y2hbMF1bbWF0Y2hbMF0ubGVuZ3RoIC0gMV1cblxuICAgICAgICB0ci5pbnNlcnRUZXh0KGxhc3RDaGFyLCBzdGFydCArIG1hdGNoWzBdLmxlbmd0aCAtIDEpXG5cbiAgICAgICAgLy8gaW5zZXJ0IG5vZGUgZnJvbSBpbnB1dCBydWxlXG4gICAgICAgIHRyLnJlcGxhY2VXaXRoKG1hdGNoU3RhcnQsIGVuZCwgbmV3Tm9kZSlcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0pIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0aW9uU3RhcnQgPSBjb25maWcudHlwZS5pc0lubGluZSA/IHN0YXJ0IDogc3RhcnQgLSAxXG5cbiAgICAgICAgdHIuaW5zZXJ0KGluc2VydGlvblN0YXJ0LCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcykpLmRlbGV0ZSh0ci5tYXBwaW5nLm1hcChzdGFydCksIHRyLm1hcHBpbmcubWFwKGVuZCkpXG4gICAgICB9XG5cbiAgICAgIHRyLnNjcm9sbEludG9WaWV3KClcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB0eXBlIHsgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgdHlwZSB7IElucHV0UnVsZUZpbmRlciB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB7IElucHV0UnVsZSB9IGZyb20gJy4uL0lucHV0UnVsZS5qcydcbmltcG9ydCB0eXBlIHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBjaGFuZ2VzIHRoZSB0eXBlIG9mIGEgdGV4dGJsb2NrIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC4gV2hlbiB1c2luZyBhIHJlZ3VsYXIgZXhwcmVzaW9uIHlvdeKAmWxsXG4gKiBwcm9iYWJseSB3YW50IHRoZSByZWdleHAgdG8gc3RhcnQgd2l0aCBgXmAsIHNvIHRoYXQgdGhlIHBhdHRlcm4gY2FuXG4gKiBvbmx5IG9jY3VyIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI2lucHV0LXJ1bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKGNvbmZpZzoge1xuICBmaW5kOiBJbnB1dFJ1bGVGaW5kZXJcbiAgdHlwZTogTm9kZVR5cGVcbiAgZ2V0QXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4gfCAoKG1hdGNoOiBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXkpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pIHwgZmFsc2UgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGNvbnN0ICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fVxuXG4gICAgICBpZiAoISRzdGFydC5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkc3RhcnQuaW5kZXgoLTEpLCAkc3RhcnQuaW5kZXhBZnRlcigtMSksIGNvbmZpZy50eXBlKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBzdGF0ZS50ci5kZWxldGUocmFuZ2UuZnJvbSwgcmFuZ2UudG8pLnNldEJsb2NrVHlwZShyYW5nZS5mcm9tLCByYW5nZS5mcm9tLCBjb25maWcudHlwZSwgYXR0cmlidXRlcylcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB0eXBlIHsgSW5wdXRSdWxlRmluZGVyIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuaW1wb3J0IHsgSW5wdXRSdWxlIH0gZnJvbSAnLi4vSW5wdXRSdWxlLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI2lucHV0LXJ1bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0SW5wdXRSdWxlKGNvbmZpZzogeyBmaW5kOiBJbnB1dFJ1bGVGaW5kZXI7IHJlcGxhY2U6IHN0cmluZyB9KSB7XG4gIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGxldCBpbnNlcnQgPSBjb25maWcucmVwbGFjZVxuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG9cblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuXG4gICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldFxuXG4gICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kXG5cbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnRcbiAgICAgICAgICBzdGFydCA9IGVuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSwgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgY2FuSm9pbiwgZmluZFdyYXBwaW5nIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nXG5cbmltcG9ydCB0eXBlIHsgRWRpdG9yIH0gZnJvbSAnLi4vRWRpdG9yLmpzJ1xuaW1wb3J0IHR5cGUgeyBJbnB1dFJ1bGVGaW5kZXIgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgeyBJbnB1dFJ1bGUgfSBmcm9tICcuLi9JbnB1dFJ1bGUuanMnXG5pbXBvcnQgdHlwZSB7IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSB9IGZyb20gJy4uL3R5cGVzLmpzJ1xuaW1wb3J0IHsgY2FsbE9yUmV0dXJuIH0gZnJvbSAnLi4vdXRpbGl0aWVzL2NhbGxPclJldHVybi5qcydcblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIGEgdGV4dGJsb2NrIHdoZW4gYVxuICogZ2l2ZW4gc3RyaW5nIGlzIHR5cGVkLiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNpb24geW914oCZbGxcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICpcbiAqIGB0eXBlYCBpcyB0aGUgdHlwZSBvZiBub2RlIHRvIHdyYXAgaW4uXG4gKlxuICogQnkgZGVmYXVsdCwgaWYgdGhlcmXigJlzIGEgbm9kZSB3aXRoIHRoZSBzYW1lIHR5cGUgYWJvdmUgdGhlIG5ld2x5XG4gKiB3cmFwcGVkIG5vZGUsIHRoZSBydWxlIHdpbGwgdHJ5IHRvIGpvaW4gdGhvc2VcbiAqIHR3byBub2Rlcy4gWW91IGNhbiBwYXNzIGEgam9pbiBwcmVkaWNhdGUsIHdoaWNoIHRha2VzIGEgcmVndWxhclxuICogZXhwcmVzc2lvbiBtYXRjaCBhbmQgdGhlIG5vZGUgYmVmb3JlIHRoZSB3cmFwcGVkIG5vZGUsIGFuZCBjYW5cbiAqIHJldHVybiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciBhIGpvaW4gc2hvdWxkIGhhcHBlbi5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI2lucHV0LXJ1bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwcGluZ0lucHV0UnVsZShjb25maWc6IHtcbiAgZmluZDogSW5wdXRSdWxlRmluZGVyXG4gIHR5cGU6IE5vZGVUeXBlXG4gIGtlZXBNYXJrcz86IGJvb2xlYW5cbiAga2VlcEF0dHJpYnV0ZXM/OiBib29sZWFuXG4gIGVkaXRvcj86IEVkaXRvclxuICBnZXRBdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55PiB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSkgPT4gUmVjb3JkPHN0cmluZywgYW55PikgfCBmYWxzZSB8IG51bGxcbiAgam9pblByZWRpY2F0ZT86IChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LCBub2RlOiBQcm9zZU1pcnJvck5vZGUpID0+IGJvb2xlYW5cbn0pIHtcbiAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2gsIGNoYWluIH0pID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9XG4gICAgICBjb25zdCB0ciA9IHN0YXRlLnRyLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgIGNvbnN0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pXG4gICAgICBjb25zdCBibG9ja1JhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKVxuICAgICAgY29uc3Qgd3JhcHBpbmcgPSBibG9ja1JhbmdlICYmIGZpbmRXcmFwcGluZyhibG9ja1JhbmdlLCBjb25maWcudHlwZSwgYXR0cmlidXRlcylcblxuICAgICAgaWYgKCF3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICB0ci53cmFwKGJsb2NrUmFuZ2UsIHdyYXBwaW5nKVxuXG4gICAgICBpZiAoY29uZmlnLmtlZXBNYXJrcyAmJiBjb25maWcuZWRpdG9yKSB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGVcbiAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGNvbmZpZy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlclxuICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcblxuICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSlcblxuICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgLyoqIElmIHRoZSBub2RlVHlwZSBpcyBgYnVsbGV0TGlzdGAgb3IgYG9yZGVyZWRMaXN0YCBzZXQgdGhlIGBub2RlVHlwZWAgYXMgYGxpc3RJdGVtYCAqL1xuICAgICAgICBjb25zdCBub2RlVHlwZSA9XG4gICAgICAgICAgY29uZmlnLnR5cGUubmFtZSA9PT0gJ2J1bGxldExpc3QnIHx8IGNvbmZpZy50eXBlLm5hbWUgPT09ICdvcmRlcmVkTGlzdCcgPyAnbGlzdEl0ZW0nIDogJ3Rhc2tMaXN0J1xuXG4gICAgICAgIGNoYWluKCkudXBkYXRlQXR0cmlidXRlcyhub2RlVHlwZSwgYXR0cmlidXRlcykucnVuKClcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSAtIDEpLm5vZGVCZWZvcmVcblxuICAgICAgaWYgKFxuICAgICAgICBiZWZvcmUgJiZcbiAgICAgICAgYmVmb3JlLnR5cGUgPT09IGNvbmZpZy50eXBlICYmXG4gICAgICAgIGNhbkpvaW4odHIuZG9jLCByYW5nZS5mcm9tIC0gMSkgJiZcbiAgICAgICAgKCFjb25maWcuam9pblByZWRpY2F0ZSB8fCBjb25maWcuam9pblByZWRpY2F0ZShtYXRjaCwgYmVmb3JlKSlcbiAgICAgICkge1xuICAgICAgICB0ci5qb2luKHJhbmdlLmZyb20gLSAxKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiZXhwb3J0IHR5cGUgQXR0cmlidXRlcyA9IFJlY29yZDxzdHJpbmcsIGFueT5cblxuZXhwb3J0IHR5cGUgRE9NT3V0cHV0U3BlY0VsZW1lbnQgPSAwIHwgQXR0cmlidXRlcyB8IERPTU91dHB1dFNwZWNBcnJheVxuLyoqXG4gKiBCZXR0ZXIgZGVzY3JpYmVzIHRoZSBvdXRwdXQgb2YgYSBgcmVuZGVySFRNTGAgZnVuY3Rpb24gaW4gcHJvc2VtaXJyb3JcbiAqIEBzZWUgaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTU91dHB1dFNwZWNcbiAqL1xuZXhwb3J0IHR5cGUgRE9NT3V0cHV0U3BlY0FycmF5ID1cbiAgfCBbc3RyaW5nXVxuICB8IFtzdHJpbmcsIEF0dHJpYnV0ZXNdXG4gIHwgW3N0cmluZywgMF1cbiAgfCBbc3RyaW5nLCBBdHRyaWJ1dGVzLCAwXVxuICB8IFtzdHJpbmcsIEF0dHJpYnV0ZXMsIERPTU91dHB1dFNwZWNBcnJheSB8IDBdXG4gIHwgW3N0cmluZywgRE9NT3V0cHV0U3BlY0FycmF5XVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbmFtZXNwYWNlXG4gIG5hbWVzcGFjZSBKU1gge1xuICAgIC8vIEB0cy1pZ25vcmUgLSBjb25mbGljdCB3aXRoIFJlYWN0IHR5cGluZ3NcbiAgICB0eXBlIEVsZW1lbnQgPSBbc3RyaW5nLCAuLi5hbnlbXV1cbiAgICAvLyBAdHMtaWdub3JlIC0gY29uZmxpY3Qgd2l0aCBSZWFjdCB0eXBpbmdzXG4gICAgaW50ZXJmYWNlIEludHJpbnNpY0VsZW1lbnRzIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgLSBjb25mbGljdCB3aXRoIFJlYWN0IHR5cGluZ3NcbiAgICAgIFtrZXk6IHN0cmluZ106IGFueVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBKU1hSZW5kZXJlciA9IChcbiAgdGFnOiAnc2xvdCcgfCBzdHJpbmcgfCAoKHByb3BzPzogQXR0cmlidXRlcykgPT4gRE9NT3V0cHV0U3BlY0FycmF5IHwgRE9NT3V0cHV0U3BlY0VsZW1lbnQpLFxuICBwcm9wcz86IEF0dHJpYnV0ZXMsXG4gIC4uLmNoaWxkcmVuOiBKU1hSZW5kZXJlcltdXG4pID0+IERPTU91dHB1dFNwZWNBcnJheSB8IERPTU91dHB1dFNwZWNFbGVtZW50XG5cbmV4cG9ydCBmdW5jdGlvbiBGcmFnbWVudChwcm9wczogeyBjaGlsZHJlbjogSlNYUmVuZGVyZXJbXSB9KSB7XG4gIHJldHVybiBwcm9wcy5jaGlsZHJlblxufVxuXG5leHBvcnQgY29uc3QgaDogSlNYUmVuZGVyZXIgPSAodGFnLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIC8vIFRyZWF0IHRoZSBzbG90IHRhZyBhcyB0aGUgUHJvc2VtaXJyb3IgaG9sZSB0byByZW5kZXIgY29udGVudCBpbnRvXG4gIGlmICh0YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiAwXG4gIH1cblxuICAvLyBJZiB0aGUgdGFnIGlzIGEgZnVuY3Rpb24sIGNhbGwgaXQgd2l0aCB0aGUgcHJvcHNcbiAgaWYgKHRhZyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHRhZyhhdHRyaWJ1dGVzKVxuICB9XG5cbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gYXR0cmlidXRlcyA/PyB7fVxuXG4gIGlmICh0YWcgPT09ICdzdmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTVkcgZWxlbWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEpTWCBzeW50YXgsIHVzZSB0aGUgYXJyYXkgc3ludGF4IGluc3RlYWQnKVxuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIHRhZywgYXR0cmlidXRlcywgYW5kIGNoaWxkcmVuXG4gIHJldHVybiBbdGFnLCByZXN0LCBjaGlsZHJlbl1cbn1cblxuLy8gU2VlXG4vLyBodHRwczovL2VzYnVpbGQuZ2l0aHViLmlvL2FwaS8janN4LWltcG9ydC1zb3VyY2Vcbi8vIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy90c2NvbmZpZy8janN4SW1wb3J0U291cmNlXG5cbmV4cG9ydCB7IGggYXMgY3JlYXRlRWxlbWVudCwgaCBhcyBqc3gsIGggYXMganN4REVWLCBoIGFzIGpzeHMgfVxuIiwgIi8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY5Njk0ODZcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVGb3JSZWdFeChzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpXG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xufVxuIiwgImltcG9ydCB0eXBlIHsgVmlld011dGF0aW9uUmVjb3JkIH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5pbXBvcnQgdHlwZSB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHR5cGUgeyBNYXJrVmlld1Byb3BzLCBNYXJrVmlld1JlbmRlcmVyT3B0aW9ucyB9IGZyb20gJy4vdHlwZXMuanMnXG5pbXBvcnQgeyBpc0FuZHJvaWQsIGlzaU9TIH0gZnJvbSAnLi91dGlsaXRpZXMvaW5kZXguanMnXG5cbmV4cG9ydCBjbGFzcyBNYXJrVmlldzxDb21wb25lbnQsIE9wdGlvbnMgZXh0ZW5kcyBNYXJrVmlld1JlbmRlcmVyT3B0aW9ucyA9IE1hcmtWaWV3UmVuZGVyZXJPcHRpb25zPiB7XG4gIGNvbXBvbmVudDogQ29tcG9uZW50XG4gIGVkaXRvcjogRWRpdG9yXG4gIG9wdGlvbnM6IE9wdGlvbnNcbiAgbWFyazogTWFya1ZpZXdQcm9wc1snbWFyayddXG4gIEhUTUxBdHRyaWJ1dGVzOiBNYXJrVmlld1Byb3BzWydIVE1MQXR0cmlidXRlcyddXG5cbiAgY29uc3RydWN0b3IoY29tcG9uZW50OiBDb21wb25lbnQsIHByb3BzOiBNYXJrVmlld1Byb3BzLCBvcHRpb25zPzogUGFydGlhbDxPcHRpb25zPikge1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50XG4gICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3JcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfSBhcyBPcHRpb25zXG4gICAgdGhpcy5tYXJrID0gcHJvcHMubWFya1xuICAgIHRoaXMuSFRNTEF0dHJpYnV0ZXMgPSBwcm9wcy5IVE1MQXR0cmlidXRlc1xuICB9XG5cbiAgZ2V0IGRvbSgpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tXG4gIH1cblxuICBnZXQgY29udGVudERPTSgpOiBIVE1MRWxlbWVudCB8IG51bGwge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbjogVmlld011dGF0aW9uUmVjb3JkKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uKHsgbXV0YXRpb24gfSlcbiAgICB9XG5cbiAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ3NlbGVjdGlvbicpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMuZG9tLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkgJiZcbiAgICAgIG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnICYmXG4gICAgICAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSkgJiZcbiAgICAgIHRoaXMuZWRpdG9yLmlzRm9jdXNlZFxuICAgICkge1xuICAgICAgY29uc3QgY2hhbmdlZE5vZGVzID0gWy4uLkFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcyksIC4uLkFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKV0gYXMgSFRNTEVsZW1lbnRbXVxuXG4gICAgICBpZiAoY2hhbmdlZE5vZGVzLmV2ZXJ5KG5vZGUgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IERPTU91dHB1dFNwZWMsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlLCBOb2RlU3BlYywgTm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgdHlwZSB7IEVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHR5cGUgeyBFeHRlbmRhYmxlQ29uZmlnIH0gZnJvbSAnLi9FeHRlbmRhYmxlLmpzJ1xuaW1wb3J0IHsgRXh0ZW5kYWJsZSB9IGZyb20gJy4vRXh0ZW5kYWJsZS5qcydcbmltcG9ydCB0eXBlIHsgQXR0cmlidXRlcywgTm9kZVZpZXdSZW5kZXJlciwgUGFyZW50Q29uZmlnIH0gZnJvbSAnLi90eXBlcy5qcydcblxuZXhwb3J0IGludGVyZmFjZSBOb2RlQ29uZmlnPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+XG4gIGV4dGVuZHMgRXh0ZW5kYWJsZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlLCBOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+LCBOb2RlVHlwZT4ge1xuICAvKipcbiAgICogTm9kZSBWaWV3XG4gICAqL1xuICBhZGROb2RlVmlldz86XG4gICAgfCAoKHRoaXM6IHtcbiAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICBlZGl0b3I6IEVkaXRvclxuICAgICAgICB0eXBlOiBOb2RlVHlwZVxuICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYWRkTm9kZVZpZXcnXVxuICAgICAgfSkgPT4gTm9kZVZpZXdSZW5kZXJlcilcbiAgICB8IG51bGxcblxuICAvKipcbiAgICogRGVmaW5lcyBpZiB0aGlzIG5vZGUgc2hvdWxkIGJlIGEgdG9wIGxldmVsIG5vZGUgKGRvYylcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgdG9wTm9kZT86IGJvb2xlYW5cblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgZXhwcmVzc2lvbiBmb3IgdGhpcyBub2RlLCBhcyBkZXNjcmliZWQgaW4gdGhlIFtzY2hlbWFcbiAgICogZ3VpZGVdKC9kb2NzL2d1aWRlLyNzY2hlbWEuY29udGVudF9leHByZXNzaW9ucykuIFdoZW4gbm90IGdpdmVuLFxuICAgKiB0aGUgbm9kZSBkb2VzIG5vdCBhbGxvdyBhbnkgY29udGVudC5cbiAgICpcbiAgICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgaXQgb24gdGhlIFByb3NlbWlycm9yIGRvY3VtZW50YXRpb24gaGVyZVxuICAgKiBAc2VlIGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI3NjaGVtYS5jb250ZW50X2V4cHJlc3Npb25zXG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAZXhhbXBsZSBjb250ZW50OiAnYmxvY2srJ1xuICAgKiBAZXhhbXBsZSBjb250ZW50OiAnaGVhZGxpbmUgcGFyYWdyYXBoIGJsb2NrKidcbiAgICovXG4gIGNvbnRlbnQ/OlxuICAgIHwgTm9kZVNwZWNbJ2NvbnRlbnQnXVxuICAgIHwgKCh0aGlzOiB7XG4gICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2NvbnRlbnQnXVxuICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgIH0pID0+IE5vZGVTcGVjWydjb250ZW50J10pXG5cbiAgLyoqXG4gICAqIFRoZSBtYXJrcyB0aGF0IGFyZSBhbGxvd2VkIGluc2lkZSBvZiB0aGlzIG5vZGUuIE1heSBiZSBhXG4gICAqIHNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgcmVmZXJyaW5nIHRvIG1hcmsgbmFtZXMgb3IgZ3JvdXBzLCBgXCJfXCJgXG4gICAqIHRvIGV4cGxpY2l0bHkgYWxsb3cgYWxsIG1hcmtzLCBvciBgXCJcImAgdG8gZGlzYWxsb3cgbWFya3MuIFdoZW5cbiAgICogbm90IGdpdmVuLCBub2RlcyB3aXRoIGlubGluZSBjb250ZW50IGRlZmF1bHQgdG8gYWxsb3dpbmcgYWxsXG4gICAqIG1hcmtzLCBvdGhlciBub2RlcyBkZWZhdWx0IHRvIG5vdCBhbGxvd2luZyBtYXJrcy5cbiAgICpcbiAgICogQGV4YW1wbGUgbWFya3M6ICdzdHJvbmcgZW0nXG4gICAqL1xuICBtYXJrcz86XG4gICAgfCBOb2RlU3BlY1snbWFya3MnXVxuICAgIHwgKCh0aGlzOiB7XG4gICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ21hcmtzJ11cbiAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICB9KSA9PiBOb2RlU3BlY1snbWFya3MnXSlcblxuICAvKipcbiAgICogVGhlIGdyb3VwIG9yIHNwYWNlLXNlcGFyYXRlZCBncm91cHMgdG8gd2hpY2ggdGhpcyBub2RlIGJlbG9uZ3MsXG4gICAqIHdoaWNoIGNhbiBiZSByZWZlcnJlZCB0byBpbiB0aGUgY29udGVudCBleHByZXNzaW9ucyBmb3IgdGhlXG4gICAqIHNjaGVtYS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCBUaXB0YXAgdXNlcyB0aGUgZ3JvdXBzICdibG9jaycgYW5kICdpbmxpbmUnIGZvciBub2Rlcy4gWW91XG4gICAqIGNhbiBhbHNvIHVzZSBjdXN0b20gZ3JvdXBzIGlmIHlvdSB3YW50IHRvIGdyb3VwIHNwZWNpZmljIG5vZGVzIHRvZ2V0aGVyXG4gICAqIGFuZCBoYW5kbGUgdGhlbSBpbiB5b3VyIHNjaGVtYS5cbiAgICogQGV4YW1wbGUgZ3JvdXA6ICdibG9jaydcbiAgICogQGV4YW1wbGUgZ3JvdXA6ICdpbmxpbmUnXG4gICAqIEBleGFtcGxlIGdyb3VwOiAnY3VzdG9tQmxvY2snIC8vIHRoaXMgdXNlcyBhIGN1c3RvbSBncm91cFxuICAgKi9cbiAgZ3JvdXA/OlxuICAgIHwgTm9kZVNwZWNbJ2dyb3VwJ11cbiAgICB8ICgodGhpczoge1xuICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydncm91cCddXG4gICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgfSkgPT4gTm9kZVNwZWNbJ2dyb3VwJ10pXG5cbiAgLyoqXG4gICAqIFNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBmb3IgaW5saW5lIG5vZGVzLiAoSW1wbGllZCBmb3IgdGV4dCBub2Rlcy4pXG4gICAqL1xuICBpbmxpbmU/OlxuICAgIHwgTm9kZVNwZWNbJ2lubGluZSddXG4gICAgfCAoKHRoaXM6IHtcbiAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnaW5saW5lJ11cbiAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICB9KSA9PiBOb2RlU3BlY1snaW5saW5lJ10pXG5cbiAgLyoqXG4gICAqIENhbiBiZSBzZXQgdG8gdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0LCB0aG91Z2ggdGhpcyBpc24ndCBhIFtsZWFmXG4gICAqIG5vZGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5pc0xlYWYpLCBpdCBkb2Vzbid0IGhhdmUgZGlyZWN0bHkgZWRpdGFibGVcbiAgICogY29udGVudCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBzaW5nbGUgdW5pdCBpbiB0aGUgdmlldy5cbiAgICpcbiAgICogQGV4YW1wbGUgYXRvbTogdHJ1ZVxuICAgKi9cbiAgYXRvbT86XG4gICAgfCBOb2RlU3BlY1snYXRvbSddXG4gICAgfCAoKHRoaXM6IHtcbiAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnYXRvbSddXG4gICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgfSkgPT4gTm9kZVNwZWNbJ2F0b20nXSlcblxuICAvKipcbiAgICogQ29udHJvbHMgd2hldGhlciBub2RlcyBvZiB0aGlzIHR5cGUgY2FuIGJlIHNlbGVjdGVkIGFzIGEgW25vZGVcbiAgICogc2VsZWN0aW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuTm9kZVNlbGVjdGlvbikuIERlZmF1bHRzIHRvIHRydWUgZm9yIG5vbi10ZXh0XG4gICAqIG5vZGVzLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqIEBleGFtcGxlIHNlbGVjdGFibGU6IGZhbHNlXG4gICAqL1xuICBzZWxlY3RhYmxlPzpcbiAgICB8IE5vZGVTcGVjWydzZWxlY3RhYmxlJ11cbiAgICB8ICgodGhpczoge1xuICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydzZWxlY3RhYmxlJ11cbiAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICB9KSA9PiBOb2RlU3BlY1snc2VsZWN0YWJsZSddKVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgbm9kZXMgb2YgdGhpcyB0eXBlIGNhbiBiZSBkcmFnZ2VkIHdpdGhvdXRcbiAgICogYmVpbmcgc2VsZWN0ZWQuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKlxuICAgKiBAZGVmYXVsdDogZmFsc2VcbiAgICogQGV4YW1wbGU6IGRyYWdnYWJsZTogdHJ1ZVxuICAgKi9cbiAgZHJhZ2dhYmxlPzpcbiAgICB8IE5vZGVTcGVjWydkcmFnZ2FibGUnXVxuICAgIHwgKCh0aGlzOiB7XG4gICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2RyYWdnYWJsZSddXG4gICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgfSkgPT4gTm9kZVNwZWNbJ2RyYWdnYWJsZSddKVxuXG4gIC8qKlxuICAgKiBDYW4gYmUgdXNlZCB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgbm9kZSBjb250YWlucyBjb2RlLCB3aGljaFxuICAgKiBjYXVzZXMgc29tZSBjb21tYW5kcyB0byBiZWhhdmUgZGlmZmVyZW50bHkuXG4gICAqL1xuICBjb2RlPzpcbiAgICB8IE5vZGVTcGVjWydjb2RlJ11cbiAgICB8ICgodGhpczoge1xuICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+Wydjb2RlJ11cbiAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICB9KSA9PiBOb2RlU3BlY1snY29kZSddKVxuXG4gIC8qKlxuICAgKiBDb250cm9scyB3YXkgd2hpdGVzcGFjZSBpbiB0aGlzIGEgbm9kZSBpcyBwYXJzZWQuIFRoZSBkZWZhdWx0IGlzXG4gICAqIGBcIm5vcm1hbFwiYCwgd2hpY2ggY2F1c2VzIHRoZSBbRE9NIHBhcnNlcl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTVBhcnNlcikgdG9cbiAgICogY29sbGFwc2Ugd2hpdGVzcGFjZSBpbiBub3JtYWwgbW9kZSwgYW5kIG5vcm1hbGl6ZSBpdCAocmVwbGFjaW5nXG4gICAqIG5ld2xpbmVzIGFuZCBzdWNoIHdpdGggc3BhY2VzKSBvdGhlcndpc2UuIGBcInByZVwiYCBjYXVzZXMgdGhlXG4gICAqIHBhcnNlciB0byBwcmVzZXJ2ZSBzcGFjZXMgaW5zaWRlIHRoZSBub2RlLiBXaGVuIHRoaXMgb3B0aW9uIGlzbid0XG4gICAqIGdpdmVuLCBidXQgW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIGlzIHRydWUsIGB3aGl0ZXNwYWNlYFxuICAgKiB3aWxsIGRlZmF1bHQgdG8gYFwicHJlXCJgLiBOb3RlIHRoYXQgdGhpcyBvcHRpb24gZG9lc24ndCBpbmZsdWVuY2VcbiAgICogdGhlIHdheSB0aGUgbm9kZSBpcyByZW5kZXJlZOKAlHRoYXQgc2hvdWxkIGJlIGhhbmRsZWQgYnkgYHRvRE9NYFxuICAgKiBhbmQvb3Igc3R5bGluZy5cbiAgICovXG4gIHdoaXRlc3BhY2U/OlxuICAgIHwgTm9kZVNwZWNbJ3doaXRlc3BhY2UnXVxuICAgIHwgKCh0aGlzOiB7XG4gICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3doaXRlc3BhY2UnXVxuICAgICAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAgIH0pID0+IE5vZGVTcGVjWyd3aGl0ZXNwYWNlJ10pXG5cbiAgLyoqXG4gICAqIEFsbG93cyBhICoqc2luZ2xlKiogbm9kZSB0byBiZSBzZXQgYXMgbGluZWJyZWFrIGVxdWl2YWxlbnQgKGUuZy4gaGFyZEJyZWFrKS5cbiAgICogV2hlbiBjb252ZXJ0aW5nIGJldHdlZW4gYmxvY2sgdHlwZXMgdGhhdCBoYXZlIHdoaXRlc3BhY2Ugc2V0IHRvIFwicHJlXCJcbiAgICogYW5kIGRvbid0IHN1cHBvcnQgdGhlIGxpbmVicmVhayBub2RlIChlLmcuIGNvZGVCbG9jaykgYW5kIG90aGVyIGJsb2NrIHR5cGVzXG4gICAqIHRoYXQgZG8gc3VwcG9ydCB0aGUgbGluZWJyZWFrIG5vZGUgKGUuZy4gcGFyYWdyYXBocykgLSB0aGlzIG5vZGUgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSBsaW5lYnJlYWsgaW5zdGVhZCBvZiBzdHJpcHBpbmcgdGhlIG5ld2xpbmUuXG4gICAqXG4gICAqIFNlZSBbbGluZWJyZWFrUmVwbGFjZW1lbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5saW5lYnJlYWtSZXBsYWNlbWVudCkuXG4gICAqL1xuICBsaW5lYnJlYWtSZXBsYWNlbWVudD86XG4gICAgfCBOb2RlU3BlY1snbGluZWJyZWFrUmVwbGFjZW1lbnQnXVxuICAgIHwgKCh0aGlzOiB7XG4gICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ2xpbmVicmVha1JlcGxhY2VtZW50J11cbiAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICB9KSA9PiBOb2RlU3BlY1snbGluZWJyZWFrUmVwbGFjZW1lbnQnXSlcblxuICAvKipcbiAgICogV2hlbiBlbmFibGVkLCBlbmFibGVzIGJvdGhcbiAgICogW2BkZWZpbmluZ0FzQ29udGV4dGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZ0FzQ29udGV4dCkgYW5kXG4gICAqIFtgZGVmaW5pbmdGb3JDb250ZW50YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nRm9yQ29udGVudCkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBleGFtcGxlIGlzb2xhdGluZzogdHJ1ZVxuICAgKi9cbiAgZGVmaW5pbmc/OlxuICAgIHwgTm9kZVNwZWNbJ2RlZmluaW5nJ11cbiAgICB8ICgodGhpczoge1xuICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydkZWZpbmluZyddXG4gICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgfSkgPT4gTm9kZVNwZWNbJ2RlZmluaW5nJ10pXG5cbiAgLyoqXG4gICAqIFdoZW4gZW5hYmxlZCAoZGVmYXVsdCBpcyBmYWxzZSksIHRoZSBzaWRlcyBvZiBub2RlcyBvZiB0aGlzIHR5cGVcbiAgICogY291bnQgYXMgYm91bmRhcmllcyB0aGF0IHJlZ3VsYXIgZWRpdGluZyBvcGVyYXRpb25zLCBsaWtlXG4gICAqIGJhY2tzcGFjaW5nIG9yIGxpZnRpbmcsIHdvbid0IGNyb3NzLiBBbiBleGFtcGxlIG9mIGEgbm9kZSB0aGF0XG4gICAqIHNob3VsZCBwcm9iYWJseSBoYXZlIHRoaXMgZW5hYmxlZCBpcyBhIHRhYmxlIGNlbGwuXG4gICAqL1xuICBpc29sYXRpbmc/OlxuICAgIHwgTm9kZVNwZWNbJ2lzb2xhdGluZyddXG4gICAgfCAoKHRoaXM6IHtcbiAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsnaXNvbGF0aW5nJ11cbiAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICB9KSA9PiBOb2RlU3BlY1snaXNvbGF0aW5nJ10pXG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZXMgRE9NIHBhcnNlciBpbmZvcm1hdGlvbiB3aXRoIHRoaXMgbm9kZSwgd2hpY2ggY2FuIGJlXG4gICAqIHVzZWQgYnkgW2BET01QYXJzZXIuZnJvbVNjaGVtYWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01QYXJzZXJeZnJvbVNjaGVtYSkgdG9cbiAgICogYXV0b21hdGljYWxseSBkZXJpdmUgYSBwYXJzZXIuIFRoZSBgbm9kZWAgZmllbGQgaW4gdGhlIHJ1bGVzIGlzXG4gICAqIGltcGxpZWQgKHRoZSBuYW1lIG9mIHRoaXMgbm9kZSB3aWxsIGJlIGZpbGxlZCBpbiBhdXRvbWF0aWNhbGx5KS5cbiAgICogSWYgeW91IHN1cHBseSB5b3VyIG93biBwYXJzZXIsIHlvdSBkbyBub3QgbmVlZCB0byBhbHNvIHNwZWNpZnlcbiAgICogcGFyc2luZyBydWxlcyBpbiB5b3VyIHNjaGVtYS5cbiAgICpcbiAgICogQGV4YW1wbGUgcGFyc2VIVE1MOiBbeyB0YWc6ICdkaXYnLCBhdHRyczogeyAnZGF0YS1pZCc6ICdteS1ibG9jaycgfSB9XVxuICAgKi9cbiAgcGFyc2VIVE1MPzogKHRoaXM6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgc3RvcmFnZTogU3RvcmFnZVxuICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydwYXJzZUhUTUwnXVxuICAgIGVkaXRvcj86IEVkaXRvclxuICB9KSA9PiBOb2RlU3BlY1sncGFyc2VET00nXVxuXG4gIC8qKlxuICAgKiBBIGRlc2NyaXB0aW9uIG9mIGEgRE9NIHN0cnVjdHVyZS4gQ2FuIGJlIGVpdGhlciBhIHN0cmluZywgd2hpY2ggaXNcbiAgICogaW50ZXJwcmV0ZWQgYXMgYSB0ZXh0IG5vZGUsIGEgRE9NIG5vZGUsIHdoaWNoIGlzIGludGVycHJldGVkIGFzXG4gICAqIGl0c2VsZiwgYSBge2RvbSwgY29udGVudERPTX1gIG9iamVjdCwgb3IgYW4gYXJyYXkuXG4gICAqXG4gICAqIEFuIGFycmF5IGRlc2NyaWJlcyBhIERPTSBlbGVtZW50LiBUaGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFycmF5XG4gICAqIHNob3VsZCBiZSBhIHN0cmluZ+KAlHRoZSBuYW1lIG9mIHRoZSBET00gZWxlbWVudCwgb3B0aW9uYWxseSBwcmVmaXhlZFxuICAgKiBieSBhIG5hbWVzcGFjZSBVUkwgYW5kIGEgc3BhY2UuIElmIHRoZSBzZWNvbmQgZWxlbWVudCBpcyBwbGFpblxuICAgKiBvYmplY3QsIGl0IGlzIGludGVycHJldGVkIGFzIGEgc2V0IG9mIGF0dHJpYnV0ZXMgZm9yIHRoZSBlbGVtZW50LlxuICAgKiBBbnkgZWxlbWVudHMgYWZ0ZXIgdGhhdCAoaW5jbHVkaW5nIHRoZSAybmQgaWYgaXQncyBub3QgYW4gYXR0cmlidXRlXG4gICAqIG9iamVjdCkgYXJlIGludGVycHJldGVkIGFzIGNoaWxkcmVuIG9mIHRoZSBET00gZWxlbWVudHMsIGFuZCBtdXN0XG4gICAqIGVpdGhlciBiZSB2YWxpZCBgRE9NT3V0cHV0U3BlY2AgdmFsdWVzLCBvciB0aGUgbnVtYmVyIHplcm8uXG4gICAqXG4gICAqIFRoZSBudW1iZXIgemVybyAocHJvbm91bmNlZCDigJxob2xl4oCdKSBpcyB1c2VkIHRvIGluZGljYXRlIHRoZSBwbGFjZVxuICAgKiB3aGVyZSBhIG5vZGUncyBjaGlsZCBub2RlcyBzaG91bGQgYmUgaW5zZXJ0ZWQuIElmIGl0IG9jY3VycyBpbiBhblxuICAgKiBvdXRwdXQgc3BlYywgaXQgc2hvdWxkIGJlIHRoZSBvbmx5IGNoaWxkIGVsZW1lbnQgaW4gaXRzIHBhcmVudFxuICAgKiBub2RlLlxuICAgKlxuICAgKiBAZXhhbXBsZSB0b0RPTTogWydkaXZbZGF0YS1pZD1cIm15LWJsb2NrXCJdJywgeyBjbGFzczogJ215LWJsb2NrJyB9LCAwXVxuICAgKi9cbiAgcmVuZGVySFRNTD86XG4gICAgfCAoKFxuICAgICAgICB0aGlzOiB7XG4gICAgICAgICAgbmFtZTogc3RyaW5nXG4gICAgICAgICAgb3B0aW9uczogT3B0aW9uc1xuICAgICAgICAgIHN0b3JhZ2U6IFN0b3JhZ2VcbiAgICAgICAgICBwYXJlbnQ6IFBhcmVudENvbmZpZzxOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PlsncmVuZGVySFRNTCddXG4gICAgICAgICAgZWRpdG9yPzogRWRpdG9yXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgbm9kZTogUHJvc2VNaXJyb3JOb2RlXG4gICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICAgICAgfSxcbiAgICAgICkgPT4gRE9NT3V0cHV0U3BlYylcbiAgICB8IG51bGxcblxuICAvKipcbiAgICogcmVuZGVycyB0aGUgbm9kZSBhcyB0ZXh0XG4gICAqIEBleGFtcGxlIHJlbmRlclRleHQ6ICgpID0+ICdmb29cbiAgICovXG4gIHJlbmRlclRleHQ/OlxuICAgIHwgKChcbiAgICAgICAgdGhpczoge1xuICAgICAgICAgIG5hbWU6IHN0cmluZ1xuICAgICAgICAgIG9wdGlvbnM6IE9wdGlvbnNcbiAgICAgICAgICBzdG9yYWdlOiBTdG9yYWdlXG4gICAgICAgICAgcGFyZW50OiBQYXJlbnRDb25maWc8Tm9kZUNvbmZpZzxPcHRpb25zLCBTdG9yYWdlPj5bJ3JlbmRlclRleHQnXVxuICAgICAgICAgIGVkaXRvcj86IEVkaXRvclxuICAgICAgICB9LFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuICAgICAgICAgIHBvczogbnVtYmVyXG4gICAgICAgICAgcGFyZW50OiBQcm9zZU1pcnJvck5vZGVcbiAgICAgICAgICBpbmRleDogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICApID0+IHN0cmluZylcbiAgICB8IG51bGxcblxuICAvKipcbiAgICogQWRkIGF0dHJpYnV0ZXMgdG8gdGhlIG5vZGVcbiAgICogQGV4YW1wbGUgYWRkQXR0cmlidXRlczogKCkgPT4gKHsgY2xhc3M6ICdmb28nIH0pXG4gICAqL1xuICBhZGRBdHRyaWJ1dGVzPzogKHRoaXM6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgc3RvcmFnZTogU3RvcmFnZVxuICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucywgU3RvcmFnZT4+WydhZGRBdHRyaWJ1dGVzJ11cbiAgICBlZGl0b3I/OiBFZGl0b3JcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LW9iamVjdC10eXBlXG4gIH0pID0+IEF0dHJpYnV0ZXMgfCB7fVxufVxuXG4vKipcbiAqIFRoZSBOb2RlIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGN1c3RvbSBub2RlIGV4dGVuc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucyNjcmVhdGUtYS1uZXctZXh0ZW5zaW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlPE9wdGlvbnMgPSBhbnksIFN0b3JhZ2UgPSBhbnk+IGV4dGVuZHMgRXh0ZW5kYWJsZTxPcHRpb25zLCBTdG9yYWdlLCBOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+PiB7XG4gIHR5cGUgPSAnbm9kZSdcblxuICBzdGF0aWMgY3JlYXRlPE8gPSBhbnksIFMgPSBhbnk+KGNvbmZpZzogUGFydGlhbDxOb2RlQ29uZmlnPE8sIFM+PiA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlPE8sIFM+KGNvbmZpZylcbiAgfVxuXG4gIGNvbmZpZ3VyZShvcHRpb25zPzogUGFydGlhbDxPcHRpb25zPikge1xuICAgIHJldHVybiBzdXBlci5jb25maWd1cmUob3B0aW9ucykgYXMgTm9kZTxPcHRpb25zLCBTdG9yYWdlPlxuICB9XG5cbiAgZXh0ZW5kPFxuICAgIEV4dGVuZGVkT3B0aW9ucyA9IE9wdGlvbnMsXG4gICAgRXh0ZW5kZWRTdG9yYWdlID0gU3RvcmFnZSxcbiAgICBFeHRlbmRlZENvbmZpZyA9IE5vZGVDb25maWc8RXh0ZW5kZWRPcHRpb25zLCBFeHRlbmRlZFN0b3JhZ2U+LFxuICA+KGV4dGVuZGVkQ29uZmlnPzogUGFydGlhbDxFeHRlbmRlZENvbmZpZz4pIHtcbiAgICByZXR1cm4gc3VwZXIuZXh0ZW5kKGV4dGVuZGVkQ29uZmlnKSBhcyBOb2RlPEV4dGVuZGVkT3B0aW9ucywgRXh0ZW5kZWRTdG9yYWdlPlxuICB9XG59XG4iLCAiaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgdHlwZSB7IE5vZGVWaWV3IGFzIFByb3NlTWlycm9yTm9kZVZpZXcsIFZpZXdNdXRhdGlvblJlY29yZCB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHR5cGUgeyBFZGl0b3IgYXMgQ29yZUVkaXRvciB9IGZyb20gJy4vRWRpdG9yLmpzJ1xuaW1wb3J0IHR5cGUgeyBEZWNvcmF0aW9uV2l0aFR5cGUsIE5vZGVWaWV3UmVuZGVyZXJPcHRpb25zLCBOb2RlVmlld1JlbmRlcmVyUHJvcHMgfSBmcm9tICcuL3R5cGVzLmpzJ1xuaW1wb3J0IHsgaXNBbmRyb2lkIH0gZnJvbSAnLi91dGlsaXRpZXMvaXNBbmRyb2lkLmpzJ1xuaW1wb3J0IHsgaXNpT1MgfSBmcm9tICcuL3V0aWxpdGllcy9pc2lPUy5qcydcblxuLyoqXG4gKiBOb2RlIHZpZXdzIGFyZSB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgcmVuZGVyZWQgRE9NIHN0cnVjdHVyZSBvZiBhIG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9ub2RlLXZpZXdzXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlVmlldzxcbiAgQ29tcG9uZW50LFxuICBOb2RlRWRpdG9yIGV4dGVuZHMgQ29yZUVkaXRvciA9IENvcmVFZGl0b3IsXG4gIE9wdGlvbnMgZXh0ZW5kcyBOb2RlVmlld1JlbmRlcmVyT3B0aW9ucyA9IE5vZGVWaWV3UmVuZGVyZXJPcHRpb25zLFxuPiBpbXBsZW1lbnRzIFByb3NlTWlycm9yTm9kZVZpZXdcbntcbiAgY29tcG9uZW50OiBDb21wb25lbnRcblxuICBlZGl0b3I6IE5vZGVFZGl0b3JcblxuICBvcHRpb25zOiBPcHRpb25zXG5cbiAgZXh0ZW5zaW9uOiBOb2RlVmlld1JlbmRlcmVyUHJvcHNbJ2V4dGVuc2lvbiddXG5cbiAgbm9kZTogTm9kZVZpZXdSZW5kZXJlclByb3BzWydub2RlJ11cblxuICBkZWNvcmF0aW9uczogTm9kZVZpZXdSZW5kZXJlclByb3BzWydkZWNvcmF0aW9ucyddXG5cbiAgaW5uZXJEZWNvcmF0aW9uczogTm9kZVZpZXdSZW5kZXJlclByb3BzWydpbm5lckRlY29yYXRpb25zJ11cblxuICB2aWV3OiBOb2RlVmlld1JlbmRlcmVyUHJvcHNbJ3ZpZXcnXVxuXG4gIGdldFBvczogTm9kZVZpZXdSZW5kZXJlclByb3BzWydnZXRQb3MnXVxuXG4gIEhUTUxBdHRyaWJ1dGVzOiBOb2RlVmlld1JlbmRlcmVyUHJvcHNbJ0hUTUxBdHRyaWJ1dGVzJ11cblxuICBpc0RyYWdnaW5nID0gZmFsc2VcblxuICBjb25zdHJ1Y3Rvcihjb21wb25lbnQ6IENvbXBvbmVudCwgcHJvcHM6IE5vZGVWaWV3UmVuZGVyZXJQcm9wcywgb3B0aW9ucz86IFBhcnRpYWw8T3B0aW9ucz4pIHtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudFxuICAgIHRoaXMuZWRpdG9yID0gcHJvcHMuZWRpdG9yIGFzIE5vZGVFZGl0b3JcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBzdG9wRXZlbnQ6IG51bGwsXG4gICAgICBpZ25vcmVNdXRhdGlvbjogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSBhcyBPcHRpb25zXG4gICAgdGhpcy5leHRlbnNpb24gPSBwcm9wcy5leHRlbnNpb25cbiAgICB0aGlzLm5vZGUgPSBwcm9wcy5ub2RlXG4gICAgdGhpcy5kZWNvcmF0aW9ucyA9IHByb3BzLmRlY29yYXRpb25zIGFzIERlY29yYXRpb25XaXRoVHlwZVtdXG4gICAgdGhpcy5pbm5lckRlY29yYXRpb25zID0gcHJvcHMuaW5uZXJEZWNvcmF0aW9uc1xuICAgIHRoaXMudmlldyA9IHByb3BzLnZpZXdcbiAgICB0aGlzLkhUTUxBdHRyaWJ1dGVzID0gcHJvcHMuSFRNTEF0dHJpYnV0ZXNcbiAgICB0aGlzLmdldFBvcyA9IHByb3BzLmdldFBvc1xuICAgIHRoaXMubW91bnQoKVxuICB9XG5cbiAgbW91bnQoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgcmV0dXJuXG4gIH1cblxuICBnZXQgZG9tKCk6IEhUTUxFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3Iudmlldy5kb20gYXMgSFRNTEVsZW1lbnRcbiAgfVxuXG4gIGdldCBjb250ZW50RE9NKCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9uRHJhZ1N0YXJ0KGV2ZW50OiBEcmFnRXZlbnQpIHtcbiAgICBjb25zdCB7IHZpZXcgfSA9IHRoaXMuZWRpdG9yXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG5cbiAgICAvLyBnZXQgdGhlIGRyYWcgaGFuZGxlIGVsZW1lbnRcbiAgICAvLyBgY2xvc2VzdGAgaXMgbm90IGF2YWlsYWJsZSBmb3IgdGV4dCBub2RlcyBzbyB3ZSBtYXkgaGF2ZSB0byB1c2UgaXRzIHBhcmVudFxuICAgIGNvbnN0IGRyYWdIYW5kbGUgPVxuICAgICAgdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudEVsZW1lbnQ/LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpIDogdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpXG5cbiAgICBpZiAoIXRoaXMuZG9tIHx8IHRoaXMuY29udGVudERPTT8uY29udGFpbnModGFyZ2V0KSB8fCAhZHJhZ0hhbmRsZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHggPSAwXG4gICAgbGV0IHkgPSAwXG5cbiAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGZvciBkcmFnIGVsZW1lbnQgaWYgd2UgdXNlIGEgZGlmZmVyZW50IGRyYWcgaGFuZGxlIGVsZW1lbnRcbiAgICBpZiAodGhpcy5kb20gIT09IGRyYWdIYW5kbGUpIHtcbiAgICAgIGNvbnN0IGRvbUJveCA9IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBjb25zdCBoYW5kbGVCb3ggPSBkcmFnSGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgIC8vIEluIFJlYWN0LCB3ZSBoYXZlIHRvIGdvIHRocm91Z2ggbmF0aXZlRXZlbnQgdG8gcmVhY2ggb2Zmc2V0WC9vZmZzZXRZLlxuICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50Lm9mZnNldFggPz8gKGV2ZW50IGFzIGFueSkubmF0aXZlRXZlbnQ/Lm9mZnNldFhcbiAgICAgIGNvbnN0IG9mZnNldFkgPSBldmVudC5vZmZzZXRZID8/IChldmVudCBhcyBhbnkpLm5hdGl2ZUV2ZW50Py5vZmZzZXRZXG5cbiAgICAgIHggPSBoYW5kbGVCb3gueCAtIGRvbUJveC54ICsgb2Zmc2V0WFxuICAgICAgeSA9IGhhbmRsZUJveC55IC0gZG9tQm94LnkgKyBvZmZzZXRZXG4gICAgfVxuXG4gICAgY29uc3QgY2xvbmVkTm9kZSA9IHRoaXMuZG9tLmNsb25lTm9kZSh0cnVlKSBhcyBIVE1MRWxlbWVudFxuXG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyPy5zZXREcmFnSW1hZ2UoY2xvbmVkTm9kZSwgeCwgeSlcblxuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKClcblxuICAgIGlmICh0eXBlb2YgcG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHdlIG5lZWQgdG8gdGVsbCBQcm9zZU1pcnJvciB0aGF0IHdlIHdhbnQgdG8gbW92ZSB0aGUgd2hvbGUgbm9kZVxuICAgIC8vIHNvIHdlIGNyZWF0ZSBhIE5vZGVTZWxlY3Rpb25cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh2aWV3LnN0YXRlLmRvYywgcG9zKVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuXG4gICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbilcbiAgfVxuXG4gIHN0b3BFdmVudChldmVudDogRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50KHsgZXZlbnQgfSlcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcbiAgICBjb25zdCBpc0luRWxlbWVudCA9IHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkgJiYgIXRoaXMuY29udGVudERPTT8uY29udGFpbnModGFyZ2V0KVxuXG4gICAgLy8gYW55IGV2ZW50IGZyb20gY2hpbGQgbm9kZXMgc2hvdWxkIGJlIGhhbmRsZWQgYnkgUHJvc2VNaXJyb3JcbiAgICBpZiAoIWlzSW5FbGVtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBpc0RyYWdFdmVudCA9IGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgnZHJhZycpXG4gICAgY29uc3QgaXNEcm9wRXZlbnQgPSBldmVudC50eXBlID09PSAnZHJvcCdcbiAgICBjb25zdCBpc0lucHV0ID0gWydJTlBVVCcsICdCVVRUT04nLCAnU0VMRUNUJywgJ1RFWFRBUkVBJ10uaW5jbHVkZXModGFyZ2V0LnRhZ05hbWUpIHx8IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZVxuXG4gICAgLy8gYW55IGlucHV0IGV2ZW50IHdpdGhpbiBub2RlIHZpZXdzIHNob3VsZCBiZSBpZ25vcmVkIGJ5IFByb3NlTWlycm9yXG4gICAgaWYgKGlzSW5wdXQgJiYgIWlzRHJvcEV2ZW50ICYmICFpc0RyYWdFdmVudCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBjb25zdCB7IGlzRWRpdGFibGUgfSA9IHRoaXMuZWRpdG9yXG4gICAgY29uc3QgeyBpc0RyYWdnaW5nIH0gPSB0aGlzXG4gICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlXG4gICAgY29uc3QgaXNTZWxlY3RhYmxlID0gTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUodGhpcy5ub2RlKVxuICAgIGNvbnN0IGlzQ29weUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2NvcHknXG4gICAgY29uc3QgaXNQYXN0ZUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ3Bhc3RlJ1xuICAgIGNvbnN0IGlzQ3V0RXZlbnQgPSBldmVudC50eXBlID09PSAnY3V0J1xuICAgIGNvbnN0IGlzQ2xpY2tFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nXG5cbiAgICAvLyBQcm9zZU1pcnJvciB0cmllcyB0byBkcmFnIHNlbGVjdGFibGUgbm9kZXNcbiAgICAvLyBldmVuIGlmIGBkcmFnZ2FibGVgIGlzIHNldCB0byBgZmFsc2VgXG4gICAgLy8gdGhpcyBmaXggcHJldmVudHMgdGhhdFxuICAgIGlmICghaXNEcmFnZ2FibGUgJiYgaXNTZWxlY3RhYmxlICYmIGlzRHJhZ0V2ZW50ICYmIGV2ZW50LnRhcmdldCA9PT0gdGhpcy5kb20pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNEcmFnRXZlbnQgJiYgIWlzRHJhZ2dpbmcgJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRvbSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gd2UgaGF2ZSB0byBzdG9yZSB0aGF0IGRyYWdnaW5nIHN0YXJ0ZWRcbiAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNFZGl0YWJsZSAmJiAhaXNEcmFnZ2luZyAmJiBpc0NsaWNrRXZlbnQpIHtcbiAgICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0YXJnZXQuY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcbiAgICAgIGNvbnN0IGlzVmFsaWREcmFnSGFuZGxlID0gZHJhZ0hhbmRsZSAmJiAodGhpcy5kb20gPT09IGRyYWdIYW5kbGUgfHwgdGhpcy5kb20uY29udGFpbnMoZHJhZ0hhbmRsZSkpXG5cbiAgICAgIGlmIChpc1ZhbGlkRHJhZ0hhbmRsZSkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnZHJhZ2VuZCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnZHJvcCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAnbW91c2V1cCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgb25jZTogdHJ1ZSB9LFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhlc2UgZXZlbnRzIGFyZSBoYW5kbGVkIGJ5IHByb3NlbWlycm9yXG4gICAgaWYgKGlzRHJhZ2dpbmcgfHwgaXNEcm9wRXZlbnQgfHwgaXNDb3B5RXZlbnQgfHwgaXNQYXN0ZUV2ZW50IHx8IGlzQ3V0RXZlbnQgfHwgKGlzQ2xpY2tFdmVudCAmJiBpc1NlbGVjdGFibGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgRE9NIFttdXRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL011dGF0aW9uT2JzZXJ2ZXIpIG9yIGEgc2VsZWN0aW9uIGNoYW5nZSBoYXBwZW5zIHdpdGhpbiB0aGUgdmlldy5cbiAgICogQHJldHVybiBgZmFsc2VgIGlmIHRoZSBlZGl0b3Igc2hvdWxkIHJlLXJlYWQgdGhlIHNlbGVjdGlvbiBvciByZS1wYXJzZSB0aGUgcmFuZ2UgYXJvdW5kIHRoZSBtdXRhdGlvblxuICAgKiBAcmV0dXJuIGB0cnVlYCBpZiBpdCBjYW4gc2FmZWx5IGJlIGlnbm9yZWQuXG4gICAqL1xuICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbjogVmlld011dGF0aW9uUmVjb3JkKSB7XG4gICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlnbm9yZU11dGF0aW9uKHsgbXV0YXRpb24gfSlcbiAgICB9XG5cbiAgICAvLyBhIGxlYWYvYXRvbSBub2RlIGlzIGxpa2UgYSBibGFjayBib3ggZm9yIFByb3NlTWlycm9yXG4gICAgLy8gYW5kIHNob3VsZCBiZSBmdWxseSBoYW5kbGVkIGJ5IHRoZSBub2RlIHZpZXdcbiAgICBpZiAodGhpcy5ub2RlLmlzTGVhZiB8fCB0aGlzLm5vZGUuaXNBdG9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIFByb3NlTWlycm9yIHNob3VsZCBoYW5kbGUgYW55IHNlbGVjdGlvbnNcbiAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ3NlbGVjdGlvbicpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHRyeSB0byBwcmV2ZW50IGEgYnVnIG9uIGlPUyBhbmQgQW5kcm9pZCB0aGF0IHdpbGwgYnJlYWsgbm9kZSB2aWV3cyBvbiBlbnRlclxuICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBQcm9zZU1pcnJvciBjYW7igJl0IHByZXZlbnREaXNwYXRjaCBvbiBlbnRlclxuICAgIC8vIHRoaXMgd2lsbCBsZWFkIHRvIGEgcmUtcmVuZGVyIG9mIHRoZSBub2RlIHZpZXcgb24gZW50ZXJcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTIxNFxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8yNTM0XG4gICAgaWYgKFxuICAgICAgdGhpcy5kb20uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSAmJlxuICAgICAgbXV0YXRpb24udHlwZSA9PT0gJ2NoaWxkTGlzdCcgJiZcbiAgICAgIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKSAmJlxuICAgICAgdGhpcy5lZGl0b3IuaXNGb2N1c2VkXG4gICAgKSB7XG4gICAgICBjb25zdCBjaGFuZ2VkTm9kZXMgPSBbLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKSwgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5yZW1vdmVkTm9kZXMpXSBhcyBIVE1MRWxlbWVudFtdXG5cbiAgICAgIC8vIHdl4oCZbGwgY2hlY2sgaWYgZXZlcnkgY2hhbmdlZCBub2RlIGlzIGNvbnRlbnRFZGl0YWJsZVxuICAgICAgLy8gdG8gbWFrZSBzdXJlIGl04oCZcyBwcm9iYWJseSBtdXRhdGVkIGJ5IFByb3NlTWlycm9yXG4gICAgICBpZiAoY2hhbmdlZE5vZGVzLmV2ZXJ5KG5vZGUgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gd2Ugd2lsbCBhbGxvdyBtdXRhdGlvbiBjb250ZW50RE9NIHdpdGggYXR0cmlidXRlc1xuICAgIC8vIHNvIHdlIGNhbiBmb3IgZXhhbXBsZSBhZGRpbmcgY2xhc3NlcyB3aXRoaW4gb3VyIG5vZGUgdmlld1xuICAgIGlmICh0aGlzLmNvbnRlbnRET00gPT09IG11dGF0aW9uLnRhcmdldCAmJiBtdXRhdGlvbi50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gUHJvc2VNaXJyb3Igc2hvdWxkIGhhbmRsZSBhbnkgY2hhbmdlcyB3aXRoaW4gY29udGVudERPTVxuICAgIGlmICh0aGlzLmNvbnRlbnRET00uY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHByb3NlbWlycm9yIG5vZGUuXG4gICAqL1xuICB1cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKClcblxuICAgICAgaWYgKHR5cGVvZiBwb3MgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcbiAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIG5vZGUuXG4gICAqL1xuICBkZWxldGVOb2RlKCk6IHZvaWQge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLmdldFBvcygpXG5cbiAgICBpZiAodHlwZW9mIGZyb20gIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5ub2RlLm5vZGVTaXplXG5cbiAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5kZWxldGVSYW5nZSh7IGZyb20sIHRvIH0pXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0TWFya3NCZXR3ZWVuIH0gZnJvbSAnLi4vaGVscGVycy9nZXRNYXJrc0JldHdlZW4uanMnXG5pbXBvcnQgdHlwZSB7IFBhc3RlUnVsZUZpbmRlciB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB7IFBhc3RlUnVsZSB9IGZyb20gJy4uL1Bhc3RlUnVsZS5qcydcbmltcG9ydCB0eXBlIHsgRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvY2FsbE9yUmV0dXJuLmpzJ1xuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjcGFzdGUtcnVsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcmtQYXN0ZVJ1bGUoY29uZmlnOiB7XG4gIGZpbmQ6IFBhc3RlUnVsZUZpbmRlclxuICB0eXBlOiBNYXJrVHlwZVxuICBnZXRBdHRyaWJ1dGVzPzpcbiAgICB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgICB8ICgobWF0Y2g6IEV4dGVuZGVkUmVnRXhwTWF0Y2hBcnJheSwgZXZlbnQ6IENsaXBib2FyZEV2ZW50KSA9PiBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIHwgZmFsc2VcbiAgICB8IG51bGxcbn0pIHtcbiAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2gsIHBhc3RlRXZlbnQgfSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCwgcGFzdGVFdmVudClcblxuICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGVcbiAgICAgIGNvbnN0IGNhcHR1cmVHcm91cCA9IG1hdGNoW21hdGNoLmxlbmd0aCAtIDFdXG4gICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXVxuICAgICAgbGV0IG1hcmtFbmQgPSByYW5nZS50b1xuXG4gICAgICBpZiAoY2FwdHVyZUdyb3VwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLylcbiAgICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcmFuZ2UuZnJvbSArIGZ1bGxNYXRjaC5pbmRleE9mKGNhcHR1cmVHcm91cClcbiAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGhcblxuICAgICAgICBjb25zdCBleGNsdWRlZE1hcmtzID0gZ2V0TWFya3NCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCBzdGF0ZS5kb2MpXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQgYXMgTWFya1R5cGVbXVxuXG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpXG5cbiAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICB0ci5kZWxldGUodGV4dEVuZCwgcmFuZ2UudG8pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydClcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoXG5cbiAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSlcblxuICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmltcG9ydCB0eXBlIHsgUGFzdGVSdWxlRmluZGVyIH0gZnJvbSAnLi4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHsgUGFzdGVSdWxlIH0gZnJvbSAnLi4vUGFzdGVSdWxlLmpzJ1xuaW1wb3J0IHR5cGUgeyBFeHRlbmRlZFJlZ0V4cE1hdGNoQXJyYXksIEpTT05Db250ZW50IH0gZnJvbSAnLi4vdHlwZXMuanMnXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4gfSBmcm9tICcuLi91dGlsaXRpZXMvaW5kZXguanMnXG5cbi8qKlxuICogQnVpbGQgYW4gcGFzdGUgcnVsZSB0aGF0IGFkZHMgYSBub2RlIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9kb2NzL2VkaXRvci9leHRlbnNpb25zL2N1c3RvbS1leHRlbnNpb25zL2V4dGVuZC1leGlzdGluZyNwYXN0ZS1ydWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbm9kZVBhc3RlUnVsZShjb25maWc6IHtcbiAgZmluZDogUGFzdGVSdWxlRmluZGVyXG4gIHR5cGU6IE5vZGVUeXBlXG4gIGdldEF0dHJpYnV0ZXM/OlxuICAgIHwgUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHwgKChtYXRjaDogRXh0ZW5kZWRSZWdFeHBNYXRjaEFycmF5LCBldmVudDogQ2xpcGJvYXJkRXZlbnQpID0+IFJlY29yZDxzdHJpbmcsIGFueT4pXG4gICAgfCBmYWxzZVxuICAgIHwgbnVsbFxuICBnZXRDb250ZW50PzogSlNPTkNvbnRlbnRbXSB8ICgoYXR0cnM6IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IEpTT05Db250ZW50W10pIHwgZmFsc2UgfCBudWxsXG59KSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyKHsgbWF0Y2gsIGNoYWluLCByYW5nZSwgcGFzdGVFdmVudCB9KSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoLCBwYXN0ZUV2ZW50KVxuICAgICAgY29uc3QgY29udGVudCA9IGNhbGxPclJldHVybihjb25maWcuZ2V0Q29udGVudCwgdW5kZWZpbmVkLCBhdHRyaWJ1dGVzKVxuXG4gICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0geyB0eXBlOiBjb25maWcudHlwZS5uYW1lLCBhdHRyczogYXR0cmlidXRlcyB9IGFzIEpTT05Db250ZW50XG5cbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIG5vZGUuY29udGVudCA9IGNvbnRlbnRcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoLmlucHV0KSB7XG4gICAgICAgIGNoYWluKCkuZGVsZXRlUmFuZ2UocmFuZ2UpLmluc2VydENvbnRlbnRBdChyYW5nZS5mcm9tLCBub2RlKVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBQYXN0ZVJ1bGVGaW5kZXIgfSBmcm9tICcuLi9QYXN0ZVJ1bGUuanMnXG5pbXBvcnQgeyBQYXN0ZVJ1bGUgfSBmcm9tICcuLi9QYXN0ZVJ1bGUuanMnXG5cbi8qKlxuICogQnVpbGQgYW4gcGFzdGUgcnVsZSB0aGF0IHJlcGxhY2VzIHRleHQgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI3Bhc3RlLXJ1bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0UGFzdGVSdWxlKGNvbmZpZzogeyBmaW5kOiBQYXN0ZVJ1bGVGaW5kZXI7IHJlcGxhY2U6IHN0cmluZyB9KSB7XG4gIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgIGxldCBpbnNlcnQgPSBjb25maWcucmVwbGFjZVxuICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbVxuICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG9cblxuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKVxuXG4gICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpXG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldFxuXG4gICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kXG5cbiAgICAgICAgaWYgKGN1dE9mZiA+IDApIHtcbiAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnRcbiAgICAgICAgICBzdGFydCA9IGVuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKVxuICAgIH0sXG4gIH0pXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBUcmFuc2FjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2tlclJlc3VsdCB7XG4gIHBvc2l0aW9uOiBudW1iZXJcbiAgZGVsZXRlZDogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgVHJhY2tlciB7XG4gIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblxuXG4gIGN1cnJlbnRTdGVwOiBudW1iZXJcblxuICBjb25zdHJ1Y3Rvcih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25cbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwcy5sZW5ndGhcbiAgfVxuXG4gIG1hcChwb3NpdGlvbjogbnVtYmVyKTogVHJhY2tlclJlc3VsdCB7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZVxuXG4gICAgY29uc3QgbWFwcGVkUG9zaXRpb24gPSB0aGlzLnRyYW5zYWN0aW9uLnN0ZXBzLnNsaWNlKHRoaXMuY3VycmVudFN0ZXApLnJlZHVjZSgobmV3UG9zaXRpb24sIHN0ZXApID0+IHtcbiAgICAgIGNvbnN0IG1hcFJlc3VsdCA9IHN0ZXAuZ2V0TWFwKCkubWFwUmVzdWx0KG5ld1Bvc2l0aW9uKVxuXG4gICAgICBpZiAobWFwUmVzdWx0LmRlbGV0ZWQpIHtcbiAgICAgICAgZGVsZXRlZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcFJlc3VsdC5wb3NcbiAgICB9LCBwb3NpdGlvbilcblxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogbWFwcGVkUG9zaXRpb24sXG4gICAgICBkZWxldGVkLFxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcbmltcG9ydCB7IGRyb3BQb2ludCB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5cbi8qKlxuQ3JlYXRlIGEgcGx1Z2luIHRoYXQsIHdoZW4gYWRkZWQgdG8gYSBQcm9zZU1pcnJvciBpbnN0YW5jZSxcbmNhdXNlcyBhIGRlY29yYXRpb24gdG8gc2hvdyB1cCBhdCB0aGUgZHJvcCBwb3NpdGlvbiB3aGVuIHNvbWV0aGluZ1xuaXMgZHJhZ2dlZCBvdmVyIHRoZSBlZGl0b3IuXG5cbk5vZGVzIG1heSBhZGQgYSBgZGlzYWJsZURyb3BDdXJzb3JgIHByb3BlcnR5IHRvIHRoZWlyIHNwZWMgdG9cbmNvbnRyb2wgdGhlIHNob3dpbmcgb2YgYSBkcm9wIGN1cnNvciBpbnNpZGUgdGhlbS4gVGhpcyBtYXkgYmUgYVxuYm9vbGVhbiBvciBhIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgdmlldyBhbmQgYVxucG9zaXRpb24sIGFuZCBzaG91bGQgcmV0dXJuIGEgYm9vbGVhbi5cbiovXG5mdW5jdGlvbiBkcm9wQ3Vyc29yKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgdmlldyhlZGl0b3JWaWV3KSB7IHJldHVybiBuZXcgRHJvcEN1cnNvclZpZXcoZWRpdG9yVmlldywgb3B0aW9ucyk7IH1cbiAgICB9KTtcbn1cbmNsYXNzIERyb3BDdXJzb3JWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0b3JWaWV3LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lZGl0b3JWaWV3ID0gZWRpdG9yVmlldztcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy53aWR0aCA9IChfYSA9IG9wdGlvbnMud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XG4gICAgICAgIHRoaXMuY29sb3IgPSBvcHRpb25zLmNvbG9yID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IChvcHRpb25zLmNvbG9yIHx8IFwiYmxhY2tcIik7XG4gICAgICAgIHRoaXMuY2xhc3MgPSBvcHRpb25zLmNsYXNzO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW1wiZHJhZ292ZXJcIiwgXCJkcmFnZW5kXCIsIFwiZHJvcFwiLCBcImRyYWdsZWF2ZVwiXS5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlciA9IChlKSA9PiB7IHRoaXNbbmFtZV0oZSk7IH07XG4gICAgICAgICAgICBlZGl0b3JWaWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgaGFuZGxlciB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5mb3JFYWNoKCh7IG5hbWUsIGhhbmRsZXIgfSkgPT4gdGhpcy5lZGl0b3JWaWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpKTtcbiAgICB9XG4gICAgdXBkYXRlKGVkaXRvclZpZXcsIHByZXZTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3JQb3MgIT0gbnVsbCAmJiBwcmV2U3RhdGUuZG9jICE9IGVkaXRvclZpZXcuc3RhdGUuZG9jKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJzb3JQb3MgPiBlZGl0b3JWaWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IobnVsbCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3Vyc29yKHBvcykge1xuICAgICAgICBpZiAocG9zID09IHRoaXMuY3Vyc29yUG9zKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IHBvcztcbiAgICAgICAgaWYgKHBvcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlT3ZlcmxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZU92ZXJsYXkoKSB7XG4gICAgICAgIGxldCAkcG9zID0gdGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYy5yZXNvbHZlKHRoaXMuY3Vyc29yUG9zKTtcbiAgICAgICAgbGV0IGlzQmxvY2sgPSAhJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCwgcmVjdDtcbiAgICAgICAgbGV0IGVkaXRvckRPTSA9IHRoaXMuZWRpdG9yVmlldy5kb20sIGVkaXRvclJlY3QgPSBlZGl0b3JET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBzY2FsZVggPSBlZGl0b3JSZWN0LndpZHRoIC8gZWRpdG9yRE9NLm9mZnNldFdpZHRoLCBzY2FsZVkgPSBlZGl0b3JSZWN0LmhlaWdodCAvIGVkaXRvckRPTS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmIChpc0Jsb2NrKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICAgICAgaWYgKGJlZm9yZSB8fCBhZnRlcikge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5lZGl0b3JWaWV3Lm5vZGVET00odGhpcy5jdXJzb3JQb3MgLSAoYmVmb3JlID8gYmVmb3JlLm5vZGVTaXplIDogMCkpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub2RlUmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3AgPSBiZWZvcmUgPyBub2RlUmVjdC5ib3R0b20gOiBub2RlUmVjdC50b3A7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSAodG9wICsgdGhpcy5lZGl0b3JWaWV3Lm5vZGVET00odGhpcy5jdXJzb3JQb3MpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGFsZldpZHRoID0gKHRoaXMud2lkdGggLyAyKSAqIHNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogbm9kZVJlY3QubGVmdCwgcmlnaHQ6IG5vZGVSZWN0LnJpZ2h0LCB0b3A6IHRvcCAtIGhhbGZXaWR0aCwgYm90dG9tOiB0b3AgKyBoYWxmV2lkdGggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICBsZXQgY29vcmRzID0gdGhpcy5lZGl0b3JWaWV3LmNvb3Jkc0F0UG9zKHRoaXMuY3Vyc29yUG9zKTtcbiAgICAgICAgICAgIGxldCBoYWxmV2lkdGggPSAodGhpcy53aWR0aCAvIDIpICogc2NhbGVYO1xuICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogY29vcmRzLmxlZnQgLSBoYWxmV2lkdGgsIHJpZ2h0OiBjb29yZHMubGVmdCArIGhhbGZXaWR0aCwgdG9wOiBjb29yZHMudG9wLCBib3R0b206IGNvb3Jkcy5ib3R0b20gfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5lZGl0b3JWaWV3LmRvbS5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGFzcylcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5jbGFzcztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHotaW5kZXg6IDUwOyBwb2ludGVyLWV2ZW50czogbm9uZTtcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJwcm9zZW1pcnJvci1kcm9wY3Vyc29yLWJsb2NrXCIsIGlzQmxvY2spO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcInByb3NlbWlycm9yLWRyb3BjdXJzb3ItaW5saW5lXCIsICFpc0Jsb2NrKTtcbiAgICAgICAgbGV0IHBhcmVudExlZnQsIHBhcmVudFRvcDtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50ID09IGRvY3VtZW50LmJvZHkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpLnBvc2l0aW9uID09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgIHBhcmVudExlZnQgPSAtcGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICBwYXJlbnRUb3AgPSAtcGFnZVlPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGxldCBwYXJlbnRTY2FsZVggPSByZWN0LndpZHRoIC8gcGFyZW50Lm9mZnNldFdpZHRoLCBwYXJlbnRTY2FsZVkgPSByZWN0LmhlaWdodCAvIHBhcmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBwYXJlbnRMZWZ0ID0gcmVjdC5sZWZ0IC0gcGFyZW50LnNjcm9sbExlZnQgKiBwYXJlbnRTY2FsZVg7XG4gICAgICAgICAgICBwYXJlbnRUb3AgPSByZWN0LnRvcCAtIHBhcmVudC5zY3JvbGxUb3AgKiBwYXJlbnRTY2FsZVk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSAocmVjdC5sZWZ0IC0gcGFyZW50TGVmdCkgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSAocmVjdC50b3AgLSBwYXJlbnRUb3ApIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAocmVjdC5ib3R0b20gLSByZWN0LnRvcCkgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgfVxuICAgIHNjaGVkdWxlUmVtb3ZhbCh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2V0Q3Vyc29yKG51bGwpLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgZHJhZ292ZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvclZpZXcuZWRpdGFibGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmVkaXRvclZpZXcucG9zQXRDb29yZHMoeyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfSk7XG4gICAgICAgIGxldCBub2RlID0gcG9zICYmIHBvcy5pbnNpZGUgPj0gMCAmJiB0aGlzLmVkaXRvclZpZXcuc3RhdGUuZG9jLm5vZGVBdChwb3MuaW5zaWRlKTtcbiAgICAgICAgbGV0IGRpc2FibGVEcm9wQ3Vyc29yID0gbm9kZSAmJiBub2RlLnR5cGUuc3BlYy5kaXNhYmxlRHJvcEN1cnNvcjtcbiAgICAgICAgbGV0IGRpc2FibGVkID0gdHlwZW9mIGRpc2FibGVEcm9wQ3Vyc29yID09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBkaXNhYmxlRHJvcEN1cnNvcih0aGlzLmVkaXRvclZpZXcsIHBvcywgZXZlbnQpXG4gICAgICAgICAgICA6IGRpc2FibGVEcm9wQ3Vyc29yO1xuICAgICAgICBpZiAocG9zICYmICFkaXNhYmxlZCkge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHBvcy5wb3M7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nICYmIHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZy5zbGljZSkge1xuICAgICAgICAgICAgICAgIGxldCBwb2ludCA9IGRyb3BQb2ludCh0aGlzLmVkaXRvclZpZXcuc3RhdGUuZG9jLCB0YXJnZXQsIHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZy5zbGljZSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IodGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDUwMDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYWdlbmQoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW1vdmFsKDIwKTtcbiAgICB9XG4gICAgZHJvcCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoMjApO1xuICAgIH1cbiAgICBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvclZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IobnVsbCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBkcm9wQ3Vyc29yIH07XG4iLCAiaW1wb3J0IHsga2V5ZG93bkhhbmRsZXIgfSBmcm9tICdwcm9zZW1pcnJvci1rZXltYXAnO1xuaW1wb3J0IHsgU2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uLCBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5pbXBvcnQgeyBTbGljZSwgRnJhZ21lbnQgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBEZWNvcmF0aW9uU2V0LCBEZWNvcmF0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itdmlldyc7XG5cbi8qKlxuR2FwIGN1cnNvciBzZWxlY3Rpb25zIGFyZSByZXByZXNlbnRlZCB1c2luZyB0aGlzIGNsYXNzLiBJdHNcbmAkYW5jaG9yYCBhbmQgYCRoZWFkYCBwcm9wZXJ0aWVzIGJvdGggcG9pbnQgYXQgdGhlIGN1cnNvciBwb3NpdGlvbi5cbiovXG5jbGFzcyBHYXBDdXJzb3IgZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGdhcCBjdXJzb3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigkcG9zKSB7XG4gICAgICAgIHN1cGVyKCRwb3MsICRwb3MpO1xuICAgIH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgICAgIHJldHVybiBHYXBDdXJzb3IudmFsaWQoJHBvcykgPyBuZXcgR2FwQ3Vyc29yKCRwb3MpIDogU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxuICAgIGNvbnRlbnQoKSB7IHJldHVybiBTbGljZS5lbXB0eTsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEdhcEN1cnNvciAmJiBvdGhlci5oZWFkID09IHRoaXMuaGVhZDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImdhcGN1cnNvclwiLCBwb3M6IHRoaXMuaGVhZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBHYXBDdXJzb3IuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgR2FwQ3Vyc29yKGRvYy5yZXNvbHZlKGpzb24ucG9zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0Qm9va21hcmsoKSB7IHJldHVybiBuZXcgR2FwQm9va21hcmsodGhpcy5hbmNob3IpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgdmFsaWQoJHBvcykge1xuICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQuaXNUZXh0YmxvY2sgfHwgIWNsb3NlZEJlZm9yZSgkcG9zKSB8fCAhY2xvc2VkQWZ0ZXIoJHBvcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHBhcmVudC50eXBlLnNwZWMuYWxsb3dHYXBDdXJzb3I7XG4gICAgICAgIGlmIChvdmVycmlkZSAhPSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgICAgICBsZXQgZGVmbHQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoJHBvcy5pbmRleCgpKS5kZWZhdWx0VHlwZTtcbiAgICAgICAgcmV0dXJuIGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kR2FwQ3Vyc29yRnJvbSgkcG9zLCBkaXIsIG11c3RNb3ZlID0gZmFsc2UpIHtcbiAgICAgICAgc2VhcmNoOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoIW11c3RNb3ZlICYmIEdhcEN1cnNvci52YWxpZCgkcG9zKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcztcbiAgICAgICAgICAgIGxldCBwb3MgPSAkcG9zLnBvcywgbmV4dCA9IG51bGw7XG4gICAgICAgICAgICAvLyBTY2FuIHVwIGZyb20gdGhpcyBwb3NpdGlvblxuICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7OyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDwgcGFyZW50LmNoaWxkQ291bnQgOiAkcG9zLmluZGV4KGQpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcGFyZW50LmNoaWxkKGRpciA+IDAgPyAkcG9zLmluZGV4QWZ0ZXIoZCkgOiAkcG9zLmluZGV4KGQpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgICAgICAgICAgbGV0ICRjdXIgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKEdhcEN1cnNvci52YWxpZCgkY3VyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRjdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbmQgdGhlbiBkb3duIGludG8gdGhlIG5leHQgbm9kZVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCBpbnNpZGUgPSBkaXIgPiAwID8gbmV4dC5maXJzdENoaWxkIDogbmV4dC5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuaXNBdG9tICYmICFuZXh0LmlzVGV4dCAmJiAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRwb3MgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyArIG5leHQubm9kZVNpemUgKiBkaXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVzdE1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNlYXJjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IGluc2lkZTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGxldCAkY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChHYXBDdXJzb3IudmFsaWQoJGN1cikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5HYXBDdXJzb3IucHJvdG90eXBlLnZpc2libGUgPSBmYWxzZTtcbkdhcEN1cnNvci5maW5kRnJvbSA9IEdhcEN1cnNvci5maW5kR2FwQ3Vyc29yRnJvbTtcblNlbGVjdGlvbi5qc29uSUQoXCJnYXBjdXJzb3JcIiwgR2FwQ3Vyc29yKTtcbmNsYXNzIEdhcEJvb2ttYXJrIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MpIHtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2FwQm9va21hcmsobWFwcGluZy5tYXAodGhpcy5wb3MpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiBHYXBDdXJzb3IudmFsaWQoJHBvcykgPyBuZXcgR2FwQ3Vyc29yKCRwb3MpIDogU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VkQmVmb3JlKCRwb3MpIHtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleChkKSwgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuICAgICAgICAvLyBBdCB0aGUgc3RhcnQgb2YgdGhpcyBwYXJlbnQsIGxvb2sgYXQgbmV4dCBvbmVcbiAgICAgICAgaWYgKGluZGV4ID09IDApIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBpZiB0aGUgbm9kZSBiZWZvcmUgKG9yIGl0cyBmaXJzdCBhbmNlc3RvcikgaXMgY2xvc2VkXG4gICAgICAgIGZvciAobGV0IGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpOzsgYmVmb3JlID0gYmVmb3JlLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKChiZWZvcmUuY2hpbGRDb3VudCA9PSAwICYmICFiZWZvcmUuaW5saW5lQ29udGVudCkgfHwgYmVmb3JlLmlzQXRvbSB8fCBiZWZvcmUudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGl0IHN0YXJ0IG9mIGRvY3VtZW50XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjbG9zZWRBZnRlcigkcG9zKSB7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihkKSwgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuICAgICAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGFmdGVyID0gcGFyZW50LmNoaWxkKGluZGV4KTs7IGFmdGVyID0gYWZ0ZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKChhZnRlci5jaGlsZENvdW50ID09IDAgJiYgIWFmdGVyLmlubGluZUNvbnRlbnQpIHx8IGFmdGVyLmlzQXRvbSB8fCBhZnRlci50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGFmdGVyLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbkNyZWF0ZSBhIGdhcCBjdXJzb3IgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIHRoaXMgd2lsbCBjYXB0dXJlIGNsaWNrc1xubmVhciBhbmQgYXJyb3cta2V5LW1vdGlvbiBwYXN0IHBsYWNlcyB0aGF0IGRvbid0IGhhdmUgYSBub3JtYWxseVxuc2VsZWN0YWJsZSBwb3NpdGlvbiBuZWFyYnksIGFuZCBjcmVhdGUgYSBnYXAgY3Vyc29yIHNlbGVjdGlvbiBmb3JcbnRoZW0uIFRoZSBjdXJzb3IgaXMgZHJhd24gYXMgYW4gZWxlbWVudCB3aXRoIGNsYXNzXG5gUHJvc2VNaXJyb3ItZ2FwY3Vyc29yYC4gWW91IGNhbiBlaXRoZXIgaW5jbHVkZVxuYHN0eWxlL2dhcGN1cnNvci5jc3NgIGZyb20gdGhlIHBhY2thZ2UncyBkaXJlY3Rvcnkgb3IgYWRkIHlvdXIgb3duXG5zdHlsZXMgdG8gbWFrZSBpdCB2aXNpYmxlLlxuKi9cbmZ1bmN0aW9uIGdhcEN1cnNvcigpIHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBkZWNvcmF0aW9uczogZHJhd0dhcEN1cnNvcixcbiAgICAgICAgICAgIGNyZWF0ZVNlbGVjdGlvbkJldHdlZW4oX3ZpZXcsICRhbmNob3IsICRoZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRhbmNob3IucG9zID09ICRoZWFkLnBvcyAmJiBHYXBDdXJzb3IudmFsaWQoJGhlYWQpID8gbmV3IEdhcEN1cnNvcigkaGVhZCkgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZUNsaWNrLFxuICAgICAgICAgICAgaGFuZGxlS2V5RG93bixcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czogeyBiZWZvcmVpbnB1dDogYmVmb3JlaW5wdXQgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBoYW5kbGVLZXlEb3duID0ga2V5ZG93bkhhbmRsZXIoe1xuICAgIFwiQXJyb3dMZWZ0XCI6IGFycm93KFwiaG9yaXpcIiwgLTEpLFxuICAgIFwiQXJyb3dSaWdodFwiOiBhcnJvdyhcImhvcml6XCIsIDEpLFxuICAgIFwiQXJyb3dVcFwiOiBhcnJvdyhcInZlcnRcIiwgLTEpLFxuICAgIFwiQXJyb3dEb3duXCI6IGFycm93KFwidmVydFwiLCAxKVxufSk7XG5mdW5jdGlvbiBhcnJvdyhheGlzLCBkaXIpIHtcbiAgICBjb25zdCBkaXJTdHIgPSBheGlzID09IFwidmVydFwiID8gKGRpciA+IDAgPyBcImRvd25cIiA6IFwidXBcIikgOiAoZGlyID4gMCA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgICAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgJHN0YXJ0ID0gZGlyID4gMCA/IHNlbC4kdG8gOiBzZWwuJGZyb20sIG11c3RNb3ZlID0gc2VsLmVtcHR5O1xuICAgICAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikge1xuICAgICAgICAgICAgaWYgKCF2aWV3LmVuZE9mVGV4dGJsb2NrKGRpclN0cikgfHwgJHN0YXJ0LmRlcHRoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbXVzdE1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKGRpciA+IDAgPyAkc3RhcnQuYWZ0ZXIoKSA6ICRzdGFydC5iZWZvcmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0ICRmb3VuZCA9IEdhcEN1cnNvci5maW5kR2FwQ3Vyc29yRnJvbSgkc3RhcnQsIGRpciwgbXVzdE1vdmUpO1xuICAgICAgICBpZiAoISRmb3VuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJGZvdW5kKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlQ2xpY2sodmlldywgcG9zLCBldmVudCkge1xuICAgIGlmICghdmlldyB8fCAhdmlldy5lZGl0YWJsZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghR2FwQ3Vyc29yLnZhbGlkKCRwb3MpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNsaWNrUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IGxlZnQ6IGV2ZW50LmNsaWVudFgsIHRvcDogZXZlbnQuY2xpZW50WSB9KTtcbiAgICBpZiAoY2xpY2tQb3MgJiYgY2xpY2tQb3MuaW5zaWRlID4gLTEgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUodmlldy5zdGF0ZS5kb2Mubm9kZUF0KGNsaWNrUG9zLmluc2lkZSkpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgR2FwQ3Vyc29yKCRwb3MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBUaGlzIGlzIGEgaGFjayB0aGF0LCB3aGVuIGEgY29tcG9zaXRpb24gc3RhcnRzIHdoaWxlIGEgZ2FwIGN1cnNvclxuLy8gaXMgYWN0aXZlLCBxdWlja2x5IGNyZWF0ZXMgYW4gaW5saW5lIGNvbnRleHQgZm9yIHRoZSBjb21wb3NpdGlvbiB0b1xuLy8gaGFwcGVuIGluLCB0byBhdm9pZCBpdCBiZWluZyBhYm9ydGVkIGJ5IHRoZSBET00gc2VsZWN0aW9uIGJlaW5nXG4vLyBtb3ZlZCBpbnRvIGEgdmFsaWQgcG9zaXRpb24uXG5mdW5jdGlvbiBiZWZvcmVpbnB1dCh2aWV3LCBldmVudCkge1xuICAgIGlmIChldmVudC5pbnB1dFR5cGUgIT0gXCJpbnNlcnRDb21wb3NpdGlvblRleHRcIiB8fCAhKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgR2FwQ3Vyc29yKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7ICRmcm9tIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgaW5zZXJ0ID0gJGZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRmcm9tLmluZGV4KCkpLmZpbmRXcmFwcGluZyh2aWV3LnN0YXRlLnNjaGVtYS5ub2Rlcy50ZXh0KTtcbiAgICBpZiAoIWluc2VydClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBmcmFnID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgaSA9IGluc2VydC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgZnJhZyA9IEZyYWdtZW50LmZyb20oaW5zZXJ0W2ldLmNyZWF0ZUFuZEZpbGwobnVsbCwgZnJhZykpO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHIucmVwbGFjZSgkZnJvbS5wb3MsICRmcm9tLnBvcywgbmV3IFNsaWNlKGZyYWcsIDAsIDApKTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKCRmcm9tLnBvcyArIDEpKSk7XG4gICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZHJhd0dhcEN1cnNvcihzdGF0ZSkge1xuICAgIGlmICghKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEdhcEN1cnNvcikpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBub2RlLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3ItZ2FwY3Vyc29yXCI7XG4gICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKHN0YXRlLmRvYywgW0RlY29yYXRpb24ud2lkZ2V0KHN0YXRlLnNlbGVjdGlvbi5oZWFkLCBub2RlLCB7IGtleTogXCJnYXBjdXJzb3JcIiB9KV0pO1xufVxuXG5leHBvcnQgeyBHYXBDdXJzb3IsIGdhcEN1cnNvciB9O1xuIiwgInZhciBHT09EX0xFQUZfU0laRSA9IDIwMDtcblxuLy8gOjogY2xhc3M8VD4gQSByb3BlIHNlcXVlbmNlIGlzIGEgcGVyc2lzdGVudCBzZXF1ZW5jZSBkYXRhIHN0cnVjdHVyZVxuLy8gdGhhdCBzdXBwb3J0cyBhcHBlbmRpbmcsIHByZXBlbmRpbmcsIGFuZCBzbGljaW5nIHdpdGhvdXQgZG9pbmcgYVxuLy8gZnVsbCBjb3B5LiBJdCBpcyByZXByZXNlbnRlZCBhcyBhIG1vc3RseS1iYWxhbmNlZCB0cmVlLlxudmFyIFJvcGVTZXF1ZW5jZSA9IGZ1bmN0aW9uIFJvcGVTZXF1ZW5jZSAoKSB7fTtcblxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKG90aGVyKSB7XG4gIGlmICghb3RoZXIubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgb3RoZXIgPSBSb3BlU2VxdWVuY2UuZnJvbShvdGhlcik7XG5cbiAgcmV0dXJuICghdGhpcy5sZW5ndGggJiYgb3RoZXIpIHx8XG4gICAgKG90aGVyLmxlbmd0aCA8IEdPT0RfTEVBRl9TSVpFICYmIHRoaXMubGVhZkFwcGVuZChvdGhlcikpIHx8XG4gICAgKHRoaXMubGVuZ3RoIDwgR09PRF9MRUFGX1NJWkUgJiYgb3RoZXIubGVhZlByZXBlbmQodGhpcykpIHx8XG4gICAgdGhpcy5hcHBlbmRJbm5lcihvdGhlcilcbn07XG5cbi8vIDo6ICh1bmlvbjxbVF0sIFJvcGVTZXF1ZW5jZTxUPj4pIFx1MjE5MiBSb3BlU2VxdWVuY2U8VD5cbi8vIFByZXBlbmQgYW4gYXJyYXkgb3Igb3RoZXIgcm9wZSB0byB0aGlzIG9uZSwgcmV0dXJuaW5nIGEgbmV3IHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kIChvdGhlcikge1xuICBpZiAoIW90aGVyLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gIHJldHVybiBSb3BlU2VxdWVuY2UuZnJvbShvdGhlcikuYXBwZW5kKHRoaXMpXG59O1xuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmFwcGVuZElubmVyID0gZnVuY3Rpb24gYXBwZW5kSW5uZXIgKG90aGVyKSB7XG4gIHJldHVybiBuZXcgQXBwZW5kKHRoaXMsIG90aGVyKVxufTtcblxuLy8gOjogKD9udW1iZXIsID9udW1iZXIpIFx1MjE5MiBSb3BlU2VxdWVuY2U8VD5cbi8vIENyZWF0ZSBhIHJvcGUgcmVwZXNlbnRpbmcgYSBzdWItc2VxdWVuY2Ugb2YgdGhpcyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZnJvbSA+PSB0bykgeyByZXR1cm4gUm9wZVNlcXVlbmNlLmVtcHR5IH1cbiAgcmV0dXJuIHRoaXMuc2xpY2VJbm5lcihNYXRoLm1heCgwLCBmcm9tKSwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHRvKSlcbn07XG5cbi8vIDo6IChudW1iZXIpIFx1MjE5MiBUXG4vLyBSZXRyaWV2ZSB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gZnJvbSB0aGlzIHJvcGUuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgeyByZXR1cm4gdW5kZWZpbmVkIH1cbiAgcmV0dXJuIHRoaXMuZ2V0SW5uZXIoaSlcbn07XG5cbi8vIDo6ICgoZWxlbWVudDogVCwgaW5kZXg6IG51bWJlcikgXHUyMTkyID9ib29sLCA/bnVtYmVyLCA/bnVtYmVyKVxuLy8gQ2FsbCB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2ggZWxlbWVudCBiZXR3ZWVuIHRoZSBnaXZlblxuLy8gaW5kaWNlcy4gVGhpcyB0ZW5kcyB0byBiZSBtb3JlIGVmZmljaWVudCB0aGFuIGxvb3Bpbmcgb3ZlciB0aGVcbi8vIGluZGljZXMgYW5kIGNhbGxpbmcgYGdldGAsIGJlY2F1c2UgaXQgZG9lc24ndCBoYXZlIHRvIGRlc2NlbmQgdGhlXG4vLyB0cmVlIGZvciBldmVyeSBlbGVtZW50LlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaCAoZiwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGZyb20gPD0gdG8pXG4gICAgeyB0aGlzLmZvckVhY2hJbm5lcihmLCBmcm9tLCB0bywgMCk7IH1cbiAgZWxzZVxuICAgIHsgdGhpcy5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBmcm9tLCB0bywgMCk7IH1cbn07XG5cbi8vIDo6ICgoZWxlbWVudDogVCwgaW5kZXg6IG51bWJlcikgXHUyMTkyIFUsID9udW1iZXIsID9udW1iZXIpIFx1MjE5MiBbVV1cbi8vIE1hcCB0aGUgZ2l2ZW4gZnVuY3Rpb25zIG92ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3BlLCBwcm9kdWNpbmdcbi8vIGEgZmxhdCBhcnJheS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChmLCBmcm9tLCB0bykge1xuICAgIGlmICggZnJvbSA9PT0gdm9pZCAwICkgZnJvbSA9IDA7XG4gICAgaWYgKCB0byA9PT0gdm9pZCAwICkgdG8gPSB0aGlzLmxlbmd0aDtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWx0LCBpKSB7IHJldHVybiByZXN1bHQucHVzaChmKGVsdCwgaSkpOyB9LCBmcm9tLCB0byk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8vIDo6ICg/dW5pb248W1RdLCBSb3BlU2VxdWVuY2U8VD4+KSBcdTIxOTIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBDcmVhdGUgYSByb3BlIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gYXJyYXksIG9yIHJldHVybiB0aGUgcm9wZVxuLy8gaXRzZWxmIGlmIGEgcm9wZSB3YXMgZ2l2ZW4uXG5Sb3BlU2VxdWVuY2UuZnJvbSA9IGZ1bmN0aW9uIGZyb20gKHZhbHVlcykge1xuICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUm9wZVNlcXVlbmNlKSB7IHJldHVybiB2YWx1ZXMgfVxuICByZXR1cm4gdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggPyBuZXcgTGVhZih2YWx1ZXMpIDogUm9wZVNlcXVlbmNlLmVtcHR5XG59O1xuXG52YXIgTGVhZiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFJvcGVTZXF1ZW5jZSkge1xuICBmdW5jdGlvbiBMZWFmKHZhbHVlcykge1xuICAgIFJvcGVTZXF1ZW5jZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICB9XG5cbiAgaWYgKCBSb3BlU2VxdWVuY2UgKSBMZWFmLl9fcHJvdG9fXyA9IFJvcGVTZXF1ZW5jZTtcbiAgTGVhZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSb3BlU2VxdWVuY2UgJiYgUm9wZVNlcXVlbmNlLnByb3RvdHlwZSApO1xuICBMZWFmLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExlYWY7XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgbGVuZ3RoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGRlcHRoOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1xuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLnNsaWNlSW5uZXIgPSBmdW5jdGlvbiBzbGljZUlubmVyIChmcm9tLCB0bykge1xuICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHJldHVybiBuZXcgTGVhZih0aGlzLnZhbHVlcy5zbGljZShmcm9tLCB0bykpXG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUuZ2V0SW5uZXIgPSBmdW5jdGlvbiBnZXRJbm5lciAoaSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1tpXVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZvckVhY2hJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCB0bzsgaSsrKVxuICAgICAgeyBpZiAoZih0aGlzLnZhbHVlc1tpXSwgc3RhcnQgKyBpKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZvckVhY2hJbnZlcnRlZElubmVyID0gZnVuY3Rpb24gZm9yRWFjaEludmVydGVkSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIGZvciAodmFyIGkgPSBmcm9tIC0gMTsgaSA+PSB0bzsgaS0tKVxuICAgICAgeyBpZiAoZih0aGlzLnZhbHVlc1tpXSwgc3RhcnQgKyBpKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH0gfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmxlYWZBcHBlbmQgPSBmdW5jdGlvbiBsZWFmQXBwZW5kIChvdGhlcikge1xuICAgIGlmICh0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCA8PSBHT09EX0xFQUZfU0laRSlcbiAgICAgIHsgcmV0dXJuIG5ldyBMZWFmKHRoaXMudmFsdWVzLmNvbmNhdChvdGhlci5mbGF0dGVuKCkpKSB9XG4gIH07XG5cbiAgTGVhZi5wcm90b3R5cGUubGVhZlByZXBlbmQgPSBmdW5jdGlvbiBsZWFmUHJlcGVuZCAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGggPD0gR09PRF9MRUFGX1NJWkUpXG4gICAgICB7IHJldHVybiBuZXcgTGVhZihvdGhlci5mbGF0dGVuKCkuY29uY2F0KHRoaXMudmFsdWVzKSkgfVxuICB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5sZW5ndGguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmRlcHRoLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGVhZi5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHJldHVybiBMZWFmO1xufShSb3BlU2VxdWVuY2UpKTtcblxuLy8gOjogUm9wZVNlcXVlbmNlXG4vLyBUaGUgZW1wdHkgcm9wZSBzZXF1ZW5jZS5cblJvcGVTZXF1ZW5jZS5lbXB0eSA9IG5ldyBMZWFmKFtdKTtcblxudmFyIEFwcGVuZCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFJvcGVTZXF1ZW5jZSkge1xuICBmdW5jdGlvbiBBcHBlbmQobGVmdCwgcmlnaHQpIHtcbiAgICBSb3BlU2VxdWVuY2UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoO1xuICAgIHRoaXMuZGVwdGggPSBNYXRoLm1heChsZWZ0LmRlcHRoLCByaWdodC5kZXB0aCkgKyAxO1xuICB9XG5cbiAgaWYgKCBSb3BlU2VxdWVuY2UgKSBBcHBlbmQuX19wcm90b19fID0gUm9wZVNlcXVlbmNlO1xuICBBcHBlbmQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUm9wZVNlcXVlbmNlICYmIFJvcGVTZXF1ZW5jZS5wcm90b3R5cGUgKTtcbiAgQXBwZW5kLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFwcGVuZDtcblxuICBBcHBlbmQucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0LmZsYXR0ZW4oKS5jb25jYXQodGhpcy5yaWdodC5mbGF0dGVuKCkpXG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5nZXRJbm5lciA9IGZ1bmN0aW9uIGdldElubmVyIChpKSB7XG4gICAgcmV0dXJuIGkgPCB0aGlzLmxlZnQubGVuZ3RoID8gdGhpcy5sZWZ0LmdldChpKSA6IHRoaXMucmlnaHQuZ2V0KGkgLSB0aGlzLmxlZnQubGVuZ3RoKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZm9yRWFjaElubmVyID0gZnVuY3Rpb24gZm9yRWFjaElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKGZyb20gPCBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMubGVmdC5mb3JFYWNoSW5uZXIoZiwgZnJvbSwgTWF0aC5taW4odG8sIGxlZnRMZW4pLCBzdGFydCkgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0byA+IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5yaWdodC5mb3JFYWNoSW5uZXIoZiwgTWF0aC5tYXgoZnJvbSAtIGxlZnRMZW4sIDApLCBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdG8pIC0gbGVmdExlbiwgc3RhcnQgKyBsZWZ0TGVuKSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mb3JFYWNoSW52ZXJ0ZWRJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbnZlcnRlZElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKGZyb20gPiBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgZnJvbSAtIGxlZnRMZW4sIE1hdGgubWF4KHRvLCBsZWZ0TGVuKSAtIGxlZnRMZW4sIHN0YXJ0ICsgbGVmdExlbikgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0byA8IGxlZnRMZW4gJiZcbiAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hJbnZlcnRlZElubmVyKGYsIE1hdGgubWluKGZyb20sIGxlZnRMZW4pLCB0bywgc3RhcnQpID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLnNsaWNlSW5uZXIgPSBmdW5jdGlvbiBzbGljZUlubmVyIChmcm9tLCB0bykge1xuICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHZhciBsZWZ0TGVuID0gdGhpcy5sZWZ0Lmxlbmd0aDtcbiAgICBpZiAodG8gPD0gbGVmdExlbikgeyByZXR1cm4gdGhpcy5sZWZ0LnNsaWNlKGZyb20sIHRvKSB9XG4gICAgaWYgKGZyb20gPj0gbGVmdExlbikgeyByZXR1cm4gdGhpcy5yaWdodC5zbGljZShmcm9tIC0gbGVmdExlbiwgdG8gLSBsZWZ0TGVuKSB9XG4gICAgcmV0dXJuIHRoaXMubGVmdC5zbGljZShmcm9tLCBsZWZ0TGVuKS5hcHBlbmQodGhpcy5yaWdodC5zbGljZSgwLCB0byAtIGxlZnRMZW4pKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUubGVhZkFwcGVuZCA9IGZ1bmN0aW9uIGxlYWZBcHBlbmQgKG90aGVyKSB7XG4gICAgdmFyIGlubmVyID0gdGhpcy5yaWdodC5sZWFmQXBwZW5kKG90aGVyKTtcbiAgICBpZiAoaW5uZXIpIHsgcmV0dXJuIG5ldyBBcHBlbmQodGhpcy5sZWZ0LCBpbm5lcikgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUubGVhZlByZXBlbmQgPSBmdW5jdGlvbiBsZWFmUHJlcGVuZCAob3RoZXIpIHtcbiAgICB2YXIgaW5uZXIgPSB0aGlzLmxlZnQubGVhZlByZXBlbmQob3RoZXIpO1xuICAgIGlmIChpbm5lcikgeyByZXR1cm4gbmV3IEFwcGVuZChpbm5lciwgdGhpcy5yaWdodCkgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuYXBwZW5kSW5uZXIgPSBmdW5jdGlvbiBhcHBlbmRJbm5lciAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZWZ0LmRlcHRoID49IE1hdGgubWF4KHRoaXMucmlnaHQuZGVwdGgsIG90aGVyLmRlcHRoKSArIDEpXG4gICAgICB7IHJldHVybiBuZXcgQXBwZW5kKHRoaXMubGVmdCwgbmV3IEFwcGVuZCh0aGlzLnJpZ2h0LCBvdGhlcikpIH1cbiAgICByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLCBvdGhlcilcbiAgfTtcblxuICByZXR1cm4gQXBwZW5kO1xufShSb3BlU2VxdWVuY2UpKTtcblxuZXhwb3J0IGRlZmF1bHQgUm9wZVNlcXVlbmNlO1xuIiwgImltcG9ydCBSb3BlU2VxdWVuY2UgZnJvbSAncm9wZS1zZXF1ZW5jZSc7XG5pbXBvcnQgeyBNYXBwaW5nIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcbmltcG9ydCB7IFBsdWdpbktleSwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vLyBQcm9zZU1pcnJvcidzIGhpc3RvcnkgaXNuJ3Qgc2ltcGx5IGEgd2F5IHRvIHJvbGwgYmFjayB0byBhIHByZXZpb3VzXG4vLyBzdGF0ZSwgYmVjYXVzZSBQcm9zZU1pcnJvciBzdXBwb3J0cyBhcHBseWluZyBjaGFuZ2VzIHdpdGhvdXQgYWRkaW5nXG4vLyB0aGVtIHRvIHRoZSBoaXN0b3J5IChmb3IgZXhhbXBsZSBkdXJpbmcgY29sbGFib3JhdGlvbikuXG4vL1xuLy8gVG8gdGhpcyBlbmQsIGVhY2ggJ0JyYW5jaCcgKG9uZSBmb3IgdGhlIHVuZG8gaGlzdG9yeSBhbmQgb25lIGZvclxuLy8gdGhlIHJlZG8gaGlzdG9yeSkga2VlcHMgYW4gYXJyYXkgb2YgJ0l0ZW1zJywgd2hpY2ggY2FuIG9wdGlvbmFsbHlcbi8vIGhvbGQgYSBzdGVwIChhbiBhY3R1YWwgdW5kb2FibGUgY2hhbmdlKSwgYW5kIGFsd2F5cyBob2xkIGEgcG9zaXRpb25cbi8vIG1hcCAod2hpY2ggaXMgbmVlZGVkIHRvIG1vdmUgY2hhbmdlcyBiZWxvdyB0aGVtIHRvIGFwcGx5IHRvIHRoZVxuLy8gY3VycmVudCBkb2N1bWVudCkuXG4vL1xuLy8gQW4gaXRlbSB0aGF0IGhhcyBib3RoIGEgc3RlcCBhbmQgYSBzZWxlY3Rpb24gYm9va21hcmsgaXMgdGhlIHN0YXJ0XG4vLyBvZiBhbiAnZXZlbnQnIFx1MjAxNCBhIGdyb3VwIG9mIGNoYW5nZXMgdGhhdCB3aWxsIGJlIHVuZG9uZSBvciByZWRvbmUgYXRcbi8vIG9uY2UuIChJdCBzdG9yZXMgb25seSB0aGUgYm9va21hcmssIHNpbmNlIHRoYXQgd2F5IHdlIGRvbid0IGhhdmUgdG9cbi8vIHByb3ZpZGUgYSBkb2N1bWVudCB1bnRpbCB0aGUgc2VsZWN0aW9uIGlzIGFjdHVhbGx5IGFwcGxpZWQsIHdoaWNoXG4vLyBpcyB1c2VmdWwgd2hlbiBjb21wcmVzc2luZy4pXG4vLyBVc2VkIHRvIHNjaGVkdWxlIGhpc3RvcnkgY29tcHJlc3Npb25cbmNvbnN0IG1heF9lbXB0eV9pdGVtcyA9IDUwMDtcbmNsYXNzIEJyYW5jaCB7XG4gICAgY29uc3RydWN0b3IoaXRlbXMsIGV2ZW50Q291bnQpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmV2ZW50Q291bnQgPSBldmVudENvdW50O1xuICAgIH1cbiAgICAvLyBQb3AgdGhlIGxhdGVzdCBldmVudCBvZmYgdGhlIGJyYW5jaCdzIGhpc3RvcnkgYW5kIGFwcGx5IGl0XG4gICAgLy8gdG8gYSBkb2N1bWVudCB0cmFuc2Zvcm0uXG4gICAgcG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yICg7OyBlbmQtLSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLml0ZW1zLmdldChlbmQgLSAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0LnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC0tZW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZW1hcCwgbWFwRnJvbTtcbiAgICAgICAgaWYgKHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoZW5kLCB0aGlzLml0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHN0YXRlLnRyO1xuICAgICAgICBsZXQgc2VsZWN0aW9uLCByZW1haW5pbmc7XG4gICAgICAgIGxldCBhZGRBZnRlciA9IFtdLCBhZGRCZWZvcmUgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAgPSB0aGlzLnJlbWFwcGluZyhlbmQsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFwKSB7XG4gICAgICAgICAgICAgICAgYWRkQmVmb3JlLnB1c2gobmV3IEl0ZW0oaXRlbS5tYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLCBtYXA7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXAgJiYgdHJhbnNmb3JtLm1heWJlU3RlcChzdGVwKS5kb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwID0gdHJhbnNmb3JtLm1hcHBpbmcubWFwc1t0cmFuc2Zvcm0ubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBhZGRBZnRlci5wdXNoKG5ldyBJdGVtKG1hcCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFkZEFmdGVyLmxlbmd0aCArIGFkZEJlZm9yZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgICAgIGlmIChtYXApXG4gICAgICAgICAgICAgICAgICAgIHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLm1heWJlU3RlcChpdGVtLnN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gcmVtYXAgPyBpdGVtLnNlbGVjdGlvbi5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpIDogaXRlbS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gbmV3IEJyYW5jaCh0aGlzLml0ZW1zLnNsaWNlKDAsIGVuZCkuYXBwZW5kKGFkZEJlZm9yZS5yZXZlcnNlKCkuY29uY2F0KGFkZEFmdGVyKSksIHRoaXMuZXZlbnRDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4geyByZW1haW5pbmc6IHJlbWFpbmluZywgdHJhbnNmb3JtLCBzZWxlY3Rpb246IHNlbGVjdGlvbiB9O1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBuZXcgYnJhbmNoIHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybSBhZGRlZC5cbiAgICBhZGRUcmFuc2Zvcm0odHJhbnNmb3JtLCBzZWxlY3Rpb24sIGhpc3RPcHRpb25zLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgIGxldCBuZXdJdGVtcyA9IFtdLCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICBsZXQgb2xkSXRlbXMgPSB0aGlzLml0ZW1zLCBsYXN0SXRlbSA9ICFwcmVzZXJ2ZUl0ZW1zICYmIG9sZEl0ZW1zLmxlbmd0aCA/IG9sZEl0ZW1zLmdldChvbGRJdGVtcy5sZW5ndGggLSAxKSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IHRyYW5zZm9ybS5zdGVwc1tpXS5pbnZlcnQodHJhbnNmb3JtLmRvY3NbaV0pO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgSXRlbSh0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW2ldLCBzdGVwLCBzZWxlY3Rpb24pLCBtZXJnZWQ7XG4gICAgICAgICAgICBpZiAobWVyZ2VkID0gbGFzdEl0ZW0gJiYgbGFzdEl0ZW0ubWVyZ2UoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gbWVyZ2VkO1xuICAgICAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgICAgICBuZXdJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9sZEl0ZW1zID0gb2xkSXRlbXMuc2xpY2UoMCwgb2xkSXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGV2ZW50Q291bnQrKztcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlSXRlbXMpXG4gICAgICAgICAgICAgICAgbGFzdEl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdmVyZmxvdyA9IGV2ZW50Q291bnQgLSBoaXN0T3B0aW9ucy5kZXB0aDtcbiAgICAgICAgaWYgKG92ZXJmbG93ID4gREVQVEhfT1ZFUkZMT1cpIHtcbiAgICAgICAgICAgIG9sZEl0ZW1zID0gY3V0T2ZmRXZlbnRzKG9sZEl0ZW1zLCBvdmVyZmxvdyk7XG4gICAgICAgICAgICBldmVudENvdW50IC09IG92ZXJmbG93O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKG9sZEl0ZW1zLmFwcGVuZChuZXdJdGVtcyksIGV2ZW50Q291bnQpO1xuICAgIH1cbiAgICByZW1hcHBpbmcoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IG1hcHMgPSBuZXcgTWFwcGluZztcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWlycm9yUG9zID0gaXRlbS5taXJyb3JPZmZzZXQgIT0gbnVsbCAmJiBpIC0gaXRlbS5taXJyb3JPZmZzZXQgPj0gZnJvbVxuICAgICAgICAgICAgICAgID8gbWFwcy5tYXBzLmxlbmd0aCAtIGl0ZW0ubWlycm9yT2Zmc2V0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbWFwcy5hcHBlbmRNYXAoaXRlbS5tYXAsIG1pcnJvclBvcyk7XG4gICAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIG1hcHM7XG4gICAgfVxuICAgIGFkZE1hcHMoYXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKHRoaXMuaXRlbXMuYXBwZW5kKGFycmF5Lm1hcChtYXAgPT4gbmV3IEl0ZW0obWFwKSkpLCB0aGlzLmV2ZW50Q291bnQpO1xuICAgIH1cbiAgICAvLyBXaGVuIHRoZSBjb2xsYWIgbW9kdWxlIHJlY2VpdmVzIHJlbW90ZSBjaGFuZ2VzLCB0aGUgaGlzdG9yeSBoYXNcbiAgICAvLyB0byBrbm93IGFib3V0IHRob3NlLCBzbyB0aGF0IGl0IGNhbiBhZGp1c3QgdGhlIHN0ZXBzIHRoYXQgd2VyZVxuICAgIC8vIHJlYmFzZWQgb24gdG9wIG9mIHRoZSByZW1vdGUgY2hhbmdlcywgYW5kIGluY2x1ZGUgdGhlIHBvc2l0aW9uXG4gICAgLy8gbWFwcyBmb3IgdGhlIHJlbW90ZSBjaGFuZ2VzIGluIGl0cyBhcnJheSBvZiBpdGVtcy5cbiAgICByZWJhc2VkKHJlYmFzZWRUcmFuc2Zvcm0sIHJlYmFzZWRDb3VudCkge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRDb3VudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcmViYXNlZEl0ZW1zID0gW10sIHN0YXJ0ID0gTWF0aC5tYXgoMCwgdGhpcy5pdGVtcy5sZW5ndGggLSByZWJhc2VkQ291bnQpO1xuICAgICAgICBsZXQgbWFwcGluZyA9IHJlYmFzZWRUcmFuc2Zvcm0ubWFwcGluZztcbiAgICAgICAgbGV0IG5ld1VudGlsID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7XG4gICAgICAgIGxldCBldmVudENvdW50ID0gdGhpcy5ldmVudENvdW50O1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7IGlmIChpdGVtLnNlbGVjdGlvbilcbiAgICAgICAgICAgIGV2ZW50Q291bnQtLTsgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgaVJlYmFzZWQgPSByZWJhc2VkQ291bnQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLmdldE1pcnJvcigtLWlSZWJhc2VkKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBuZXdVbnRpbCA9IE1hdGgubWluKG5ld1VudGlsLCBwb3MpO1xuICAgICAgICAgICAgbGV0IG1hcCA9IG1hcHBpbmcubWFwc1twb3NdO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gcmViYXNlZFRyYW5zZm9ybS5zdGVwc1twb3NdLmludmVydChyZWJhc2VkVHJhbnNmb3JtLmRvY3NbcG9zXSk7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChtYXBwaW5nLnNsaWNlKGlSZWJhc2VkICsgMSwgcG9zKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDb3VudCsrO1xuICAgICAgICAgICAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCwgc3RlcCwgc2VsZWN0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWJhc2VkSXRlbXMucHVzaChuZXcgSXRlbShtYXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc3RhcnQpO1xuICAgICAgICBsZXQgbmV3TWFwcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gcmViYXNlZENvdW50OyBpIDwgbmV3VW50aWw7IGkrKylcbiAgICAgICAgICAgIG5ld01hcHMucHVzaChuZXcgSXRlbShtYXBwaW5nLm1hcHNbaV0pKTtcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwLCBzdGFydCkuYXBwZW5kKG5ld01hcHMpLmFwcGVuZChyZWJhc2VkSXRlbXMpO1xuICAgICAgICBsZXQgYnJhbmNoID0gbmV3IEJyYW5jaChpdGVtcywgZXZlbnRDb3VudCk7XG4gICAgICAgIGlmIChicmFuY2guZW1wdHlJdGVtQ291bnQoKSA+IG1heF9lbXB0eV9pdGVtcylcbiAgICAgICAgICAgIGJyYW5jaCA9IGJyYW5jaC5jb21wcmVzcyh0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRJdGVtcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgIH1cbiAgICBlbXB0eUl0ZW1Db3VudCgpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4geyBpZiAoIWl0ZW0uc3RlcClcbiAgICAgICAgICAgIGNvdW50Kys7IH0pO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIC8vIENvbXByZXNzaW5nIGEgYnJhbmNoIG1lYW5zIHJld3JpdGluZyBpdCB0byBwdXNoIHRoZSBhaXIgKG1hcC1vbmx5XG4gICAgLy8gaXRlbXMpIG91dC4gRHVyaW5nIGNvbGxhYm9yYXRpb24sIHRoZXNlIG5hdHVyYWxseSBhY2N1bXVsYXRlXG4gICAgLy8gYmVjYXVzZSBlYWNoIHJlbW90ZSBjaGFuZ2UgYWRkcyBvbmUuIFRoZSBgdXB0b2AgYXJndW1lbnQgaXMgdXNlZFxuICAgIC8vIHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGl0ZW1zIGJlbG93IGEgZ2l2ZW4gbGV2ZWwgYXJlIGNvbXByZXNzZWQsXG4gICAgLy8gYmVjYXVzZSBgcmViYXNlZGAgcmVsaWVzIG9uIGEgY2xlYW4sIHVudG91Y2hlZCBzZXQgb2YgaXRlbXMgaW5cbiAgICAvLyBvcmRlciB0byBhc3NvY2lhdGUgb2xkIGl0ZW1zIHdpdGggcmViYXNlZCBzdGVwcy5cbiAgICBjb21wcmVzcyh1cHRvID0gdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoMCwgdXB0byksIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgbGV0IGl0ZW1zID0gW10sIGV2ZW50cyA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPj0gdXB0bykge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0uc3RlcCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcCA9IHN0ZXAgJiYgc3RlcC5nZXRNYXAoKTtcbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgaWYgKG1hcClcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAuYXBwZW5kTWFwKG1hcCwgbWFwRnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGl0ZW0uc2VsZWN0aW9uICYmIGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMrKztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0l0ZW0gPSBuZXcgSXRlbShtYXAuaW52ZXJ0KCksIHN0ZXAsIHNlbGVjdGlvbiksIG1lcmdlZCwgbGFzdCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXJnZWQgPSBpdGVtcy5sZW5ndGggJiYgaXRlbXNbbGFzdF0ubWVyZ2UobmV3SXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tsYXN0XSA9IG1lcmdlZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLm1hcCkge1xuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pdGVtcy5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4gbmV3IEJyYW5jaChSb3BlU2VxdWVuY2UuZnJvbShpdGVtcy5yZXZlcnNlKCkpLCBldmVudHMpO1xuICAgIH1cbn1cbkJyYW5jaC5lbXB0eSA9IG5ldyBCcmFuY2goUm9wZVNlcXVlbmNlLmVtcHR5LCAwKTtcbmZ1bmN0aW9uIGN1dE9mZkV2ZW50cyhpdGVtcywgbikge1xuICAgIGxldCBjdXRQb2ludDtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbiAmJiAobi0tID09IDApKSB7XG4gICAgICAgICAgICBjdXRQb2ludCA9IGk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXRlbXMuc2xpY2UoY3V0UG9pbnQpO1xufVxuY2xhc3MgSXRlbSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIChmb3J3YXJkKSBzdGVwIG1hcCBmb3IgdGhpcyBpdGVtLlxuICAgIG1hcCwgXG4gICAgLy8gVGhlIGludmVydGVkIHN0ZXBcbiAgICBzdGVwLCBcbiAgICAvLyBJZiB0aGlzIGlzIG5vbi1udWxsLCB0aGlzIGl0ZW0gaXMgdGhlIHN0YXJ0IG9mIGEgZ3JvdXAsIGFuZFxuICAgIC8vIHRoaXMgc2VsZWN0aW9uIGlzIHRoZSBzdGFydGluZyBzZWxlY3Rpb24gZm9yIHRoZSBncm91cCAodGhlIG9uZVxuICAgIC8vIHRoYXQgd2FzIGFjdGl2ZSBiZWZvcmUgdGhlIGZpcnN0IHN0ZXAgd2FzIGFwcGxpZWQpXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvLyBJZiB0aGlzIGl0ZW0gaXMgdGhlIGludmVyc2Ugb2YgYSBwcmV2aW91cyBtYXBwaW5nIG9uIHRoZSBzdGFjayxcbiAgICAvLyB0aGlzIHBvaW50cyBhdCB0aGUgaW52ZXJzZSdzIG9mZnNldFxuICAgIG1pcnJvck9mZnNldCkge1xuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5zdGVwID0gc3RlcDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMubWlycm9yT2Zmc2V0ID0gbWlycm9yT2Zmc2V0O1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5zdGVwICYmIG90aGVyLnN0ZXAgJiYgIW90aGVyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHN0ZXAgPSBvdGhlci5zdGVwLm1lcmdlKHRoaXMuc3RlcCk7XG4gICAgICAgICAgICBpZiAoc3RlcClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEl0ZW0oc3RlcC5nZXRNYXAoKS5pbnZlcnQoKSwgc3RlcCwgdGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVGhlIHZhbHVlIG9mIHRoZSBzdGF0ZSBmaWVsZCB0aGF0IHRyYWNrcyB1bmRvL3JlZG8gaGlzdG9yeSBmb3IgdGhhdFxuLy8gc3RhdGUuIFdpbGwgYmUgc3RvcmVkIGluIHRoZSBwbHVnaW4gc3RhdGUgd2hlbiB0aGUgaGlzdG9yeSBwbHVnaW5cbi8vIGlzIGFjdGl2ZS5cbmNsYXNzIEhpc3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZG9uZSwgdW5kb25lLCBwcmV2UmFuZ2VzLCBwcmV2VGltZSwgcHJldkNvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIHRoaXMudW5kb25lID0gdW5kb25lO1xuICAgICAgICB0aGlzLnByZXZSYW5nZXMgPSBwcmV2UmFuZ2VzO1xuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG4gICAgICAgIHRoaXMucHJldkNvbXBvc2l0aW9uID0gcHJldkNvbXBvc2l0aW9uO1xuICAgIH1cbn1cbmNvbnN0IERFUFRIX09WRVJGTE9XID0gMjA7XG4vLyBSZWNvcmQgYSB0cmFuc2Zvcm1hdGlvbiBpbiB1bmRvIGhpc3RvcnkuXG5mdW5jdGlvbiBhcHBseVRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCB0ciwgb3B0aW9ucykge1xuICAgIGxldCBoaXN0b3J5VHIgPSB0ci5nZXRNZXRhKGhpc3RvcnlLZXkpLCByZWJhc2VkO1xuICAgIGlmIChoaXN0b3J5VHIpXG4gICAgICAgIHJldHVybiBoaXN0b3J5VHIuaGlzdG9yeVN0YXRlO1xuICAgIGlmICh0ci5nZXRNZXRhKGNsb3NlSGlzdG9yeUtleSkpXG4gICAgICAgIGhpc3RvcnkgPSBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUsIG51bGwsIDAsIC0xKTtcbiAgICBsZXQgYXBwZW5kZWQgPSB0ci5nZXRNZXRhKFwiYXBwZW5kZWRUcmFuc2FjdGlvblwiKTtcbiAgICBpZiAodHIuc3RlcHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIGhpc3Rvcnk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwcGVuZGVkICYmIGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkpIHtcbiAgICAgICAgaWYgKGFwcGVuZGVkLmdldE1ldGEoaGlzdG9yeUtleSkucmVkbylcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgaGlzdG9yeS51bmRvbmUsIHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHMpLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZSwgaGlzdG9yeS51bmRvbmUuYWRkVHJhbnNmb3JtKHRyLCB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIG51bGwsIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHIuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSAhPT0gZmFsc2UgJiYgIShhcHBlbmRlZCAmJiBhcHBlbmRlZC5nZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIpID09PSBmYWxzZSkpIHtcbiAgICAgICAgLy8gR3JvdXAgdHJhbnNmb3JtcyB0aGF0IG9jY3VyIGluIHF1aWNrIHN1Y2Nlc3Npb24gaW50byBvbmUgZXZlbnQuXG4gICAgICAgIGxldCBjb21wb3NpdGlvbiA9IHRyLmdldE1ldGEoXCJjb21wb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IG5ld0dyb3VwID0gaGlzdG9yeS5wcmV2VGltZSA9PSAwIHx8XG4gICAgICAgICAgICAoIWFwcGVuZGVkICYmIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uICE9IGNvbXBvc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgKGhpc3RvcnkucHJldlRpbWUgPCAodHIudGltZSB8fCAwKSAtIG9wdGlvbnMubmV3R3JvdXBEZWxheSB8fCAhaXNBZGphY2VudFRvKHRyLCBoaXN0b3J5LnByZXZSYW5nZXMpKSk7XG4gICAgICAgIGxldCBwcmV2UmFuZ2VzID0gYXBwZW5kZWQgPyBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSA6IHJhbmdlc0Zvcih0ci5tYXBwaW5nLm1hcHMpO1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUuYWRkVHJhbnNmb3JtKHRyLCBuZXdHcm91cCA/IHN0YXRlLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpIDogdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBCcmFuY2guZW1wdHksIHByZXZSYW5nZXMsIHRyLnRpbWUsIGNvbXBvc2l0aW9uID09IG51bGwgPyBoaXN0b3J5LnByZXZDb21wb3NpdGlvbiA6IGNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmViYXNlZCA9IHRyLmdldE1ldGEoXCJyZWJhc2VkXCIpKSB7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIGNvbGxhYiBtb2R1bGUgdG8gdGVsbCB0aGUgaGlzdG9yeSB0aGF0IHNvbWUgb2YgaXRzXG4gICAgICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gcmViYXNlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBoaXN0b3J5LnVuZG9uZS5yZWJhc2VkKHRyLCByZWJhc2VkKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRNYXBzKHRyLm1hcHBpbmcubWFwcyksIGhpc3RvcnkudW5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZyksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0FkamFjZW50VG8odHJhbnNmb3JtLCBwcmV2UmFuZ2VzKSB7XG4gICAgaWYgKCFwcmV2UmFuZ2VzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF0cmFuc2Zvcm0uZG9jQ2hhbmdlZClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGFkamFjZW50ID0gZmFsc2U7XG4gICAgdHJhbnNmb3JtLm1hcHBpbmcubWFwc1swXS5mb3JFYWNoKChzdGFydCwgZW5kKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldlJhbmdlcy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIGlmIChzdGFydCA8PSBwcmV2UmFuZ2VzW2kgKyAxXSAmJiBlbmQgPj0gcHJldlJhbmdlc1tpXSlcbiAgICAgICAgICAgICAgICBhZGphY2VudCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkamFjZW50O1xufVxuZnVuY3Rpb24gcmFuZ2VzRm9yKG1hcHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IG1hcHMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHJlc3VsdC5sZW5ndGggPT0gMDsgaS0tKVxuICAgICAgICBtYXBzW2ldLmZvckVhY2goKF9mcm9tLCBfdG8sIGZyb20sIHRvKSA9PiByZXN1bHQucHVzaChmcm9tLCB0bykpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXBSYW5nZXMocmFuZ2VzLCBtYXBwaW5nKSB7XG4gICAgaWYgKCFyYW5nZXMpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwKHJhbmdlc1tpXSwgMSksIHRvID0gbWFwcGluZy5tYXAocmFuZ2VzW2kgKyAxXSwgLTEpO1xuICAgICAgICBpZiAoZnJvbSA8PSB0bylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyb20sIHRvKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEFwcGx5IHRoZSBsYXRlc3QgZXZlbnQgZnJvbSBvbmUgYnJhbmNoIHRvIHRoZSBkb2N1bWVudCBhbmQgc2hpZnQgdGhlIGV2ZW50XG4vLyBvbnRvIHRoZSBvdGhlciBicmFuY2guXG5mdW5jdGlvbiBoaXN0VHJhbnNhY3Rpb24oaGlzdG9yeSwgc3RhdGUsIHJlZG8pIHtcbiAgICBsZXQgcHJlc2VydmVJdGVtcyA9IG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKTtcbiAgICBsZXQgaGlzdE9wdGlvbnMgPSBoaXN0b3J5S2V5LmdldChzdGF0ZSkuc3BlYy5jb25maWc7XG4gICAgbGV0IHBvcCA9IChyZWRvID8gaGlzdG9yeS51bmRvbmUgOiBoaXN0b3J5LmRvbmUpLnBvcEV2ZW50KHN0YXRlLCBwcmVzZXJ2ZUl0ZW1zKTtcbiAgICBpZiAoIXBvcClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHBvcC5zZWxlY3Rpb24ucmVzb2x2ZShwb3AudHJhbnNmb3JtLmRvYyk7XG4gICAgbGV0IGFkZGVkID0gKHJlZG8gPyBoaXN0b3J5LmRvbmUgOiBoaXN0b3J5LnVuZG9uZSkuYWRkVHJhbnNmb3JtKHBvcC50cmFuc2Zvcm0sIHN0YXRlLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpLCBoaXN0T3B0aW9ucywgcHJlc2VydmVJdGVtcyk7XG4gICAgbGV0IG5ld0hpc3QgPSBuZXcgSGlzdG9yeVN0YXRlKHJlZG8gPyBhZGRlZCA6IHBvcC5yZW1haW5pbmcsIHJlZG8gPyBwb3AucmVtYWluaW5nIDogYWRkZWQsIG51bGwsIDAsIC0xKTtcbiAgICByZXR1cm4gcG9wLnRyYW5zZm9ybS5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKS5zZXRNZXRhKGhpc3RvcnlLZXksIHsgcmVkbywgaGlzdG9yeVN0YXRlOiBuZXdIaXN0IH0pO1xufVxubGV0IGNhY2hlZFByZXNlcnZlSXRlbXMgPSBmYWxzZSwgY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgPSBudWxsO1xuLy8gQ2hlY2sgd2hldGhlciBhbnkgcGx1Z2luIGluIHRoZSBnaXZlbiBzdGF0ZSBoYXMgYVxuLy8gYGhpc3RvcnlQcmVzZXJ2ZUl0ZW1zYCBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0XG4vLyBwcmVzZXJ2ZSBzdGVwcyBleGFjdGx5IGFzIHRoZXkgY2FtZSBpbiwgc28gdGhhdCB0aGV5IGNhbiBiZVxuLy8gcmViYXNlZC5cbmZ1bmN0aW9uIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSB7XG4gICAgbGV0IHBsdWdpbnMgPSBzdGF0ZS5wbHVnaW5zO1xuICAgIGlmIChjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyAhPSBwbHVnaW5zKSB7XG4gICAgICAgIGNhY2hlZFByZXNlcnZlSXRlbXMgPSBmYWxzZTtcbiAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgPSBwbHVnaW5zO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAocGx1Z2luc1tpXS5zcGVjLmhpc3RvcnlQcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRQcmVzZXJ2ZUl0ZW1zO1xufVxuLyoqXG5TZXQgYSBmbGFnIG9uIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiB0aGF0IHdpbGwgcHJldmVudCBmdXJ0aGVyIHN0ZXBzXG5mcm9tIGJlaW5nIGFwcGVuZGVkIHRvIGFuIGV4aXN0aW5nIGhpc3RvcnkgZXZlbnQgKHNvIHRoYXQgdGhleVxucmVxdWlyZSBhIHNlcGFyYXRlIHVuZG8gY29tbWFuZCB0byB1bmRvKS5cbiovXG5mdW5jdGlvbiBjbG9zZUhpc3RvcnkodHIpIHtcbiAgICByZXR1cm4gdHIuc2V0TWV0YShjbG9zZUhpc3RvcnlLZXksIHRydWUpO1xufVxuY29uc3QgaGlzdG9yeUtleSA9IG5ldyBQbHVnaW5LZXkoXCJoaXN0b3J5XCIpO1xuY29uc3QgY2xvc2VIaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImNsb3NlSGlzdG9yeVwiKTtcbi8qKlxuUmV0dXJucyBhIHBsdWdpbiB0aGF0IGVuYWJsZXMgdGhlIHVuZG8gaGlzdG9yeSBmb3IgYW4gZWRpdG9yLiBUaGVcbnBsdWdpbiB3aWxsIHRyYWNrIHVuZG8gYW5kIHJlZG8gc3RhY2tzLCB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIHRoZVxuW2B1bmRvYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2hpc3RvcnkudW5kbykgYW5kIFtgcmVkb2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNoaXN0b3J5LnJlZG8pIGNvbW1hbmRzLlxuXG5Zb3UgY2FuIHNldCBhbiBgXCJhZGRUb0hpc3RvcnlcImAgW21ldGFkYXRhXG5wcm9wZXJ0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNldE1ldGEpIG9mIGBmYWxzZWAgb24gYSB0cmFuc2FjdGlvblxudG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIHJvbGxlZCBiYWNrIGJ5IHVuZG8uXG4qL1xuZnVuY3Rpb24gaGlzdG9yeShjb25maWcgPSB7fSkge1xuICAgIGNvbmZpZyA9IHsgZGVwdGg6IGNvbmZpZy5kZXB0aCB8fCAxMDAsXG4gICAgICAgIG5ld0dyb3VwRGVsYXk6IGNvbmZpZy5uZXdHcm91cERlbGF5IHx8IDUwMCB9O1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBoaXN0b3J5S2V5LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgaW5pdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShCcmFuY2guZW1wdHksIEJyYW5jaC5lbXB0eSwgbnVsbCwgMCwgLTEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGx5KHRyLCBoaXN0LCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseVRyYW5zYWN0aW9uKGhpc3QsIHN0YXRlLCB0ciwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgYmVmb3JlaW5wdXQodmlldywgZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5wdXRUeXBlID0gZS5pbnB1dFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gaW5wdXRUeXBlID09IFwiaGlzdG9yeVVuZG9cIiA/IHVuZG8gOiBpbnB1dFR5cGUgPT0gXCJoaXN0b3J5UmVkb1wiID8gcmVkbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZCh2aWV3LnN0YXRlLCB2aWV3LmRpc3BhdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ29tbWFuZChyZWRvLCBzY3JvbGwpIHtcbiAgICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgICAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICBpZiAoIWhpc3QgfHwgKHJlZG8gPyBoaXN0LnVuZG9uZSA6IGhpc3QuZG9uZSkuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCB0ciA9IGhpc3RUcmFuc2FjdGlvbihoaXN0LCBzdGF0ZSwgcmVkbyk7XG4gICAgICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc2Nyb2xsID8gdHIuc2Nyb2xsSW50b1ZpZXcoKSA6IHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB1bmRvZXMgdGhlIGxhc3QgY2hhbmdlLCBpZiBhbnkuXG4qL1xuY29uc3QgdW5kbyA9IGJ1aWxkQ29tbWFuZChmYWxzZSwgdHJ1ZSk7XG4vKipcbkEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHJlZG9lcyB0aGUgbGFzdCB1bmRvbmUgY2hhbmdlLCBpZiBhbnkuXG4qL1xuY29uc3QgcmVkbyA9IGJ1aWxkQ29tbWFuZCh0cnVlLCB0cnVlKTtcbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdW5kb2VzIHRoZSBsYXN0IGNoYW5nZS4gRG9uJ3Qgc2Nyb2xsIHRoZVxuc2VsZWN0aW9uIGludG8gdmlldy5cbiovXG5jb25zdCB1bmRvTm9TY3JvbGwgPSBidWlsZENvbW1hbmQoZmFsc2UsIGZhbHNlKTtcbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgcmVkb2VzIHRoZSBsYXN0IHVuZG9uZSBjaGFuZ2UuIERvbid0XG5zY3JvbGwgdGhlIHNlbGVjdGlvbiBpbnRvIHZpZXcuXG4qL1xuY29uc3QgcmVkb05vU2Nyb2xsID0gYnVpbGRDb21tYW5kKHRydWUsIGZhbHNlKTtcbi8qKlxuVGhlIGFtb3VudCBvZiB1bmRvYWJsZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuZnVuY3Rpb24gdW5kb0RlcHRoKHN0YXRlKSB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICByZXR1cm4gaGlzdCA/IGhpc3QuZG9uZS5ldmVudENvdW50IDogMDtcbn1cbi8qKlxuVGhlIGFtb3VudCBvZiByZWRvYWJsZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gZWRpdG9yIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHJlZG9EZXB0aChzdGF0ZSkge1xuICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIGhpc3QgPyBoaXN0LnVuZG9uZS5ldmVudENvdW50IDogMDtcbn1cblxuZXhwb3J0IHsgY2xvc2VIaXN0b3J5LCBoaXN0b3J5LCByZWRvLCByZWRvRGVwdGgsIHJlZG9Ob1Njcm9sbCwgdW5kbywgdW5kb0RlcHRoLCB1bmRvTm9TY3JvbGwgfTtcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgdHlwZSB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGludGVyZmFjZSBDaGFyYWN0ZXJDb3VudE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYmUgYWxsb3dlZC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlIDE4MFxuICAgKi9cbiAgbGltaXQ6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWRcbiAgLyoqXG4gICAqIFRoZSBtb2RlIGJ5IHdoaWNoIHRoZSBzaXplIGlzIGNhbGN1bGF0ZWQuIElmIHNldCB0byBgdGV4dFNpemVgLCB0aGUgdGV4dENvbnRlbnQgb2YgdGhlIGRvY3VtZW50IGlzIHVzZWQuXG4gICAqIElmIHNldCB0byBgbm9kZVNpemVgLCB0aGUgbm9kZVNpemUgb2YgdGhlIGRvY3VtZW50IGlzIHVzZWQuXG4gICAqIEBkZWZhdWx0ICd0ZXh0U2l6ZSdcbiAgICogQGV4YW1wbGUgJ3RleHRTaXplJ1xuICAgKi9cbiAgbW9kZTogJ3RleHRTaXplJyB8ICdub2RlU2l6ZSdcbiAgLyoqXG4gICAqIFRoZSB0ZXh0IGNvdW50ZXIgZnVuY3Rpb24gdG8gdXNlLiBEZWZhdWx0cyB0byBhIHNpbXBsZSBjaGFyYWN0ZXIgY291bnQuXG4gICAqIEBkZWZhdWx0ICh0ZXh0KSA9PiB0ZXh0Lmxlbmd0aFxuICAgKiBAZXhhbXBsZSAodGV4dCkgPT4gWy4uLm5ldyBJbnRsLlNlZ21lbnRlcigpLnNlZ21lbnQodGV4dCldLmxlbmd0aFxuICAgKi9cbiAgdGV4dENvdW50ZXI6ICh0ZXh0OiBzdHJpbmcpID0+IG51bWJlclxuICAvKipcbiAgICogVGhlIHdvcmQgY291bnRlciBmdW5jdGlvbiB0byB1c2UuIERlZmF1bHRzIHRvIGEgc2ltcGxlIHdvcmQgY291bnQuXG4gICAqIEBkZWZhdWx0ICh0ZXh0KSA9PiB0ZXh0LnNwbGl0KCcgJykuZmlsdGVyKHdvcmQgPT4gd29yZCAhPT0gJycpLmxlbmd0aFxuICAgKiBAZXhhbXBsZSAodGV4dCkgPT4gdGV4dC5zcGxpdCgvXFxzKy8pLmZpbHRlcih3b3JkID0+IHdvcmQgIT09ICcnKS5sZW5ndGhcbiAgICovXG4gIHdvcmRDb3VudGVyOiAodGV4dDogc3RyaW5nKSA9PiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGFyYWN0ZXJDb3VudFN0b3JhZ2Uge1xuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgY2hhcmFjdGVyIGNvdW50LiAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBvcHRpb25zLm5vZGUgVGhlIG5vZGUgdG8gZ2V0IHRoZSBjaGFyYWN0ZXJzIGZyb20uIERlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgKiBAcGFyYW0gb3B0aW9ucy5tb2RlIFRoZSBtb2RlIGJ5IHdoaWNoIHRoZSBzaXplIGlzIGNhbGN1bGF0ZWQuIElmIHNldCB0byBgdGV4dFNpemVgLCB0aGUgdGV4dENvbnRlbnQgb2YgdGhlIGRvY3VtZW50IGlzIHVzZWQuXG4gICAqL1xuICBjaGFyYWN0ZXJzOiAob3B0aW9ucz86IHsgbm9kZT86IFByb3NlTWlycm9yTm9kZTsgbW9kZT86ICd0ZXh0U2l6ZScgfCAnbm9kZVNpemUnIH0pID0+IG51bWJlclxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlciBvZiB3b3JkcyBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgY2hhcmFjdGVyIGNvdW50LiAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSBvcHRpb25zLm5vZGUgVGhlIG5vZGUgdG8gZ2V0IHRoZSB3b3JkcyBmcm9tLiBEZWZhdWx0cyB0byB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAgICovXG4gIHdvcmRzOiAob3B0aW9ucz86IHsgbm9kZT86IFByb3NlTWlycm9yTm9kZSB9KSA9PiBudW1iZXJcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgU3RvcmFnZSB7XG4gICAgY2hhcmFjdGVyQ291bnQ6IENoYXJhY3RlckNvdW50U3RvcmFnZVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjb3VudCB0aGUgY2hhcmFjdGVycyBhbmQgd29yZHMgb2YgeW91ciBkb2N1bWVudC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2NoYXJhY3Rlci1jb3VudFxuICovXG5leHBvcnQgY29uc3QgQ2hhcmFjdGVyQ291bnQgPSBFeHRlbnNpb24uY3JlYXRlPENoYXJhY3RlckNvdW50T3B0aW9ucywgQ2hhcmFjdGVyQ291bnRTdG9yYWdlPih7XG4gIG5hbWU6ICdjaGFyYWN0ZXJDb3VudCcsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGltaXQ6IG51bGwsXG4gICAgICBtb2RlOiAndGV4dFNpemUnLFxuICAgICAgdGV4dENvdW50ZXI6IHRleHQgPT4gdGV4dC5sZW5ndGgsXG4gICAgICB3b3JkQ291bnRlcjogdGV4dCA9PiB0ZXh0LnNwbGl0KCcgJykuZmlsdGVyKHdvcmQgPT4gd29yZCAhPT0gJycpLmxlbmd0aCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkU3RvcmFnZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhcmFjdGVyczogKCkgPT4gMCxcbiAgICAgIHdvcmRzOiAoKSA9PiAwLFxuICAgIH1cbiAgfSxcblxuICBvbkJlZm9yZUNyZWF0ZSgpIHtcbiAgICB0aGlzLnN0b3JhZ2UuY2hhcmFjdGVycyA9IG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IG9wdGlvbnM/Lm5vZGUgfHwgdGhpcy5lZGl0b3Iuc3RhdGUuZG9jXG4gICAgICBjb25zdCBtb2RlID0gb3B0aW9ucz8ubW9kZSB8fCB0aGlzLm9wdGlvbnMubW9kZVxuXG4gICAgICBpZiAobW9kZSA9PT0gJ3RleHRTaXplJykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0QmV0d2VlbigwLCBub2RlLmNvbnRlbnQuc2l6ZSwgdW5kZWZpbmVkLCAnICcpXG5cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy50ZXh0Q291bnRlcih0ZXh0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5ub2RlU2l6ZVxuICAgIH1cblxuICAgIHRoaXMuc3RvcmFnZS53b3JkcyA9IG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IG9wdGlvbnM/Lm5vZGUgfHwgdGhpcy5lZGl0b3Iuc3RhdGUuZG9jXG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0QmV0d2VlbigwLCBub2RlLmNvbnRlbnQuc2l6ZSwgJyAnLCAnICcpXG5cbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMud29yZENvdW50ZXIodGV4dClcbiAgICB9XG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGxldCBpbml0aWFsRXZhbHVhdGlvbkRvbmUgPSBmYWxzZVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NoYXJhY3RlckNvdW50JyksXG4gICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoaW5pdGlhbEV2YWx1YXRpb25Eb25lKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBsaW1pdCA9IHRoaXMub3B0aW9ucy5saW1pdFxuXG4gICAgICAgICAgaWYgKGxpbWl0ID09PSBudWxsIHx8IGxpbWl0ID09PSB1bmRlZmluZWQgfHwgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgIGluaXRpYWxFdmFsdWF0aW9uRG9uZSA9IHRydWVcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGluaXRpYWxDb250ZW50U2l6ZSA9IHRoaXMuc3RvcmFnZS5jaGFyYWN0ZXJzKHsgbm9kZTogbmV3U3RhdGUuZG9jIH0pXG5cbiAgICAgICAgICBpZiAoaW5pdGlhbENvbnRlbnRTaXplID4gbGltaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXIgPSBpbml0aWFsQ29udGVudFNpemUgLSBsaW1pdFxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IDBcbiAgICAgICAgICAgIGNvbnN0IHRvID0gb3ZlclxuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGBbQ2hhcmFjdGVyQ291bnRdIEluaXRpYWwgY29udGVudCBleGNlZWRlZCBsaW1pdCBvZiAke2xpbWl0fSBjaGFyYWN0ZXJzLiBDb250ZW50IHdhcyBhdXRvbWF0aWNhbGx5IHRyaW1tZWQuYCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pXG5cbiAgICAgICAgICAgIGluaXRpYWxFdmFsdWF0aW9uRG9uZSA9IHRydWVcbiAgICAgICAgICAgIHJldHVybiB0clxuICAgICAgICAgIH1cblxuICAgICAgICAgIGluaXRpYWxFdmFsdWF0aW9uRG9uZSA9IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZmlsdGVyVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbiwgc3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBsaW1pdCA9IHRoaXMub3B0aW9ucy5saW1pdFxuXG4gICAgICAgICAgLy8gTm90aGluZyBoYXMgY2hhbmdlZCBvciBubyBsaW1pdCBpcyBkZWZpbmVkLiBJZ25vcmUgaXQuXG4gICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkIHx8IGxpbWl0ID09PSAwIHx8IGxpbWl0ID09PSBudWxsIHx8IGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgb2xkU2l6ZSA9IHRoaXMuc3RvcmFnZS5jaGFyYWN0ZXJzKHsgbm9kZTogc3RhdGUuZG9jIH0pXG4gICAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMuc3RvcmFnZS5jaGFyYWN0ZXJzKHsgbm9kZTogdHJhbnNhY3Rpb24uZG9jIH0pXG5cbiAgICAgICAgICAvLyBFdmVyeXRoaW5nIGlzIGluIHRoZSBsaW1pdC4gR29vZC5cbiAgICAgICAgICBpZiAobmV3U2l6ZSA8PSBsaW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUaGUgbGltaXQgaGFzIGFscmVhZHkgYmVlbiBleGNlZWRlZCBidXQgd2lsbCBiZSByZWR1Y2VkLlxuICAgICAgICAgIGlmIChvbGRTaXplID4gbGltaXQgJiYgbmV3U2l6ZSA+IGxpbWl0ICYmIG5ld1NpemUgPD0gb2xkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUaGUgbGltaXQgaGFzIGFscmVhZHkgYmVlbiBleGNlZWRlZCBhbmQgd2lsbCBiZSBpbmNyZWFzZWQgZnVydGhlci5cbiAgICAgICAgICBpZiAob2xkU2l6ZSA+IGxpbWl0ICYmIG5ld1NpemUgPiBsaW1pdCAmJiBuZXdTaXplID4gb2xkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNQYXN0ZSA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3Bhc3RlJylcblxuICAgICAgICAgIC8vIEJsb2NrIGFsbCBleGNlZWRpbmcgdHJhbnNhY3Rpb25zIHRoYXQgd2VyZSBub3QgcGFzdGVkLlxuICAgICAgICAgIGlmICghaXNQYXN0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRm9yIHBhc3RlZCBjb250ZW50LCB3ZSB0cnkgdG8gcmVtb3ZlIHRoZSBleGNlZWRpbmcgY29udGVudC5cbiAgICAgICAgICBjb25zdCBwb3MgPSB0cmFuc2FjdGlvbi5zZWxlY3Rpb24uJGhlYWQucG9zXG4gICAgICAgICAgY29uc3Qgb3ZlciA9IG5ld1NpemUgLSBsaW1pdFxuICAgICAgICAgIGNvbnN0IGZyb20gPSBwb3MgLSBvdmVyXG4gICAgICAgICAgY29uc3QgdG8gPSBwb3NcblxuICAgICAgICAgIC8vIEl04oCZcyBwcm9iYWJseSBhIGJhZCBpZGVhIHRvIG11dGF0ZSB0cmFuc2FjdGlvbnMgd2l0aGluIGBmaWx0ZXJUcmFuc2FjdGlvbmBcbiAgICAgICAgICAvLyBidXQgZm9yIG5vdyB0aGlzIGlzIHdvcmtpbmcgZmluZS5cbiAgICAgICAgICB0cmFuc2FjdGlvbi5kZWxldGVSYW5nZShmcm9tLCB0bylcblxuICAgICAgICAgIC8vIEluIHNvbWUgc2l0dWF0aW9ucywgdGhlIGxpbWl0IHdpbGwgY29udGludWUgdG8gYmUgZXhjZWVkZWQgYWZ0ZXIgdHJpbW1pbmcuXG4gICAgICAgICAgLy8gVGhpcyBoYXBwZW5zIGUuZy4gd2hlbiB0cnVuY2F0aW5nIHdpdGhpbiBhIGNvbXBsZXggbm9kZSAoZS5nLiB0YWJsZSlcbiAgICAgICAgICAvLyBhbmQgUHJvc2VNaXJyb3IgaGFzIHRvIGNsb3NlIHRoaXMgbm9kZSBhZ2Fpbi5cbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBjYXNlLCB3ZSBwcmV2ZW50IHRoZSB0cmFuc2FjdGlvbiBjb21wbGV0ZWx5LlxuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTaXplID0gdGhpcy5zdG9yYWdlLmNoYXJhY3RlcnMoeyBub2RlOiB0cmFuc2FjdGlvbi5kb2MgfSlcblxuICAgICAgICAgIGlmICh1cGRhdGVkU2l6ZSA+IGxpbWl0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBkcm9wQ3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9wbS9kcm9wY3Vyc29yJ1xuXG5leHBvcnQgaW50ZXJmYWNlIERyb3BjdXJzb3JPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgZHJvcCBjdXJzb3JcbiAgICogQGRlZmF1bHQgJ2N1cnJlbnRDb2xvcidcbiAgICogQGV4YW1wbGUgJ3JlZCdcbiAgICovXG4gIGNvbG9yOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSBkcm9wIGN1cnNvclxuICAgKiBAZGVmYXVsdCAxXG4gICAqIEBleGFtcGxlIDJcbiAgICovXG4gIHdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWRcblxuICAvKipcbiAgICogVGhlIGNsYXNzIG9mIHRoZSBkcm9wIGN1cnNvclxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICogQGV4YW1wbGUgJ2Ryb3AtY3Vyc29yJ1xuICAgKi9cbiAgY2xhc3M6IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gYWRkIGEgZHJvcCBjdXJzb3IgdG8geW91ciBlZGl0b3IuXG4gKiBBIGRyb3AgY3Vyc29yIGlzIGEgbGluZSB0aGF0IGFwcGVhcnMgd2hlbiB5b3UgZHJhZyBhbmQgZHJvcCBjb250ZW50XG4gKiBpbi1iZXR3ZWVuIG5vZGVzLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvZHJvcGN1cnNvclxuICovXG5leHBvcnQgY29uc3QgRHJvcGN1cnNvciA9IEV4dGVuc2lvbi5jcmVhdGU8RHJvcGN1cnNvck9wdGlvbnM+KHtcbiAgbmFtZTogJ2Ryb3BDdXJzb3InLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgY2xhc3M6IHVuZGVmaW5lZCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIHJldHVybiBbZHJvcEN1cnNvcih0aGlzLm9wdGlvbnMpXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5leHBvcnQgaW50ZXJmYWNlIEZvY3VzT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgY2xhc3MgbmFtZSB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgZm9jdXNlZCBub2RlLlxuICAgKiBAZGVmYXVsdCAnaGFzLWZvY3VzJ1xuICAgKiBAZXhhbXBsZSAnaXMtZm9jdXNlZCdcbiAgICovXG4gIGNsYXNzTmFtZTogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBtb2RlIGJ5IHdoaWNoIHRoZSBmb2N1c2VkIG5vZGUgaXMgZGV0ZXJtaW5lZC5cbiAgICogLSBBbGw6IEFsbCBub2RlcyBhcmUgbWFya2VkIGFzIGZvY3VzZWQuXG4gICAqIC0gRGVlcGVzdDogT25seSB0aGUgZGVlcGVzdCBub2RlIGlzIG1hcmtlZCBhcyBmb2N1c2VkLlxuICAgKiAtIFNoYWxsb3dlc3Q6IE9ubHkgdGhlIHNoYWxsb3dlc3Qgbm9kZSBpcyBtYXJrZWQgYXMgZm9jdXNlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgJ2FsbCdcbiAgICogQGV4YW1wbGUgJ2RlZXBlc3QnXG4gICAqIEBleGFtcGxlICdzaGFsbG93ZXN0J1xuICAgKi9cbiAgbW9kZTogJ2FsbCcgfCAnZGVlcGVzdCcgfCAnc2hhbGxvd2VzdCdcbn1cblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGFkZCBhIGNsYXNzIHRvIHRoZSBmb2N1c2VkIG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvZm9jdXNcbiAqL1xuZXhwb3J0IGNvbnN0IEZvY3VzID0gRXh0ZW5zaW9uLmNyZWF0ZTxGb2N1c09wdGlvbnM+KHtcbiAgbmFtZTogJ2ZvY3VzJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc05hbWU6ICdoYXMtZm9jdXMnLFxuICAgICAgbW9kZTogJ2FsbCcsXG4gICAgfVxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnZm9jdXMnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBkZWNvcmF0aW9uczogKHsgZG9jLCBzZWxlY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpc0VkaXRhYmxlLCBpc0ZvY3VzZWQgfSA9IHRoaXMuZWRpdG9yXG4gICAgICAgICAgICBjb25zdCB7IGFuY2hvciB9ID0gc2VsZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uczogRGVjb3JhdGlvbltdID0gW11cblxuICAgICAgICAgICAgaWYgKCFpc0VkaXRhYmxlIHx8ICFpc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgW10pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1heGltdW0gTGV2ZWxzXG4gICAgICAgICAgICBsZXQgbWF4TGV2ZWxzID0gMFxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1vZGUgPT09ICdkZWVwZXN0Jykge1xuICAgICAgICAgICAgICBkb2MuZGVzY2VuZGFudHMoKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50ID0gYW5jaG9yID49IHBvcyAmJiBhbmNob3IgPD0gcG9zICsgbm9kZS5ub2RlU2l6ZSAtIDFcblxuICAgICAgICAgICAgICAgIGlmICghaXNDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYXhMZXZlbHMgKz0gMVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggY3VycmVudFxuICAgICAgICAgICAgbGV0IGN1cnJlbnRMZXZlbCA9IDBcblxuICAgICAgICAgICAgZG9jLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnQgPSBhbmNob3IgPj0gcG9zICYmIGFuY2hvciA8PSBwb3MgKyBub2RlLm5vZGVTaXplIC0gMVxuXG4gICAgICAgICAgICAgIGlmICghaXNDdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgKz0gMVxuXG4gICAgICAgICAgICAgIGNvbnN0IG91dE9mU2NvcGUgPVxuICAgICAgICAgICAgICAgICh0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RlZXBlc3QnICYmIG1heExldmVscyAtIGN1cnJlbnRMZXZlbCA+IDApIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMub3B0aW9ucy5tb2RlID09PSAnc2hhbGxvd2VzdCcgJiYgY3VycmVudExldmVsID4gMSlcblxuICAgICAgICAgICAgICBpZiAob3V0T2ZTY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RlZXBlc3QnXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKFxuICAgICAgICAgICAgICAgIERlY29yYXRpb24ubm9kZShwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzOiB0aGlzLm9wdGlvbnMuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBkZWNvcmF0aW9ucylcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgdHlwZSB7IFBhcmVudENvbmZpZyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IGNhbGxPclJldHVybiwgRXh0ZW5zaW9uLCBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IGdhcEN1cnNvciB9IGZyb20gJ0B0aXB0YXAvcG0vZ2FwY3Vyc29yJ1xuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBOb2RlQ29uZmlnPE9wdGlvbnMsIFN0b3JhZ2U+IHtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBnYXAgY3Vyc29yIGlzIGFsbG93ZWQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uIE11c3QgcmV0dXJuIGB0cnVlYCBvciBgZmFsc2VgLlxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBhbGxvd0dhcEN1cnNvcj86XG4gICAgICB8IGJvb2xlYW5cbiAgICAgIHwgbnVsbFxuICAgICAgfCAoKHRoaXM6IHtcbiAgICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgICBvcHRpb25zOiBPcHRpb25zXG4gICAgICAgICAgc3RvcmFnZTogU3RvcmFnZVxuICAgICAgICAgIHBhcmVudDogUGFyZW50Q29uZmlnPE5vZGVDb25maWc8T3B0aW9ucz4+WydhbGxvd0dhcEN1cnNvciddXG4gICAgICAgIH0pID0+IGJvb2xlYW4gfCBudWxsKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBhZGQgYSBnYXAgY3Vyc29yIHRvIHlvdXIgZWRpdG9yLlxuICogQSBnYXAgY3Vyc29yIGlzIGEgY3Vyc29yIHRoYXQgYXBwZWFycyB3aGVuIHlvdSBjbGljayBvbiBhIHBsYWNlXG4gKiB3aGVyZSBubyBjb250ZW50IGlzIHByZXNlbnQsIGZvciBleGFtcGxlIGluYmV0d2VlbiBub2Rlcy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2dhcGN1cnNvclxuICovXG5leHBvcnQgY29uc3QgR2FwY3Vyc29yID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gIG5hbWU6ICdnYXBDdXJzb3InLFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW2dhcEN1cnNvcigpXVxuICB9LFxuXG4gIGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWxsb3dHYXBDdXJzb3I6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhbGxvd0dhcEN1cnNvcicsIGNvbnRleHQpKSA/PyBudWxsLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHR5cGUgeyBFZGl0b3IgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBFeHRlbnNpb24sIGlzTm9kZUVtcHR5IH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHR5cGUgeyBOb2RlIGFzIFByb3NlbWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYWNlaG9sZGVyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiAqKlRoZSBjbGFzcyBuYW1lIGZvciB0aGUgZW1wdHkgZWRpdG9yKipcbiAgICogQGRlZmF1bHQgJ2lzLWVkaXRvci1lbXB0eSdcbiAgICovXG4gIGVtcHR5RWRpdG9yQ2xhc3M6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiAqKlRoZSBjbGFzcyBuYW1lIGZvciBlbXB0eSBub2RlcyoqXG4gICAqIEBkZWZhdWx0ICdpcy1lbXB0eSdcbiAgICovXG4gIGVtcHR5Tm9kZUNsYXNzOiBzdHJpbmdcblxuICAvKipcbiAgICogKipUaGUgcGxhY2Vob2xkZXIgY29udGVudCoqXG4gICAqXG4gICAqIFlvdSBjYW4gdXNlIGEgZnVuY3Rpb24gdG8gcmV0dXJuIGEgZHluYW1pYyBwbGFjZWhvbGRlciBvciBhIHN0cmluZy5cbiAgICogQGRlZmF1bHQgJ1dyaXRlIHNvbWV0aGluZyDigKYnXG4gICAqL1xuICBwbGFjZWhvbGRlcjpcbiAgICB8ICgoUGxhY2Vob2xkZXJQcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgbm9kZTogUHJvc2VtaXJyb3JOb2RlOyBwb3M6IG51bWJlcjsgaGFzQW5jaG9yOiBib29sZWFuIH0pID0+IHN0cmluZylcbiAgICB8IHN0cmluZ1xuXG4gIC8qKlxuICAgKiAqKkNoZWNrcyBpZiB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGJlIG9ubHkgc2hvd24gd2hlbiB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLioqXG4gICAqXG4gICAqIElmIHRydWUsIHRoZSBwbGFjZWhvbGRlciB3aWxsIG9ubHkgYmUgc2hvd24gd2hlbiB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLlxuICAgKiBJZiBmYWxzZSwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYWx3YXlzIGJlIHNob3duLlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBzaG93T25seVdoZW5FZGl0YWJsZTogYm9vbGVhblxuXG4gIC8qKlxuICAgKiAqKkNoZWNrcyBpZiB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGJlIG9ubHkgc2hvd24gd2hlbiB0aGUgY3VycmVudCBub2RlIGlzIGVtcHR5LioqXG4gICAqXG4gICAqIElmIHRydWUsIHRoZSBwbGFjZWhvbGRlciB3aWxsIG9ubHkgYmUgc2hvd24gd2hlbiB0aGUgY3VycmVudCBub2RlIGlzIGVtcHR5LlxuICAgKiBJZiBmYWxzZSwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgc2hvd24gd2hlbiBhbnkgbm9kZSBpcyBlbXB0eS5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgc2hvd09ubHlDdXJyZW50OiBib29sZWFuXG5cbiAgLyoqXG4gICAqICoqQ29udHJvbHMgaWYgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBiZSBzaG93biBmb3IgYWxsIGRlc2NlbmRlbnRzLioqXG4gICAqXG4gICAqIElmIHRydWUsIHRoZSBwbGFjZWhvbGRlciB3aWxsIGJlIHNob3duIGZvciBhbGwgZGVzY2VuZGVudHMuXG4gICAqIElmIGZhbHNlLCB0aGUgcGxhY2Vob2xkZXIgd2lsbCBvbmx5IGJlIHNob3duIGZvciB0aGUgY3VycmVudCBub2RlLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaW5jbHVkZUNoaWxkcmVuOiBib29sZWFuXG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBhZGQgYSBwbGFjZWhvbGRlciB0byB5b3VyIGVkaXRvci5cbiAqIEEgcGxhY2Vob2xkZXIgaXMgYSB0ZXh0IHRoYXQgYXBwZWFycyB3aGVuIHRoZSBlZGl0b3Igb3IgYSBub2RlIGlzIGVtcHR5LlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL3BsYWNlaG9sZGVyXG4gKi9cbmV4cG9ydCBjb25zdCBQbGFjZWhvbGRlciA9IEV4dGVuc2lvbi5jcmVhdGU8UGxhY2Vob2xkZXJPcHRpb25zPih7XG4gIG5hbWU6ICdwbGFjZWhvbGRlcicsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW1wdHlFZGl0b3JDbGFzczogJ2lzLWVkaXRvci1lbXB0eScsXG4gICAgICBlbXB0eU5vZGVDbGFzczogJ2lzLWVtcHR5JyxcbiAgICAgIHBsYWNlaG9sZGVyOiAnV3JpdGUgc29tZXRoaW5nIOKApicsXG4gICAgICBzaG93T25seVdoZW5FZGl0YWJsZTogdHJ1ZSxcbiAgICAgIHNob3dPbmx5Q3VycmVudDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVDaGlsZHJlbjogZmFsc2UsXG4gICAgfVxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgncGxhY2Vob2xkZXInKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBkZWNvcmF0aW9uczogKHsgZG9jLCBzZWxlY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSB8fCAhdGhpcy5vcHRpb25zLnNob3dPbmx5V2hlbkVkaXRhYmxlXG4gICAgICAgICAgICBjb25zdCB7IGFuY2hvciB9ID0gc2VsZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uczogRGVjb3JhdGlvbltdID0gW11cblxuICAgICAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaXNFbXB0eURvYyA9IHRoaXMuZWRpdG9yLmlzRW1wdHlcblxuICAgICAgICAgICAgZG9jLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaGFzQW5jaG9yID0gYW5jaG9yID49IHBvcyAmJiBhbmNob3IgPD0gcG9zICsgbm9kZS5ub2RlU2l6ZVxuICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gIW5vZGUuaXNMZWFmICYmIGlzTm9kZUVtcHR5KG5vZGUpXG5cbiAgICAgICAgICAgICAgaWYgKChoYXNBbmNob3IgfHwgIXRoaXMub3B0aW9ucy5zaG93T25seUN1cnJlbnQpICYmIGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gW3RoaXMub3B0aW9ucy5lbXB0eU5vZGVDbGFzc11cblxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5RG9jKSB7XG4gICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2godGhpcy5vcHRpb25zLmVtcHR5RWRpdG9yQ2xhc3MpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IERlY29yYXRpb24ubm9kZShwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzOiBjbGFzc2VzLmpvaW4oJyAnKSxcbiAgICAgICAgICAgICAgICAgICdkYXRhLXBsYWNlaG9sZGVyJzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKGRlY29yYXRpb24pXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmluY2x1ZGVDaGlsZHJlblxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKGRvYywgZGVjb3JhdGlvbnMpXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uLCBpc05vZGVTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBEZWNvcmF0aW9uLCBEZWNvcmF0aW9uU2V0IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuXG5leHBvcnQgdHlwZSBTZWxlY3Rpb25PcHRpb25zID0ge1xuICAvKipcbiAgICogVGhlIGNsYXNzIG5hbWUgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHNlbGVjdGVkIHRleHQuXG4gICAqIEBkZWZhdWx0ICdzZWxlY3Rpb24nXG4gICAqIEBleGFtcGxlICdpcy1zZWxlY3RlZCdcbiAgICovXG4gIGNsYXNzTmFtZTogc3RyaW5nXG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBhZGQgYSBjbGFzcyB0byB0aGUgc2VsZWN0ZWQgdGV4dC5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9zZWxlY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IFNlbGVjdGlvbiA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICBuYW1lOiAnc2VsZWN0aW9uJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc05hbWU6ICdzZWxlY3Rpb24nLFxuICAgIH1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgY29uc3QgeyBlZGl0b3IsIG9wdGlvbnMgfSA9IHRoaXNcblxuICAgIHJldHVybiBbXG4gICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdzZWxlY3Rpb24nKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBkZWNvcmF0aW9ucyhzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5lbXB0eSB8fCBlZGl0b3IuaXNGb2N1c2VkIHx8ICFlZGl0b3IuaXNFZGl0YWJsZSB8fCBpc05vZGVTZWxlY3Rpb24oc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBbXG4gICAgICAgICAgICAgIERlY29yYXRpb24uaW5saW5lKHN0YXRlLnNlbGVjdGlvbi5mcm9tLCBzdGF0ZS5zZWxlY3Rpb24udG8sIHtcbiAgICAgICAgICAgICAgICBjbGFzczogb3B0aW9ucy5jbGFzc05hbWUsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uXG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHR5cGUgeyBOb2RlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmZ1bmN0aW9uIG5vZGVFcXVhbHNUeXBlKHsgdHlwZXMsIG5vZGUgfTogeyB0eXBlczogTm9kZVR5cGUgfCBOb2RlVHlwZVtdOyBub2RlOiBOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZCB9KSB7XG4gIHJldHVybiAobm9kZSAmJiBBcnJheS5pc0FycmF5KHR5cGVzKSAmJiB0eXBlcy5pbmNsdWRlcyhub2RlLnR5cGUpKSB8fCBub2RlPy50eXBlID09PSB0eXBlc1xufVxuXG4vKipcbiAqIEV4dGVuc2lvbiBiYXNlZCBvbjpcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2Jsb2IvdjEvcGFja2FnZXMvdGlwdGFwLWV4dGVuc2lvbnMvc3JjL2V4dGVuc2lvbnMvVHJhaWxpbmdOb2RlLmpzXG4gKiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1pcnJvci9yZW1pcnJvci9ibG9iL2UwZjFiZWM0YTFlODA3M2NlOGY1NTAwZDYyMTkzZTUyMzIxMTU1YjkvcGFja2FnZXMvcHJvc2VtaXJyb3ItdHJhaWxpbmctbm9kZS9zcmMvdHJhaWxpbmctbm9kZS1wbHVnaW4udHNcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWlsaW5nTm9kZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIG5vZGUgdHlwZSB0aGF0IHNob3VsZCBiZSBpbnNlcnRlZCBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgICogQG5vdGUgdGhlIG5vZGUgd2lsbCBhbHdheXMgYmUgYWRkZWQgdG8gdGhlIGBub3RBZnRlcmAgbGlzdHMgdG9cbiAgICogcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlxuICAgKiBAZGVmYXVsdCAncGFyYWdyYXBoJ1xuICAgKi9cbiAgbm9kZTogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbm9kZSB0eXBlcyBhZnRlciB3aGljaCB0aGUgdHJhaWxpbmcgbm9kZSBzaG91bGQgbm90IGJlIGluc2VydGVkLlxuICAgKiBAZGVmYXVsdCBbJ3BhcmFncmFwaCddXG4gICAqL1xuICBub3RBZnRlcj86IHN0cmluZyB8IHN0cmluZ1tdXG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBhZGQgYW4gZXh0cmEgbm9kZSBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy90cmFpbGluZy1ub2RlXG4gKi9cbmV4cG9ydCBjb25zdCBUcmFpbGluZ05vZGUgPSBFeHRlbnNpb24uY3JlYXRlPFRyYWlsaW5nTm9kZU9wdGlvbnM+KHtcbiAgbmFtZTogJ3RyYWlsaW5nTm9kZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogJ3BhcmFncmFwaCcsXG4gICAgICBub3RBZnRlcjogW10sXG4gICAgfVxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICBjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luS2V5KHRoaXMubmFtZSlcbiAgICBjb25zdCBkaXNhYmxlZE5vZGVzID0gT2JqZWN0LmVudHJpZXModGhpcy5lZGl0b3Iuc2NoZW1hLm5vZGVzKVxuICAgICAgLm1hcCgoWywgdmFsdWVdKSA9PiB2YWx1ZSlcbiAgICAgIC5maWx0ZXIobm9kZSA9PiAodGhpcy5vcHRpb25zLm5vdEFmdGVyIHx8IFtdKS5jb25jYXQodGhpcy5vcHRpb25zLm5vZGUpLmluY2x1ZGVzKG5vZGUubmFtZSkpXG5cbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogcGx1Z2luLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKF8sIF9fLCBzdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZG9jLCB0ciwgc2NoZW1hIH0gPSBzdGF0ZVxuICAgICAgICAgIGNvbnN0IHNob3VsZEluc2VydE5vZGVBdEVuZCA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSlcbiAgICAgICAgICBjb25zdCBlbmRQb3NpdGlvbiA9IGRvYy5jb250ZW50LnNpemVcbiAgICAgICAgICBjb25zdCB0eXBlID0gc2NoZW1hLm5vZGVzW3RoaXMub3B0aW9ucy5ub2RlXVxuXG4gICAgICAgICAgaWYgKCFzaG91bGRJbnNlcnROb2RlQXRFbmQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0ci5pbnNlcnQoZW5kUG9zaXRpb24sIHR5cGUuY3JlYXRlKCkpXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgaW5pdDogKF8sIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IHN0YXRlLnRyLmRvYy5sYXN0Q2hpbGRcblxuICAgICAgICAgICAgcmV0dXJuICFub2RlRXF1YWxzVHlwZSh7IG5vZGU6IGxhc3ROb2RlLCB0eXBlczogZGlzYWJsZWROb2RlcyB9KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXBwbHk6ICh0ciwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdE5vZGUgPSB0ci5kb2MubGFzdENoaWxkXG5cbiAgICAgICAgICAgIHJldHVybiAhbm9kZUVxdWFsc1R5cGUoeyBub2RlOiBsYXN0Tm9kZSwgdHlwZXM6IGRpc2FibGVkTm9kZXMgfSlcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBoaXN0b3J5LCByZWRvLCB1bmRvIH0gZnJvbSAnQHRpcHRhcC9wbS9oaXN0b3J5J1xuXG5leHBvcnQgaW50ZXJmYWNlIFVuZG9SZWRvT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIGhpc3RvcnkgZXZlbnRzIHRoYXQgYXJlIGNvbGxlY3RlZCBiZWZvcmUgdGhlIG9sZGVzdCBldmVudHMgYXJlIGRpc2NhcmRlZC5cbiAgICogQGRlZmF1bHQgMTAwXG4gICAqIEBleGFtcGxlIDUwXG4gICAqL1xuICBkZXB0aDogbnVtYmVyXG5cbiAgLyoqXG4gICAqIFRoZSBkZWxheSAoaW4gbWlsbGlzZWNvbmRzKSBiZXR3ZWVuIGNoYW5nZXMgYWZ0ZXIgd2hpY2ggYSBuZXcgZ3JvdXAgc2hvdWxkIGJlIHN0YXJ0ZWQuXG4gICAqIEBkZWZhdWx0IDUwMFxuICAgKiBAZXhhbXBsZSAxMDAwXG4gICAqL1xuICBuZXdHcm91cERlbGF5OiBudW1iZXJcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuZG9SZWRvOiB7XG4gICAgICAvKipcbiAgICAgICAqIFVuZG8gcmVjZW50IGNoYW5nZXNcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy51bmRvKClcbiAgICAgICAqL1xuICAgICAgdW5kbzogKCkgPT4gUmV0dXJuVHlwZVxuICAgICAgLyoqXG4gICAgICAgKiBSZWFwcGx5IHJldmVydGVkIGNoYW5nZXNcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5yZWRvKClcbiAgICAgICAqL1xuICAgICAgcmVkbzogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gdW5kbyBhbmQgcmVkbyByZWNlbnQgY2hhbmdlcy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy91bmRvLXJlZG9cbiAqXG4gKiAqKkltcG9ydGFudCoqOiBJZiB0aGUgYEB0aXB0YXAvZXh0ZW5zaW9uLWNvbGxhYm9yYXRpb25gIHBhY2thZ2UgaXMgdXNlZCwgbWFrZSBzdXJlIHRvIHJlbW92ZVxuICogdGhlIGB1bmRvLXJlZG9gIGV4dGVuc2lvbiwgYXMgaXQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYGNvbGxhYm9yYXRpb25gIGV4dGVuc2lvbi5cbiAqXG4gKiBgQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvbmAgdXNlcyBpdHMgb3duIGhpc3RvcnkgaW1wbGVtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBVbmRvUmVkbyA9IEV4dGVuc2lvbi5jcmVhdGU8VW5kb1JlZG9PcHRpb25zPih7XG4gIG5hbWU6ICd1bmRvUmVkbycsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVwdGg6IDEwMCxcbiAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuZG86XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHVuZG8oc3RhdGUsIGRpc3BhdGNoKVxuICAgICAgICB9LFxuICAgICAgcmVkbzpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVkbyhzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICByZXR1cm4gW2hpc3RvcnkodGhpcy5vcHRpb25zKV1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC16JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudW5kbygpLFxuICAgICAgJ1NoaWZ0LU1vZC16JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgICAgJ01vZC15JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuXG4gICAgICAvLyBSdXNzaWFuIGtleWJvYXJkIGxheW91dHNcbiAgICAgICdNb2Qt0Y8nOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXG4gICAgICAnU2hpZnQtTW9kLdGPJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiZXhwb3J0IHR5cGUgQXR0cmlidXRlcyA9IFJlY29yZDxzdHJpbmcsIGFueT5cblxuZXhwb3J0IHR5cGUgRE9NT3V0cHV0U3BlY0VsZW1lbnQgPSAwIHwgQXR0cmlidXRlcyB8IERPTU91dHB1dFNwZWNBcnJheVxuLyoqXG4gKiBCZXR0ZXIgZGVzY3JpYmVzIHRoZSBvdXRwdXQgb2YgYSBgcmVuZGVySFRNTGAgZnVuY3Rpb24gaW4gcHJvc2VtaXJyb3JcbiAqIEBzZWUgaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTU91dHB1dFNwZWNcbiAqL1xuZXhwb3J0IHR5cGUgRE9NT3V0cHV0U3BlY0FycmF5ID1cbiAgfCBbc3RyaW5nXVxuICB8IFtzdHJpbmcsIEF0dHJpYnV0ZXNdXG4gIHwgW3N0cmluZywgMF1cbiAgfCBbc3RyaW5nLCBBdHRyaWJ1dGVzLCAwXVxuICB8IFtzdHJpbmcsIEF0dHJpYnV0ZXMsIERPTU91dHB1dFNwZWNBcnJheSB8IDBdXG4gIHwgW3N0cmluZywgRE9NT3V0cHV0U3BlY0FycmF5XVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbmFtZXNwYWNlXG4gIG5hbWVzcGFjZSBKU1gge1xuICAgIC8vIEB0cy1pZ25vcmUgLSBjb25mbGljdCB3aXRoIFJlYWN0IHR5cGluZ3NcbiAgICB0eXBlIEVsZW1lbnQgPSBbc3RyaW5nLCAuLi5hbnlbXV1cbiAgICAvLyBAdHMtaWdub3JlIC0gY29uZmxpY3Qgd2l0aCBSZWFjdCB0eXBpbmdzXG4gICAgaW50ZXJmYWNlIEludHJpbnNpY0VsZW1lbnRzIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgLSBjb25mbGljdCB3aXRoIFJlYWN0IHR5cGluZ3NcbiAgICAgIFtrZXk6IHN0cmluZ106IGFueVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBKU1hSZW5kZXJlciA9IChcbiAgdGFnOiAnc2xvdCcgfCBzdHJpbmcgfCAoKHByb3BzPzogQXR0cmlidXRlcykgPT4gRE9NT3V0cHV0U3BlY0FycmF5IHwgRE9NT3V0cHV0U3BlY0VsZW1lbnQpLFxuICBwcm9wcz86IEF0dHJpYnV0ZXMsXG4gIC4uLmNoaWxkcmVuOiBKU1hSZW5kZXJlcltdXG4pID0+IERPTU91dHB1dFNwZWNBcnJheSB8IERPTU91dHB1dFNwZWNFbGVtZW50XG5cbmV4cG9ydCBmdW5jdGlvbiBGcmFnbWVudChwcm9wczogeyBjaGlsZHJlbjogSlNYUmVuZGVyZXJbXSB9KSB7XG4gIHJldHVybiBwcm9wcy5jaGlsZHJlblxufVxuXG5leHBvcnQgY29uc3QgaDogSlNYUmVuZGVyZXIgPSAodGFnLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIC8vIFRyZWF0IHRoZSBzbG90IHRhZyBhcyB0aGUgUHJvc2VtaXJyb3IgaG9sZSB0byByZW5kZXIgY29udGVudCBpbnRvXG4gIGlmICh0YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiAwXG4gIH1cblxuICAvLyBJZiB0aGUgdGFnIGlzIGEgZnVuY3Rpb24sIGNhbGwgaXQgd2l0aCB0aGUgcHJvcHNcbiAgaWYgKHRhZyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHRhZyhhdHRyaWJ1dGVzKVxuICB9XG5cbiAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gYXR0cmlidXRlcyA/PyB7fVxuXG4gIGlmICh0YWcgPT09ICdzdmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTVkcgZWxlbWVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEpTWCBzeW50YXgsIHVzZSB0aGUgYXJyYXkgc3ludGF4IGluc3RlYWQnKVxuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIHRhZywgYXR0cmlidXRlcywgYW5kIGNoaWxkcmVuXG4gIHJldHVybiBbdGFnLCByZXN0LCBjaGlsZHJlbl1cbn1cblxuLy8gU2VlXG4vLyBodHRwczovL2VzYnVpbGQuZ2l0aHViLmlvL2FwaS8janN4LWltcG9ydC1zb3VyY2Vcbi8vIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy90c2NvbmZpZy8janN4SW1wb3J0U291cmNlXG5cbmV4cG9ydCB7IGggYXMgY3JlYXRlRWxlbWVudCwgaCBhcyBqc3gsIGggYXMganN4REVWLCBoIGFzIGpzeHMgfVxuIiwgIi8qKiBAanN4SW1wb3J0U291cmNlIEB0aXB0YXAvY29yZSAqL1xuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB0eXBlIHsgRE9NT3V0cHV0U3BlY0FycmF5IH0gZnJvbSAnQHRpcHRhcC9jb3JlL2pzeC1ydW50aW1lJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEJsb2NrcXVvdGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIEhUTUwgYXR0cmlidXRlcyB0byBhZGQgdG8gdGhlIGJsb2NrcXVvdGUgZWxlbWVudFxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAZXhhbXBsZSB7IGNsYXNzOiAnZm9vJyB9XG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgYmxvY2tRdW90ZToge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBibG9ja3F1b3RlIG5vZGVcbiAgICAgICAqL1xuICAgICAgc2V0QmxvY2txdW90ZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBibG9ja3F1b3RlIG5vZGVcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQmxvY2txdW90ZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgICAgLyoqXG4gICAgICAgKiBVbnNldCBhIGJsb2NrcXVvdGUgbm9kZVxuICAgICAgICovXG4gICAgICB1bnNldEJsb2NrcXVvdGU6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYXRjaGVzIGEgYmxvY2txdW90ZSB0byBhIGA+YCBhcyBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlucHV0UmVnZXggPSAvXlxccyo+XFxzJC9cblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBibG9ja3F1b3Rlcy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9ub2Rlcy9ibG9ja3F1b3RlXG4gKi9cbmV4cG9ydCBjb25zdCBCbG9ja3F1b3RlID0gTm9kZS5jcmVhdGU8QmxvY2txdW90ZU9wdGlvbnM+KHtcbiAgbmFtZTogJ2Jsb2NrcXVvdGUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgY29udGVudDogJ2Jsb2NrKycsXG5cbiAgZ3JvdXA6ICdibG9jaycsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6ICdibG9ja3F1b3RlJyB9XVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxibG9ja3F1b3RlIHsuLi5tZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyl9PlxuICAgICAgICA8c2xvdCAvPlxuICAgICAgPC9ibG9ja3F1b3RlPlxuICAgICkgYXMgdW5rbm93biBhcyBET01PdXRwdXRTcGVjQXJyYXlcbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0QmxvY2txdW90ZTpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy53cmFwSW4odGhpcy5uYW1lKVxuICAgICAgICB9LFxuICAgICAgdG9nZ2xlQmxvY2txdW90ZTpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVXcmFwKHRoaXMubmFtZSlcbiAgICAgICAgfSxcbiAgICAgIHVuc2V0QmxvY2txdW90ZTpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0KHRoaXMubmFtZSlcbiAgICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtU2hpZnQtYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJsb2NrcXVvdGUoKSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IEJsb2NrcXVvdGUgfSBmcm9tICcuL2Jsb2NrcXVvdGUuanN4J1xuXG5leHBvcnQgKiBmcm9tICcuL2Jsb2NrcXVvdGUuanN4J1xuXG5leHBvcnQgZGVmYXVsdCBCbG9ja3F1b3RlXG4iLCAiLyoqIEBqc3hJbXBvcnRTb3VyY2UgQHRpcHRhcC9jb3JlICovXG5pbXBvcnQgeyBNYXJrLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgdHlwZSB7IERPTU91dHB1dFNwZWNBcnJheSB9IGZyb20gJ0B0aXB0YXAvY29yZS9qc3gtcnVudGltZSdcblxuZXhwb3J0IGludGVyZmFjZSBCb2xkT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBIVE1MIGF0dHJpYnV0ZXMgdG8gYWRkIHRvIHRoZSBib2xkIGVsZW1lbnQuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBleGFtcGxlIHsgY2xhc3M6ICdmb28nIH1cbiAgICovXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBib2xkOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGJvbGQgbWFya1xuICAgICAgICovXG4gICAgICBzZXRCb2xkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGJvbGQgbWFya1xuICAgICAgICovXG4gICAgICB0b2dnbGVCb2xkOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgYm9sZCBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0Qm9sZDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgKipgIGFzIGlucHV0LlxuICovXG5leHBvcnQgY29uc3Qgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKFxcKlxcKig/IVxccytcXCpcXCopKCg/OlteKl0rKSlcXCpcXCooPyFcXHMrXFwqXFwqKSkkL1xuXG4vKipcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgKipgIHdoaWxlIHBhc3RpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoXFwqXFwqKD8hXFxzK1xcKlxcKikoKD86W14qXSspKVxcKlxcKig/IVxccytcXCpcXCopKS9nXG5cbi8qKlxuICogTWF0Y2hlcyBib2xkIHRleHQgdmlhIGBfX2AgYXMgaW5wdXQuXG4gKi9cbmV4cG9ydCBjb25zdCB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoX18oPyFcXHMrX18pKCg/OlteX10rKSlfXyg/IVxccytfXykpJC9cblxuLyoqXG4gKiBNYXRjaGVzIGJvbGQgdGV4dCB2aWEgYF9fYCB3aGlsZSBwYXN0aW5nLlxuICovXG5leHBvcnQgY29uc3QgdW5kZXJzY29yZVBhc3RlUmVnZXggPSAvKD86XnxcXHMpKF9fKD8hXFxzK19fKSgoPzpbXl9dKykpX18oPyFcXHMrX18pKS9nXG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBtYXJrIHRleHQgYXMgYm9sZC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9tYXJrcy9ib2xkXG4gKi9cbmV4cG9ydCBjb25zdCBCb2xkID0gTWFyay5jcmVhdGU8Qm9sZE9wdGlvbnM+KHtcbiAgbmFtZTogJ2JvbGQnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ3N0cm9uZycsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6ICdiJyxcbiAgICAgICAgZ2V0QXR0cnM6IG5vZGUgPT4gKG5vZGUgYXMgSFRNTEVsZW1lbnQpLnN0eWxlLmZvbnRXZWlnaHQgIT09ICdub3JtYWwnICYmIG51bGwsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogJ2ZvbnQtd2VpZ2h0PTQwMCcsXG4gICAgICAgIGNsZWFyTWFyazogbWFyayA9PiBtYXJrLnR5cGUubmFtZSA9PT0gdGhpcy5uYW1lLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICdmb250LXdlaWdodCcsXG4gICAgICAgIGdldEF0dHJzOiB2YWx1ZSA9PiAvXihib2xkKGVyKT98WzUtOV1cXGR7Mix9KSQvLnRlc3QodmFsdWUgYXMgc3RyaW5nKSAmJiBudWxsLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gKFxuICAgICAgPHN0cm9uZyB7Li4ubWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpfT5cbiAgICAgICAgPHNsb3QgLz5cbiAgICAgIDwvc3Ryb25nPlxuICAgICkgYXMgdW5rbm93biBhcyBET01PdXRwdXRTcGVjQXJyYXlcbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Qm9sZDpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgICAgfSxcbiAgICAgIHRvZ2dsZUJvbGQ6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICAgIH0sXG4gICAgICB1bnNldEJvbGQ6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJvbGQoKSxcbiAgICAgICdNb2QtQic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJvbGQoKSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IHN0YXJJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxuXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogdW5kZXJzY29yZVBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgQm9sZCB9IGZyb20gJy4vYm9sZC5qc3gnXG5cbmV4cG9ydCAqIGZyb20gJy4vYm9sZC5qc3gnXG5cbmV4cG9ydCBkZWZhdWx0IEJvbGRcbiIsICJpbXBvcnQgeyBNYXJrLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIEhUTUwgYXR0cmlidXRlcyBhcHBsaWVkIHRvIHRoZSBjb2RlIGVsZW1lbnQuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBleGFtcGxlIHsgY2xhc3M6ICdmb28nIH1cbiAgICovXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBjb2RlOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIGNvZGUgbWFya1xuICAgICAgICovXG4gICAgICBzZXRDb2RlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBpbmxpbmUgY29kZVxuICAgICAgICovXG4gICAgICB0b2dnbGVDb2RlOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgY29kZSBtYXJrXG4gICAgICAgKi9cbiAgICAgIHVuc2V0Q29kZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgdG8gbWF0Y2ggaW5saW5lIGNvZGUgYmxvY2tzIGVuY2xvc2VkIGluIGJhY2t0aWNrcy5cbiAqICBJdCBtYXRjaGVzOlxuICogICAgIC0gQW4gb3BlbmluZyBiYWNrdGljaywgZm9sbG93ZWQgYnlcbiAqICAgICAtIEFueSB0ZXh0IHRoYXQgZG9lc24ndCBpbmNsdWRlIGEgYmFja3RpY2sgKGNhcHR1cmVkIGZvciBtYXJraW5nKSwgZm9sbG93ZWQgYnlcbiAqICAgICAtIEEgY2xvc2luZyBiYWNrdGljay5cbiAqICBUaGlzIGVuc3VyZXMgdGhhdCBhbnkgdGV4dCBiZXR3ZWVuIGJhY2t0aWNrcyBpcyBmb3JtYXR0ZWQgYXMgY29kZSxcbiAqICByZWdhcmRsZXNzIG9mIHRoZSBzdXJyb3VuZGluZyBjaGFyYWN0ZXJzIChleGNlcHRpb24gYmVpbmcgYW5vdGhlciBiYWNrdGljaykuXG4gKi9cbmV4cG9ydCBjb25zdCBpbnB1dFJlZ2V4ID0gLyhefFteYF0pYChbXmBdKylgKD8hYCkvXG5cbi8qKlxuICogTWF0Y2hlcyBpbmxpbmUgY29kZSB3aGlsZSBwYXN0aW5nLlxuICovXG5leHBvcnQgY29uc3QgcGFzdGVSZWdleCA9IC8oXnxbXmBdKWAoW15gXSspYCg/IWApL2dcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIG1hcmsgdGV4dCBhcyBpbmxpbmUgY29kZS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9tYXJrcy9jb2RlXG4gKi9cbmV4cG9ydCBjb25zdCBDb2RlID0gTWFyay5jcmVhdGU8Q29kZU9wdGlvbnM+KHtcbiAgbmFtZTogJ2NvZGUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgZXhjbHVkZXM6ICdfJyxcblxuICBjb2RlOiB0cnVlLFxuXG4gIGV4aXRhYmxlOiB0cnVlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiAnY29kZScgfV1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ2NvZGUnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldENvZGU6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICAgIH0sXG4gICAgICB0b2dnbGVDb2RlOlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKVxuICAgICAgICB9LFxuICAgICAgdW5zZXRDb2RlOlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVDb2RlKCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgQ29kZSB9IGZyb20gJy4vY29kZS5qcydcblxuZXhwb3J0ICogZnJvbSAnLi9jb2RlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBDb2RlXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXksIFNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUJsb2NrT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBZGRzIGEgcHJlZml4IHRvIGxhbmd1YWdlIGNsYXNzZXMgdGhhdCBhcmUgYXBwbGllZCB0byBjb2RlIHRhZ3MuXG4gICAqIEBkZWZhdWx0ICdsYW5ndWFnZS0nXG4gICAqL1xuICBsYW5ndWFnZUNsYXNzUHJlZml4OiBzdHJpbmdcbiAgLyoqXG4gICAqIERlZmluZSB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBleGl0ZWQgb24gdHJpcGxlIGVudGVyLlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBleGl0T25UcmlwbGVFbnRlcjogYm9vbGVhblxuICAvKipcbiAgICogRGVmaW5lIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGV4aXRlZCBvbiBhcnJvdyBkb3duIGlmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgaXQuXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGV4aXRPbkFycm93RG93bjogYm9vbGVhblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgbGFuZ3VhZ2UuXG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGUgJ2pzJ1xuICAgKi9cbiAgZGVmYXVsdExhbmd1YWdlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkXG4gIC8qKlxuICAgKiBDdXN0b20gSFRNTCBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSByZW5kZXJlZCBIVE1MIHRhZy5cbiAgICogQGRlZmF1bHQge31cbiAgICogQGV4YW1wbGUgeyBjbGFzczogJ2ZvbycgfVxuICAgKi9cbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGNvZGVCbG9jazoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBjb2RlIGJsb2NrXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBDb2RlIGJsb2NrIGF0dHJpYnV0ZXNcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5zZXRDb2RlQmxvY2soeyBsYW5ndWFnZTogJ2phdmFzY3JpcHQnIH0pXG4gICAgICAgKi9cbiAgICAgIHNldENvZGVCbG9jazogKGF0dHJpYnV0ZXM/OiB7IGxhbmd1YWdlOiBzdHJpbmcgfSkgPT4gUmV0dXJuVHlwZVxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBjb2RlIGJsb2NrXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBDb2RlIGJsb2NrIGF0dHJpYnV0ZXNcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy50b2dnbGVDb2RlQmxvY2soeyBsYW5ndWFnZTogJ2phdmFzY3JpcHQnIH0pXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUNvZGVCbG9jazogKGF0dHJpYnV0ZXM/OiB7IGxhbmd1YWdlOiBzdHJpbmcgfSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hdGNoZXMgYSBjb2RlIGJsb2NrIHdpdGggYmFja3RpY2tzLlxuICovXG5leHBvcnQgY29uc3QgYmFja3RpY2tJbnB1dFJlZ2V4ID0gL15gYGAoW2Etel0rKT9bXFxzXFxuXSQvXG5cbi8qKlxuICogTWF0Y2hlcyBhIGNvZGUgYmxvY2sgd2l0aCB0aWxkZXMuXG4gKi9cbmV4cG9ydCBjb25zdCB0aWxkZUlucHV0UmVnZXggPSAvXn5+fihbYS16XSspP1tcXHNcXG5dJC9cblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBjb2RlIGJsb2Nrcy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9ub2Rlcy9jb2RlLWJsb2NrXG4gKi9cbmV4cG9ydCBjb25zdCBDb2RlQmxvY2sgPSBOb2RlLmNyZWF0ZTxDb2RlQmxvY2tPcHRpb25zPih7XG4gIG5hbWU6ICdjb2RlQmxvY2snLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhbmd1YWdlQ2xhc3NQcmVmaXg6ICdsYW5ndWFnZS0nLFxuICAgICAgZXhpdE9uVHJpcGxlRW50ZXI6IHRydWUsXG4gICAgICBleGl0T25BcnJvd0Rvd246IHRydWUsXG4gICAgICBkZWZhdWx0TGFuZ3VhZ2U6IG51bGwsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGNvbnRlbnQ6ICd0ZXh0KicsXG5cbiAgbWFya3M6ICcnLFxuXG4gIGdyb3VwOiAnYmxvY2snLFxuXG4gIGNvZGU6IHRydWUsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZ3VhZ2U6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLmRlZmF1bHRMYW5ndWFnZSxcbiAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICBjb25zdCB7IGxhbmd1YWdlQ2xhc3NQcmVmaXggfSA9IHRoaXMub3B0aW9uc1xuICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBbLi4uKGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ/LmNsYXNzTGlzdCB8fCBbXSldXG4gICAgICAgICAgY29uc3QgbGFuZ3VhZ2VzID0gY2xhc3NOYW1lc1xuICAgICAgICAgICAgLmZpbHRlcihjbGFzc05hbWUgPT4gY2xhc3NOYW1lLnN0YXJ0c1dpdGgobGFuZ3VhZ2VDbGFzc1ByZWZpeCkpXG4gICAgICAgICAgICAubWFwKGNsYXNzTmFtZSA9PiBjbGFzc05hbWUucmVwbGFjZShsYW5ndWFnZUNsYXNzUHJlZml4LCAnJykpXG4gICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBsYW5ndWFnZXNbMF1cblxuICAgICAgICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGxhbmd1YWdlXG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlcmVkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdwcmUnLFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdwcmUnLFxuICAgICAgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLFxuICAgICAgW1xuICAgICAgICAnY29kZScsXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczogbm9kZS5hdHRycy5sYW5ndWFnZSA/IHRoaXMub3B0aW9ucy5sYW5ndWFnZUNsYXNzUHJlZml4ICsgbm9kZS5hdHRycy5sYW5ndWFnZSA6IG51bGwsXG4gICAgICAgIH0sXG4gICAgICAgIDAsXG4gICAgICBdLFxuICAgIF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q29kZUJsb2NrOlxuICAgICAgICBhdHRyaWJ1dGVzID0+XG4gICAgICAgICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpXG4gICAgICAgIH0sXG4gICAgICB0b2dnbGVDb2RlQmxvY2s6XG4gICAgICAgIGF0dHJpYnV0ZXMgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVOb2RlKHRoaXMubmFtZSwgJ3BhcmFncmFwaCcsIGF0dHJpYnV0ZXMpXG4gICAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLUFsdC1jJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQ29kZUJsb2NrKCksXG5cbiAgICAgIC8vIHJlbW92ZSBjb2RlIGJsb2NrIHdoZW4gYXQgc3RhcnQgb2YgZG9jdW1lbnQgb3IgY29kZSBibG9jayBpcyBlbXB0eVxuICAgICAgQmFja3NwYWNlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICBjb25zdCBpc0F0U3RhcnQgPSAkYW5jaG9yLnBvcyA9PT0gMVxuXG4gICAgICAgIGlmICghZW1wdHkgfHwgJGFuY2hvci5wYXJlbnQudHlwZS5uYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0F0U3RhcnQgfHwgISRhbmNob3IucGFyZW50LnRleHRDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5jb21tYW5kcy5jbGVhck5vZGVzKClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLy8gZXhpdCBub2RlIG9uIHRyaXBsZSBlbnRlclxuICAgICAgRW50ZXI6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPblRyaXBsZUVudGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3JcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gICAgICAgIGNvbnN0IHsgJGZyb20sIGVtcHR5IH0gPSBzZWxlY3Rpb25cblxuICAgICAgICBpZiAoIWVtcHR5IHx8ICRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDJcbiAgICAgICAgY29uc3QgZW5kc1dpdGhEb3VibGVOZXdsaW5lID0gJGZyb20ucGFyZW50LnRleHRDb250ZW50LmVuZHNXaXRoKCdcXG5cXG4nKVxuXG4gICAgICAgIGlmICghaXNBdEVuZCB8fCAhZW5kc1dpdGhEb3VibGVOZXdsaW5lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWRpdG9yXG4gICAgICAgICAgLmNoYWluKClcbiAgICAgICAgICAuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICB0ci5kZWxldGUoJGZyb20ucG9zIC0gMiwgJGZyb20ucG9zKVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmV4aXRDb2RlKClcbiAgICAgICAgICAucnVuKClcbiAgICAgIH0sXG5cbiAgICAgIC8vIGV4aXQgbm9kZSBvbiBhcnJvdyBkb3duXG4gICAgICBBcnJvd0Rvd246ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPbkFycm93RG93bikge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gZWRpdG9yXG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBkb2MgfSA9IHN0YXRlXG4gICAgICAgIGNvbnN0IHsgJGZyb20sIGVtcHR5IH0gPSBzZWxlY3Rpb25cblxuICAgICAgICBpZiAoIWVtcHR5IHx8ICRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDJcblxuICAgICAgICBpZiAoIWlzQXRFbmQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFmdGVyID0gJGZyb20uYWZ0ZXIoKVxuXG4gICAgICAgIGlmIChhZnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub2RlQWZ0ZXIgPSBkb2Mubm9kZUF0KGFmdGVyKVxuXG4gICAgICAgIGlmIChub2RlQWZ0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKGRvYy5yZXNvbHZlKGFmdGVyKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKClcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBiYWNrdGlja0lucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHtcbiAgICAgICAgICBsYW5ndWFnZTogbWF0Y2hbMV0sXG4gICAgICAgIH0pLFxuICAgICAgfSksXG4gICAgICB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogdGlsZGVJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7XG4gICAgICAgICAgbGFuZ3VhZ2U6IG1hdGNoWzFdLFxuICAgICAgICB9KSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIHRoaXMgcGx1Z2luIGNyZWF0ZXMgYSBjb2RlIGJsb2NrIGZvciBwYXN0ZWQgY29udGVudCBmcm9tIFZTIENvZGVcbiAgICAgIC8vIHdlIGNhbiBhbHNvIGRldGVjdCB0aGUgY29waWVkIGNvZGUgbGFuZ3VhZ2VcbiAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NvZGVCbG9ja1ZTQ29kZUhhbmRsZXInKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LmNsaXBib2FyZERhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvbuKAmXQgY3JlYXRlIGEgbmV3IGNvZGUgYmxvY2sgd2l0aGluIGNvZGUgYmxvY2tzXG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3IuaXNBY3RpdmUodGhpcy50eXBlLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJylcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZSA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndnNjb2RlLWVkaXRvci1kYXRhJylcbiAgICAgICAgICAgIGNvbnN0IHZzY29kZURhdGEgPSB2c2NvZGUgPyBKU09OLnBhcnNlKHZzY29kZSkgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gdnNjb2RlRGF0YT8ubW9kZVxuXG4gICAgICAgICAgICBpZiAoIXRleHQgfHwgIWxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IHRyLCBzY2hlbWEgfSA9IHZpZXcuc3RhdGVcblxuICAgICAgICAgICAgLy8gcHJlcGFyZSBhIHRleHQgbm9kZVxuICAgICAgICAgICAgLy8gc3RyaXAgY2FycmlhZ2UgcmV0dXJuIGNoYXJzIGZyb20gdGV4dCBwYXN0ZWQgYXMgY29kZVxuICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itdmlldy9jb21taXQvYTUwYTZiY2NlYjRjZTUyYWM4ZmNjNjE2MjQ4OGQ4ODc1NjEzYWFjZFxuICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBzY2hlbWEudGV4dCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgJ1xcbicpKVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBjb2RlIGJsb2NrIHdpdGggdGhlIHRleHQgbm9kZVxuICAgICAgICAgICAgLy8gcmVwbGFjZSBzZWxlY3Rpb24gd2l0aCB0aGUgY29kZSBibG9ja1xuICAgICAgICAgICAgdHIucmVwbGFjZVNlbGVjdGlvbldpdGgodGhpcy50eXBlLmNyZWF0ZSh7IGxhbmd1YWdlIH0sIHRleHROb2RlKSlcblxuICAgICAgICAgICAgaWYgKHRyLnNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZSAhPT0gdGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgIC8vIHB1dCBjdXJzb3IgaW5zaWRlIHRoZSBuZXdseSBjcmVhdGVkIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCB0ci5zZWxlY3Rpb24uZnJvbSAtIDIpKSkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIG1ldGEgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBvdGhlciBwbHVnaW5zIHRoYXQgZGVwZW5kcyBvbiB0aGUgcGFzdGUgZXZlbnRcbiAgICAgICAgICAgIC8vIGxpa2UgdGhlIHBhc3RlIHJ1bGUgcGx1Z2luXG4gICAgICAgICAgICB0ci5zZXRNZXRhKCdwYXN0ZScsIHRydWUpXG5cbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpXG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgQ29kZUJsb2NrIH0gZnJvbSAnLi9jb2RlLWJsb2NrLmpzJ1xuXG5leHBvcnQgKiBmcm9tICcuL2NvZGUtYmxvY2suanMnXG5cbmV4cG9ydCBkZWZhdWx0IENvZGVCbG9ja1xuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgTm9kZVBvcyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGRlZmF1bHQgTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICdjdXN0b21CbG9jaycsXG5cbiAgICBncm91cDogJ2Jsb2NrJyxcblxuICAgIGF0b206IHRydWUsXG5cbiAgICBkZWZpbmluZzogdHJ1ZSxcblxuICAgIGRyYWdnYWJsZTogdHJ1ZSxcblxuICAgIHNlbGVjdGFibGU6IHRydWUsXG5cbiAgICBpc29sYXRpbmc6IHRydWUsXG5cbiAgICBhbGxvd0dhcEN1cnNvcjogdHJ1ZSxcblxuICAgIGlubGluZTogZmFsc2UsXG5cbiAgICBhZGROb2RlVmlldygpIHtcbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgZ2V0UG9zLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtY29uZmlnJywgbm9kZS5hdHRycy5jb25maWcpXG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgbm9kZS5hdHRycy5pZClcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScsICdjdXN0b21CbG9jaycpXG5cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICBoZWFkZXIuY2xhc3NOYW1lID1cbiAgICAgICAgICAgICAgICAnZmktZm8tcmljaC1lZGl0b3ItY3VzdG9tLWJsb2NrLWhlYWRlciBmaS1ub3QtcHJvc2UnXG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoaGVhZGVyKVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZWRpdG9yLmlzRWRpdGFibGUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZS5hdHRycy5jb25maWcgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgbm9kZS5hdHRycy5jb25maWcgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhub2RlLmF0dHJzLmNvbmZpZykubGVuZ3RoID4gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdEJ1dHRvbkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICAgICAgZWRpdEJ1dHRvbkNvbnRhaW5lci5jbGFzc05hbWUgPVxuICAgICAgICAgICAgICAgICAgICAnZmktZm8tcmljaC1lZGl0b3ItY3VzdG9tLWJsb2NrLWVkaXQtYnRuLWN0bidcbiAgICAgICAgICAgICAgICBoZWFkZXIuYXBwZW5kQ2hpbGQoZWRpdEJ1dHRvbkNvbnRhaW5lcilcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKVxuICAgICAgICAgICAgICAgIGVkaXRCdXR0b24uY2xhc3NOYW1lID0gJ2ZpLWljb24tYnRuJ1xuICAgICAgICAgICAgICAgIGVkaXRCdXR0b24udHlwZSA9ICdidXR0b24nXG4gICAgICAgICAgICAgICAgZWRpdEJ1dHRvbi5pbm5lckhUTUwgPVxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24ub3B0aW9ucy5lZGl0Q3VzdG9tQmxvY2tCdXR0b25JY29uSHRtbFxuICAgICAgICAgICAgICAgIGVkaXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PlxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24ub3B0aW9ucy5lZGl0Q3VzdG9tQmxvY2tVc2luZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cnMuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHJzLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZWRpdEJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChlZGl0QnV0dG9uKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgICAgICBoZWFkaW5nLmNsYXNzTmFtZSA9ICdmaS1mby1yaWNoLWVkaXRvci1jdXN0b20tYmxvY2staGVhZGluZydcbiAgICAgICAgICAgIGhlYWRpbmcudGV4dENvbnRlbnQgPSBub2RlLmF0dHJzLmxhYmVsXG4gICAgICAgICAgICBoZWFkZXIuYXBwZW5kQ2hpbGQoaGVhZGluZylcblxuICAgICAgICAgICAgaWYgKGVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlQnV0dG9uQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgICAgICBkZWxldGVCdXR0b25Db250YWluZXIuY2xhc3NOYW1lID1cbiAgICAgICAgICAgICAgICAgICAgJ2ZpLWZvLXJpY2gtZWRpdG9yLWN1c3RvbS1ibG9jay1kZWxldGUtYnRuLWN0bidcbiAgICAgICAgICAgICAgICBoZWFkZXIuYXBwZW5kQ2hpbGQoZGVsZXRlQnV0dG9uQ29udGFpbmVyKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJylcbiAgICAgICAgICAgICAgICBkZWxldGVCdXR0b24uY2xhc3NOYW1lID0gJ2ZpLWljb24tYnRuJ1xuICAgICAgICAgICAgICAgIGRlbGV0ZUJ1dHRvbi50eXBlID0gJ2J1dHRvbidcbiAgICAgICAgICAgICAgICBkZWxldGVCdXR0b24uaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLm9wdGlvbnMuZGVsZXRlQ3VzdG9tQmxvY2tCdXR0b25JY29uSHRtbFxuICAgICAgICAgICAgICAgIGRlbGV0ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNoYWluKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXROb2RlU2VsZWN0aW9uKGdldFBvcygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRlbGV0ZVNlbGVjdGlvbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAucnVuKCksXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGRlbGV0ZUJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChkZWxldGVCdXR0b24pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmF0dHJzLnByZXZpZXcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgICAgICBwcmV2aWV3LmNsYXNzTmFtZSA9XG4gICAgICAgICAgICAgICAgICAgICdmaS1mby1yaWNoLWVkaXRvci1jdXN0b20tYmxvY2stcHJldmlldyBmaS1ub3QtcHJvc2UnXG4gICAgICAgICAgICAgICAgcHJldmlldy5pbm5lckhUTUwgPSBhdG9iKG5vZGUuYXR0cnMucHJldmlldylcbiAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQocHJldmlldylcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkb20sXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGV0ZUN1c3RvbUJsb2NrQnV0dG9uSWNvbkh0bWw6IG51bGwsXG4gICAgICAgICAgICBlZGl0Q3VzdG9tQmxvY2tCdXR0b25JY29uSHRtbDogbnVsbCxcbiAgICAgICAgICAgIGVkaXRDdXN0b21CbG9ja1VzaW5nOiAoKSA9PiB7fSxcbiAgICAgICAgICAgIGluc2VydEN1c3RvbUJsb2NrVXNpbmc6ICgpID0+IHt9LFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+XG4gICAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29uZmlnJykpLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWlkJyksXG4gICAgICAgICAgICAgICAgcmVuZGVySFRNTDogKGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1pZCc6IGF0dHJpYnV0ZXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWxhYmVsJyksXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcHJldmlldzoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyc2VIVE1MOiAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcHJldmlldycpLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogYGRpdltkYXRhLXR5cGU9XCIke3RoaXMubmFtZX1cIl1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXVxuICAgIH0sXG5cbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydkaXYnLCBtZXJnZUF0dHJpYnV0ZXMoSFRNTEF0dHJpYnV0ZXMpXVxuICAgIH0sXG5cbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEJhY2tzcGFjZTogKCkgPT5cbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyLCBzdGF0ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc0N1c3RvbUJsb2NrID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1wdHksIGFuY2hvciB9ID0gc2VsZWN0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSBub2RlIGFuZCBwb3NpdGlvbiBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXN0b21CbG9ja05vZGUgPSBuZXcgUHJvc2VNaXJyb3JOb2RlKClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1c3RvbUJsb2NrUG9zID0gMFxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oYW5jaG9yIC0gMSwgYW5jaG9yLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlLm5hbWUgPT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ3VzdG9tQmxvY2sgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQmxvY2tOb2RlID0gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbUJsb2NrUG9zID0gcG9zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQ3VzdG9tQmxvY2tcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIGNvbnN0IHsgaW5zZXJ0Q3VzdG9tQmxvY2tVc2luZyB9ID0gdGhpcy5vcHRpb25zXG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURyb3AodmlldywgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKCdjdXN0b21CbG9jaycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1c3RvbUJsb2NrSWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5nZXREYXRhKCdjdXN0b21CbG9jaycpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEN1c3RvbUJsb2NrVXNpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQmxvY2tJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnBvc0F0Q29vcmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBldmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdXG4gICAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBkb2N1bWVudCBub2RlIHdoaWNoIHJlcHJlc2VudHMgdGhlIHRvcCBsZXZlbCBub2RlIG9mIHRoZSBlZGl0b3IuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbm9kZXMvZG9jdW1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IERvY3VtZW50ID0gTm9kZS5jcmVhdGUoe1xuICBuYW1lOiAnZG9jJyxcbiAgdG9wTm9kZTogdHJ1ZSxcbiAgY29udGVudDogJ2Jsb2NrKycsXG59KVxuIiwgImltcG9ydCB7IERvY3VtZW50IH0gZnJvbSAnLi9kb2N1bWVudC5qcydcblxuZXhwb3J0ICogZnJvbSAnLi9kb2N1bWVudC5qcydcblxuZXhwb3J0IGRlZmF1bHQgRG9jdW1lbnRcbiIsICJpbXBvcnQgeyBEcm9wY3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb25zJ1xuXG5leHBvcnQgdHlwZSB7IERyb3BjdXJzb3JPcHRpb25zIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb25zJ1xuZXhwb3J0IHsgRHJvcGN1cnNvciB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9ucydcblxuZXhwb3J0IGRlZmF1bHQgRHJvcGN1cnNvclxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuLyoqXG4gKiBUaGUgaGVhZGluZyBsZXZlbCBvcHRpb25zLlxuICovXG5leHBvcnQgdHlwZSBMZXZlbCA9IDEgfCAyIHwgMyB8IDQgfCA1IHwgNlxuXG5leHBvcnQgaW50ZXJmYWNlIEhlYWRpbmdPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBhdmFpbGFibGUgaGVhZGluZyBsZXZlbHMuXG4gICAqIEBkZWZhdWx0IFsxLCAyLCAzLCA0LCA1LCA2XVxuICAgKiBAZXhhbXBsZSBbMSwgMiwgM11cbiAgICovXG4gIGxldmVsczogTGV2ZWxbXVxuXG4gIC8qKlxuICAgKiBUaGUgSFRNTCBhdHRyaWJ1dGVzIGZvciBhIGhlYWRpbmcgbm9kZS5cbiAgICogQGRlZmF1bHQge31cbiAgICogQGV4YW1wbGUgeyBjbGFzczogJ2ZvbycgfVxuICAgKi9cbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGhlYWRpbmc6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgaGVhZGluZyBub2RlXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgaGVhZGluZyBhdHRyaWJ1dGVzXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0SGVhZGluZyh7IGxldmVsOiAxIH0pXG4gICAgICAgKi9cbiAgICAgIHNldEhlYWRpbmc6IChhdHRyaWJ1dGVzOiB7IGxldmVsOiBMZXZlbCB9KSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGhlYWRpbmcgbm9kZVxuICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGhlYWRpbmcgYXR0cmlidXRlc1xuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbDogMSB9KVxuICAgICAgICovXG4gICAgICB0b2dnbGVIZWFkaW5nOiAoYXR0cmlidXRlczogeyBsZXZlbDogTGV2ZWwgfSkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGhlYWRpbmdzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9oZWFkaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBIZWFkaW5nID0gTm9kZS5jcmVhdGU8SGVhZGluZ09wdGlvbnM+KHtcbiAgbmFtZTogJ2hlYWRpbmcnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsczogWzEsIDIsIDMsIDQsIDUsIDZdLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAnaW5saW5lKicsXG5cbiAgZ3JvdXA6ICdibG9jaycsXG5cbiAgZGVmaW5pbmc6IHRydWUsXG5cbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6IHtcbiAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLm1hcCgobGV2ZWw6IExldmVsKSA9PiAoe1xuICAgICAgdGFnOiBgaCR7bGV2ZWx9YCxcbiAgICAgIGF0dHJzOiB7IGxldmVsIH0sXG4gICAgfSkpXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IG5vZGUsIEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICBjb25zdCBoYXNMZXZlbCA9IHRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMobm9kZS5hdHRycy5sZXZlbClcbiAgICBjb25zdCBsZXZlbCA9IGhhc0xldmVsID8gbm9kZS5hdHRycy5sZXZlbCA6IHRoaXMub3B0aW9ucy5sZXZlbHNbMF1cblxuICAgIHJldHVybiBbYGgke2xldmVsfWAsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0SGVhZGluZzpcbiAgICAgICAgYXR0cmlidXRlcyA9PlxuICAgICAgICAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKGF0dHJpYnV0ZXMubGV2ZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpXG4gICAgICAgIH0sXG4gICAgICB0b2dnbGVIZWFkaW5nOlxuICAgICAgICBhdHRyaWJ1dGVzID0+XG4gICAgICAgICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5sZXZlbHMuaW5jbHVkZXMoYXR0cmlidXRlcy5sZXZlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVOb2RlKHRoaXMubmFtZSwgJ3BhcmFncmFwaCcsIGF0dHJpYnV0ZXMpXG4gICAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLnJlZHVjZShcbiAgICAgIChpdGVtcywgbGV2ZWwpID0+ICh7XG4gICAgICAgIC4uLml0ZW1zLFxuICAgICAgICAuLi57XG4gICAgICAgICAgW2BNb2QtQWx0LSR7bGV2ZWx9YF06ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbCB9KSxcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgICAge30sXG4gICAgKVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHMubWFwKGxldmVsID0+IHtcbiAgICAgIHJldHVybiB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogbmV3IFJlZ0V4cChgXigjeyR7TWF0aC5taW4oLi4udGhpcy5vcHRpb25zLmxldmVscyl9LCR7bGV2ZWx9fSlcXFxccyRgKSxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBnZXRBdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgbGV2ZWwsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IEhlYWRpbmcgfSBmcm9tICcuL2hlYWRpbmcuanMnXG5cbmV4cG9ydCAqIGZyb20gJy4vaGVhZGluZy5qcydcblxuZXhwb3J0IGRlZmF1bHQgSGVhZGluZ1xuIiwgImltcG9ydCB7IE1hcmssIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBJdGFsaWNPcHRpb25zIHtcbiAgLyoqXG4gICAqIEhUTUwgYXR0cmlidXRlcyB0byBhZGQgdG8gdGhlIGl0YWxpYyBlbGVtZW50LlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAZXhhbXBsZSB7IGNsYXNzOiAnZm9vJyB9XG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgaXRhbGljOiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhbiBpdGFsaWMgbWFya1xuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNldEl0YWxpYygpXG4gICAgICAgKi9cbiAgICAgIHNldEl0YWxpYzogKCkgPT4gUmV0dXJuVHlwZVxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYW4gaXRhbGljIG1hcmtcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKVxuICAgICAgICovXG4gICAgICB0b2dnbGVJdGFsaWM6ICgpID0+IFJldHVyblR5cGVcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYW4gaXRhbGljIG1hcmtcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy51bnNldEl0YWxpYygpXG4gICAgICAgKi9cbiAgICAgIHVuc2V0SXRhbGljOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSAqaXRhbGljKiBvbiBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShcXCooPyFcXHMrXFwqKSgoPzpbXipdKykpXFwqKD8hXFxzK1xcKikpJC9cblxuLyoqXG4gKiBNYXRjaGVzIGFuIGl0YWxpYyB0byBhICppdGFsaWMqIG9uIHBhc3RlLlxuICovXG5leHBvcnQgY29uc3Qgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKFxcKig/IVxccytcXCopKCg/OlteKl0rKSlcXCooPyFcXHMrXFwqKSkvZ1xuXG4vKipcbiAqIE1hdGNoZXMgYW4gaXRhbGljIHRvIGEgX2l0YWxpY18gb24gaW5wdXQuXG4gKi9cbmV4cG9ydCBjb25zdCB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoXyg/IVxccytfKSgoPzpbXl9dKykpXyg/IVxccytfKSkkL1xuXG4vKipcbiAqIE1hdGNoZXMgYW4gaXRhbGljIHRvIGEgX2l0YWxpY18gb24gcGFzdGUuXG4gKi9cbmV4cG9ydCBjb25zdCB1bmRlcnNjb3JlUGFzdGVSZWdleCA9IC8oPzpefFxccykoXyg/IVxccytfKSgoPzpbXl9dKykpXyg/IVxccytfKSkvZ1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGl0YWxpYyB0ZXh0LlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9tYXJrcy9pdGFsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IEl0YWxpYyA9IE1hcmsuY3JlYXRlPEl0YWxpY09wdGlvbnM+KHtcbiAgbmFtZTogJ2l0YWxpYycsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnZW0nLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnaScsXG4gICAgICAgIGdldEF0dHJzOiBub2RlID0+IChub2RlIGFzIEhUTUxFbGVtZW50KS5zdHlsZS5mb250U3R5bGUgIT09ICdub3JtYWwnICYmIG51bGwsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogJ2ZvbnQtc3R5bGU9bm9ybWFsJyxcbiAgICAgICAgY2xlYXJNYXJrOiBtYXJrID0+IG1hcmsudHlwZS5uYW1lID09PSB0aGlzLm5hbWUsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogJ2ZvbnQtc3R5bGU9aXRhbGljJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnZW0nLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEl0YWxpYzpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgICAgfSxcbiAgICAgIHRvZ2dsZUl0YWxpYzpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSlcbiAgICAgICAgfSxcbiAgICAgIHVuc2V0SXRhbGljOlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLWknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKSxcbiAgICAgICdNb2QtSSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogc3RhcklucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHN0YXJQYXN0ZVJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBJdGFsaWMgfSBmcm9tICcuL2l0YWxpYy5qcydcblxuZXhwb3J0ICogZnJvbSAnLi9pdGFsaWMuanMnXG5cbmV4cG9ydCBkZWZhdWx0IEl0YWxpY1xuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSwgbm9kZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZU9wdGlvbnMge1xuICAvKipcbiAgICogQ29udHJvbHMgaWYgdGhlIGltYWdlIG5vZGUgc2hvdWxkIGJlIGlubGluZSBvciBub3QuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGlubGluZTogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBDb250cm9scyBpZiBiYXNlNjQgaW1hZ2VzIGFyZSBhbGxvd2VkLiBFbmFibGUgdGhpcyBpZiB5b3Ugd2FudCB0byBhbGxvd1xuICAgKiBiYXNlNjQgaW1hZ2UgdXJscyBpbiB0aGUgYHNyY2AgYXR0cmlidXRlLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBhbGxvd0Jhc2U2NDogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBIVE1MIGF0dHJpYnV0ZXMgdG8gYWRkIHRvIHRoZSBpbWFnZSBlbGVtZW50LlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAZXhhbXBsZSB7IGNsYXNzOiAnZm9vJyB9XG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNldEltYWdlT3B0aW9ucyB7XG4gIHNyYzogc3RyaW5nXG4gIGFsdD86IHN0cmluZ1xuICB0aXRsZT86IHN0cmluZ1xuICB3aWR0aD86IG51bWJlclxuICBoZWlnaHQ/OiBudW1iZXJcbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGltYWdlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhbiBpbWFnZVxuICAgICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGltYWdlIGF0dHJpYnV0ZXNcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBlZGl0b3JcbiAgICAgICAqICAgLmNvbW1hbmRzXG4gICAgICAgKiAgIC5zZXRJbWFnZSh7IHNyYzogJ2h0dHBzOi8vdGlwdGFwLmRldi9sb2dvLnBuZycsIGFsdDogJ3RpcHRhcCcsIHRpdGxlOiAndGlwdGFwIGxvZ28nIH0pXG4gICAgICAgKi9cbiAgICAgIHNldEltYWdlOiAob3B0aW9uczogU2V0SW1hZ2VPcHRpb25zKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWF0Y2hlcyBhbiBpbWFnZSB0byBhICFbaW1hZ2VdKHNyYyBcInRpdGxlXCIpIG9uIGlucHV0LlxuICovXG5leHBvcnQgY29uc3QgaW5wdXRSZWdleCA9IC8oPzpefFxccykoIVxcWyguK3w6PyldXFwoKFxcUyspKD86KD86XFxzKylbXCInXShcXFMrKVtcIiddKT9cXCkpJC9cblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGluc2VydCBpbWFnZXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2ltYWdlXG4gKi9cbmV4cG9ydCBjb25zdCBJbWFnZSA9IE5vZGUuY3JlYXRlPEltYWdlT3B0aW9ucz4oe1xuICBuYW1lOiAnaW1hZ2UnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlubGluZTogZmFsc2UsXG4gICAgICBhbGxvd0Jhc2U2NDogZmFsc2UsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGlubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmlubGluZVxuICB9LFxuXG4gIGdyb3VwKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5saW5lID8gJ2lubGluZScgOiAnYmxvY2snXG4gIH0sXG5cbiAgZHJhZ2dhYmxlOiB0cnVlLFxuXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNyYzoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgfSxcbiAgICAgIGFsdDoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgfSxcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICB9LFxuICAgICAgd2lkdGg6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IHRoaXMub3B0aW9ucy5hbGxvd0Jhc2U2NCA/ICdpbWdbc3JjXScgOiAnaW1nW3NyY106bm90KFtzcmNePVwiZGF0YTpcIl0pJyxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnaW1nJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRJbWFnZTpcbiAgICAgICAgb3B0aW9ucyA9PlxuICAgICAgICAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnQoe1xuICAgICAgICAgICAgdHlwZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgYXR0cnM6IG9wdGlvbnMsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbm9kZUlucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4ge1xuICAgICAgICAgIGNvbnN0IFssICwgYWx0LCBzcmMsIHRpdGxlXSA9IG1hdGNoXG5cbiAgICAgICAgICByZXR1cm4geyBzcmMsIGFsdCwgdGl0bGUgfVxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBJbWFnZSB9IGZyb20gJy4vaW1hZ2UuanMnXG5cbmV4cG9ydCAqIGZyb20gJy4vaW1hZ2UuanMnXG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlXG4iLCAiaW1wb3J0IEltYWdlIGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWltYWdlJ1xuXG5leHBvcnQgZGVmYXVsdCBJbWFnZS5leHRlbmQoe1xuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLnBhcmVudD8uKCksXG5cbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IChlbGVtZW50KSA9PiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1pZCcpLFxuICAgICAgICAgICAgICAgIHJlbmRlckhUTUw6IChhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtaWQnOiBhdHRyaWJ1dGVzLmlkLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICB9LFxufSlcbiIsICIvLyBUSElTIEZJTEUgSVMgQVVUT01BVElDQUxMWSBHRU5FUkFURUQgRE8gTk9UIEVESVQgRElSRUNUTFlcbi8vIFNlZSB1cGRhdGUtdGxkcy5qcyBmb3IgZW5jb2RpbmcvZGVjb2RpbmcgZm9ybWF0XG4vLyBodHRwczovL2RhdGEuaWFuYS5vcmcvVExEL3RsZHMtYWxwaGEtYnktZG9tYWluLnR4dFxuY29uc3QgZW5jb2RlZFRsZHMgPSAnYWFhMXJwM2JiMG90dDN2aWU0YzFsZTJvZ2FkbzV1ZGhhYmk3YzBhZGVteTVjZW50dXJlNm91bnRhbnQwczlvMXRvcjRkMHMxdWx0NGUwZzFybzJ0bmE0ZjBsMXJpY2E1ZzBha2hhbjVlbmN5NWkwZzFyYnVzM2ZvcmNlNXRlbDVrZG4zbDBpYmFiYTRwYXk0bGZpbmFuejZzdGF0ZTV5MnNhY2UzdG9tNW0wYXpvbjRlcmljYW5leHByZXNzN2ZhbWlseTExeDJmYW0zaWNhM3N0ZXJkYW04bmFseXRpY3M3ZHJvaWQ1cXVhbjR6Mm8wbDJwYXJ0bWVudHM4cDBsZTRxMHVhcmVsbGU4cjBhYjFtY280Y2hpM215MnBhMnQwZTNzMGRhMmlhMnNvY2lhdGVzOXQwaGxldGE1dG9ybmV5N3UwY3Rpb241ZGkwYmxlM28zc3Bvc3Q1dGhvcjNvMHM0dzBzMngwYTJ6MHVyZTViYTBieTJpZHUzbmFtZXg0ZDFrMnIwY2Vsb25hNWxheWNhcmQ0czVlZm9vdDVnYWluczZzZWJhbGw1a2V0YmFsbDh1aGF1czV5ZXJuNWIwYzF0MXZhM2NnMW4yZDFlMGF0czJ1dHk0ZXIycmxpbjRzdDBidXk1dDJmMWcxaDBhcnRpNWkwYmxlM2Qxa2UybmcwbzNvMXoyajFsYWNrMGZyaWRheTlvY2tidXN0ZXI4ZzFvbWJlcmc3dWUzbTBzMXcybjBwcGFyaWJhczlvMGF0czNlaHJpbmdlcjhmYTJtMW5kMm8wazBpbmc1c2NoMnRpazJvbjR0MXV0aXF1ZTZ4MnIwYWRlc2NvNmlkZ2VzdG9uZTlvYWR3YXk1a2VyM3RoZXI1dXNzZWxzN3MxdDF1aWxkMGVyczZzaW5lc3M2eTF6ejN2MXcxeTF6MGgzY2EwYjFmZTJsMGwxdmlua2xlaW45bTBlcmEzcDJub24zcGV0b3duNWl0YWwwb25lOHIwYXZhbjRkczJlMGVyMHM0czJzYTFlMWgxaW5vNHQwZXJpbmc1aG9saWM3YmExbjFyZTNjMWQxZW50ZXI0bzFybjNmMGExZDJnMWgwYW5lbDJuZWw0cml0eTRzZTJ0MmVhcDNpbnRhaTVyaXN0bWFzNm9tZTR1cmNoNWkwcHJpYW5pNnJjbGU0c2NvM3RhZGVsNGkwYzJ5M2sxbDBhaW1zNGVhbmluZzZpY2sybmljMXF1ZTZvdGhpbmc1dWQzdWIwbWVkNm0xbjFvMGFjaDNkZXMzZmZlZTRsbGVnZTRvZ25lNW0wbWJhbms0dW5pdHk2cGFueTJyZTN1dGVyNXNlYzRuZG9zM3N0cnVjdGlvbjh1bHRpbmc3dGFjdDNyYWN0b3JzOW9raW5nNGwxcDJyc2ljYTV1bnRyeTRwb24wczRyc2VzNnBhMnIwZWRpdDBjYXJkNHVuaW9uOWlja2V0NW93bjNzMXVpc2UwczZ1MGlzaW5lbGxhOXYxdzF4MXkwbXJ1M291M3oyZGFkMW5jZTN0YTFlMWluZzNzdW40eTJjbGszZHMyZTBhbDBlcjJzM2dyZWU0bGl2ZXJ5NWwxb2l0dGU1dGEzbW9jcmF0Nm50YWwyaXN0NXNpMGduNHYyaGwyaWFtb25kczZldDJnaXRhbDVyZWN0MG9yeTdzY291bnQzdmVyNWgyeTJqMWsxbTFucDJvMGNzMXRvcjRnMW1haW5zNXQxd25sb2FkN3JpdmU0dHYydWJhaTNubG9wNHBvbnQ0cmJhbjV2YWcycjJ6MmVhcnRoM3QyYzBvMmRla2EzdTBjYXRpb244ZTFnMW1haWwzZXJjazVuZXJneTRnaW5lZXIwaW5nOXRlcnByaXNlczEwcHNvbjRxdWlwbWVudDhyMGljc3NvbjZuaTNzMHExdGF0ZTV0MXUwcm92aXNpb244czJ2ZW50czV4Y2hhbmdlNnBlcnQzb3NlZDRyZXNzNXRyYXNwYWNlMTBmYWdlMmlsMXJ3aW5kczZ0aDNtaWx5NG4wczJybTBlcnM1c2hpb240dDNlZGV4M2VkYmFjazZycmFyaTNlcm82aTBkZWxpdHk1bzJsbTJuYWwxbmNlMWlhbDdyZTBzdG9uZTZtZGFsZTZzaDBpbmc1dDBuZXNzNmoxazFsaWNrcjNnaHRzNHIyb3Jpc3Q0d2VyczV5Mm0xbzBvMGQxdGJhbGw2cmQxZXgyc2FsZTR1bTN1bmRhdGlvbjh4MnIwZWUxc2VuaXVzN2wxb2dhbnM0bnRpZXI3dHIydWppdHN1NW4wZDJybml0dXJlN3Rib2w1eWkzZ2EwbDBsZXJ5M28xdXA0bWUwczNwMXJkZW40eTJiMGl6M2QwbjJlMGExbnQwaW5nNW9yZ2U1ZjFnMGVlM2gxaTBmdDBzM3ZlczJpbmc1bDBhc3MzZTFvYmFsMm80bTBhaWwzYmgybzF4Mm4xb2RhZGR5NWxkMHBvaW50NmYybzBkeWVhcjVnMGxlNHAxdDF2MnAxcTFyMGFpbmdlcjVwaGljczV0aXM0ZWVuM2lwZTNvY2VyeTR1cDRzMXQxdTBjY2kzZ2UyaWRlMnRhcnM1cnUzdzF5MmhhaXIybWJ1cmc1bmdvdXQ1dXMzYm8yZGZjMGJhbms3ZWFsdGgwY2FyZThscDFzaW5raTZyZTFtZXM1aXBob3A0c2FtaXRzdTd0YWNoaTV2MmswdDJtMW4xb2NrZXk0bGRpbmdzNWlkYXk1bWVkZXBvdDVnb29kczVzMGVuc2U3bmRhM3JzZTNzcGl0YWw1dDBpbmc1dDBlbHMzbWFpbDV1c2UzdzJyMXNiYzN0MXUwZ2hlczV5YXR0M3VuZGFpN2libTJjYmMyZTF1MmQxZTBlZTNmbTJrYW5vNGwxbTBhbWF0NGRiMm1vMGJpbGllbjluMGMxZHVzdHJpZXM4ZmluaXRpNW8yZzFrMXN0aXR1dGU2dXJhbmNlNGU0dDBlcm5hdGlvbmFsMTB1aXQ0dmVzdG1lbnRzMTBvMXBpcmFuZ2E3cTFyMGlzaDRzMG1haWxpNXQwYW5idWw3dDBhdTJ2M2phZ3VhcjR2YTNjYjJlMGVwMnR6dDN3ZWxyeTZpbzJsbDJtMHAybmoybzBiczF1cmc0dDF5MnAwbW9yZ2FuNnJzM3VlZ29zNG5pcGVyN2thdWZlbjVkZGkzZTBycnlob3RlbHM2cHJvcGVydGllczE0ZmgyZzFoMWkwYTFkczJtMW5kbGU0dGNoZW41d2kzbTFuMW9lbG4zbWF0c3U1c2hlcjVwMG1nMm4ycjBkMWVkM3Vva2dyb3VwOHcxeTBvdG80ejJsYTBjYWl4YTVtYm9yZ2hpbmk4ZXIzbmQwcm92ZXI2eGVzczVzYWxsZTV0MGlubzNyb2JlNXcweWVyNWIxYzFkczJlYXNlM2NsZXJjNWZyYWs0Z2FsMm8yeHVzNGdidDNpMGRsMmZlMGluc3VyYW5jZTlzdHlsZTdnaHRpbmc2a2UybGx5M21pdGVkNG8ybmNvbG40azJ2ZTFpbmc1azFsYzFwMm9hbjBzM2NrZXIzdXMzbDFuZG9uNHR0ZTFvM3ZlM3BsMGZpbmFuY2lhbDExcjFzMXQwZDBhM3UwbmRiZWNrNnhlMXVyeTV2MXkybWEwZHJpZDRpZjFzb240a2V1cDRuMGFnZW1lbnQ3Z28zcDFya2V0MGluZzNzNHJpb3R0NXNoYWxsczd0dGVsNWJhMmMwa2luc2V5N2QxZTBkMGlhM2V0Mmxib3VybmU3bWUxb3JpYWw2bjB1MnJja21zZDdnMWgxaWFtaTNjcm9zb2Z0N2wxbmkxdDJ0MHN1YmlzaGk5azFsMGIxczJtMGEybjFvMGJpMGxlNGRhMmUxaTFtMW5hc2gzZXkyc3RlcjVybW9uM3RnYWdlNnNjb3c0dG8wcmN5Y2xlczl2MGllNHAxcTFyMXMwZDJ0MG4xcjJ1MHNldW0zaWM0djF3MXgxeTF6Mm5hMGIxZ295YTRtZTJ2eTNiYTJjMWUwYzF0MGJhbms0ZmxpeDR3b3JrNXVzdGFyNXcwczJ4dDBkaXJlY3Q3dXM0ZjBsMmcwbzJoazJpMGNvMmtlMW9uM25qYTNzc2FuMXk1bDFvMGtpYTNydG9uNHcwcnV6M3R2NHAxcjBhMXcydHQydTF5YzJ6Mm9iaTFzZXJ2ZXI3ZmZpY2U1a2luYXdhNmxheWFuMGdyb3VwOWxvM20wZWdhNG5lMWcxbDBpbmU1b28ycGVuM3JhY2xlM25nZTRnMGFuaWM1aWdpbnM2c2FrYTR0c3VrYTR0MnZoM3BhMGdlMm5hc29uaWM3cmlzMnMxdG5lcnM0czF5M3kyY2N3M2UwdDJmMGl6ZXI1ZzFoMGFybWFjeTZkMWlsaXBzNW9uZTJ0bzBncmFwaHk2czR5c2lvNWljczF0ZXQydXJlczZkMW4wZzFrMm9uZWVyNXp6YTRrMWwwYWNlMnkwc3RhdGlvbjl1bWJpbmc1czNtMW4wYzJvaGwya2VyM2xpdGllNXJuMnN0M3IwYW1lcmljYTZ4aTNlc3MzaW1lM28wZDB1Y3Rpb25zOGYxZ3Jlc3NpdmU4bW8ycGVydGllczN5NXRlY3Rpb244dTBkZW50aWFsOXMxdDF1YjJ3MGMyeTJxYTFwb24zdWViZWMzc3Q1cmFjaW5nNGRpbzRlMGFkMWxlc3RhdGU2dG9yMnk0Y2lwZXM1ZDBzdG9uZTV1bWJyZWxsYTloYWIzaXNlMG4zdDJsaWFuY2U2bjB0MGFsczVwYWlyM29ydDN1YmxpY2FuOHN0MGF1cmFudDh2aWV3MHM1eHJvdGg2aWNoMGFyZGxpNm9oM2wxbzFwMm8wY2tzM2RlbzNnZXJzNG9tM3MwdnAzdTBnYnkzaHIybjJ3MGUyeXVreXU2c2EwYXJsYW5kNmZlMHR5NGt1cmE0bGUxb24zbXNjbHViNHVuZzVuZHZpazBjb3JvbWFudDEyb2ZpNHAxcmwyczF2ZTJ4bzNiMGkxczJjMGIxaGFlZmZsZXI3bWlkdDRvbGFyc2hpcHM4b2wzdWxlM3dhcno1aWVuY2U1b3QzZDFlMGFyY2gzdDJjdXJlMWl0eTZlazJsZWN0NG5lcjNydmljZXM2dmVuM3cxeDB5M2ZyMmcxaDBhbmdyaWxhNnJwM2VsbDNpYTFrc2hhNW9lczJwMHBpbmc1dWppM3czaTBsazJuYTFnbGVzNXRlM2oxazBpMG4yeTBwZTRsMGluZzRtMGFydDNpbGU0bjBjZjNvMGNjZXIzaWFsNGZ0YmFuazR3YXJlNmh1MmxhcjJ1dGlvbnM3bmcxeTJ5MnBhMGNlM29ydDJ0M3IwbDJzMXQwYWRhMnBsZXM0cjF0ZWJhbms0ZmFybTdjMGdyb3VwNm9ja2hvbG02cmFnZTNlM3JlYW00dWRpbzJ5M3lsZTR1MGNrczNwcGxpZXMzeTJvcnQ1cmYxZ2VyeTV6dWtpNXYxd2F0Y2g0aXNzNHgxeTBkbmV5NHN0ZW1zNnoydGFiMWlwZWk0bGsyb2JhbzRyZ2V0NHRhbW90b3JzNnIydG9vNHgwaTNjMGkyZDBrMmVhbTJjaDBub2xvZ3k4bDFtYXNlazVubmlzNHZhM2YxZzFoMGQxZWF0ZXIycmU2aWFhMmNrZXRzNWVuZGE0cHMycmVzMm9sNGowbWF4eDR4MmswbWF4eDVsMW0wYWxsNG4xbzBkYXkza3lvM29sczNwMXJheTNzaGliYTV0YWwzdXJzM3duMnlvdGEzczNyMGFkZTFpbmc0aW5pbmc1dmVsMGVyczBpbnN1cmFuY2UxNnVzdDN2MnQxdWJlMmkxbmVzM3NodTR2MHMydzF6MnVhMWJhbmszczJnMWsxbmljb20zdmVyc2l0eThvMm9sMnBzMnMxeTF6MnZhMGNhdGlvbnM3bmExZ3VhcmQ3YzFlMGdhczNudHVyZXM2cmlzaWduNW1cdTAwRjZnZW5zYmVyYXRlcjJ1bmcxNHNpY2hlcnVuZzEwdDJnMWkwYWplczRkZW8zZzFraW5nNGxsYXM0bjFwMXJnaW40c2ExaW9uNHZhMW8zbGFhbmRlcmVuOW4xb2RrYTNsdm8zdGUxaW5nM28yeWFnZTV1MndhbGVzMm1hcnQ0dGVyNG5nMGdvdTV0Y2gwZXM2ZWF0aGVyMGNoYW5uZWwxMmJjYW0zZXIyc2l0ZTVkMGRpbmc1aWJvMnIzZjFob3N3aG82aWVuMmtpMmxsaWFtaGlsbDluMGRvd3M0ZTFuZXJzNm1lMm9sdGVyc2tsdXdlcjExb2RzaWRlNnJrMHMybGQzdzJzMXRjMWYzeGJveDNlcm94NGlodWFuNG4yeHgyeXozeWFjaHRzNGhvbzNtYXh1bjVuZGV4NWUxb2RvYmFzaGk3Z2Eya29oYW1hNnUwdHViZTZ0MXVuM3phMHBwb3M0cmEzZXJvM2lwMm0xb25lM3VlcmljaDZ3Mic7XG4vLyBJbnRlcm5hdGlvbmFsaXplZCBkb21haW4gbmFtZXMgY29udGFpbmluZyBub24tQVNDSUlcbmNvbnN0IGVuY29kZWRVdGxkcyA9ICdcdTAzQjVcdTAzQkIxXHUwM0M1Mlx1MDQzMVx1MDQzMzFcdTA0MzVcdTA0M0IzXHUwNDM0XHUwNDM1XHUwNDQyXHUwNDM4NFx1MDQzNVx1MDQ0RTJcdTA0M0FcdTA0MzBcdTA0NDJcdTA0M0VcdTA0M0JcdTA0MzhcdTA0M0E2XHUwNDNFXHUwNDNDM1x1MDQzQ1x1MDQzQVx1MDQzNDJcdTA0M0VcdTA0M0QxXHUwNDQxXHUwNDNBXHUwNDMyXHUwNDMwNlx1MDQzRVx1MDQzRFx1MDQzQlx1MDQzMFx1MDQzOVx1MDQzRDVcdTA0NDBcdTA0MzMzXHUwNDQwXHUwNDQzXHUwNDQxMlx1MDQ0NDJcdTA0NDFcdTA0MzBcdTA0MzlcdTA0NDIzXHUwNDQwXHUwNDMxM1x1MDQ0M1x1MDQzQVx1MDQ0MDNcdTA0OUJcdTA0MzBcdTA0MzczXHUwNTcwXHUwNTYxXHUwNTc1M1x1MDVEOVx1MDVFOVx1MDVFOFx1MDVEMFx1MDVEQzVcdTA1RTdcdTA1RDVcdTA1REQzXHUwNjI3XHUwNjI4XHUwNjQ4XHUwNjM4XHUwNjI4XHUwNjRBNVx1MDYzMVx1MDYyN1x1MDY0NVx1MDY0M1x1MDY0ODVcdTA2NDRcdTA2MjdcdTA2MzFcdTA2MkZcdTA2NDY0XHUwNjI4XHUwNjJEXHUwNjMxXHUwNjRBXHUwNjQ2NVx1MDYyQ1x1MDYzMlx1MDYyN1x1MDYyNlx1MDYzMTVcdTA2MzNcdTA2MzlcdTA2NDhcdTA2MkZcdTA2NEFcdTA2Mjk2XHUwNjM5XHUwNjQ0XHUwNjRBXHUwNjI3XHUwNjQ2NVx1MDY0NVx1MDYzQVx1MDYzMVx1MDYyODVcdTA2NDVcdTA2MjdcdTA2MzFcdTA2MjdcdTA2MkE1XHUwNkNDXHUwNjMxXHUwNjI3XHUwNjQ2NVx1MDYyOFx1MDYyN1x1MDYzMVx1MDYyQTJcdTA2MzJcdTA2MjdcdTA2MzE0XHUwNjRBXHUwNjJBXHUwNjQzM1x1MDZCRVx1MDYyN1x1MDYzMVx1MDYyQTVcdTA2MkFcdTA2NDhcdTA2NDZcdTA2MzM0XHUwNjMzXHUwNjQ4XHUwNjJGXHUwNjI3XHUwNjQ2M1x1MDYzMVx1MDY0QVx1MDYyOTVcdTA2MzRcdTA2MjhcdTA2NDNcdTA2Mjk0XHUwNjM5XHUwNjMxXHUwNjI3XHUwNjQyMlx1MDYyODJcdTA2NDVcdTA2MjdcdTA2NDY0XHUwNjQxXHUwNjQ0XHUwNjMzXHUwNjM3XHUwNjRBXHUwNjQ2Nlx1MDY0Mlx1MDYzN1x1MDYzMTNcdTA2NDNcdTA2MjdcdTA2MkJcdTA2NDhcdTA2NDRcdTA2NEFcdTA2NDM2XHUwNjQ4XHUwNjQ1M1x1MDY0NVx1MDYzNVx1MDYzMTJcdTA2NDRcdTA2NEFcdTA2MzNcdTA2NEFcdTA2Mjc1XHUwNjQ4XHUwNjMxXHUwNjRBXHUwNjJBXHUwNjI3XHUwNjQ2XHUwNjRBXHUwNjI3N1x1MDY0Mlx1MDYzOTRcdTA2NDdcdTA2NDVcdTA2MzFcdTA2MjdcdTA2NDc1XHUwNjdFXHUwNjI3XHUwNkE5XHUwNjMzXHUwNjJBXHUwNjI3XHUwNjQ2N1x1MDY4MFx1MDYyN1x1MDYzMVx1MDYyQTRcdTA5MTVcdTA5NDlcdTA5MkUzXHUwOTI4XHUwOTQ3XHUwOTFGM1x1MDkyRFx1MDkzRVx1MDkzMFx1MDkyNDBcdTA5MkVcdTA5NEQzXHUwOTRCXHUwOTI0NVx1MDkzOFx1MDkwMlx1MDkxN1x1MDkyMFx1MDkyODVcdTA5QUNcdTA5QkVcdTA5ODJcdTA5QjJcdTA5QkU1XHUwOUFEXHUwOUJFXHUwOUIwXHUwOUE0Mlx1MDlGMFx1MDlBNDRcdTBBMkRcdTBBM0VcdTBBMzBcdTBBMjQ0XHUwQUFEXHUwQUJFXHUwQUIwXHUwQUE0NFx1MEIyRFx1MEIzRVx1MEIzMFx1MEIyNDRcdTBCODdcdTBCQThcdTBCQ0RcdTBCQTRcdTBCQkZcdTBCQUZcdTBCQkU2XHUwQkIyXHUwQjk5XHUwQkNEXHUwQjk1XHUwQkM4Nlx1MEI5QVx1MEJCRlx1MEI5OVx1MEJDRFx1MEI5NVx1MEJBQVx1MEJDRFx1MEJBQVx1MEJDMlx1MEJCMFx1MEJDRDExXHUwQzJEXHUwQzNFXHUwQzMwXHUwQzI0XHUwQzRENVx1MENBRFx1MENCRVx1MENCMFx1MENBNDRcdTBEMkRcdTBEM0VcdTBEMzBcdTBEMjRcdTBEMDI1XHUwREJEXHUwRDgyXHUwRDlBXHUwRENGNFx1MEUwNFx1MEUyRFx1MEUyMTNcdTBFNDRcdTBFMTdcdTBFMjIzXHUwRUE1XHUwRUIyXHUwRUE3M1x1MTBEMlx1MTBENDJcdTMwN0ZcdTMwOTNcdTMwNkEzXHUzMEEyXHUzMERFXHUzMEJFXHUzMEYzNFx1MzBBRlx1MzBFOVx1MzBBNlx1MzBDOTRcdTMwQjBcdTMwRkNcdTMwQjBcdTMwRUI0XHUzMEIzXHUzMEUwMlx1MzBCOVx1MzBDOFx1MzBBMjNcdTMwQkJcdTMwRkNcdTMwRUIzXHUzMEQ1XHUzMEExXHUzMEMzXHUzMEI3XHUzMEU3XHUzMEYzNlx1MzBERFx1MzBBNFx1MzBGM1x1MzBDODRcdTRFMTZcdTc1NEMyXHU0RTJEXHU0RkUxMVx1NTZGRDFcdTU3MEIxXHU2NTg3XHU3RjUxM1x1NEU5QVx1OUE2Q1x1OTAwQTNcdTRGMDFcdTRFMUEyXHU0RjVCXHU1QzcxMlx1NEZFMVx1NjA2RjJcdTUwNjVcdTVFQjcyXHU1MTZCXHU1MzY2Mlx1NTE2Q1x1NTNGODFcdTc2Q0EyXHU1M0YwXHU2RTdFMVx1NzA2MzJcdTU1NDZcdTU3Q0UxXHU1RTk3MVx1NjgwNzJcdTU2MDlcdTkxQ0MwXHU1OTI3XHU5MTUyXHU1RTk3NVx1NTcyOFx1N0VCRjJcdTU5MjdcdTYyRkYyXHU1OTI5XHU0RTNCXHU2NTU5M1x1NUEzMVx1NEU1MDJcdTVCQjZcdTk2RkIyXHU1RTdGXHU0RTFDMlx1NUZBRVx1NTM1QTJcdTYxNDhcdTU1ODQyXHU2MjExXHU3MjMxXHU0RjYwM1x1NjI0Qlx1NjczQTJcdTYyREJcdTgwNTgyXHU2NTNGXHU1MkExMVx1NUU5QzJcdTY1QjBcdTUyQTBcdTU3NjEyXHU5NUZCMlx1NjVGNlx1NUMxQTJcdTY2RjhcdTdDNEQyXHU2NzNBXHU2Nzg0Mlx1NkRFMVx1OUE2Q1x1OTUyMTNcdTZFMzhcdTYyMEYyXHU2RkIzXHU5NTgwMlx1NzBCOVx1NzcwQjJcdTc5RkJcdTUyQTgyXHU3RUM0XHU3RUM3XHU2NzNBXHU2Nzg0NFx1N0Y1MVx1NTc0MDFcdTVFOTcxXHU3QUQ5MVx1N0VEQzJcdTgwNTRcdTkwMUEyXHU4QzM3XHU2QjRDMlx1OEQyRFx1NzI2OTJcdTkwMUFcdThDQTkyXHU5NkM2XHU1NkUyMlx1OTZGQlx1OEEwQVx1NzZDOFx1NzlEMTRcdTk4REVcdTUyMjlcdTZENjYzXHU5OERGXHU1NEMxMlx1OTkxMFx1NTM4NTJcdTk5OTlcdTY4M0NcdTkxQ0NcdTYyQzkzXHU2RTJGMlx1QjJGN1x1QjEzNzFcdUNFRjQyXHVDMEJDXHVDMTMxMlx1RDU1Q1x1QUQ2RDInO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKiBAdGVtcGxhdGUgQlxuICogQHBhcmFtIHtBfSB0YXJnZXRcbiAqIEBwYXJhbSB7Qn0gcHJvcGVydGllc1xuICogQHJldHVybiB7QSAmIEJ9XG4gKi9cbmNvbnN0IGFzc2lnbiA9ICh0YXJnZXQsIHByb3BlcnRpZXMpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgIHRhcmdldFtrZXldID0gcHJvcGVydGllc1trZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEZpbml0ZSBTdGF0ZSBNYWNoaW5lIGdlbmVyYXRpb24gdXRpbGl0aWVzXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge3sgW2dyb3VwOiBzdHJpbmddOiBUW10gfX0gQ29sbGVjdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7IFtncm91cDogc3RyaW5nXTogdHJ1ZSB9fSBGbGFnc1xuICovXG5cbi8vIEtleXMgaW4gc2Nhbm5lciBDb2xsZWN0aW9ucyBpbnN0YW5jZXNcbmNvbnN0IG51bWVyaWMgPSAnbnVtZXJpYyc7XG5jb25zdCBhc2NpaSA9ICdhc2NpaSc7XG5jb25zdCBhbHBoYSA9ICdhbHBoYSc7XG5jb25zdCBhc2NpaW51bWVyaWMgPSAnYXNjaWludW1lcmljJztcbmNvbnN0IGFscGhhbnVtZXJpYyA9ICdhbHBoYW51bWVyaWMnO1xuY29uc3QgZG9tYWluID0gJ2RvbWFpbic7XG5jb25zdCBlbW9qaSA9ICdlbW9qaSc7XG5jb25zdCBzY2hlbWUgPSAnc2NoZW1lJztcbmNvbnN0IHNsYXNoc2NoZW1lID0gJ3NsYXNoc2NoZW1lJztcbmNvbnN0IHdoaXRlc3BhY2UgPSAnd2hpdGVzcGFjZSc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBncm91cHMgdG8gcmVnaXN0ZXIgaW5cbiAqIEByZXR1cm5zIHtUW119IEN1cnJlbnQgbGlzdCBvZiB0b2tlbnMgaW4gdGhlIGdpdmVuIGNvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJHcm91cChuYW1lLCBncm91cHMpIHtcbiAgaWYgKCEobmFtZSBpbiBncm91cHMpKSB7XG4gICAgZ3JvdXBzW25hbWVdID0gW107XG4gIH1cbiAgcmV0dXJuIGdyb3Vwc1tuYW1lXTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB0IHRva2VuIHRvIGFkZFxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gZ3JvdXBzXG4gKiBAcGFyYW0ge0ZsYWdzfSBmbGFnc1xuICovXG5mdW5jdGlvbiBhZGRUb0dyb3Vwcyh0LCBmbGFncywgZ3JvdXBzKSB7XG4gIGlmIChmbGFnc1tudW1lcmljXSkge1xuICAgIGZsYWdzW2FzY2lpbnVtZXJpY10gPSB0cnVlO1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thc2NpaV0pIHtcbiAgICBmbGFnc1thc2NpaW51bWVyaWNdID0gdHJ1ZTtcbiAgICBmbGFnc1thbHBoYV0gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thc2NpaW51bWVyaWNdKSB7XG4gICAgZmxhZ3NbYWxwaGFudW1lcmljXSA9IHRydWU7XG4gIH1cbiAgaWYgKGZsYWdzW2FscGhhXSkge1xuICAgIGZsYWdzW2FscGhhbnVtZXJpY10gPSB0cnVlO1xuICB9XG4gIGlmIChmbGFnc1thbHBoYW51bWVyaWNdKSB7XG4gICAgZmxhZ3NbZG9tYWluXSA9IHRydWU7XG4gIH1cbiAgaWYgKGZsYWdzW2Vtb2ppXSkge1xuICAgIGZsYWdzW2RvbWFpbl0gPSB0cnVlO1xuICB9XG4gIGZvciAoY29uc3QgayBpbiBmbGFncykge1xuICAgIGNvbnN0IGdyb3VwID0gcmVnaXN0ZXJHcm91cChrLCBncm91cHMpO1xuICAgIGlmIChncm91cC5pbmRleE9mKHQpIDwgMCkge1xuICAgICAgZ3JvdXAucHVzaCh0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB0IHRva2VuIHRvIGNoZWNrXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBncm91cHNcbiAqIEByZXR1cm5zIHtGbGFnc30gZ3JvdXAgZmxhZ3MgdGhhdCBjb250YWluIHRoaXMgdG9rZW5cbiAqL1xuZnVuY3Rpb24gZmxhZ3NGb3JUb2tlbih0LCBncm91cHMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgYyBpbiBncm91cHMpIHtcbiAgICBpZiAoZ3JvdXBzW2NdLmluZGV4T2YodCkgPj0gMCkge1xuICAgICAgcmVzdWx0W2NdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge251bGwgfCBUIH0gVHJhbnNpdGlvblxuICovXG5cbi8qKlxuICogRGVmaW5lIGEgYmFzaWMgc3RhdGUgbWFjaGluZSBzdGF0ZS4gaiBpcyB0aGUgbGlzdCBvZiBjaGFyYWN0ZXIgdHJhbnNpdGlvbnMsXG4gKiBqciBpcyB0aGUgbGlzdCBvZiByZWdleC1tYXRjaCB0cmFuc2l0aW9ucywgamQgaXMgdGhlIGRlZmF1bHQgc3RhdGUgdG9cbiAqIHRyYW5zaXRpb24gdG8gdCBpcyB0aGUgYWNjZXB0aW5nIHRva2VuIHR5cGUsIGlmIGFueS4gSWYgdGhpcyBpcyB0aGUgdGVybWluYWxcbiAqIHN0YXRlLCB0aGVuIGl0IGRvZXMgbm90IGVtaXQgYSB0b2tlbi5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgdHlwZSBUIHJlcHJlc2VudHMgdGhlIHR5cGUgb2YgdGhlIHRva2VuIHRoaXMgc3RhdGUgYWNjZXB0cy4gVGhpc1xuICogc2hvdWxkIGJlIGEgc3RyaW5nIChzdWNoIGFzIG9mIHRoZSB0b2tlbiBleHBvcnRzIGluIGB0ZXh0LmpzYCkgb3IgYVxuICogTXVsdGlUb2tlbiBzdWJjbGFzcyAoZnJvbSBgbXVsdGkuanNgKVxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt0b2tlbl0gVG9rZW4gdGhhdCB0aGlzIHN0YXRlIGVtaXRzXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHRva2VuID0gbnVsbCkge1xuICAvLyB0aGlzLm4gPSBudWxsOyAvLyBERUJVRzogU3RhdGUgbmFtZVxuICAvKiogQHR5cGUge3sgW2lucHV0OiBzdHJpbmddOiBTdGF0ZTxUPiB9fSBqICovXG4gIHRoaXMuaiA9IHt9OyAvLyBJTVBMRU1FTlRBVElPTiAxXG4gIC8vIHRoaXMuaiA9IFtdOyAvLyBJTVBMRU1FTlRBVElPTiAyXG4gIC8qKiBAdHlwZSB7W1JlZ0V4cCwgU3RhdGU8VD5dW119IGpyICovXG4gIHRoaXMuanIgPSBbXTtcbiAgLyoqIEB0eXBlIHs/U3RhdGU8VD59IGpkICovXG4gIHRoaXMuamQgPSBudWxsO1xuICAvKiogQHR5cGUgez9UfSB0ICovXG4gIHRoaXMudCA9IHRva2VuO1xufVxuXG4vKipcbiAqIFNjYW5uZXIgdG9rZW4gZ3JvdXBzXG4gKiBAdHlwZSBDb2xsZWN0aW9uczxzdHJpbmc+XG4gKi9cblN0YXRlLmdyb3VwcyA9IHt9O1xuU3RhdGUucHJvdG90eXBlID0ge1xuICBhY2NlcHRzKCkge1xuICAgIHJldHVybiAhIXRoaXMudDtcbiAgfSxcbiAgLyoqXG4gICAqIEZvbGxvdyBhbiBleGlzdGluZyB0cmFuc2l0aW9uIGZyb20gdGhlIGdpdmVuIGlucHV0IHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgKiBEb2VzIG5vdCBtdXRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBjaGFyYWN0ZXIgb3IgdG9rZW4gdHlwZSB0byB0cmFuc2l0aW9uIG9uXG4gICAqIEByZXR1cm5zIHs/U3RhdGU8VD59IHRoZSBuZXh0IHN0YXRlLCBpZiBhbnlcbiAgICovXG4gIGdvKGlucHV0KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzO1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHN0YXRlLmpbaW5wdXRdO1xuICAgIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuanIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gc3RhdGUuanJbaV1bMF07XG4gICAgICBjb25zdCBuZXh0U3RhdGUgPSBzdGF0ZS5qcltpXVsxXTsgLy8gbm90ZTogbWlnaHQgYmUgZW1wdHkgdG8gcHJldmVudCBkZWZhdWx0IGp1bXBcbiAgICAgIGlmIChuZXh0U3RhdGUgJiYgcmVnZXgudGVzdChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm93aGVyZSBsZWZ0IHRvIGp1bXAhIFJldHVybiBkZWZhdWx0LCBpZiBhbnlcbiAgICByZXR1cm4gc3RhdGUuamQ7XG4gIH0sXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdGF0ZSBoYXMgYSB0cmFuc2l0aW9uIGZvciB0aGUgZ2l2ZW4gaW5wdXQuIFNldCB0aGUgc2Vjb25kXG4gICAqIGFyZ3VtZW50IHRvIHRydWUgdG8gb25seSBsb29rIGZvciBhbiBleGFjdCBtYXRjaCAoYW5kIG5vdCBhIGRlZmF1bHQgb3JcbiAgICogcmVndWxhci1leHByZXNzaW9uLWJhc2VkIHRyYW5zaXRpb24pXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV4YWN0T25seVxuICAgKi9cbiAgaGFzKGlucHV0LCBleGFjdE9ubHkgPSBmYWxzZSkge1xuICAgIHJldHVybiBleGFjdE9ubHkgPyBpbnB1dCBpbiB0aGlzLmogOiAhIXRoaXMuZ28oaW5wdXQpO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidHJhbnNpdGlvbiBhbGxcIjsgY3JlYXRlIGEgdHJhbnNpdGlvbiBmcm9tIHRoZSBhcnJheSBvZiBpdGVtc1xuICAgKiBpbiB0aGUgZ2l2ZW4gbGlzdCB0byB0aGUgc2FtZSBmaW5hbCByZXN1bHRpbmcgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0cyBHcm91cCBvZiBpbnB1dHMgdG8gdHJhbnNpdGlvbiBvblxuICAgKiBAcGFyYW0ge1RyYW5zaXRpb248VD4gfCBTdGF0ZTxUPn0gW25leHRdIFRyYW5zaXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdIENvbGxlY3Rpb25zIGZsYWdzIHRvIGFkZCB0b2tlbiB0b1xuICAgKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXSBNYXN0ZXIgbGlzdCBvZiB0b2tlbiBncm91cHNcbiAgICovXG4gIHRhKGlucHV0cywgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnR0KGlucHV0c1tpXSwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSByZWdleHAgdHJhbnNpdGlvblwiOyBkZWZpbmVzIGEgdHJhbnNpdGlvbiBmb3IgdGhpcyBzdGF0ZVxuICAgKiB3aGVuIGl0IGVuY291bnRlcnMgYSB0b2tlbiB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cCBSZWd1bGFyIGV4cHJlc3Npb24gdHJhbnNpdGlvbiAocG9wdWxhdGUgZmlyc3QpXG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIHRva2VuIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHIocmVnZXhwLCBuZXh0LCBmbGFncywgZ3JvdXBzKSB7XG4gICAgZ3JvdXBzID0gZ3JvdXBzIHx8IFN0YXRlLmdyb3VwcztcbiAgICBsZXQgbmV4dFN0YXRlO1xuICAgIGlmIChuZXh0ICYmIG5leHQuaikge1xuICAgICAgbmV4dFN0YXRlID0gbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9rZW4gd2l0aCBtYXliZSB0b2tlbiBncm91cHNcbiAgICAgIG5leHRTdGF0ZSA9IG5ldyBTdGF0ZShuZXh0KTtcbiAgICAgIGlmIChmbGFncyAmJiBncm91cHMpIHtcbiAgICAgICAgYWRkVG9Hcm91cHMobmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuanIucHVzaChbcmVnZXhwLCBuZXh0U3RhdGVdKTtcbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuICAvKipcbiAgICogU2hvcnQgZm9yIFwidGFrZSB0cmFuc2l0aW9uc1wiLCB3aWxsIHRha2UgYXMgbWFueSBzZXF1ZW50aWFsIHRyYW5zaXRpb25zIGFzXG4gICAqIHRoZSBsZW5ndGggb2YgdGhlIGdpdmVuIGlucHV0IGFuZCByZXR1cm5zIHRoZVxuICAgKiByZXN1bHRpbmcgZmluYWwgc3RhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0XG4gICAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF0gVHJhbnNpdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc10gQ29sbGVjdGlvbnMgZmxhZ3MgdG8gYWRkIHRva2VuIHRvXG4gICAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdIE1hc3RlciBsaXN0IG9mIHRva2VuIGdyb3Vwc1xuICAgKiBAcmV0dXJucyB7U3RhdGU8VD59IHRha2VuIGFmdGVyIHRoZSBnaXZlbiBpbnB1dFxuICAgKi9cbiAgdHMoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzO1xuICAgIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgICBpZiAoIWxlbikge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgc3RhdGUgPSBzdGF0ZS50dChpbnB1dFtpXSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZS50dChpbnB1dFtsZW4gLSAxXSwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTaG9ydCBmb3IgXCJ0YWtlIHRyYW5zaXRpb25cIiwgdGhpcyBpcyBhIG1ldGhvZCBmb3IgYnVpbGRpbmcvd29ya2luZyB3aXRoXG4gICAqIHN0YXRlIG1hY2hpbmVzLlxuICAgKlxuICAgKiBJZiBhIHN0YXRlIGFscmVhZHkgZXhpc3RzIGZvciB0aGUgZ2l2ZW4gaW5wdXQsIHJldHVybnMgaXQuXG4gICAqXG4gICAqIElmIGEgdG9rZW4gaXMgc3BlY2lmaWVkLCB0aGF0IHN0YXRlIHdpbGwgZW1pdCB0aGF0IHRva2VuIHdoZW4gcmVhY2hlZCBieVxuICAgKiB0aGUgbGlua2lmeSBlbmdpbmUuXG4gICAqXG4gICAqIElmIG5vIHN0YXRlIGV4aXN0cywgaXQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIHNvbWUgZGVmYXVsdCB0cmFuc2l0aW9uc1xuICAgKiB0aGF0IHJlc2VtYmxlIGV4aXN0aW5nIGRlZmF1bHQgdHJhbnNpdGlvbnMuXG4gICAqXG4gICAqIElmIGEgc3RhdGUgaXMgZ2l2ZW4gZm9yIHRoZSBzZWNvbmQgYXJndW1lbnQsIHRoYXQgc3RhdGUgd2lsbCBiZVxuICAgKiB0cmFuc2l0aW9uZWQgdG8gb24gdGhlIGdpdmVuIGlucHV0IHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGF0IGlucHV0XG4gICAqIHByZXZpb3VzbHkgZGlkLlxuICAgKlxuICAgKiBTcGVjaWZ5IGEgdG9rZW4gZ3JvdXAgZmxhZ3MgdG8gZGVmaW5lIGdyb3VwcyB0aGF0IHRoaXMgdG9rZW4gYmVsb25ncyB0by5cbiAgICogVGhlIHRva2VuIHdpbGwgYmUgYWRkZWQgdG8gY29ycmVzcG9uZGluZyBlbnRpcmVzIGluIHRoZSBnaXZlbiBncm91cHNcbiAgICogb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgY2hhcmFjdGVyLCB0b2tlbiB0eXBlIHRvIHRyYW5zaXRpb24gb25cbiAgICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XSBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXSBDb2xsZWN0aW9ucyBmbGFncyB0byBhZGQgdG9rZW4gdG9cbiAgICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc10gTWFzdGVyIGxpc3Qgb2YgZ3JvdXBzXG4gICAqIEByZXR1cm5zIHtTdGF0ZTxUPn0gdGFrZW4gYWZ0ZXIgdGhlIGdpdmVuIGlucHV0XG4gICAqL1xuICB0dChpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcykge1xuICAgIGdyb3VwcyA9IGdyb3VwcyB8fCBTdGF0ZS5ncm91cHM7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgZXhpc3Rpbmcgc3RhdGUgZ2l2ZW4sIGp1c3QgYSBiYXNpYyB0cmFuc2l0aW9uXG4gICAgaWYgKG5leHQgJiYgbmV4dC5qKSB7XG4gICAgICBzdGF0ZS5qW2lucHV0XSA9IG5leHQ7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG4gICAgY29uc3QgdCA9IG5leHQ7XG5cbiAgICAvLyBUYWtlIHRoZSB0cmFuc2l0aW9uIHdpdGggdGhlIHVzdWFsIGRlZmF1bHQgbWVjaGFuaXNtcyBhbmQgdXNlIHRoYXQgYXNcbiAgICAvLyBhIHRlbXBsYXRlIGZvciBjcmVhdGluZyB0aGUgbmV4dCBzdGF0ZVxuICAgIGxldCBuZXh0U3RhdGUsXG4gICAgICB0ZW1wbGF0ZVN0YXRlID0gc3RhdGUuZ28oaW5wdXQpO1xuICAgIGlmICh0ZW1wbGF0ZVN0YXRlKSB7XG4gICAgICBuZXh0U3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICAgIGFzc2lnbihuZXh0U3RhdGUuaiwgdGVtcGxhdGVTdGF0ZS5qKTtcbiAgICAgIG5leHRTdGF0ZS5qci5wdXNoLmFwcGx5KG5leHRTdGF0ZS5qciwgdGVtcGxhdGVTdGF0ZS5qcik7XG4gICAgICBuZXh0U3RhdGUuamQgPSB0ZW1wbGF0ZVN0YXRlLmpkO1xuICAgICAgbmV4dFN0YXRlLnQgPSB0ZW1wbGF0ZVN0YXRlLnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRTdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICAgIH1cbiAgICBpZiAodCkge1xuICAgICAgLy8gRW5zdXJlIG5ld2x5IHRva2VuIGlzIGluIHRoZSBzYW1lIGdyb3VwcyBhcyB0aGUgb2xkIHRva2VuXG4gICAgICBpZiAoZ3JvdXBzKSB7XG4gICAgICAgIGlmIChuZXh0U3RhdGUudCAmJiB0eXBlb2YgbmV4dFN0YXRlLnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgYWxsRmxhZ3MgPSBhc3NpZ24oZmxhZ3NGb3JUb2tlbihuZXh0U3RhdGUudCwgZ3JvdXBzKSwgZmxhZ3MpO1xuICAgICAgICAgIGFkZFRvR3JvdXBzKHQsIGFsbEZsYWdzLCBncm91cHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGZsYWdzKSB7XG4gICAgICAgICAgYWRkVG9Hcm91cHModCwgZmxhZ3MsIGdyb3Vwcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRTdGF0ZS50ID0gdDsgLy8gb3ZlcndyaXRlIGFueXRoaW5nIHRoYXQgd2FzIHByZXZpb3VzbHkgdGhlcmVcbiAgICB9XG4gICAgc3RhdGUualtpbnB1dF0gPSBuZXh0U3RhdGU7XG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9ucyB0byBpbXByb3ZlIG1pbmlmaWNhdGlvbiAobm90IGV4cG9ydGVkIG91dHNpZGUgbGlua2lmeWpzIG1vZHVsZSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGlucHV0XG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKiBAcGFyYW0ge0NvbGxlY3Rpb25zPFQ+fSBbZ3JvdXBzXVxuICovXG5jb25zdCB0YSA9IChzdGF0ZSwgaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnRhKGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTdGF0ZTxUPn0gc3RhdGVcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF1cbiAqIEBwYXJhbSB7RmxhZ3N9IFtmbGFnc11cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKi9cbmNvbnN0IHRyID0gKHN0YXRlLCByZWdleHAsIG5leHQsIGZsYWdzLCBncm91cHMpID0+IHN0YXRlLnRyKHJlZ2V4cCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U3RhdGU8VD59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBpbnB1dFxuICogQHBhcmFtIHtUIHwgU3RhdGU8VD59IFtuZXh0XVxuICogQHBhcmFtIHtGbGFnc30gW2ZsYWdzXVxuICogQHBhcmFtIHtDb2xsZWN0aW9uczxUPn0gW2dyb3Vwc11cbiAqL1xuY29uc3QgdHMgPSAoc3RhdGUsIGlucHV0LCBuZXh0LCBmbGFncywgZ3JvdXBzKSA9PiBzdGF0ZS50cyhpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3Vwcyk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U3RhdGU8VD59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7VCB8IFN0YXRlPFQ+fSBbbmV4dF1cbiAqIEBwYXJhbSB7Q29sbGVjdGlvbnM8VD59IFtncm91cHNdXG4gKiBAcGFyYW0ge0ZsYWdzfSBbZmxhZ3NdXG4gKi9cbmNvbnN0IHR0ID0gKHN0YXRlLCBpbnB1dCwgbmV4dCwgZmxhZ3MsIGdyb3VwcykgPT4gc3RhdGUudHQoaW5wdXQsIG5leHQsIGZsYWdzLCBncm91cHMpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5UZXh0IFRva2Vuc1xuSWRlbnRpZmllcnMgZm9yIHRva2VuIG91dHB1dHMgZnJvbSB0aGUgcmVnZXhwIHNjYW5uZXJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gQSB2YWxpZCB3ZWIgZG9tYWluIHRva2VuXG5jb25zdCBXT1JEID0gJ1dPUkQnOyAvLyBvbmx5IGNvbnRhaW5zIGEtelxuY29uc3QgVVdPUkQgPSAnVVdPUkQnOyAvLyBjb250YWlucyBsZXR0ZXJzIG90aGVyIHRoYW4gYS16LCB1c2VkIGZvciBJRE5cbmNvbnN0IEFTQ0lJTlVNRVJJQ0FMID0gJ0FTQ0lJTlVNRVJJQ0FMJzsgLy8gY29udGFpbnMgYS16LCAwLTlcbmNvbnN0IEFMUEhBTlVNRVJJQ0FMID0gJ0FMUEhBTlVNRVJJQ0FMJzsgLy8gY29udGFpbnMgbnVtYmVycyBhbmQgbGV0dGVycyBvdGhlciB0aGFuIGEteiwgdXNlZCBmb3IgSUROXG5cbi8vIFNwZWNpYWwgY2FzZSBvZiB3b3JkXG5jb25zdCBMT0NBTEhPU1QgPSAnTE9DQUxIT1NUJztcblxuLy8gVmFsaWQgdG9wLWxldmVsIGRvbWFpbiwgc3BlY2lhbCBjYXNlIG9mIFdPUkQgKHNlZSB0bGRzLmpzKVxuY29uc3QgVExEID0gJ1RMRCc7XG5cbi8vIFZhbGlkIElETiBUTEQsIHNwZWNpYWwgY2FzZSBvZiBVV09SRCAoc2VlIHRsZHMuanMpXG5jb25zdCBVVExEID0gJ1VUTEQnO1xuXG4vLyBUaGUgc2NoZW1lIHBvcnRpb24gb2YgYSB3ZWIgVVJJIHByb3RvY29sLiBTdXBwb3J0ZWQgdHlwZXMgaW5jbHVkZTogYG1haWx0b2AsXG4vLyBgZmlsZWAsIGFuZCB1c2VyLWRlZmluZWQgY3VzdG9tIHByb3RvY29scy4gTGltaXRlZCB0byBzY2hlbWVzIHRoYXQgY29udGFpblxuLy8gb25seSBsZXR0ZXJzXG5jb25zdCBTQ0hFTUUgPSAnU0NIRU1FJztcblxuLy8gU2ltaWxhciB0byBTQ0hFTUUsIGV4Y2VwdCBtYWtlcyBkaXN0aW5jdGlvbiBmb3Igc2NoZW1lcyB0aGF0IG11c3QgYWx3YXlzIGJlXG4vLyBmb2xsb3dlZCBieSBgOi8vYCwgbm90IGp1c3QgYDpgLiBTdXBwb3J0ZWQgdHlwZXMgaW5jbHVkZSBgaHR0cGAsIGBodHRwc2AsXG4vLyBgZnRwYCwgYGZ0cHNgXG5jb25zdCBTTEFTSF9TQ0hFTUUgPSAnU0xBU0hfU0NIRU1FJztcblxuLy8gQW55IHNlcXVlbmNlIG9mIGRpZ2l0cyAwLTlcbmNvbnN0IE5VTSA9ICdOVU0nO1xuXG4vLyBBbnkgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2UgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgbmV3bGluZVxuY29uc3QgV1MgPSAnV1MnO1xuXG4vLyBOZXcgbGluZSAodW5peCBzdHlsZSlcbmNvbnN0IE5MID0gJ05MJzsgLy8gXFxuXG5cbi8vIE9wZW5pbmcvY2xvc2luZyBicmFja2V0IGNsYXNzZXNcbi8vIFRPRE86IFJlbmFtZSBPUEVOIC0+IExFRlQgYW5kIENMT1NFIC0+IFJJR0hUIGluIHY1IHRvIGZpdCB3aXRoIFVuaWNvZGUgbmFtZXNcbi8vIEFsc28gcmVuYW1lIGFuZ2xlIGJyYWNrZXMgdG8gTEVTU1RIQU4gYW5kIEdSRUFURVIgVEhBTlxuY29uc3QgT1BFTkJSQUNFID0gJ09QRU5CUkFDRSc7IC8vIHtcbmNvbnN0IENMT1NFQlJBQ0UgPSAnQ0xPU0VCUkFDRSc7IC8vIH1cbmNvbnN0IE9QRU5CUkFDS0VUID0gJ09QRU5CUkFDS0VUJzsgLy8gW1xuY29uc3QgQ0xPU0VCUkFDS0VUID0gJ0NMT1NFQlJBQ0tFVCc7IC8vIF1cbmNvbnN0IE9QRU5QQVJFTiA9ICdPUEVOUEFSRU4nOyAvLyAoXG5jb25zdCBDTE9TRVBBUkVOID0gJ0NMT1NFUEFSRU4nOyAvLyApXG5jb25zdCBPUEVOQU5HTEVCUkFDS0VUID0gJ09QRU5BTkdMRUJSQUNLRVQnOyAvLyA8XG5jb25zdCBDTE9TRUFOR0xFQlJBQ0tFVCA9ICdDTE9TRUFOR0xFQlJBQ0tFVCc7IC8vID5cbmNvbnN0IEZVTExXSURUSExFRlRQQVJFTiA9ICdGVUxMV0lEVEhMRUZUUEFSRU4nOyAvLyBcdUZGMDhcbmNvbnN0IEZVTExXSURUSFJJR0hUUEFSRU4gPSAnRlVMTFdJRFRIUklHSFRQQVJFTic7IC8vIFx1RkYwOVxuY29uc3QgTEVGVENPUk5FUkJSQUNLRVQgPSAnTEVGVENPUk5FUkJSQUNLRVQnOyAvLyBcdTMwMENcbmNvbnN0IFJJR0hUQ09STkVSQlJBQ0tFVCA9ICdSSUdIVENPUk5FUkJSQUNLRVQnOyAvLyBcdTMwMERcbmNvbnN0IExFRlRXSElURUNPUk5FUkJSQUNLRVQgPSAnTEVGVFdISVRFQ09STkVSQlJBQ0tFVCc7IC8vIFx1MzAwRVxuY29uc3QgUklHSFRXSElURUNPUk5FUkJSQUNLRVQgPSAnUklHSFRXSElURUNPUk5FUkJSQUNLRVQnOyAvLyBcdTMwMEZcbmNvbnN0IEZVTExXSURUSExFU1NUSEFOID0gJ0ZVTExXSURUSExFU1NUSEFOJzsgLy8gXHVGRjFDXG5jb25zdCBGVUxMV0lEVEhHUkVBVEVSVEhBTiA9ICdGVUxMV0lEVEhHUkVBVEVSVEhBTic7IC8vIFx1RkYxRVxuXG4vLyBWYXJpb3VzIHN5bWJvbHNcbmNvbnN0IEFNUEVSU0FORCA9ICdBTVBFUlNBTkQnOyAvLyAmXG5jb25zdCBBUE9TVFJPUEhFID0gJ0FQT1NUUk9QSEUnOyAvLyAnXG5jb25zdCBBU1RFUklTSyA9ICdBU1RFUklTSyc7IC8vICpcbmNvbnN0IEFUID0gJ0FUJzsgLy8gQFxuY29uc3QgQkFDS1NMQVNIID0gJ0JBQ0tTTEFTSCc7IC8vIFxcXG5jb25zdCBCQUNLVElDSyA9ICdCQUNLVElDSyc7IC8vIGBcbmNvbnN0IENBUkVUID0gJ0NBUkVUJzsgLy8gXlxuY29uc3QgQ09MT04gPSAnQ09MT04nOyAvLyA6XG5jb25zdCBDT01NQSA9ICdDT01NQSc7IC8vICxcbmNvbnN0IERPTExBUiA9ICdET0xMQVInOyAvLyAkXG5jb25zdCBET1QgPSAnRE9UJzsgLy8gLlxuY29uc3QgRVFVQUxTID0gJ0VRVUFMUyc7IC8vID1cbmNvbnN0IEVYQ0xBTUFUSU9OID0gJ0VYQ0xBTUFUSU9OJzsgLy8gIVxuY29uc3QgSFlQSEVOID0gJ0hZUEhFTic7IC8vIC1cbmNvbnN0IFBFUkNFTlQgPSAnUEVSQ0VOVCc7IC8vICVcbmNvbnN0IFBJUEUgPSAnUElQRSc7IC8vIHxcbmNvbnN0IFBMVVMgPSAnUExVUyc7IC8vICtcbmNvbnN0IFBPVU5EID0gJ1BPVU5EJzsgLy8gI1xuY29uc3QgUVVFUlkgPSAnUVVFUlknOyAvLyA/XG5jb25zdCBRVU9URSA9ICdRVU9URSc7IC8vIFwiXG5jb25zdCBGVUxMV0lEVEhNSURETEVET1QgPSAnRlVMTFdJRFRITUlERExFRE9UJzsgLy8gXHUzMEZCXG5cbmNvbnN0IFNFTUkgPSAnU0VNSSc7IC8vIDtcbmNvbnN0IFNMQVNIID0gJ1NMQVNIJzsgLy8gL1xuY29uc3QgVElMREUgPSAnVElMREUnOyAvLyB+XG5jb25zdCBVTkRFUlNDT1JFID0gJ1VOREVSU0NPUkUnOyAvLyBfXG5cbi8vIEVtb2ppIHN5bWJvbFxuY29uc3QgRU1PSkkkMSA9ICdFTU9KSSc7XG5cbi8vIERlZmF1bHQgdG9rZW4gLSBhbnl0aGluZyB0aGF0IGlzIG5vdCBvbmUgb2YgdGhlIGFib3ZlXG5jb25zdCBTWU0gPSAnU1lNJztcblxudmFyIHRrID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdEFMUEhBTlVNRVJJQ0FMOiBBTFBIQU5VTUVSSUNBTCxcblx0QU1QRVJTQU5EOiBBTVBFUlNBTkQsXG5cdEFQT1NUUk9QSEU6IEFQT1NUUk9QSEUsXG5cdEFTQ0lJTlVNRVJJQ0FMOiBBU0NJSU5VTUVSSUNBTCxcblx0QVNURVJJU0s6IEFTVEVSSVNLLFxuXHRBVDogQVQsXG5cdEJBQ0tTTEFTSDogQkFDS1NMQVNILFxuXHRCQUNLVElDSzogQkFDS1RJQ0ssXG5cdENBUkVUOiBDQVJFVCxcblx0Q0xPU0VBTkdMRUJSQUNLRVQ6IENMT1NFQU5HTEVCUkFDS0VULFxuXHRDTE9TRUJSQUNFOiBDTE9TRUJSQUNFLFxuXHRDTE9TRUJSQUNLRVQ6IENMT1NFQlJBQ0tFVCxcblx0Q0xPU0VQQVJFTjogQ0xPU0VQQVJFTixcblx0Q09MT046IENPTE9OLFxuXHRDT01NQTogQ09NTUEsXG5cdERPTExBUjogRE9MTEFSLFxuXHRET1Q6IERPVCxcblx0RU1PSkk6IEVNT0pJJDEsXG5cdEVRVUFMUzogRVFVQUxTLFxuXHRFWENMQU1BVElPTjogRVhDTEFNQVRJT04sXG5cdEZVTExXSURUSEdSRUFURVJUSEFOOiBGVUxMV0lEVEhHUkVBVEVSVEhBTixcblx0RlVMTFdJRFRITEVGVFBBUkVOOiBGVUxMV0lEVEhMRUZUUEFSRU4sXG5cdEZVTExXSURUSExFU1NUSEFOOiBGVUxMV0lEVEhMRVNTVEhBTixcblx0RlVMTFdJRFRITUlERExFRE9UOiBGVUxMV0lEVEhNSURETEVET1QsXG5cdEZVTExXSURUSFJJR0hUUEFSRU46IEZVTExXSURUSFJJR0hUUEFSRU4sXG5cdEhZUEhFTjogSFlQSEVOLFxuXHRMRUZUQ09STkVSQlJBQ0tFVDogTEVGVENPUk5FUkJSQUNLRVQsXG5cdExFRlRXSElURUNPUk5FUkJSQUNLRVQ6IExFRlRXSElURUNPUk5FUkJSQUNLRVQsXG5cdExPQ0FMSE9TVDogTE9DQUxIT1NULFxuXHROTDogTkwsXG5cdE5VTTogTlVNLFxuXHRPUEVOQU5HTEVCUkFDS0VUOiBPUEVOQU5HTEVCUkFDS0VULFxuXHRPUEVOQlJBQ0U6IE9QRU5CUkFDRSxcblx0T1BFTkJSQUNLRVQ6IE9QRU5CUkFDS0VULFxuXHRPUEVOUEFSRU46IE9QRU5QQVJFTixcblx0UEVSQ0VOVDogUEVSQ0VOVCxcblx0UElQRTogUElQRSxcblx0UExVUzogUExVUyxcblx0UE9VTkQ6IFBPVU5ELFxuXHRRVUVSWTogUVVFUlksXG5cdFFVT1RFOiBRVU9URSxcblx0UklHSFRDT1JORVJCUkFDS0VUOiBSSUdIVENPUk5FUkJSQUNLRVQsXG5cdFJJR0hUV0hJVEVDT1JORVJCUkFDS0VUOiBSSUdIVFdISVRFQ09STkVSQlJBQ0tFVCxcblx0U0NIRU1FOiBTQ0hFTUUsXG5cdFNFTUk6IFNFTUksXG5cdFNMQVNIOiBTTEFTSCxcblx0U0xBU0hfU0NIRU1FOiBTTEFTSF9TQ0hFTUUsXG5cdFNZTTogU1lNLFxuXHRUSUxERTogVElMREUsXG5cdFRMRDogVExELFxuXHRVTkRFUlNDT1JFOiBVTkRFUlNDT1JFLFxuXHRVVExEOiBVVExELFxuXHRVV09SRDogVVdPUkQsXG5cdFdPUkQ6IFdPUkQsXG5cdFdTOiBXU1xufSk7XG5cbi8vIE5vdGUgdGhhdCB0aGVzZSB0d28gVW5pY29kZSBvbmVzIGV4cGFuZCBpbnRvIGEgcmVhbGx5IGJpZyBvbmUgd2l0aCBCYWJlbFxuY29uc3QgQVNDSUlfTEVUVEVSID0gL1thLXpdLztcbmNvbnN0IExFVFRFUiA9IC9cXHB7TH0vdTsgLy8gQW55IFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggbGV0dGVyIGRhdGEgdHlwZVxuY29uc3QgRU1PSkkgPSAvXFxwe0Vtb2ppfS91OyAvLyBBbnkgVW5pY29kZSBlbW9qaSBjaGFyYWN0ZXJcbmNvbnN0IEVNT0pJX1ZBUklBVElPTiQxID0gL1xcdWZlMGYvO1xuY29uc3QgRElHSVQgPSAvXFxkLztcbmNvbnN0IFNQQUNFID0gL1xccy87XG5cbnZhciByZWdleHAgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0QVNDSUlfTEVUVEVSOiBBU0NJSV9MRVRURVIsXG5cdERJR0lUOiBESUdJVCxcblx0RU1PSkk6IEVNT0pJLFxuXHRFTU9KSV9WQVJJQVRJT046IEVNT0pJX1ZBUklBVElPTiQxLFxuXHRMRVRURVI6IExFVFRFUixcblx0U1BBQ0U6IFNQQUNFXG59KTtcblxuLyoqXG5cdFRoZSBzY2FubmVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSB0aGF0IHRha2VzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXQsIGFuZFxuXHRvdXRwdXRzIGFuIGFycmF5IG9mIHRva2VucyBpbnN0YW5jZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZWFzeSBVUkwgcGFyc2luZy5cbiovXG5cbmNvbnN0IENSID0gJ1xccic7IC8vIGNhcnJpYWdlLXJldHVybiBjaGFyYWN0ZXJcbmNvbnN0IExGID0gJ1xcbic7IC8vIGxpbmUtZmVlZCBjaGFyYWN0ZXJcbmNvbnN0IEVNT0pJX1ZBUklBVElPTiA9ICdcXHVmZTBmJzsgLy8gVmFyaWF0aW9uIHNlbGVjdG9yLCBmb2xsb3dzIGhlYXJ0IGFuZCBvdGhlcnNcbmNvbnN0IEVNT0pJX0pPSU5FUiA9ICdcXHUyMDBkJzsgLy8gemVyby13aWR0aCBqb2luZXJcbmNvbnN0IE9CSkVDVF9SRVBMQUNFTUVOVCA9ICdcXHVmZmZjJzsgLy8gd2hpdGVzcGFjZSBwbGFjZWhvbGRlciB0aGF0IHNvbWV0aW1lcyBhcHBlYXJzIGluIHJpY2ggdGV4dCBlZGl0b3JzXG5cbmxldCB0bGRzID0gbnVsbCxcbiAgdXRsZHMgPSBudWxsOyAvLyBkb24ndCBjaGFuZ2Ugc28gb25seSBoYXZlIHRvIGJlIGNvbXB1dGVkIG9uY2VcblxuLyoqXG4gKiBTY2FubmVyIG91dHB1dCB0b2tlbjpcbiAqIC0gYHRgIGlzIHRoZSB0b2tlbiBuYW1lIChlLmcuLCAnTlVNJywgJ0VNT0pJJywgJ1RMRCcpXG4gKiAtIGB2YCBpcyB0aGUgdmFsdWUgb2YgdGhlIHRva2VuIChlLmcuLCAnMTIzJywgJ1x1Mjc2NFx1RkUwRicsICdjb20nKVxuICogLSBgc2AgaXMgdGhlIHN0YXJ0IGluZGV4IG9mIHRoZSB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiAtIGBlYCBpcyB0aGUgZW5kIGluZGV4IG9mIHRoZSB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiBAdHlwZWRlZiB7e3Q6IHN0cmluZywgdjogc3RyaW5nLCBzOiBudW1iZXIsIGU6IG51bWJlcn19IFRva2VuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHR5cGVkZWYge3sgW2NvbGxlY3Rpb246IHN0cmluZ106IFRbXSB9fSBDb2xsZWN0aW9uc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgc2Nhbm5lciBjaGFyYWN0ZXItYmFzZWQgc3RhdGUgbWFjaGluZSBmb3IgdGhlIGdpdmVuIHN0YXJ0XG4gKiBzdGF0ZVxuICogQHBhcmFtIHtbc3RyaW5nLCBib29sZWFuXVtdfSBjdXN0b21TY2hlbWVzIExpc3Qgb2YgY3VzdG9tIHNjaGVtZXMsIHdoZXJlIGVhY2hcbiAqIGl0ZW0gaXMgYSBsZW5ndGgtMiB0dXBsZSB3aXRoIHRoZSBmaXJzdCBlbGVtZW50IHNldCB0byB0aGUgc3RyaW5nIHNjaGVtZSwgYW5kXG4gKiB0aGUgc2Vjb25kIGVsZW1lbnQgc2V0IHRvIGB0cnVlYCBpZiB0aGUgYDovL2AgYWZ0ZXIgdGhlIHNjaGVtZSBpcyBvcHRpb25hbFxuICovXG5mdW5jdGlvbiBpbml0JDIoY3VzdG9tU2NoZW1lcyA9IFtdKSB7XG4gIC8vIEZyZXF1ZW50bHkgdXNlZCBzdGF0ZXMgKG5hbWUgYXJndW1lbnQgcmVtb3ZlZCBkdXJpbmcgbWluaWZpY2F0aW9uKVxuICAvKiogQHR5cGUgQ29sbGVjdGlvbnM8c3RyaW5nPiAqL1xuICBjb25zdCBncm91cHMgPSB7fTsgLy8gb2YgdG9rZW5zXG4gIFN0YXRlLmdyb3VwcyA9IGdyb3VwcztcbiAgLyoqIEB0eXBlIFN0YXRlPHN0cmluZz4gKi9cbiAgY29uc3QgU3RhcnQgPSBuZXcgU3RhdGUoKTtcbiAgaWYgKHRsZHMgPT0gbnVsbCkge1xuICAgIHRsZHMgPSBkZWNvZGVUbGRzKGVuY29kZWRUbGRzKTtcbiAgfVxuICBpZiAodXRsZHMgPT0gbnVsbCkge1xuICAgIHV0bGRzID0gZGVjb2RlVGxkcyhlbmNvZGVkVXRsZHMpO1xuICB9XG5cbiAgLy8gU3RhdGVzIGZvciBzcGVjaWFsIFVSTCBzeW1ib2xzIHRoYXQgYWNjZXB0IGltbWVkaWF0ZWx5IGFmdGVyIHN0YXJ0XG4gIHR0KFN0YXJ0LCBcIidcIiwgQVBPU1RST1BIRSk7XG4gIHR0KFN0YXJ0LCAneycsIE9QRU5CUkFDRSk7XG4gIHR0KFN0YXJ0LCAnfScsIENMT1NFQlJBQ0UpO1xuICB0dChTdGFydCwgJ1snLCBPUEVOQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXScsIENMT1NFQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnKCcsIE9QRU5QQVJFTik7XG4gIHR0KFN0YXJ0LCAnKScsIENMT1NFUEFSRU4pO1xuICB0dChTdGFydCwgJzwnLCBPUEVOQU5HTEVCUkFDS0VUKTtcbiAgdHQoU3RhcnQsICc+JywgQ0xPU0VBTkdMRUJSQUNLRVQpO1xuICB0dChTdGFydCwgJ1x1RkYwOCcsIEZVTExXSURUSExFRlRQQVJFTik7XG4gIHR0KFN0YXJ0LCAnXHVGRjA5JywgRlVMTFdJRFRIUklHSFRQQVJFTik7XG4gIHR0KFN0YXJ0LCAnXHUzMDBDJywgTEVGVENPUk5FUkJSQUNLRVQpO1xuICB0dChTdGFydCwgJ1x1MzAwRCcsIFJJR0hUQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXHUzMDBFJywgTEVGVFdISVRFQ09STkVSQlJBQ0tFVCk7XG4gIHR0KFN0YXJ0LCAnXHUzMDBGJywgUklHSFRXSElURUNPUk5FUkJSQUNLRVQpO1xuICB0dChTdGFydCwgJ1x1RkYxQycsIEZVTExXSURUSExFU1NUSEFOKTtcbiAgdHQoU3RhcnQsICdcdUZGMUUnLCBGVUxMV0lEVEhHUkVBVEVSVEhBTik7XG4gIHR0KFN0YXJ0LCAnJicsIEFNUEVSU0FORCk7XG4gIHR0KFN0YXJ0LCAnKicsIEFTVEVSSVNLKTtcbiAgdHQoU3RhcnQsICdAJywgQVQpO1xuICB0dChTdGFydCwgJ2AnLCBCQUNLVElDSyk7XG4gIHR0KFN0YXJ0LCAnXicsIENBUkVUKTtcbiAgdHQoU3RhcnQsICc6JywgQ09MT04pO1xuICB0dChTdGFydCwgJywnLCBDT01NQSk7XG4gIHR0KFN0YXJ0LCAnJCcsIERPTExBUik7XG4gIHR0KFN0YXJ0LCAnLicsIERPVCk7XG4gIHR0KFN0YXJ0LCAnPScsIEVRVUFMUyk7XG4gIHR0KFN0YXJ0LCAnIScsIEVYQ0xBTUFUSU9OKTtcbiAgdHQoU3RhcnQsICctJywgSFlQSEVOKTtcbiAgdHQoU3RhcnQsICclJywgUEVSQ0VOVCk7XG4gIHR0KFN0YXJ0LCAnfCcsIFBJUEUpO1xuICB0dChTdGFydCwgJysnLCBQTFVTKTtcbiAgdHQoU3RhcnQsICcjJywgUE9VTkQpO1xuICB0dChTdGFydCwgJz8nLCBRVUVSWSk7XG4gIHR0KFN0YXJ0LCAnXCInLCBRVU9URSk7XG4gIHR0KFN0YXJ0LCAnLycsIFNMQVNIKTtcbiAgdHQoU3RhcnQsICc7JywgU0VNSSk7XG4gIHR0KFN0YXJ0LCAnficsIFRJTERFKTtcbiAgdHQoU3RhcnQsICdfJywgVU5ERVJTQ09SRSk7XG4gIHR0KFN0YXJ0LCAnXFxcXCcsIEJBQ0tTTEFTSCk7XG4gIHR0KFN0YXJ0LCAnXHUzMEZCJywgRlVMTFdJRFRITUlERExFRE9UKTtcbiAgY29uc3QgTnVtID0gdHIoU3RhcnQsIERJR0lULCBOVU0sIHtcbiAgICBbbnVtZXJpY106IHRydWVcbiAgfSk7XG4gIHRyKE51bSwgRElHSVQsIE51bSk7XG4gIGNvbnN0IEFzY2lpbnVtZXJpYyA9IHRyKE51bSwgQVNDSUlfTEVUVEVSLCBBU0NJSU5VTUVSSUNBTCwge1xuICAgIFthc2NpaW51bWVyaWNdOiB0cnVlXG4gIH0pO1xuICBjb25zdCBBbHBoYW51bWVyaWMgPSB0cihOdW0sIExFVFRFUiwgQUxQSEFOVU1FUklDQUwsIHtcbiAgICBbYWxwaGFudW1lcmljXTogdHJ1ZVxuICB9KTtcblxuICAvLyBTdGF0ZSB3aGljaCBlbWl0cyBhIHdvcmQgdG9rZW5cbiAgY29uc3QgV29yZCA9IHRyKFN0YXJ0LCBBU0NJSV9MRVRURVIsIFdPUkQsIHtcbiAgICBbYXNjaWldOiB0cnVlXG4gIH0pO1xuICB0cihXb3JkLCBESUdJVCwgQXNjaWludW1lcmljKTtcbiAgdHIoV29yZCwgQVNDSUlfTEVUVEVSLCBXb3JkKTtcbiAgdHIoQXNjaWludW1lcmljLCBESUdJVCwgQXNjaWludW1lcmljKTtcbiAgdHIoQXNjaWludW1lcmljLCBBU0NJSV9MRVRURVIsIEFzY2lpbnVtZXJpYyk7XG5cbiAgLy8gU2FtZSBhcyBwcmV2aW91cywgYnV0IHNwZWNpZmljIHRvIG5vbi1mc20uYXNjaWkgYWxwaGFiZXQgd29yZHNcbiAgY29uc3QgVVdvcmQgPSB0cihTdGFydCwgTEVUVEVSLCBVV09SRCwge1xuICAgIFthbHBoYV06IHRydWVcbiAgfSk7XG4gIHRyKFVXb3JkLCBBU0NJSV9MRVRURVIpOyAvLyBOb24tYWNjZXB0aW5nXG4gIHRyKFVXb3JkLCBESUdJVCwgQWxwaGFudW1lcmljKTtcbiAgdHIoVVdvcmQsIExFVFRFUiwgVVdvcmQpO1xuICB0cihBbHBoYW51bWVyaWMsIERJR0lULCBBbHBoYW51bWVyaWMpO1xuICB0cihBbHBoYW51bWVyaWMsIEFTQ0lJX0xFVFRFUik7IC8vIE5vbi1hY2NlcHRpbmdcbiAgdHIoQWxwaGFudW1lcmljLCBMRVRURVIsIEFscGhhbnVtZXJpYyk7IC8vIE5vbi1hY2NlcHRpbmdcblxuICAvLyBXaGl0ZXNwYWNlIGp1bXBzXG4gIC8vIFRva2VucyBvZiBvbmx5IG5vbi1uZXdsaW5lIHdoaXRlc3BhY2UgYXJlIGFyYml0cmFyaWx5IGxvbmdcbiAgLy8gSWYgYW55IHdoaXRlc3BhY2UgZXhjZXB0IG5ld2xpbmUsIG1vcmUgd2hpdGVzcGFjZSFcbiAgY29uc3QgTmwgPSB0dChTdGFydCwgTEYsIE5MLCB7XG4gICAgW3doaXRlc3BhY2VdOiB0cnVlXG4gIH0pO1xuICBjb25zdCBDciA9IHR0KFN0YXJ0LCBDUiwgV1MsIHtcbiAgICBbd2hpdGVzcGFjZV06IHRydWVcbiAgfSk7XG4gIGNvbnN0IFdzID0gdHIoU3RhcnQsIFNQQUNFLCBXUywge1xuICAgIFt3aGl0ZXNwYWNlXTogdHJ1ZVxuICB9KTtcbiAgdHQoU3RhcnQsIE9CSkVDVF9SRVBMQUNFTUVOVCwgV3MpO1xuICB0dChDciwgTEYsIE5sKTsgLy8gXFxyXFxuXG4gIHR0KENyLCBPQkpFQ1RfUkVQTEFDRU1FTlQsIFdzKTtcbiAgdHIoQ3IsIFNQQUNFLCBXcyk7XG4gIHR0KFdzLCBDUik7IC8vIG5vbi1hY2NlcHRpbmcgc3RhdGUgdG8gYXZvaWQgbWl4aW5nIHdoaXRlc3BhY2VzXG4gIHR0KFdzLCBMRik7IC8vIG5vbi1hY2NlcHRpbmcgc3RhdGUgdG8gYXZvaWQgbWl4aW5nIHdoaXRlc3BhY2VzXG4gIHRyKFdzLCBTUEFDRSwgV3MpO1xuICB0dChXcywgT0JKRUNUX1JFUExBQ0VNRU5ULCBXcyk7XG5cbiAgLy8gRW1vamkgdG9rZW5zLiBUaGV5IGFyZSBub3QgZ3JvdXBlZCBieSB0aGUgc2Nhbm5lciBleGNlcHQgaW4gY2FzZXMgd2hlcmUgYVxuICAvLyB6ZXJvLXdpZHRoIGpvaW5lciBpcyBwcmVzZW50XG4gIGNvbnN0IEVtb2ppID0gdHIoU3RhcnQsIEVNT0pJLCBFTU9KSSQxLCB7XG4gICAgW2Vtb2ppXTogdHJ1ZVxuICB9KTtcbiAgdHQoRW1vamksICcjJyk7IC8vIG5vIHRyYW5zaXRpb24sIGVtb2ppIHJlZ2V4IHNlZW1zIHRvIG1hdGNoICNcbiAgdHIoRW1vamksIEVNT0pJLCBFbW9qaSk7XG4gIHR0KEVtb2ppLCBFTU9KSV9WQVJJQVRJT04sIEVtb2ppKTtcbiAgLy8gdHQoU3RhcnQsIEVNT0pJX1ZBUklBVElPTiwgRW1vamkpOyAvLyBUaGlzIG9uZSBpcyBza2V0Y2h5XG5cbiAgY29uc3QgRW1vamlKb2luZXIgPSB0dChFbW9qaSwgRU1PSklfSk9JTkVSKTtcbiAgdHQoRW1vamlKb2luZXIsICcjJyk7XG4gIHRyKEVtb2ppSm9pbmVyLCBFTU9KSSwgRW1vamkpO1xuICAvLyB0dChFbW9qaUpvaW5lciwgRU1PSklfVkFSSUFUSU9OLCBFbW9qaSk7IC8vIGFsc28gc2tldGNoeVxuXG4gIC8vIEdlbmVyYXRlcyBzdGF0ZXMgZm9yIHRvcC1sZXZlbCBkb21haW5zXG4gIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG1vc3QgYWNjdXJhdGUgd2hlbiB0bGRzIGFyZSBpbiBhbHBoYWJldGljYWwgb3JkZXJcbiAgY29uc3Qgd29yZGpyID0gW1tBU0NJSV9MRVRURVIsIFdvcmRdLCBbRElHSVQsIEFzY2lpbnVtZXJpY11dO1xuICBjb25zdCB1d29yZGpyID0gW1tBU0NJSV9MRVRURVIsIG51bGxdLCBbTEVUVEVSLCBVV29yZF0sIFtESUdJVCwgQWxwaGFudW1lcmljXV07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGxkcy5sZW5ndGg7IGkrKykge1xuICAgIGZhc3R0cyhTdGFydCwgdGxkc1tpXSwgVExELCBXT1JELCB3b3JkanIpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdXRsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBmYXN0dHMoU3RhcnQsIHV0bGRzW2ldLCBVVExELCBVV09SRCwgdXdvcmRqcik7XG4gIH1cbiAgYWRkVG9Hcm91cHMoVExELCB7XG4gICAgdGxkOiB0cnVlLFxuICAgIGFzY2lpOiB0cnVlXG4gIH0sIGdyb3Vwcyk7XG4gIGFkZFRvR3JvdXBzKFVUTEQsIHtcbiAgICB1dGxkOiB0cnVlLFxuICAgIGFscGhhOiB0cnVlXG4gIH0sIGdyb3Vwcyk7XG5cbiAgLy8gQ29sbGVjdCB0aGUgc3RhdGVzIGdlbmVyYXRlZCBieSBkaWZmZXJlbnQgcHJvdG9jb2xzLiBOT1RFOiBJZiBhbnkgbmV3IFRMRHNcbiAgLy8gZ2V0IGFkZGVkIHRoYXQgYXJlIGFsc28gcHJvdG9jb2xzLCBzZXQgdGhlIHRva2VuIHRvIGJlIHRoZSBzYW1lIGFzIHRoZVxuICAvLyBwcm90b2NvbCB0byBlbnN1cmUgcGFyc2luZyB3b3JrcyBhcyBleHBlY3RlZC5cbiAgZmFzdHRzKFN0YXJ0LCAnZmlsZScsIFNDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnbWFpbHRvJywgU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdodHRwJywgU0xBU0hfU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdodHRwcycsIFNMQVNIX1NDSEVNRSwgV09SRCwgd29yZGpyKTtcbiAgZmFzdHRzKFN0YXJ0LCAnZnRwJywgU0xBU0hfU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBmYXN0dHMoU3RhcnQsICdmdHBzJywgU0xBU0hfU0NIRU1FLCBXT1JELCB3b3JkanIpO1xuICBhZGRUb0dyb3VwcyhTQ0hFTUUsIHtcbiAgICBzY2hlbWU6IHRydWUsXG4gICAgYXNjaWk6IHRydWVcbiAgfSwgZ3JvdXBzKTtcbiAgYWRkVG9Hcm91cHMoU0xBU0hfU0NIRU1FLCB7XG4gICAgc2xhc2hzY2hlbWU6IHRydWUsXG4gICAgYXNjaWk6IHRydWVcbiAgfSwgZ3JvdXBzKTtcblxuICAvLyBSZWdpc3RlciBjdXN0b20gc2NoZW1lcy4gQXNzdW1lcyBlYWNoIHNjaGVtZSBpcyBhc2NpaW51bWVyaWMgd2l0aCBoeXBoZW5zXG4gIGN1c3RvbVNjaGVtZXMgPSBjdXN0b21TY2hlbWVzLnNvcnQoKGEsIGIpID0+IGFbMF0gPiBiWzBdID8gMSA6IC0xKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXN0b21TY2hlbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2NoID0gY3VzdG9tU2NoZW1lc1tpXVswXTtcbiAgICBjb25zdCBvcHRpb25hbFNsYXNoU2xhc2ggPSBjdXN0b21TY2hlbWVzW2ldWzFdO1xuICAgIGNvbnN0IGZsYWdzID0gb3B0aW9uYWxTbGFzaFNsYXNoID8ge1xuICAgICAgW3NjaGVtZV06IHRydWVcbiAgICB9IDoge1xuICAgICAgW3NsYXNoc2NoZW1lXTogdHJ1ZVxuICAgIH07XG4gICAgaWYgKHNjaC5pbmRleE9mKCctJykgPj0gMCkge1xuICAgICAgZmxhZ3NbZG9tYWluXSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghQVNDSUlfTEVUVEVSLnRlc3Qoc2NoKSkge1xuICAgICAgZmxhZ3NbbnVtZXJpY10gPSB0cnVlOyAvLyBudW1iZXJzIG9ubHlcbiAgICB9IGVsc2UgaWYgKERJR0lULnRlc3Qoc2NoKSkge1xuICAgICAgZmxhZ3NbYXNjaWludW1lcmljXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYWdzW2FzY2lpXSA9IHRydWU7XG4gICAgfVxuICAgIHRzKFN0YXJ0LCBzY2gsIHNjaCwgZmxhZ3MpO1xuICB9XG5cbiAgLy8gTG9jYWxob3N0IHRva2VuXG4gIHRzKFN0YXJ0LCAnbG9jYWxob3N0JywgTE9DQUxIT1NULCB7XG4gICAgYXNjaWk6IHRydWVcbiAgfSk7XG5cbiAgLy8gU2V0IGRlZmF1bHQgdHJhbnNpdGlvbiBmb3Igc3RhcnQgc3RhdGUgKHNvbWUgc3ltYm9sKVxuICBTdGFydC5qZCA9IG5ldyBTdGF0ZShTWU0pO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBTdGFydCxcbiAgICB0b2tlbnM6IGFzc2lnbih7XG4gICAgICBncm91cHNcbiAgICB9LCB0aylcbiAgfTtcbn1cblxuLyoqXG5cdEdpdmVuIGEgc3RyaW5nLCByZXR1cm5zIGFuIGFycmF5IG9mIFRPS0VOIGluc3RhbmNlcyByZXByZXNlbnRpbmcgdGhlXG5cdGNvbXBvc2l0aW9uIG9mIHRoYXQgc3RyaW5nLlxuXG5cdEBtZXRob2QgcnVuXG5cdEBwYXJhbSB7U3RhdGU8c3RyaW5nPn0gc3RhcnQgc2Nhbm5lciBzdGFydGluZyBzdGF0ZVxuXHRAcGFyYW0ge3N0cmluZ30gc3RyIGlucHV0IHN0cmluZyB0byBzY2FuXG5cdEByZXR1cm4ge1Rva2VuW119IGxpc3Qgb2YgdG9rZW5zLCBlYWNoIHdpdGggYSB0eXBlIGFuZCB2YWx1ZVxuKi9cbmZ1bmN0aW9uIHJ1biQxKHN0YXJ0LCBzdHIpIHtcbiAgLy8gU3RhdGUgbWFjaGluZSBpcyBub3QgY2FzZSBzZW5zaXRpdmUsIHNvIGlucHV0IGlzIHRva2VuaXplZCBpbiBsb3dlcmNhc2VkXG4gIC8vIGZvcm0gKHN0aWxsIHJldHVybnMgcmVndWxhciBjYXNlKS4gVXNlcyBzZWxlY3RpdmUgYHRvTG93ZXJDYXNlYCBiZWNhdXNlXG4gIC8vIGxvd2VyY2FzaW5nIHRoZSBlbnRpcmUgc3RyaW5nIGNhdXNlcyB0aGUgbGVuZ3RoIGFuZCBjaGFyYWN0ZXIgcG9zaXRpb24gdG9cbiAgLy8gdmFyeSBpbiBzb21lIG5vbi1FbmdsaXNoIHN0cmluZ3Mgd2l0aCBWOC1iYXNlZCBydW50aW1lcy5cbiAgY29uc3QgaXRlcmFibGUgPSBzdHJpbmdUb0FycmF5KHN0ci5yZXBsYWNlKC9bQS1aXS9nLCBjID0+IGMudG9Mb3dlckNhc2UoKSkpO1xuICBjb25zdCBjaGFyQ291bnQgPSBpdGVyYWJsZS5sZW5ndGg7IC8vIDw9IGxlbiBpZiB0aGVyZSBhcmUgZW1vamlzLCBldGNcbiAgY29uc3QgdG9rZW5zID0gW107IC8vIHJldHVybiB2YWx1ZVxuXG4gIC8vIGN1cnNvciB0aHJvdWdoIHRoZSBzdHJpbmcgaXRzZWxmLCBhY2NvdW50aW5nIGZvciBjaGFyYWN0ZXJzIHRoYXQgaGF2ZVxuICAvLyB3aWR0aCB3aXRoIGxlbmd0aCAyIHN1Y2ggYXMgZW1vamlzXG4gIGxldCBjdXJzb3IgPSAwO1xuXG4gIC8vIEN1cnNvciB0aHJvdWdoIHRoZSBhcnJheS1yZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RyaW5nXG4gIGxldCBjaGFyQ3Vyc29yID0gMDtcblxuICAvLyBUb2tlbml6ZSB0aGUgc3RyaW5nXG4gIHdoaWxlIChjaGFyQ3Vyc29yIDwgY2hhckNvdW50KSB7XG4gICAgbGV0IHN0YXRlID0gc3RhcnQ7XG4gICAgbGV0IG5leHRTdGF0ZSA9IG51bGw7XG4gICAgbGV0IHRva2VuTGVuZ3RoID0gMDtcbiAgICBsZXQgbGF0ZXN0QWNjZXB0aW5nID0gbnVsbDtcbiAgICBsZXQgc2luY2VBY2NlcHRzID0gLTE7XG4gICAgbGV0IGNoYXJzU2luY2VBY2NlcHRzID0gLTE7XG4gICAgd2hpbGUgKGNoYXJDdXJzb3IgPCBjaGFyQ291bnQgJiYgKG5leHRTdGF0ZSA9IHN0YXRlLmdvKGl0ZXJhYmxlW2NoYXJDdXJzb3JdKSkpIHtcbiAgICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgICBpZiAoc3RhdGUuYWNjZXB0cygpKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cyA9IDA7XG4gICAgICAgIGNoYXJzU2luY2VBY2NlcHRzID0gMDtcbiAgICAgICAgbGF0ZXN0QWNjZXB0aW5nID0gc3RhdGU7XG4gICAgICB9IGVsc2UgaWYgKHNpbmNlQWNjZXB0cyA+PSAwKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cyArPSBpdGVyYWJsZVtjaGFyQ3Vyc29yXS5sZW5ndGg7XG4gICAgICAgIGNoYXJzU2luY2VBY2NlcHRzKys7XG4gICAgICB9XG4gICAgICB0b2tlbkxlbmd0aCArPSBpdGVyYWJsZVtjaGFyQ3Vyc29yXS5sZW5ndGg7XG4gICAgICBjdXJzb3IgKz0gaXRlcmFibGVbY2hhckN1cnNvcl0ubGVuZ3RoO1xuICAgICAgY2hhckN1cnNvcisrO1xuICAgIH1cblxuICAgIC8vIFJvbGwgYmFjayB0byB0aGUgbGF0ZXN0IGFjY2VwdGluZyBzdGF0ZVxuICAgIGN1cnNvciAtPSBzaW5jZUFjY2VwdHM7XG4gICAgY2hhckN1cnNvciAtPSBjaGFyc1NpbmNlQWNjZXB0cztcbiAgICB0b2tlbkxlbmd0aCAtPSBzaW5jZUFjY2VwdHM7XG5cbiAgICAvLyBObyBtb3JlIGp1bXBzLCBqdXN0IG1ha2UgYSBuZXcgdG9rZW4gZnJvbSB0aGUgbGFzdCBhY2NlcHRpbmcgb25lXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgdDogbGF0ZXN0QWNjZXB0aW5nLnQsXG4gICAgICAvLyB0b2tlbiB0eXBlL25hbWVcbiAgICAgIHY6IHN0ci5zbGljZShjdXJzb3IgLSB0b2tlbkxlbmd0aCwgY3Vyc29yKSxcbiAgICAgIC8vIHN0cmluZyB2YWx1ZVxuICAgICAgczogY3Vyc29yIC0gdG9rZW5MZW5ndGgsXG4gICAgICAvLyBzdGFydCBpbmRleFxuICAgICAgZTogY3Vyc29yIC8vIGVuZCBpbmRleCAoZXhjbHVkaW5nKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFN0cmluZyB0byBhbiBBcnJheSBvZiBjaGFyYWN0ZXJzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXQgc29tZVxuICogY2hhcmFjdGVycyBsaWtlIGVtb2ppcyB0YWtlIHVwIHR3byBzdHJpbmcgaW5kZXhlcy5cbiAqXG4gKiBBZGFwdGVkIGZyb20gY29yZS1qcyAoTUlUIGxpY2Vuc2UpXG4gKiBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iLzJkNjljZjVmOTlhYjNlYTM0NjNjMzk1ZGY4MWU1YTE1YjY4ZjQ5ZDkvcGFja2FnZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qc1xuICpcbiAqIEBmdW5jdGlvbiBzdHJpbmdUb0FycmF5XG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBsZW4pIHtcbiAgICBsZXQgZmlyc3QgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgbGV0IHNlY29uZDtcbiAgICBsZXQgY2hhciA9IGZpcnN0IDwgMHhkODAwIHx8IGZpcnN0ID4gMHhkYmZmIHx8IGluZGV4ICsgMSA9PT0gbGVuIHx8IChzZWNvbmQgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpKSA8IDB4ZGMwMCB8fCBzZWNvbmQgPiAweGRmZmYgPyBzdHJbaW5kZXhdIC8vIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICA6IHN0ci5zbGljZShpbmRleCwgaW5kZXggKyAyKTsgLy8gdHdvLWluZGV4IGNoYXJhY3RlcnNcbiAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICBpbmRleCArPSBjaGFyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZhc3QgdmVyc2lvbiBvZiB0cyBmdW5jdGlvbiBmb3Igd2hlbiB0cmFuc2l0aW9uIGRlZmF1bHRzIGFyZSB3ZWxsIGtub3duXG4gKiBAcGFyYW0ge1N0YXRlPHN0cmluZz59IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0XG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdHRcbiAqIEBwYXJhbSB7W1JlZ0V4cCwgU3RhdGU8c3RyaW5nPl1bXX0ganJcbiAqIEByZXR1cm5zIHtTdGF0ZTxzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBmYXN0dHMoc3RhdGUsIGlucHV0LCB0LCBkZWZhdWx0dCwganIpIHtcbiAgbGV0IG5leHQ7XG4gIGNvbnN0IGxlbiA9IGlucHV0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgaWYgKHN0YXRlLmpbY2hhcl0pIHtcbiAgICAgIG5leHQgPSBzdGF0ZS5qW2NoYXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0ID0gbmV3IFN0YXRlKGRlZmF1bHR0KTtcbiAgICAgIG5leHQuanIgPSBqci5zbGljZSgpO1xuICAgICAgc3RhdGUualtjaGFyXSA9IG5leHQ7XG4gICAgfVxuICAgIHN0YXRlID0gbmV4dDtcbiAgfVxuICBuZXh0ID0gbmV3IFN0YXRlKHQpO1xuICBuZXh0LmpyID0ganIuc2xpY2UoKTtcbiAgc3RhdGUualtpbnB1dFtsZW4gLSAxXV0gPSBuZXh0O1xuICByZXR1cm4gbmV4dDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBUb3AtTGV2ZWwgRG9tYWluIG5hbWVzIGVuY29kZWQgaW4gdXBkYXRlLXRsZHMuanMgYmFja1xuICogaW50byBhIGxpc3Qgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSB7c3RyfSBlbmNvZGVkIGVuY29kZWQgVExEcyBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJbXX0gb3JpZ2luYWwgVExEcyBsaXN0XG4gKi9cbmZ1bmN0aW9uIGRlY29kZVRsZHMoZW5jb2RlZCkge1xuICBjb25zdCB3b3JkcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxldCBkaWdpdHMgPSAnMDEyMzQ1Njc4OSc7XG4gIHdoaWxlIChpIDwgZW5jb2RlZC5sZW5ndGgpIHtcbiAgICBsZXQgcG9wRGlnaXRDb3VudCA9IDA7XG4gICAgd2hpbGUgKGRpZ2l0cy5pbmRleE9mKGVuY29kZWRbaSArIHBvcERpZ2l0Q291bnRdKSA+PSAwKSB7XG4gICAgICBwb3BEaWdpdENvdW50Kys7IC8vIGVuY291bnRlcmVkIHNvbWUgZGlnaXRzLCBoYXZlIHRvIHBvcCB0byBnbyBvbmUgbGV2ZWwgdXAgdHJpZVxuICAgIH1cbiAgICBpZiAocG9wRGlnaXRDb3VudCA+IDApIHtcbiAgICAgIHdvcmRzLnB1c2goc3RhY2suam9pbignJykpOyAvLyB3aGF0ZXZlciBwcmVjZWRlZCB0aGUgcG9wIGRpZ2l0cyBtdXN0IGJlIGEgd29yZFxuICAgICAgZm9yIChsZXQgcG9wQ291bnQgPSBwYXJzZUludChlbmNvZGVkLnN1YnN0cmluZyhpLCBpICsgcG9wRGlnaXRDb3VudCksIDEwKTsgcG9wQ291bnQgPiAwOyBwb3BDb3VudC0tKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgICAgaSArPSBwb3BEaWdpdENvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5wdXNoKGVuY29kZWRbaV0pOyAvLyBkcm9wIGRvd24gYSBsZXZlbCBpbnRvIHRoZSB0cmllXG4gICAgICBpKys7XG4gICAgfVxuICB9XG4gIHJldHVybiB3b3Jkcztcbn1cblxuLyoqXG4gKiBBbiBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgaXMgYSB2YWxpZCBET00gRXZlbnQgTmFtZSBzdWNoIGFzIGBjbGlja2Agb3IgYGZvY3VzYFxuICogYW5kIGVhY2ggdmFsdWUgaXMgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvbi5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudCNldmVudHNcbiAqIEB0eXBlZGVmIHs/eyBbZXZlbnQ6IHN0cmluZ106IEZ1bmN0aW9uIH19IEV2ZW50TGlzdGVuZXJzXG4gKi9cblxuLyoqXG4gKiBBbGwgZm9ybWF0dGVkIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gcmVuZGVyIGEgbGluaywgaW5jbHVkaW5nIGB0YWdOYW1lYCxcbiAqIGBhdHRyaWJ1dGVzYCwgYGNvbnRlbnRgIGFuZCBgZXZlbnRMaXN0ZW5lcnNgLlxuICogQHR5cGVkZWYge3sgdGFnTmFtZTogYW55LCBhdHRyaWJ1dGVzOiB7W2F0dHI6IHN0cmluZ106IGFueX0sIGNvbnRlbnQ6IHN0cmluZyxcbiAqIGV2ZW50TGlzdGVuZXJzOiBFdmVudExpc3RlbmVycyB9fSBJbnRlcm1lZGlhdGVSZXByZXNlbnRhdGlvblxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYW4gb2JqZWN0IGRlc2NyaWJlZCBieSB0aGUgdGVtcGxhdGUgdHlwZSBgT2Agb3IgYSBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdmFsdWUgKHVzdWFsbHkgdGhlIGxpbmsncyBocmVmIGF0dHJpYnV0ZSksIHRoZVxuICogbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikgYW5kIGFuIGludGVybmFsIHRva2VuIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgbGluay4gSXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgdGhlIHRlbXBsYXRlIHR5cGUgYE9gXG4gKiBAdGVtcGxhdGUgT1xuICogQHR5cGVkZWYge08gfCAoKHZhbHVlOiBzdHJpbmcsIHR5cGU6IHN0cmluZywgdG9rZW46IE11bHRpVG9rZW4pID0+IE8pfSBPcHRPYmpcbiAqL1xuXG4vKipcbiAqIFNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gZGVzY3JpYmVkIGJ5IHRlbXBsYXRlIHR5cGUgYEZgIG9yIGFuIG9iamVjdC5cbiAqXG4gKiBFYWNoIGtleSBpbiB0aGUgb2JqZWN0IHNob3VsZCBiZSBhIGxpbmsgdHlwZSAoYCd1cmwnYCwgYCdoYXNodGFnYCcsIGV0Yy4pLiBFYWNoXG4gKiB2YWx1ZSBzaG91bGQgYmUgYSBmdW5jdGlvbiB3aXRoIHRlbXBsYXRlIHR5cGUgYEZgIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlXG4gKiBjb3JyZXNwb25kaW5nIGxpbmsgdHlwZSBpcyBlbmNvdW50ZXJlZC5cbiAqIEB0ZW1wbGF0ZSBGXG4gKiBAdHlwZWRlZiB7RiB8IHsgW3R5cGU6IHN0cmluZ106IEZ9fSBPcHRGblxuICovXG5cbi8qKlxuICogU3BlY2lmeSBlaXRoZXIgYSB2YWx1ZSB3aXRoIHRlbXBsYXRlIHR5cGUgYFZgLCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgVmAgb3JcbiAqIGFuIG9iamVjdCB3aGVyZSBlYWNoIHZhbHVlIHJlc29sdmVzIHRvIGBWYC5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzdHJpbmcgdmFsdWUgKHVzdWFsbHkgdGhlIGxpbmsncyBocmVmIGF0dHJpYnV0ZSksIHRoZVxuICogbGluayB0eXBlIChgJ3VybCdgLCBgJ2hhc2h0YWdgJywgZXRjLikgYW5kIGFuIGludGVybmFsIHRva2VuIHJlcHJlc2VudGF0aW9uXG4gKiBvZiB0aGUgbGluay4gSXQgc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgdGhlIHRlbXBsYXRlIHR5cGUgYFZgXG4gKlxuICogRm9yIHRoZSBvYmplY3QsIGVhY2gga2V5IHNob3VsZCBiZSBhIGxpbmsgdHlwZSAoYCd1cmwnYCwgYCdoYXNodGFnYCcsIGV0Yy4pLlxuICogRWFjaCB2YWx1ZSBzaG91bGQgZWl0aGVyIGhhdmUgdHlwZSBgVmAgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgVi4gVGhpc1xuICogZnVuY3Rpb24gc2ltaWxhcmx5IHRha2VzIGEgc3RyaW5nIHZhbHVlIGFuZCBhIHRva2VuLlxuICpcbiAqIEV4YW1wbGUgdmFsaWQgdHlwZXMgZm9yIGBPcHQ8c3RyaW5nPmA6XG4gKlxuICogYGBganNcbiAqICdoZWxsbydcbiAqICh2YWx1ZSwgdHlwZSwgdG9rZW4pID0+ICd3b3JsZCdcbiAqIHsgdXJsOiAnaGVsbG8nLCBlbWFpbDogKHZhbHVlLCB0b2tlbikgPT4gJ3dvcmxkJ31cbiAqIGBgYFxuICogQHRlbXBsYXRlIFZcbiAqIEB0eXBlZGVmIHtWIHwgKCh2YWx1ZTogc3RyaW5nLCB0eXBlOiBzdHJpbmcsIHRva2VuOiBNdWx0aVRva2VuKSA9PiBWKSB8IHsgW3R5cGU6IHN0cmluZ106IFYgfCAoKHZhbHVlOiBzdHJpbmcsIHRva2VuOiBNdWx0aVRva2VuKSA9PiBWKSB9fSBPcHRcbiAqL1xuXG4vKipcbiAqIFNlZSBhdmFpbGFibGUgb3B0aW9uczogaHR0cHM6Ly9saW5raWZ5LmpzLm9yZy9kb2NzL29wdGlvbnMuaHRtbFxuICogQHR5cGVkZWYge3tcbiAqIFx0ZGVmYXVsdFByb3RvY29sPzogc3RyaW5nLFxuICogIGV2ZW50cz86IE9wdE9iajxFdmVudExpc3RlbmVycz4sXG4gKiBcdGZvcm1hdD86IE9wdDxzdHJpbmc+LFxuICogXHRmb3JtYXRIcmVmPzogT3B0PHN0cmluZz4sXG4gKiBcdG5sMmJyPzogYm9vbGVhbixcbiAqIFx0dGFnTmFtZT86IE9wdDxhbnk+LFxuICogXHR0YXJnZXQ/OiBPcHQ8c3RyaW5nPixcbiAqIFx0cmVsPzogT3B0PHN0cmluZz4sXG4gKiBcdHZhbGlkYXRlPzogT3B0PGJvb2xlYW4+LFxuICogXHR0cnVuY2F0ZT86IE9wdDxudW1iZXI+LFxuICogXHRjbGFzc05hbWU/OiBPcHQ8c3RyaW5nPixcbiAqIFx0YXR0cmlidXRlcz86IE9wdE9iajwoeyBbYXR0cjogc3RyaW5nXTogYW55IH0pPixcbiAqICBpZ25vcmVUYWdzPzogc3RyaW5nW10sXG4gKiBcdHJlbmRlcj86IE9wdEZuPCgoaXI6IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uKSA9PiBhbnkpPlxuICogfX0gT3B0c1xuICovXG5cbi8qKlxuICogQHR5cGUgUmVxdWlyZWQ8T3B0cz5cbiAqL1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gIGRlZmF1bHRQcm90b2NvbDogJ2h0dHAnLFxuICBldmVudHM6IG51bGwsXG4gIGZvcm1hdDogbm9vcCxcbiAgZm9ybWF0SHJlZjogbm9vcCxcbiAgbmwyYnI6IGZhbHNlLFxuICB0YWdOYW1lOiAnYScsXG4gIHRhcmdldDogbnVsbCxcbiAgcmVsOiBudWxsLFxuICB2YWxpZGF0ZTogdHJ1ZSxcbiAgdHJ1bmNhdGU6IEluZmluaXR5LFxuICBjbGFzc05hbWU6IG51bGwsXG4gIGF0dHJpYnV0ZXM6IG51bGwsXG4gIGlnbm9yZVRhZ3M6IFtdLFxuICByZW5kZXI6IG51bGxcbn07XG5cbi8qKlxuICogVXRpbGl0eSBjbGFzcyBmb3IgbGlua2lmeSBpbnRlcmZhY2VzIHRvIGFwcGx5IHNwZWNpZmllZFxuICoge0BsaW5rIE9wdHMgZm9ybWF0dGluZyBhbmQgcmVuZGVyaW5nIG9wdGlvbnN9LlxuICpcbiAqIEBwYXJhbSB7T3B0cyB8IE9wdGlvbnN9IFtvcHRzXSBPcHRpb24gdmFsdWUgb3ZlcnJpZGVzLlxuICogQHBhcmFtIHsoaXI6IEludGVybWVkaWF0ZVJlcHJlc2VudGF0aW9uKSA9PiBhbnl9IFtkZWZhdWx0UmVuZGVyXSAoRm9yXG4gKiAgIGludGVybmFsIHVzZSkgZGVmYXVsdCByZW5kZXIgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIGhvdyB0byBnZW5lcmF0ZSBhblxuICogICBIVE1MIGVsZW1lbnQgYmFzZWQgb24gYSBsaW5rIHRva2VuJ3MgZGVyaXZlZCB0YWdOYW1lLCBhdHRyaWJ1dGVzIGFuZCBIVE1MLlxuICogICBTaW1pbGFyIHRvIHJlbmRlciBvcHRpb25cbiAqL1xuZnVuY3Rpb24gT3B0aW9ucyhvcHRzLCBkZWZhdWx0UmVuZGVyID0gbnVsbCkge1xuICBsZXQgbyA9IGFzc2lnbih7fSwgZGVmYXVsdHMpO1xuICBpZiAob3B0cykge1xuICAgIG8gPSBhc3NpZ24obywgb3B0cyBpbnN0YW5jZW9mIE9wdGlvbnMgPyBvcHRzLm8gOiBvcHRzKTtcbiAgfVxuXG4gIC8vIEVuc3VyZSBhbGwgaWdub3JlZCB0YWdzIGFyZSB1cHBlcmNhc2VcbiAgY29uc3QgaWdub3JlZFRhZ3MgPSBvLmlnbm9yZVRhZ3M7XG4gIGNvbnN0IHVwcGVyY2FzZUlnbm9yZWRUYWdzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWdub3JlZFRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB1cHBlcmNhc2VJZ25vcmVkVGFncy5wdXNoKGlnbm9yZWRUYWdzW2ldLnRvVXBwZXJDYXNlKCkpO1xuICB9XG4gIC8qKiBAcHJvdGVjdGVkICovXG4gIHRoaXMubyA9IG87XG4gIGlmIChkZWZhdWx0UmVuZGVyKSB7XG4gICAgdGhpcy5kZWZhdWx0UmVuZGVyID0gZGVmYXVsdFJlbmRlcjtcbiAgfVxuICB0aGlzLmlnbm9yZVRhZ3MgPSB1cHBlcmNhc2VJZ25vcmVkVGFncztcbn1cbk9wdGlvbnMucHJvdG90eXBlID0ge1xuICBvOiBkZWZhdWx0cyxcbiAgLyoqXG4gICAqIEB0eXBlIHN0cmluZ1tdXG4gICAqL1xuICBpZ25vcmVUYWdzOiBbXSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7SW50ZXJtZWRpYXRlUmVwcmVzZW50YXRpb259IGlyXG4gICAqIEByZXR1cm5zIHthbnl9XG4gICAqL1xuICBkZWZhdWx0UmVuZGVyKGlyKSB7XG4gICAgcmV0dXJuIGlyO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGJhc2VkIG9uIHdoZXRoZXIgYSB0b2tlbiBzaG91bGQgYmUgZGlzcGxheWVkIGFzIGFcbiAgICogbGluayBiYXNlZCBvbiB0aGUgdXNlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge011bHRpVG9rZW59IHRva2VuXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2hlY2sodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ3ZhbGlkYXRlJywgdG9rZW4udG9TdHJpbmcoKSwgdG9rZW4pO1xuICB9LFxuICAvLyBQcml2YXRlIG1ldGhvZHNcblxuICAvKipcbiAgICogUmVzb2x2ZSBhbiBvcHRpb24ncyB2YWx1ZSBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBhbmQgdGhlIGdpdmVuXG4gICAqIHBhcmFtcy4gSWYgb3BlcmF0b3IgYW5kIHRva2VuIGFyZSBzcGVjaWZpZWQgYW5kIHRoZSB0YXJnZXQgb3B0aW9uIGlzXG4gICAqIGNhbGxhYmxlLCBhdXRvbWF0aWNhbGx5IGNhbGxzIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudC5cbiAgICogQHRlbXBsYXRlIHtrZXlvZiBPcHRzfSBLXG4gICAqIEBwYXJhbSB7S30ga2V5IE5hbWUgb2Ygb3B0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wZXJhdG9yXSB3aWxsIGJlIHBhc3NlZCB0byB0aGUgdGFyZ2V0IG9wdGlvbiBpZiBpdCdzIGFcbiAgICogZnVuY3Rpb24uIElmIG5vdCBzcGVjaWZpZWQsIFJBVyBmdW5jdGlvbiB2YWx1ZSBnZXRzIHJldHVybmVkXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gW3Rva2VuXSBUaGUgdG9rZW4gZnJvbSBsaW5raWZ5LnRva2VuaXplXG4gICAqIEByZXR1cm5zIHtPcHRzW0tdIHwgYW55fVxuICAgKi9cbiAgZ2V0KGtleSwgb3BlcmF0b3IsIHRva2VuKSB7XG4gICAgY29uc3QgaXNDYWxsYWJsZSA9IG9wZXJhdG9yICE9IG51bGw7XG4gICAgbGV0IG9wdGlvbiA9IHRoaXMub1trZXldO1xuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICByZXR1cm4gb3B0aW9uO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbiA9IHRva2VuLnQgaW4gb3B0aW9uID8gb3B0aW9uW3Rva2VuLnRdIDogZGVmYXVsdHNba2V5XTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnZnVuY3Rpb24nICYmIGlzQ2FsbGFibGUpIHtcbiAgICAgICAgb3B0aW9uID0gb3B0aW9uKG9wZXJhdG9yLCB0b2tlbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnZnVuY3Rpb24nICYmIGlzQ2FsbGFibGUpIHtcbiAgICAgIG9wdGlvbiA9IG9wdGlvbihvcGVyYXRvciwgdG9rZW4udCwgdG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9uO1xuICB9LFxuICAvKipcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBPcHRzfSBMXG4gICAqIEBwYXJhbSB7TH0ga2V5IE5hbWUgb2Ygb3B0aW9ucyBvYmplY3QgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3BlcmF0b3JdXG4gICAqIEBwYXJhbSB7TXVsdGlUb2tlbn0gW3Rva2VuXVxuICAgKiBAcmV0dXJucyB7T3B0c1tMXSB8IGFueX1cbiAgICovXG4gIGdldE9iaihrZXksIG9wZXJhdG9yLCB0b2tlbikge1xuICAgIGxldCBvYmogPSB0aGlzLm9ba2V5XTtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyAmJiBvcGVyYXRvciAhPSBudWxsKSB7XG4gICAgICBvYmogPSBvYmoob3BlcmF0b3IsIHRva2VuLnQsIHRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGdpdmVuIHRva2VuIHRvIGEgcmVuZGVyZWQgZWxlbWVudCB0aGF0IG1heSBiZSBhZGRlZCB0byB0aGVcbiAgICogY2FsbGluZy1pbnRlcmZhY2UncyBET01cbiAgICogQHBhcmFtIHtNdWx0aVRva2VufSB0b2tlbiBUb2tlbiB0byByZW5kZXIgdG8gYW4gSFRNTCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHthbnl9IFJlbmRlciByZXN1bHQ7IGUuZy4sIEhUTUwgc3RyaW5nLCBET00gZWxlbWVudCwgUmVhY3RcbiAgICogICBDb21wb25lbnQsIGV0Yy5cbiAgICovXG4gIHJlbmRlcih0b2tlbikge1xuICAgIGNvbnN0IGlyID0gdG9rZW4ucmVuZGVyKHRoaXMpOyAvLyBpbnRlcm1lZGlhdGUgcmVwcmVzZW50YXRpb25cbiAgICBjb25zdCByZW5kZXJGbiA9IHRoaXMuZ2V0KCdyZW5kZXInLCBudWxsLCB0b2tlbikgfHwgdGhpcy5kZWZhdWx0UmVuZGVyO1xuICAgIHJldHVybiByZW5kZXJGbihpciwgdG9rZW4udCwgdG9rZW4pO1xuICB9XG59O1xuZnVuY3Rpb24gbm9vcCh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn1cblxudmFyIG9wdGlvbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0T3B0aW9uczogT3B0aW9ucyxcblx0YXNzaWduOiBhc3NpZ24sXG5cdGRlZmF1bHRzOiBkZWZhdWx0c1xufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0TXVsdGktVG9rZW5zXG5cdFRva2VucyBjb21wb3NlZCBvZiBhcnJheXMgb2YgVGV4dFRva2Vuc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gTXVsdGlUb2tlbih2YWx1ZSwgdG9rZW5zKSB7XG4gIHRoaXMudCA9ICd0b2tlbic7XG4gIHRoaXMudiA9IHZhbHVlO1xuICB0aGlzLnRrID0gdG9rZW5zO1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHVzZWQgZm9yIG1hbnVmYWN0dXJpbmcgdG9rZW5zIG9mIHRleHQgdG9rZW5zLiBUaGF0IGlzIHJhdGhlclxuICogdGhhbiB0aGUgdmFsdWUgZm9yIGEgdG9rZW4gYmVpbmcgYSBzbWFsbCBzdHJpbmcgb2YgdGV4dCwgaXQncyB2YWx1ZSBhbiBhcnJheVxuICogb2YgdGV4dCB0b2tlbnMuXG4gKlxuICogVXNlZCBmb3IgZ3JvdXBpbmcgdG9nZXRoZXIgVVJMcywgZW1haWxzLCBoYXNodGFncywgYW5kIG90aGVyIHBvdGVudGlhbFxuICogY3JlYXRpb25zLlxuICogQGNsYXNzIE11bHRpVG9rZW5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdlxuICogQHByb3BlcnR5IHtUb2tlbltdfSB0a1xuICogQGFic3RyYWN0XG4gKi9cbk11bHRpVG9rZW4ucHJvdG90eXBlID0ge1xuICBpc0xpbms6IGZhbHNlLFxuICAvKipcbiAgICogUmV0dXJuIHRoZSBzdHJpbmcgdGhpcyB0b2tlbiByZXByZXNlbnRzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy52O1xuICB9LFxuICAvKipcbiAgICogV2hhdCBzaG91bGQgdGhlIHZhbHVlIGZvciB0aGlzIHRva2VuIGJlIGluIHRoZSBgaHJlZmAgSFRNTCBhdHRyaWJ1dGU/XG4gICAqIFJldHVybnMgdGhlIGAudG9TdHJpbmdgIHZhbHVlIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NoZW1lXVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0hyZWYoc2NoZW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBGb3JtYXR0aW5nIG9wdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHRvRm9ybWF0dGVkU3RyaW5nKG9wdGlvbnMpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgdHJ1bmNhdGUgPSBvcHRpb25zLmdldCgndHJ1bmNhdGUnLCB2YWwsIHRoaXMpO1xuICAgIGNvbnN0IGZvcm1hdHRlZCA9IG9wdGlvbnMuZ2V0KCdmb3JtYXQnLCB2YWwsIHRoaXMpO1xuICAgIHJldHVybiB0cnVuY2F0ZSAmJiBmb3JtYXR0ZWQubGVuZ3RoID4gdHJ1bmNhdGUgPyBmb3JtYXR0ZWQuc3Vic3RyaW5nKDAsIHRydW5jYXRlKSArICdcdTIwMjYnIDogZm9ybWF0dGVkO1xuICB9LFxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0b0Zvcm1hdHRlZEhyZWYob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmdldCgnZm9ybWF0SHJlZicsIHRoaXMudG9IcmVmKG9wdGlvbnMuZ2V0KCdkZWZhdWx0UHJvdG9jb2wnKSksIHRoaXMpO1xuICB9LFxuICAvKipcbiAgICogVGhlIHN0YXJ0IGluZGV4IG9mIHRoaXMgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhcnRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy50a1swXS5zO1xuICB9LFxuICAvKipcbiAgICogVGhlIGVuZCBpbmRleCBvZiB0aGlzIHRva2VuIGluIHRoZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmcgKHVwIHRvIHRoaXNcbiAgICogaW5kZXggYnV0IG5vdCBpbmNsdWRpbmcgaXQpXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBlbmRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy50a1t0aGlzLnRrLmxlbmd0aCAtIDFdLmU7XG4gIH0sXG4gIC8qKlxuICBcdFJldHVybnMgYW4gb2JqZWN0ICBvZiByZWxldmFudCB2YWx1ZXMgZm9yIHRoaXMgdG9rZW4sIHdoaWNoIGluY2x1ZGVzIGtleXNcbiAgXHQqIHR5cGUgLSBLaW5kIG9mIHRva2VuICgndXJsJywgJ2VtYWlsJywgZXRjLilcbiAgXHQqIHZhbHVlIC0gT3JpZ2luYWwgdGV4dFxuICBcdCogaHJlZiAtIFRoZSB2YWx1ZSB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgYW5jaG9yIHRhZydzIGhyZWZcbiAgXHRcdGF0dHJpYnV0ZVxuICBcdFx0QG1ldGhvZCB0b09iamVjdFxuICBcdEBwYXJhbSB7c3RyaW5nfSBbcHJvdG9jb2xdIGAnaHR0cCdgIGJ5IGRlZmF1bHRcbiAgKi9cbiAgdG9PYmplY3QocHJvdG9jb2wgPSBkZWZhdWx0cy5kZWZhdWx0UHJvdG9jb2wpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy50LFxuICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKSxcbiAgICAgIGlzTGluazogdGhpcy5pc0xpbmssXG4gICAgICBocmVmOiB0aGlzLnRvSHJlZihwcm90b2NvbCksXG4gICAgICBzdGFydDogdGhpcy5zdGFydEluZGV4KCksXG4gICAgICBlbmQ6IHRoaXMuZW5kSW5kZXgoKVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgRm9ybWF0dGluZyBvcHRpb25cbiAgICovXG4gIHRvRm9ybWF0dGVkT2JqZWN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogdGhpcy50LFxuICAgICAgdmFsdWU6IHRoaXMudG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucyksXG4gICAgICBpc0xpbms6IHRoaXMuaXNMaW5rLFxuICAgICAgaHJlZjogdGhpcy50b0Zvcm1hdHRlZEhyZWYob3B0aW9ucyksXG4gICAgICBzdGFydDogdGhpcy5zdGFydEluZGV4KCksXG4gICAgICBlbmQ6IHRoaXMuZW5kSW5kZXgoKVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgdG9rZW4gc2hvdWxkIGJlIHJlbmRlcmVkIGFzIGEgbGluayBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdmFsaWRhdGUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmdldCgndmFsaWRhdGUnLCB0aGlzLnRvU3RyaW5nKCksIHRoaXMpO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJuIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgaG93IHRoaXMgbGluayBzaG91bGQgYmUgcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBGb3JtYXR0aW5uZyBvcHRpb25zXG4gICAqL1xuICByZW5kZXIob3B0aW9ucykge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcztcbiAgICBjb25zdCBocmVmID0gdGhpcy50b0hyZWYob3B0aW9ucy5nZXQoJ2RlZmF1bHRQcm90b2NvbCcpKTtcbiAgICBjb25zdCBmb3JtYXR0ZWRIcmVmID0gb3B0aW9ucy5nZXQoJ2Zvcm1hdEhyZWYnLCBocmVmLCB0aGlzKTtcbiAgICBjb25zdCB0YWdOYW1lID0gb3B0aW9ucy5nZXQoJ3RhZ05hbWUnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMudG9Gb3JtYXR0ZWRTdHJpbmcob3B0aW9ucyk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IG9wdGlvbnMuZ2V0KCdjbGFzc05hbWUnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy5nZXQoJ3RhcmdldCcsIGhyZWYsIHRva2VuKTtcbiAgICBjb25zdCByZWwgPSBvcHRpb25zLmdldCgncmVsJywgaHJlZiwgdG9rZW4pO1xuICAgIGNvbnN0IGF0dHJzID0gb3B0aW9ucy5nZXRPYmooJ2F0dHJpYnV0ZXMnLCBocmVmLCB0b2tlbik7XG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLmdldE9iaignZXZlbnRzJywgaHJlZiwgdG9rZW4pO1xuICAgIGF0dHJpYnV0ZXMuaHJlZiA9IGZvcm1hdHRlZEhyZWY7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IGNsYXNzTmFtZTtcbiAgICB9XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgYXR0cmlidXRlcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfVxuICAgIGlmIChyZWwpIHtcbiAgICAgIGF0dHJpYnV0ZXMucmVsID0gcmVsO1xuICAgIH1cbiAgICBpZiAoYXR0cnMpIHtcbiAgICAgIGFzc2lnbihhdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0YWdOYW1lLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBldmVudExpc3RlbmVyc1xuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRva2VuIHRoYXQgY2FuIGJlIGVtaXR0ZWQgYnkgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSByZWFkYWJsZSB0eXBlIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIHByb3BlcnRpZXMgdG8gYXNzaWduIG9yIG92ZXJyaWRlLCBpbmNsdWRpbmcgaXNMaW5rID0gdHJ1ZSBvciBmYWxzZVxuICogQHJldHVybnMge25ldyAodmFsdWU6IHN0cmluZywgdG9rZW5zOiBUb2tlbltdKSA9PiBNdWx0aVRva2VufSBuZXcgdG9rZW4gY2xhc3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9rZW5DbGFzcyh0eXBlLCBwcm9wcykge1xuICBjbGFzcyBUb2tlbiBleHRlbmRzIE11bHRpVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbnMpIHtcbiAgICAgIHN1cGVyKHZhbHVlLCB0b2tlbnMpO1xuICAgICAgdGhpcy50ID0gdHlwZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBwIGluIHByb3BzKSB7XG4gICAgVG9rZW4ucHJvdG90eXBlW3BdID0gcHJvcHNbcF07XG4gIH1cbiAgVG9rZW4udCA9IHR5cGU7XG4gIHJldHVybiBUb2tlbjtcbn1cblxuLyoqXG5cdFJlcHJlc2VudHMgYSBsaXN0IG9mIHRva2VucyBtYWtpbmcgdXAgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXG4qL1xuY29uc3QgRW1haWwgPSBjcmVhdGVUb2tlbkNsYXNzKCdlbWFpbCcsIHtcbiAgaXNMaW5rOiB0cnVlLFxuICB0b0hyZWYoKSB7XG4gICAgcmV0dXJuICdtYWlsdG86JyArIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufSk7XG5cbi8qKlxuXHRSZXByZXNlbnRzIHNvbWUgcGxhaW4gdGV4dFxuKi9cbmNvbnN0IFRleHQgPSBjcmVhdGVUb2tlbkNsYXNzKCd0ZXh0Jyk7XG5cbi8qKlxuXHRNdWx0aS1saW5lYnJlYWsgdG9rZW4gLSByZXByZXNlbnRzIGEgbGluZSBicmVha1xuXHRAY2xhc3MgTmxcbiovXG5jb25zdCBObCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ25sJyk7XG5cbi8qKlxuXHRSZXByZXNlbnRzIGEgbGlzdCBvZiB0ZXh0IHRva2VucyBtYWtpbmcgdXAgYSB2YWxpZCBVUkxcblx0QGNsYXNzIFVybFxuKi9cbmNvbnN0IFVybCA9IGNyZWF0ZVRva2VuQ2xhc3MoJ3VybCcsIHtcbiAgaXNMaW5rOiB0cnVlLFxuICAvKipcbiAgXHRMb3dlcmNhc2VzIHJlbGV2YW50IHBhcnRzIG9mIHRoZSBkb21haW4gYW5kIGFkZHMgdGhlIHByb3RvY29sIGlmXG4gIFx0cmVxdWlyZWQuIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGVzY2FwZSB1bnNhZmUgSFRNTCBjaGFyYWN0ZXJzIGluIHRoZVxuICBcdFVSTC5cbiAgXHRcdEBwYXJhbSB7c3RyaW5nfSBbc2NoZW1lXSBkZWZhdWx0IHNjaGVtZSAoZS5nLiwgJ2h0dHBzJylcbiAgXHRAcmV0dXJuIHtzdHJpbmd9IHRoZSBmdWxsIGhyZWZcbiAgKi9cbiAgdG9IcmVmKHNjaGVtZSA9IGRlZmF1bHRzLmRlZmF1bHRQcm90b2NvbCkge1xuICAgIC8vIENoZWNrIGlmIGFscmVhZHkgaGFzIGEgcHJlZml4IHNjaGVtZVxuICAgIHJldHVybiB0aGlzLmhhc1Byb3RvY29sKCkgPyB0aGlzLnYgOiBgJHtzY2hlbWV9Oi8vJHt0aGlzLnZ9YDtcbiAgfSxcbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhpcyBVUkwgdG9rZW4gaGFzIGEgcHJvdG9jb2xcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1Byb3RvY29sKCkge1xuICAgIGNvbnN0IHRva2VucyA9IHRoaXMudGs7XG4gICAgcmV0dXJuIHRva2Vucy5sZW5ndGggPj0gMiAmJiB0b2tlbnNbMF0udCAhPT0gTE9DQUxIT1NUICYmIHRva2Vuc1sxXS50ID09PSBDT0xPTjtcbiAgfVxufSk7XG5cbnZhciBtdWx0aSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRCYXNlOiBNdWx0aVRva2VuLFxuXHRFbWFpbDogRW1haWwsXG5cdE11bHRpVG9rZW46IE11bHRpVG9rZW4sXG5cdE5sOiBObCxcblx0VGV4dDogVGV4dCxcblx0VXJsOiBVcmwsXG5cdGNyZWF0ZVRva2VuQ2xhc3M6IGNyZWF0ZVRva2VuQ2xhc3Ncbn0pO1xuXG4vKipcblx0Tm90IGV4YWN0bHkgcGFyc2VyLCBtb3JlIGxpa2UgdGhlIHNlY29uZC1zdGFnZSBzY2FubmVyIChhbHRob3VnaCB3ZSBjYW5cblx0dGhlb3JldGljYWxseSBob3Rzd2FwIHRoZSBjb2RlIGhlcmUgd2l0aCBhIHJlYWwgcGFyc2VyIGluIHRoZSBmdXR1cmUuLi4gYnV0XG5cdGZvciBhIGxpdHRsZSBVUkwtZmluZGluZyB1dGlsaXR5IGFic3RyYWN0IHN5bnRheCB0cmVlcyBtYXkgYmUgYSBsaXR0bGVcblx0b3ZlcmtpbGwpLlxuXG5cdFVSTCBmb3JtYXQ6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVJJX3NjaGVtZVxuXHRFbWFpbCBmb3JtYXQ6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1haWxBZGRyZXNzIChsaW5rcyB0byBSRkMgaW5cblx0cmVmZXJlbmNlKVxuXG5cdEBtb2R1bGUgbGlua2lmeVxuXHRAc3VibW9kdWxlIHBhcnNlclxuXHRAbWFpbiBydW5cbiovXG5cbmNvbnN0IG1ha2VTdGF0ZSA9IGFyZyA9PiBuZXcgU3RhdGUoYXJnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgcGFyc2VyIG11bHRpIHRva2VuLWJhc2VkIHN0YXRlIG1hY2hpbmVcbiAqIEBwYXJhbSB7eyBncm91cHM6IENvbGxlY3Rpb25zPHN0cmluZz4gfX0gdG9rZW5zXG4gKi9cbmZ1bmN0aW9uIGluaXQkMSh7XG4gIGdyb3Vwc1xufSkge1xuICAvLyBUeXBlcyBvZiBjaGFyYWN0ZXJzIHRoZSBVUkwgY2FuIGRlZmluaXRlbHkgZW5kIGluXG4gIGNvbnN0IHFzQWNjZXB0aW5nID0gZ3JvdXBzLmRvbWFpbi5jb25jYXQoW0FNUEVSU0FORCwgQVNURVJJU0ssIEFULCBCQUNLU0xBU0gsIEJBQ0tUSUNLLCBDQVJFVCwgRE9MTEFSLCBFUVVBTFMsIEhZUEhFTiwgTlVNLCBQRVJDRU5ULCBQSVBFLCBQTFVTLCBQT1VORCwgU0xBU0gsIFNZTSwgVElMREUsIFVOREVSU0NPUkVdKTtcblxuICAvLyBUeXBlcyBvZiB0b2tlbnMgdGhhdCBjYW4gZm9sbG93IGEgVVJMIGFuZCBiZSBwYXJ0IG9mIHRoZSBxdWVyeSBzdHJpbmdcbiAgLy8gYnV0IGNhbm5vdCBiZSB0aGUgdmVyeSBsYXN0IGNoYXJhY3RlcnNcbiAgLy8gQ2hhcmFjdGVycyB0aGF0IGNhbm5vdCBhcHBlYXIgaW4gdGhlIFVSTCBhdCBhbGwgc2hvdWxkIGJlIGV4Y2x1ZGVkXG4gIGNvbnN0IHFzTm9uQWNjZXB0aW5nID0gW0FQT1NUUk9QSEUsIENPTE9OLCBDT01NQSwgRE9ULCBFWENMQU1BVElPTiwgUEVSQ0VOVCwgUVVFUlksIFFVT1RFLCBTRU1JLCBPUEVOQU5HTEVCUkFDS0VULCBDTE9TRUFOR0xFQlJBQ0tFVCwgT1BFTkJSQUNFLCBDTE9TRUJSQUNFLCBDTE9TRUJSQUNLRVQsIE9QRU5CUkFDS0VULCBPUEVOUEFSRU4sIENMT1NFUEFSRU4sIEZVTExXSURUSExFRlRQQVJFTiwgRlVMTFdJRFRIUklHSFRQQVJFTiwgTEVGVENPUk5FUkJSQUNLRVQsIFJJR0hUQ09STkVSQlJBQ0tFVCwgTEVGVFdISVRFQ09STkVSQlJBQ0tFVCwgUklHSFRXSElURUNPUk5FUkJSQUNLRVQsIEZVTExXSURUSExFU1NUSEFOLCBGVUxMV0lEVEhHUkVBVEVSVEhBTl07XG5cbiAgLy8gRm9yIGFkZHJlc3NlcyB3aXRob3V0IHRoZSBtYWlsdG8gcHJlZml4XG4gIC8vIFRva2VucyBhbGxvd2VkIGluIHRoZSBsb2NhbHBhcnQgb2YgdGhlIGVtYWlsXG4gIGNvbnN0IGxvY2FscGFydEFjY2VwdGluZyA9IFtBTVBFUlNBTkQsIEFQT1NUUk9QSEUsIEFTVEVSSVNLLCBCQUNLU0xBU0gsIEJBQ0tUSUNLLCBDQVJFVCwgRE9MTEFSLCBFUVVBTFMsIEhZUEhFTiwgT1BFTkJSQUNFLCBDTE9TRUJSQUNFLCBQRVJDRU5ULCBQSVBFLCBQTFVTLCBQT1VORCwgUVVFUlksIFNMQVNILCBTWU0sIFRJTERFLCBVTkRFUlNDT1JFXTtcblxuICAvLyBUaGUgdW5pdmVyc2FsIHN0YXJ0aW5nIHN0YXRlLlxuICAvKipcbiAgICogQHR5cGUgU3RhdGU8VG9rZW4+XG4gICAqL1xuICBjb25zdCBTdGFydCA9IG1ha2VTdGF0ZSgpO1xuICBjb25zdCBMb2NhbHBhcnQgPSB0dChTdGFydCwgVElMREUpOyAvLyBMb2NhbCBwYXJ0IG9mIHRoZSBlbWFpbCBhZGRyZXNzXG4gIHRhKExvY2FscGFydCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShMb2NhbHBhcnQsIGdyb3Vwcy5kb21haW4sIExvY2FscGFydCk7XG4gIGNvbnN0IERvbWFpbiA9IG1ha2VTdGF0ZSgpLFxuICAgIFNjaGVtZSA9IG1ha2VTdGF0ZSgpLFxuICAgIFNsYXNoU2NoZW1lID0gbWFrZVN0YXRlKCk7XG4gIHRhKFN0YXJ0LCBncm91cHMuZG9tYWluLCBEb21haW4pOyAvLyBwYXJzZWQgc3RyaW5nIGVuZHMgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZSAoQSlcbiAgdGEoU3RhcnQsIGdyb3Vwcy5zY2hlbWUsIFNjaGVtZSk7IC8vIGUuZy4sICdtYWlsdG8nXG4gIHRhKFN0YXJ0LCBncm91cHMuc2xhc2hzY2hlbWUsIFNsYXNoU2NoZW1lKTsgLy8gZS5nLiwgJ2h0dHAnXG5cbiAgdGEoRG9tYWluLCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKERvbWFpbiwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgY29uc3QgTG9jYWxwYXJ0QXQgPSB0dChEb21haW4sIEFUKTsgLy8gTG9jYWwgcGFydCBvZiB0aGUgZW1haWwgYWRkcmVzcyBwbHVzIEBcblxuICB0dChMb2NhbHBhcnQsIEFULCBMb2NhbHBhcnRBdCk7IC8vIGNsb3NlIHRvIGFuIGVtYWlsIGFkZHJlc3Mgbm93XG5cbiAgLy8gTG9jYWwgcGFydCBvZiBhbiBlbWFpbCBhZGRyZXNzIGNhbiBiZSBlLmcuICdodHRwJyBvciAnbWFpbHRvJ1xuICB0dChTY2hlbWUsIEFULCBMb2NhbHBhcnRBdCk7XG4gIHR0KFNsYXNoU2NoZW1lLCBBVCwgTG9jYWxwYXJ0QXQpO1xuICBjb25zdCBMb2NhbHBhcnREb3QgPSB0dChMb2NhbHBhcnQsIERPVCk7IC8vIExvY2FsIHBhcnQgb2YgdGhlIGVtYWlsIGFkZHJlc3MgcGx1cyAnLicgKGxvY2FscGFydCBjYW5ub3QgZW5kIGluIC4pXG4gIHRhKExvY2FscGFydERvdCwgbG9jYWxwYXJ0QWNjZXB0aW5nLCBMb2NhbHBhcnQpO1xuICB0YShMb2NhbHBhcnREb3QsIGdyb3Vwcy5kb21haW4sIExvY2FscGFydCk7XG4gIGNvbnN0IEVtYWlsRG9tYWluID0gbWFrZVN0YXRlKCk7XG4gIHRhKExvY2FscGFydEF0LCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuICB0YShFbWFpbERvbWFpbiwgZ3JvdXBzLmRvbWFpbiwgRW1haWxEb21haW4pO1xuICBjb25zdCBFbWFpbERvbWFpbkRvdCA9IHR0KEVtYWlsRG9tYWluLCBET1QpOyAvLyBkb21haW4gZm9sbG93ZWQgYnkgRE9UXG4gIHRhKEVtYWlsRG9tYWluRG90LCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIGNvbnN0IEVtYWlsJDEgPSBtYWtlU3RhdGUoRW1haWwpOyAvLyBQb3NzaWJsZSBlbWFpbCBhZGRyZXNzIChjb3VsZCBoYXZlIG1vcmUgdGxkcylcbiAgdGEoRW1haWxEb21haW5Eb3QsIGdyb3Vwcy50bGQsIEVtYWlsJDEpO1xuICB0YShFbWFpbERvbWFpbkRvdCwgZ3JvdXBzLnV0bGQsIEVtYWlsJDEpO1xuICB0dChMb2NhbHBhcnRBdCwgTE9DQUxIT1NULCBFbWFpbCQxKTtcblxuICAvLyBIeXBoZW4gY2FuIGp1bXAgYmFjayB0byBhIGRvbWFpbiBuYW1lXG4gIGNvbnN0IEVtYWlsRG9tYWluSHlwaGVuID0gdHQoRW1haWxEb21haW4sIEhZUEhFTik7IC8vIHBhcnNlZCBzdHJpbmcgc3RhcnRzIHdpdGggbG9jYWwgZW1haWwgaW5mbyArIEAgd2l0aCBhIHBvdGVudGlhbCBkb21haW4gbmFtZVxuICB0dChFbWFpbERvbWFpbkh5cGhlbiwgSFlQSEVOLCBFbWFpbERvbWFpbkh5cGhlbik7XG4gIHRhKEVtYWlsRG9tYWluSHlwaGVuLCBncm91cHMuZG9tYWluLCBFbWFpbERvbWFpbik7XG4gIHRhKEVtYWlsJDEsIGdyb3Vwcy5kb21haW4sIEVtYWlsRG9tYWluKTtcbiAgdHQoRW1haWwkMSwgRE9ULCBFbWFpbERvbWFpbkRvdCk7XG4gIHR0KEVtYWlsJDEsIEhZUEhFTiwgRW1haWxEb21haW5IeXBoZW4pO1xuXG4gIC8vIEZpbmFsIHBvc3NpYmxlIGVtYWlsIHN0YXRlc1xuICBjb25zdCBFbWFpbENvbG9uID0gdHQoRW1haWwkMSwgQ09MT04pOyAvLyBVUkwgZm9sbG93ZWQgYnkgY29sb24gKHBvdGVudGlhbCBwb3J0IG51bWJlciBoZXJlKVxuICAvKmNvbnN0IEVtYWlsQ29sb25Qb3J0ID0gKi9cbiAgdGEoRW1haWxDb2xvbiwgZ3JvdXBzLm51bWVyaWMsIEVtYWlsKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IGNvbG9uIGFuZCBwb3J0IG51bWJlclxuXG4gIC8vIEFjY291bnQgZm9yIGRvdHMgYW5kIGh5cGhlbnMuIEh5cGhlbnMgYXJlIHVzdWFsbHkgcGFydHMgb2YgZG9tYWluIG5hbWVzXG4gIC8vIChidXQgbm90IFRMRHMpXG4gIGNvbnN0IERvbWFpbkh5cGhlbiA9IHR0KERvbWFpbiwgSFlQSEVOKTsgLy8gZG9tYWluIGZvbGxvd2VkIGJ5IGh5cGhlblxuICBjb25zdCBEb21haW5Eb3QgPSB0dChEb21haW4sIERPVCk7IC8vIGRvbWFpbiBmb2xsb3dlZCBieSBET1RcbiAgdHQoRG9tYWluSHlwaGVuLCBIWVBIRU4sIERvbWFpbkh5cGhlbik7XG4gIHRhKERvbWFpbkh5cGhlbiwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdGEoRG9tYWluRG90LCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgY29uc3QgRG9tYWluRG90VGxkID0gbWFrZVN0YXRlKFVybCk7IC8vIFNpbXBsZXN0IHBvc3NpYmxlIFVSTCB3aXRoIG5vIHF1ZXJ5IHN0cmluZ1xuICB0YShEb21haW5Eb3QsIGdyb3Vwcy50bGQsIERvbWFpbkRvdFRsZCk7XG4gIHRhKERvbWFpbkRvdCwgZ3JvdXBzLnV0bGQsIERvbWFpbkRvdFRsZCk7XG4gIHRhKERvbWFpbkRvdFRsZCwgZ3JvdXBzLmRvbWFpbiwgRG9tYWluKTtcbiAgdGEoRG9tYWluRG90VGxkLCBsb2NhbHBhcnRBY2NlcHRpbmcsIExvY2FscGFydCk7XG4gIHR0KERvbWFpbkRvdFRsZCwgRE9ULCBEb21haW5Eb3QpO1xuICB0dChEb21haW5Eb3RUbGQsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcbiAgdHQoRG9tYWluRG90VGxkLCBBVCwgTG9jYWxwYXJ0QXQpO1xuICBjb25zdCBEb21haW5Eb3RUbGRDb2xvbiA9IHR0KERvbWFpbkRvdFRsZCwgQ09MT04pOyAvLyBVUkwgZm9sbG93ZWQgYnkgY29sb24gKHBvdGVudGlhbCBwb3J0IG51bWJlciBoZXJlKVxuICBjb25zdCBEb21haW5Eb3RUbGRDb2xvblBvcnQgPSBtYWtlU3RhdGUoVXJsKTsgLy8gVExEIGZvbGxvd2VkIGJ5IGEgcG9ydCBudW1iZXJcbiAgdGEoRG9tYWluRG90VGxkQ29sb24sIGdyb3Vwcy5udW1lcmljLCBEb21haW5Eb3RUbGRDb2xvblBvcnQpO1xuXG4gIC8vIExvbmcgVVJMIHdpdGggb3B0aW9uYWwgcG9ydCBhbmQgbWF5YmUgcXVlcnkgc3RyaW5nXG4gIGNvbnN0IFVybCQxID0gbWFrZVN0YXRlKFVybCk7XG5cbiAgLy8gVVJMIHdpdGggZXh0cmEgc3ltYm9scyBhdCB0aGUgZW5kLCBmb2xsb3dlZCBieSBhbiBvcGVuaW5nIGJyYWNrZXRcbiAgY29uc3QgVXJsTm9uYWNjZXB0ID0gbWFrZVN0YXRlKCk7IC8vIFVSTCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHMgKHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIGZpbmFsIFVSTClcblxuICAvLyBRdWVyeSBzdHJpbmdzXG4gIHRhKFVybCQxLCBxc0FjY2VwdGluZywgVXJsJDEpO1xuICB0YShVcmwkMSwgcXNOb25BY2NlcHRpbmcsIFVybE5vbmFjY2VwdCk7XG4gIHRhKFVybE5vbmFjY2VwdCwgcXNBY2NlcHRpbmcsIFVybCQxKTtcbiAgdGEoVXJsTm9uYWNjZXB0LCBxc05vbkFjY2VwdGluZywgVXJsTm9uYWNjZXB0KTtcblxuICAvLyBCZWNvbWUgcmVhbCBVUkxzIGFmdGVyIGBTTEFTSGAgb3IgYENPTE9OIE5VTSBTTEFTSGBcbiAgLy8gSGVyZSB3b3JrcyB3aXRoIG9yIHdpdGhvdXQgc2NoZW1lOi8vIHByZWZpeFxuICB0dChEb21haW5Eb3RUbGQsIFNMQVNILCBVcmwkMSk7XG4gIHR0KERvbWFpbkRvdFRsZENvbG9uUG9ydCwgU0xBU0gsIFVybCQxKTtcblxuICAvLyBOb3RlIHRoYXQgZG9tYWlucyB0aGF0IGJlZ2luIHdpdGggc2NoZW1lcyBhcmUgdHJlYXRlZCBzbGlnaGx5IGRpZmZlcmVudGx5XG4gIGNvbnN0IFNjaGVtZUNvbG9uID0gdHQoU2NoZW1lLCBDT0xPTik7IC8vIGUuZy4sICdtYWlsdG86J1xuICBjb25zdCBTbGFzaFNjaGVtZUNvbG9uID0gdHQoU2xhc2hTY2hlbWUsIENPTE9OKTsgLy8gZS5nLiwgJ2h0dHA6J1xuICBjb25zdCBTbGFzaFNjaGVtZUNvbG9uU2xhc2ggPSB0dChTbGFzaFNjaGVtZUNvbG9uLCBTTEFTSCk7IC8vIGUuZy4sICdodHRwOi8nXG5cbiAgY29uc3QgVXJpUHJlZml4ID0gdHQoU2xhc2hTY2hlbWVDb2xvblNsYXNoLCBTTEFTSCk7IC8vIGUuZy4sICdodHRwOi8vJ1xuXG4gIC8vIFNjaGVtZSBzdGF0ZXMgY2FuIHRyYW5zaXRpb24gdG8gZG9tYWluIHN0YXRlc1xuICB0YShTY2hlbWUsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHR0KFNjaGVtZSwgRE9ULCBEb21haW5Eb3QpO1xuICB0dChTY2hlbWUsIEhZUEhFTiwgRG9tYWluSHlwaGVuKTtcbiAgdGEoU2xhc2hTY2hlbWUsIGdyb3Vwcy5kb21haW4sIERvbWFpbik7XG4gIHR0KFNsYXNoU2NoZW1lLCBET1QsIERvbWFpbkRvdCk7XG4gIHR0KFNsYXNoU2NoZW1lLCBIWVBIRU4sIERvbWFpbkh5cGhlbik7XG5cbiAgLy8gRm9yY2UgVVJMIHdpdGggc2NoZW1lIHByZWZpeCBmb2xsb3dlZCBieSBhbnl0aGluZyBzYW5lXG4gIHRhKFNjaGVtZUNvbG9uLCBncm91cHMuZG9tYWluLCBVcmwkMSk7XG4gIHR0KFNjaGVtZUNvbG9uLCBTTEFTSCwgVXJsJDEpO1xuICB0dChTY2hlbWVDb2xvbiwgUVVFUlksIFVybCQxKTtcbiAgdGEoVXJpUHJlZml4LCBncm91cHMuZG9tYWluLCBVcmwkMSk7XG4gIHRhKFVyaVByZWZpeCwgcXNBY2NlcHRpbmcsIFVybCQxKTtcbiAgdHQoVXJpUHJlZml4LCBTTEFTSCwgVXJsJDEpO1xuICBjb25zdCBicmFja2V0UGFpcnMgPSBbW09QRU5CUkFDRSwgQ0xPU0VCUkFDRV0sXG4gIC8vIHt9XG4gIFtPUEVOQlJBQ0tFVCwgQ0xPU0VCUkFDS0VUXSxcbiAgLy8gW11cbiAgW09QRU5QQVJFTiwgQ0xPU0VQQVJFTl0sXG4gIC8vICgpXG4gIFtPUEVOQU5HTEVCUkFDS0VULCBDTE9TRUFOR0xFQlJBQ0tFVF0sXG4gIC8vIDw+XG4gIFtGVUxMV0lEVEhMRUZUUEFSRU4sIEZVTExXSURUSFJJR0hUUEFSRU5dLFxuICAvLyBcdUZGMDhcdUZGMDlcbiAgW0xFRlRDT1JORVJCUkFDS0VULCBSSUdIVENPUk5FUkJSQUNLRVRdLFxuICAvLyBcdTMwMENcdTMwMERcbiAgW0xFRlRXSElURUNPUk5FUkJSQUNLRVQsIFJJR0hUV0hJVEVDT1JORVJCUkFDS0VUXSxcbiAgLy8gXHUzMDBFXHUzMDBGXG4gIFtGVUxMV0lEVEhMRVNTVEhBTiwgRlVMTFdJRFRIR1JFQVRFUlRIQU5dIC8vIFx1RkYxQ1x1RkYxRVxuICBdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJyYWNrZXRQYWlycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtPUEVOLCBDTE9TRV0gPSBicmFja2V0UGFpcnNbaV07XG4gICAgY29uc3QgVXJsT3BlbiA9IHR0KFVybCQxLCBPUEVOKTsgLy8gVVJMIGZvbGxvd2VkIGJ5IG9wZW4gYnJhY2tldFxuXG4gICAgLy8gQ29udGludWUgbm90IGFjY2VwdGluZyBmb3Igb3BlbiBicmFja2V0c1xuICAgIHR0KFVybE5vbmFjY2VwdCwgT1BFTiwgVXJsT3Blbik7XG5cbiAgICAvLyBDbG9zaW5nIGJyYWNrZXQgY29tcG9uZW50LiBUaGlzIGNoYXJhY3RlciBXSUxMIGJlIGluY2x1ZGVkIGluIHRoZSBVUkxcbiAgICB0dChVcmxPcGVuLCBDTE9TRSwgVXJsJDEpO1xuXG4gICAgLy8gVVJMIHRoYXQgYmVpbmdzIHdpdGggYW4gb3BlbmluZyBicmFja2V0LCBmb2xsb3dlZCBieSBhIHN5bWJvbHMuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBmaW5hbCBzdGF0ZSBjYW4gc3RpbGwgYmUgYFVybE9wZW5gIChpZiB0aGUgVVJMIGhhcyBhXG4gICAgLy8gc2luZ2xlIG9wZW5pbmcgYnJhY2tldCBmb3Igc29tZSByZWFzb24pLlxuICAgIGNvbnN0IFVybE9wZW5RID0gbWFrZVN0YXRlKFVybCk7XG4gICAgdGEoVXJsT3BlbiwgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICBjb25zdCBVcmxPcGVuU3ltcyA9IG1ha2VTdGF0ZSgpOyAvLyBVcmxPcGVuIGZvbGxvd2VkIGJ5IHNvbWUgc3ltYm9scyBpdCBjYW5ub3QgZW5kIGl0XG4gICAgdGEoVXJsT3BlbiwgcXNOb25BY2NlcHRpbmcpO1xuXG4gICAgLy8gVVJMIHRoYXQgYmVnaW5zIHdpdGggYW4gb3BlbmluZyBicmFja2V0LCBmb2xsb3dlZCBieSBzb21lIHN5bWJvbHNcbiAgICB0YShVcmxPcGVuUSwgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICB0YShVcmxPcGVuUSwgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5TeW1zKTtcbiAgICB0YShVcmxPcGVuU3ltcywgcXNBY2NlcHRpbmcsIFVybE9wZW5RKTtcbiAgICB0YShVcmxPcGVuU3ltcywgcXNOb25BY2NlcHRpbmcsIFVybE9wZW5TeW1zKTtcblxuICAgIC8vIENsb3NlIGJyYWNlL2JyYWNrZXQgdG8gYmVjb21lIHJlZ3VsYXIgVVJMXG4gICAgdHQoVXJsT3BlblEsIENMT1NFLCBVcmwkMSk7XG4gICAgdHQoVXJsT3BlblN5bXMsIENMT1NFLCBVcmwkMSk7XG4gIH1cbiAgdHQoU3RhcnQsIExPQ0FMSE9TVCwgRG9tYWluRG90VGxkKTsgLy8gbG9jYWxob3N0IGlzIGEgdmFsaWQgVVJMIHN0YXRlXG4gIHR0KFN0YXJ0LCBOTCwgTmwpOyAvLyBzaW5nbGUgbmV3IGxpbmVcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBTdGFydCxcbiAgICB0b2tlbnM6IHRrXG4gIH07XG59XG5cbi8qKlxuICogUnVuIHRoZSBwYXJzZXIgc3RhdGUgbWFjaGluZSBvbiBhIGxpc3Qgb2Ygc2Nhbm5lZCBzdHJpbmctYmFzZWQgdG9rZW5zIHRvXG4gKiBjcmVhdGUgYSBsaXN0IG9mIG11bHRpIHRva2VucywgZWFjaCBvZiB3aGljaCByZXByZXNlbnRzIGEgVVJMLCBlbWFpbCBhZGRyZXNzLFxuICogcGxhaW4gdGV4dCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7U3RhdGU8TXVsdGlUb2tlbj59IHN0YXJ0IHBhcnNlciBzdGFydCBzdGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IHRoZSBvcmlnaW5hbCBpbnB1dCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBnaXZlbiB0b2tlbnNcbiAqIEBwYXJhbSB7VG9rZW5bXX0gdG9rZW5zIGxpc3Qgb2Ygc2Nhbm5lZCB0b2tlbnNcbiAqIEByZXR1cm5zIHtNdWx0aVRva2VuW119XG4gKi9cbmZ1bmN0aW9uIHJ1bihzdGFydCwgaW5wdXQsIHRva2Vucykge1xuICBsZXQgbGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgbGV0IGN1cnNvciA9IDA7XG4gIGxldCBtdWx0aXMgPSBbXTtcbiAgbGV0IHRleHRUb2tlbnMgPSBbXTtcbiAgd2hpbGUgKGN1cnNvciA8IGxlbikge1xuICAgIGxldCBzdGF0ZSA9IHN0YXJ0O1xuICAgIGxldCBzZWNvbmRTdGF0ZSA9IG51bGw7XG4gICAgbGV0IG5leHRTdGF0ZSA9IG51bGw7XG4gICAgbGV0IG11bHRpTGVuZ3RoID0gMDtcbiAgICBsZXQgbGF0ZXN0QWNjZXB0aW5nID0gbnVsbDtcbiAgICBsZXQgc2luY2VBY2NlcHRzID0gLTE7XG4gICAgd2hpbGUgKGN1cnNvciA8IGxlbiAmJiAhKHNlY29uZFN0YXRlID0gc3RhdGUuZ28odG9rZW5zW2N1cnNvcl0udCkpKSB7XG4gICAgICAvLyBTdGFydGluZyB0b2tlbnMgd2l0aCBub3doZXJlIHRvIGp1bXAgdG8uXG4gICAgICAvLyBDb25zaWRlciB0aGVzZSB0byBiZSBqdXN0IHBsYWluIHRleHRcbiAgICAgIHRleHRUb2tlbnMucHVzaCh0b2tlbnNbY3Vyc29yKytdKTtcbiAgICB9XG4gICAgd2hpbGUgKGN1cnNvciA8IGxlbiAmJiAobmV4dFN0YXRlID0gc2Vjb25kU3RhdGUgfHwgc3RhdGUuZ28odG9rZW5zW2N1cnNvcl0udCkpKSB7XG4gICAgICAvLyBHZXQgdGhlIG5leHQgc3RhdGVcbiAgICAgIHNlY29uZFN0YXRlID0gbnVsbDtcbiAgICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgICBpZiAoc3RhdGUuYWNjZXB0cygpKSB7XG4gICAgICAgIHNpbmNlQWNjZXB0cyA9IDA7XG4gICAgICAgIGxhdGVzdEFjY2VwdGluZyA9IHN0YXRlO1xuICAgICAgfSBlbHNlIGlmIChzaW5jZUFjY2VwdHMgPj0gMCkge1xuICAgICAgICBzaW5jZUFjY2VwdHMrKztcbiAgICAgIH1cbiAgICAgIGN1cnNvcisrO1xuICAgICAgbXVsdGlMZW5ndGgrKztcbiAgICB9XG4gICAgaWYgKHNpbmNlQWNjZXB0cyA8IDApIHtcbiAgICAgIC8vIE5vIGFjY2VwdGluZyBzdGF0ZSB3YXMgZm91bmQsIHBhcnQgb2YgYSByZWd1bGFyIHRleHQgdG9rZW4gYWRkXG4gICAgICAvLyB0aGUgZmlyc3QgdGV4dCB0b2tlbiB0byB0aGUgdGV4dCB0b2tlbnMgYXJyYXkgYW5kIHRyeSBhZ2FpbiBmcm9tXG4gICAgICAvLyB0aGUgbmV4dFxuICAgICAgY3Vyc29yIC09IG11bHRpTGVuZ3RoO1xuICAgICAgaWYgKGN1cnNvciA8IGxlbikge1xuICAgICAgICB0ZXh0VG9rZW5zLnB1c2godG9rZW5zW2N1cnNvcl0pO1xuICAgICAgICBjdXJzb3IrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWNjZXB0aW5nIHN0YXRlIVxuICAgICAgLy8gRmlyc3QgY2xvc2Ugb2ZmIHRoZSB0ZXh0VG9rZW5zIChpZiBhdmFpbGFibGUpXG4gICAgICBpZiAodGV4dFRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKFRleHQsIGlucHV0LCB0ZXh0VG9rZW5zKSk7XG4gICAgICAgIHRleHRUb2tlbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gUm9sbCBiYWNrIHRvIHRoZSBsYXRlc3QgYWNjZXB0aW5nIHN0YXRlXG4gICAgICBjdXJzb3IgLT0gc2luY2VBY2NlcHRzO1xuICAgICAgbXVsdGlMZW5ndGggLT0gc2luY2VBY2NlcHRzO1xuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgbXVsdGl0b2tlblxuICAgICAgY29uc3QgTXVsdGkgPSBsYXRlc3RBY2NlcHRpbmcudDtcbiAgICAgIGNvbnN0IHN1YnRva2VucyA9IHRva2Vucy5zbGljZShjdXJzb3IgLSBtdWx0aUxlbmd0aCwgY3Vyc29yKTtcbiAgICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKE11bHRpLCBpbnB1dCwgc3VidG9rZW5zKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluYWxseSBjbG9zZSBvZmYgdGhlIHRleHRUb2tlbnMgKGlmIGF2YWlsYWJsZSlcbiAgaWYgKHRleHRUb2tlbnMubGVuZ3RoID4gMCkge1xuICAgIG11bHRpcy5wdXNoKGluaXRNdWx0aVRva2VuKFRleHQsIGlucHV0LCB0ZXh0VG9rZW5zKSk7XG4gIH1cbiAgcmV0dXJuIG11bHRpcztcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBpbnN0YW50aWF0aW5nIGEgbmV3IG11bHRpdG9rZW4gd2l0aCBhbGwgdGhlIHJlbGV2YW50XG4gKiBmaWVsZHMgZHVyaW5nIHBhcnNpbmcuXG4gKiBAcGFyYW0ge25ldyAodmFsdWU6IHN0cmluZywgdG9rZW5zOiBUb2tlbltdKSA9PiBNdWx0aVRva2VufSBNdWx0aSBjbGFzcyB0byBpbnN0YW50aWF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IG9yaWdpbmFsIGlucHV0IHN0cmluZ1xuICogQHBhcmFtIHtUb2tlbltdfSB0b2tlbnMgY29uc2VjdXRpdmUgdG9rZW5zIHNjYW5uZWQgZnJvbSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIHtNdWx0aVRva2VufVxuICovXG5mdW5jdGlvbiBpbml0TXVsdGlUb2tlbihNdWx0aSwgaW5wdXQsIHRva2Vucykge1xuICBjb25zdCBzdGFydElkeCA9IHRva2Vuc1swXS5zO1xuICBjb25zdCBlbmRJZHggPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLmU7XG4gIGNvbnN0IHZhbHVlID0gaW5wdXQuc2xpY2Uoc3RhcnRJZHgsIGVuZElkeCk7XG4gIHJldHVybiBuZXcgTXVsdGkodmFsdWUsIHRva2Vucyk7XG59XG5cbmNvbnN0IHdhcm4gPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4gfHwgKCgpID0+IHt9KTtcbmNvbnN0IHdhcm5BZHZpY2UgPSAndW50aWwgbWFudWFsIGNhbGwgb2YgbGlua2lmeS5pbml0KCkuIFJlZ2lzdGVyIGFsbCBzY2hlbWVzIGFuZCBwbHVnaW5zIGJlZm9yZSBpbnZva2luZyBsaW5raWZ5IHRoZSBmaXJzdCB0aW1lLic7XG5cbi8vIFNpZGUtZWZmZWN0IGluaXRpYWxpemF0aW9uIHN0YXRlXG5jb25zdCBJTklUID0ge1xuICBzY2FubmVyOiBudWxsLFxuICBwYXJzZXI6IG51bGwsXG4gIHRva2VuUXVldWU6IFtdLFxuICBwbHVnaW5RdWV1ZTogW10sXG4gIGN1c3RvbVNjaGVtZXM6IFtdLFxuICBpbml0aWFsaXplZDogZmFsc2Vcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIFx0c3RhcnQ6IFN0YXRlPHN0cmluZz4sXG4gKiBcdHRva2VuczogeyBncm91cHM6IENvbGxlY3Rpb25zPHN0cmluZz4gfSAmIHR5cGVvZiB0a1xuICogfX0gU2Nhbm5lckluaXRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBcdHN0YXJ0OiBTdGF0ZTxNdWx0aVRva2VuPixcbiAqIFx0dG9rZW5zOiB0eXBlb2YgbXVsdGlcbiAqIH19IFBhcnNlckluaXRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoYXJnOiB7IHNjYW5uZXI6IFNjYW5uZXJJbml0IH0pID0+IHZvaWR9IFRva2VuUGx1Z2luXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7KGFyZzogeyBzY2FubmVyOiBTY2FubmVySW5pdCwgcGFyc2VyOiBQYXJzZXJJbml0IH0pID0+IHZvaWR9IFBsdWdpblxuICovXG5cbi8qKlxuICogRGUtcmVnaXN0ZXIgYWxsIHBsdWdpbnMgYW5kIHJlc2V0IHRoZSBpbnRlcm5hbCBzdGF0ZS1tYWNoaW5lLiBVc2VkIGZvclxuICogdGVzdGluZzsgbm90IHJlcXVpcmVkIGluIHByYWN0aWNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIFN0YXRlLmdyb3VwcyA9IHt9O1xuICBJTklULnNjYW5uZXIgPSBudWxsO1xuICBJTklULnBhcnNlciA9IG51bGw7XG4gIElOSVQudG9rZW5RdWV1ZSA9IFtdO1xuICBJTklULnBsdWdpblF1ZXVlID0gW107XG4gIElOSVQuY3VzdG9tU2NoZW1lcyA9IFtdO1xuICBJTklULmluaXRpYWxpemVkID0gZmFsc2U7XG4gIHJldHVybiBJTklUO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgdG9rZW4gcGx1Z2luIHRvIGFsbG93IHRoZSBzY2FubmVyIHRvIHJlY29nbml6ZSBhZGRpdGlvbmFsIHRva2VuXG4gKiB0eXBlcyBiZWZvcmUgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGlzIGNvbnN0cnVjdGVkIGZyb20gdGhlIHJlc3VsdHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBvZiBwbHVnaW4gdG8gcmVnaXN0ZXJcbiAqIEBwYXJhbSB7VG9rZW5QbHVnaW59IHBsdWdpbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHNjYW5uZXIgc3RhdGUgbWFjaGluZVxuICogYW5kIGF2YWlsYWJsZSBzY2FubmVyIHRva2VucyBhbmQgY29sbGVjdGlvbnMgYW5kIGV4dGVuZHMgdGhlIHN0YXRlIG1hY2hpbmUgdG9cbiAqIHJlY29nbml6ZSBhZGRpdGlvbmFsIHRva2VucyBvciBncm91cHMuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVG9rZW5QbHVnaW4obmFtZSwgcGx1Z2luKSB7XG4gIGlmICh0eXBlb2YgcGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBsaW5raWZ5anM6IEludmFsaWQgdG9rZW4gcGx1Z2luICR7cGx1Z2lufSAoZXhwZWN0cyBmdW5jdGlvbilgKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IElOSVQudG9rZW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuYW1lID09PSBJTklULnRva2VuUXVldWVbaV1bMF0pIHtcbiAgICAgIHdhcm4oYGxpbmtpZnlqczogdG9rZW4gcGx1Z2luIFwiJHtuYW1lfVwiIGFscmVhZHkgcmVnaXN0ZXJlZCAtIHdpbGwgYmUgb3ZlcndyaXR0ZW5gKTtcbiAgICAgIElOSVQudG9rZW5RdWV1ZVtpXSA9IFtuYW1lLCBwbHVnaW5dO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBJTklULnRva2VuUXVldWUucHVzaChbbmFtZSwgcGx1Z2luXSk7XG4gIGlmIChJTklULmluaXRpYWxpemVkKSB7XG4gICAgd2FybihgbGlua2lmeWpzOiBhbHJlYWR5IGluaXRpYWxpemVkIC0gd2lsbCBub3QgcmVnaXN0ZXIgdG9rZW4gcGx1Z2luIFwiJHtuYW1lfVwiICR7d2FybkFkdmljZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbGlua2lmeSBwbHVnaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG9mIHBsdWdpbiB0byByZWdpc3RlclxuICogQHBhcmFtIHtQbHVnaW59IHBsdWdpbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHBhcnNlciBzdGF0ZSBtYWNoaW5lIGFuZFxuICogZXh0ZW5kcyB0aGUgcGFyc2VyIHRvIHJlY29nbml6ZSBhZGRpdGlvbmFsIGxpbmsgdHlwZXNcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4obmFtZSwgcGx1Z2luKSB7XG4gIGlmICh0eXBlb2YgcGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBsaW5raWZ5anM6IEludmFsaWQgcGx1Z2luICR7cGx1Z2lufSAoZXhwZWN0cyBmdW5jdGlvbilgKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IElOSVQucGx1Z2luUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmFtZSA9PT0gSU5JVC5wbHVnaW5RdWV1ZVtpXVswXSkge1xuICAgICAgd2FybihgbGlua2lmeWpzOiBwbHVnaW4gXCIke25hbWV9XCIgYWxyZWFkeSByZWdpc3RlcmVkIC0gd2lsbCBiZSBvdmVyd3JpdHRlbmApO1xuICAgICAgSU5JVC5wbHVnaW5RdWV1ZVtpXSA9IFtuYW1lLCBwbHVnaW5dO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBJTklULnBsdWdpblF1ZXVlLnB1c2goW25hbWUsIHBsdWdpbl0pO1xuICBpZiAoSU5JVC5pbml0aWFsaXplZCkge1xuICAgIHdhcm4oYGxpbmtpZnlqczogYWxyZWFkeSBpbml0aWFsaXplZCAtIHdpbGwgbm90IHJlZ2lzdGVyIHBsdWdpbiBcIiR7bmFtZX1cIiAke3dhcm5BZHZpY2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlY3QgVVJMcyB3aXRoIHRoZSBmb2xsb3dpbmcgYWRkaXRpb25hbCBwcm90b2NvbC4gQW55dGhpbmcgd2l0aCBmb3JtYXRcbiAqIFwicHJvdG9jb2w6Ly8uLi5cIiB3aWxsIGJlIGNvbnNpZGVyZWQgYSBsaW5rLiBJZiBgb3B0aW9uYWxTbGFzaFNsYXNoYCBpcyBzZXQgdG9cbiAqIGB0cnVlYCwgYW55dGhpbmcgd2l0aCBmb3JtYXQgXCJwcm90b2NvbDouLi5cIiB3aWxsIGJlIGNvbnNpZGVyZWQgYSBsaW5rLlxuICogQHBhcmFtIHtzdHJpbmd9IHNjaGVtZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9uYWxTbGFzaFNsYXNoXVxuICovXG5mdW5jdGlvbiByZWdpc3RlckN1c3RvbVByb3RvY29sKHNjaGVtZSwgb3B0aW9uYWxTbGFzaFNsYXNoID0gZmFsc2UpIHtcbiAgaWYgKElOSVQuaW5pdGlhbGl6ZWQpIHtcbiAgICB3YXJuKGBsaW5raWZ5anM6IGFscmVhZHkgaW5pdGlhbGl6ZWQgLSB3aWxsIG5vdCByZWdpc3RlciBjdXN0b20gc2NoZW1lIFwiJHtzY2hlbWV9XCIgJHt3YXJuQWR2aWNlfWApO1xuICB9XG4gIGlmICghL15bMC05YS16XSsoLVswLTlhLXpdKykqJC8udGVzdChzY2hlbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBsaW5raWZ5anM6IGluY29ycmVjdCBzY2hlbWUgZm9ybWF0LlxuMS4gTXVzdCBvbmx5IGNvbnRhaW4gZGlnaXRzLCBsb3dlcmNhc2UgQVNDSUkgbGV0dGVycyBvciBcIi1cIlxuMi4gQ2Fubm90IHN0YXJ0IG9yIGVuZCB3aXRoIFwiLVwiXG4zLiBcIi1cIiBjYW5ub3QgcmVwZWF0YCk7XG4gIH1cbiAgSU5JVC5jdXN0b21TY2hlbWVzLnB1c2goW3NjaGVtZSwgb3B0aW9uYWxTbGFzaFNsYXNoXSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgbGlua2lmeSBzdGF0ZSBtYWNoaW5lLiBDYWxsZWQgYXV0b21hdGljYWxseSB0aGUgZmlyc3QgdGltZVxuICogbGlua2lmeSBpcyBjYWxsZWQgb24gYSBzdHJpbmcsIGJ1dCBtYXkgYmUgY2FsbGVkIG1hbnVhbGx5IGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIC8vIEluaXRpYWxpemUgc2Nhbm5lciBzdGF0ZSBtYWNoaW5lIGFuZCBwbHVnaW5zXG4gIElOSVQuc2Nhbm5lciA9IGluaXQkMihJTklULmN1c3RvbVNjaGVtZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IElOSVQudG9rZW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIElOSVQudG9rZW5RdWV1ZVtpXVsxXSh7XG4gICAgICBzY2FubmVyOiBJTklULnNjYW5uZXJcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgcGFyc2VyIHN0YXRlIG1hY2hpbmUgYW5kIHBsdWdpbnNcbiAgSU5JVC5wYXJzZXIgPSBpbml0JDEoSU5JVC5zY2FubmVyLnRva2Vucyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSU5JVC5wbHVnaW5RdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIElOSVQucGx1Z2luUXVldWVbaV1bMV0oe1xuICAgICAgc2Nhbm5lcjogSU5JVC5zY2FubmVyLFxuICAgICAgcGFyc2VyOiBJTklULnBhcnNlclxuICAgIH0pO1xuICB9XG4gIElOSVQuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICByZXR1cm4gSU5JVDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBpbnRvIHRva2VucyB0aGF0IHJlcHJlc2VudCBsaW5rYWJsZSBhbmQgbm9uLWxpbmthYmxlIHN1Yi1jb21wb25lbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtNdWx0aVRva2VuW119IHRva2Vuc1xuICovXG5mdW5jdGlvbiB0b2tlbml6ZShzdHIpIHtcbiAgaWYgKCFJTklULmluaXRpYWxpemVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHJldHVybiBydW4oSU5JVC5wYXJzZXIuc3RhcnQsIHN0ciwgcnVuJDEoSU5JVC5zY2FubmVyLnN0YXJ0LCBzdHIpKTtcbn1cbnRva2VuaXplLnNjYW4gPSBydW4kMTsgLy8gZm9yIHRlc3RpbmdcblxuLyoqXG4gKiBGaW5kIGEgbGlzdCBvZiBsaW5rYWJsZSBpdGVtcyBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gZmluZCBsaW5rcyBpblxuICogQHBhcmFtIHtzdHJpbmcgfCBPcHRzfSBbdHlwZV0gZWl0aGVyIGZvcm1hdHRpbmcgb3B0aW9ucyBvciBzcGVjaWZpYyB0eXBlIG9mXG4gKiBsaW5rcyB0byBmaW5kLCBlLmcuLCAndXJsJyBvciAnZW1haWwnXG4gKiBAcGFyYW0ge09wdHN9IFtvcHRzXSBmb3JtYXR0aW5nIG9wdGlvbnMgZm9yIGZpbmFsIG91dHB1dC4gQ2Fubm90IGJlIHNwZWNpZmllZFxuICogaWYgb3B0cyBhbHJlYWR5IHByb3ZpZGVkIGluIGB0eXBlYCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBmaW5kKHN0ciwgdHlwZSA9IG51bGwsIG9wdHMgPSBudWxsKSB7XG4gIGlmICh0eXBlICYmIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChvcHRzKSB7XG4gICAgICB0aHJvdyBFcnJvcihgbGlua2lmeWpzOiBJbnZhbGlkIGxpbmsgdHlwZSAke3R5cGV9OyBtdXN0IGJlIGEgc3RyaW5nYCk7XG4gICAgfVxuICAgIG9wdHMgPSB0eXBlO1xuICAgIHR5cGUgPSBudWxsO1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBuZXcgT3B0aW9ucyhvcHRzKTtcbiAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoc3RyKTtcbiAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBpZiAodG9rZW4uaXNMaW5rICYmICghdHlwZSB8fCB0b2tlbi50ID09PSB0eXBlKSAmJiBvcHRpb25zLmNoZWNrKHRva2VuKSkge1xuICAgICAgZmlsdGVyZWQucHVzaCh0b2tlbi50b0Zvcm1hdHRlZE9iamVjdChvcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIHZhbGlkIGxpbmthYmxlIHRleHQgb2Ygc29tZSBzb3J0LiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdFxuICogdHJpbSB0aGUgdGV4dCBmb3IgeW91LlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBhIHNlY29uZCBgdHlwZWAgcGFyYW0sIHdoaWNoIGlzIHRoZSB0eXBlIG9mIGxpbmsgdG8gdGVzdFxuICogZm9yLlxuICpcbiAqIEZvciBleGFtcGxlLFxuICpcbiAqICAgICBsaW5raWZ5LnRlc3Qoc3RyLCAnZW1haWwnKTtcbiAqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBzdHIgaXMgYSB2YWxpZCBlbWFpbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIHRlc3QgZm9yIGxpbmtzXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIG9wdGlvbmFsIHNwZWNpZmljIGxpbmsgdHlwZSB0byBsb29rIGZvclxuICogQHJldHVybnMgYm9vbGVhbiB0cnVlL2ZhbHNlXG4gKi9cbmZ1bmN0aW9uIHRlc3Qoc3RyLCB0eXBlID0gbnVsbCkge1xuICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShzdHIpO1xuICByZXR1cm4gdG9rZW5zLmxlbmd0aCA9PT0gMSAmJiB0b2tlbnNbMF0uaXNMaW5rICYmICghdHlwZSB8fCB0b2tlbnNbMF0udCA9PT0gdHlwZSk7XG59XG5cbmV4cG9ydCB7IE11bHRpVG9rZW4sIE9wdGlvbnMsIFN0YXRlLCBjcmVhdGVUb2tlbkNsYXNzLCBmaW5kLCBpbml0LCBtdWx0aSwgb3B0aW9ucywgcmVnZXhwLCByZWdpc3RlckN1c3RvbVByb3RvY29sLCByZWdpc3RlclBsdWdpbiwgcmVnaXN0ZXJUb2tlblBsdWdpbiwgcmVzZXQsIHN0cmluZ1RvQXJyYXksIHRlc3QsIG11bHRpIGFzIHRleHQsIHRva2VuaXplIH07XG4iLCAiaW1wb3J0IHR5cGUgeyBQYXN0ZVJ1bGVNYXRjaCB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IE1hcmssIG1hcmtQYXN0ZVJ1bGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB0eXBlIHsgUGx1Z2luIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCB7IGZpbmQsIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wsIHJlc2V0IH0gZnJvbSAnbGlua2lmeWpzJ1xuXG5pbXBvcnQgeyBhdXRvbGluayB9IGZyb20gJy4vaGVscGVycy9hdXRvbGluay5qcydcbmltcG9ydCB7IGNsaWNrSGFuZGxlciB9IGZyb20gJy4vaGVscGVycy9jbGlja0hhbmRsZXIuanMnXG5pbXBvcnQgeyBwYXN0ZUhhbmRsZXIgfSBmcm9tICcuL2hlbHBlcnMvcGFzdGVIYW5kbGVyLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtQcm90b2NvbE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHByb3RvY29sIHNjaGVtZSB0byBiZSByZWdpc3RlcmVkLlxuICAgKiBAZGVmYXVsdCAnJydcbiAgICogQGV4YW1wbGUgJ2Z0cCdcbiAgICogQGV4YW1wbGUgJ2dpdCdcbiAgICovXG4gIHNjaGVtZTogc3RyaW5nXG5cbiAgLyoqXG4gICAqIElmIGVuYWJsZWQsIGl0IGFsbG93cyBvcHRpb25hbCBzbGFzaGVzIGFmdGVyIHRoZSBwcm90b2NvbC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgb3B0aW9uYWxTbGFzaGVzPzogYm9vbGVhblxufVxuXG5leHBvcnQgY29uc3QgcGFzdGVSZWdleCA9XG4gIC9odHRwcz86XFwvXFwvKD86d3d3XFwuKT9bLWEtekEtWjAtOUA6JS5fK34jPV17MSwyNTZ9XFwuW2EtekEtWl17Mix9XFxiKD86Wy1hLXpBLVowLTlAOiUuXyt+Iz0/ISYvXSopKD86Wy1hLXpBLVowLTlAOiUuXyt+Iz0/ISYvXSopL2dpXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgbm93IHRvIG9wZW4gbGlua3Mgd2hlbiB0aGUgZWRpdG9yIGlzIG5vdCBlZGl0YWJsZS5cbiAqL1xudHlwZSBEZXByZWNhdGVkT3BlbldoZW5Ob3RFZGl0YWJsZSA9ICd3aGVuTm90RWRpdGFibGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua09wdGlvbnMge1xuICAvKipcbiAgICogSWYgZW5hYmxlZCwgdGhlIGV4dGVuc2lvbiB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkIGxpbmtzIGFzIHlvdSB0eXBlLlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqIEBleGFtcGxlIGZhbHNlXG4gICAqL1xuICBhdXRvbGluazogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBjdXN0b20gcHJvdG9jb2xzIHRvIGJlIHJlZ2lzdGVyZWQgd2l0aCBsaW5raWZ5anMuXG4gICAqIEBkZWZhdWx0IFtdXG4gICAqIEBleGFtcGxlIFsnZnRwJywgJ2dpdCddXG4gICAqL1xuICBwcm90b2NvbHM6IEFycmF5PExpbmtQcm90b2NvbE9wdGlvbnMgfCBzdHJpbmc+XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcHJvdG9jb2wgdG8gdXNlIHdoZW4gbm8gcHJvdG9jb2wgaXMgc3BlY2lmaWVkLlxuICAgKiBAZGVmYXVsdCAnaHR0cCdcbiAgICovXG4gIGRlZmF1bHRQcm90b2NvbDogc3RyaW5nXG4gIC8qKlxuICAgKiBJZiBlbmFibGVkLCBsaW5rcyB3aWxsIGJlIG9wZW5lZCBvbiBjbGljay5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgb3Blbk9uQ2xpY2s6IGJvb2xlYW4gfCBEZXByZWNhdGVkT3BlbldoZW5Ob3RFZGl0YWJsZVxuICAvKipcbiAgICogQWRkcyBhIGxpbmsgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlmIHRoZSBwYXN0ZWQgY29udGVudCBvbmx5IGNvbnRhaW5zIGFuIHVybC5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgbGlua09uUGFzdGU6IGJvb2xlYW5cblxuICAvKipcbiAgICogSFRNTCBhdHRyaWJ1dGVzIHRvIGFkZCB0byB0aGUgbGluayBlbGVtZW50LlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAZXhhbXBsZSB7IGNsYXNzOiAnZm9vJyB9XG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGBzaG91bGRBdXRvTGlua2Agb3B0aW9uIGluc3RlYWQuXG4gICAqIEEgdmFsaWRhdGlvbiBmdW5jdGlvbiB0aGF0IG1vZGlmaWVzIGxpbmsgdmVyaWZpY2F0aW9uIGZvciB0aGUgYXV0byBsaW5rZXIuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgdXJsIHRvIGJlIHZhbGlkYXRlZC5cbiAgICogQHJldHVybnMgLSBUcnVlIGlmIHRoZSB1cmwgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIHZhbGlkYXRlOiAodXJsOiBzdHJpbmcpID0+IGJvb2xlYW5cblxuICAvKipcbiAgICogQSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHdoaWNoIGlzIHVzZWQgZm9yIGNvbmZpZ3VyaW5nIGxpbmsgdmVyaWZpY2F0aW9uIGZvciBwcmV2ZW50aW5nIFhTUyBhdHRhY2tzLlxuICAgKiBPbmx5IG1vZGlmeSB0aGlzIGlmIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBVUkwgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpc0FsbG93ZWRVcmk6ICh1cmwsIHsgZGVmYXVsdFZhbGlkYXRlLCBwcm90b2NvbHMsIGRlZmF1bHRQcm90b2NvbCB9KSA9PiB7XG4gICAqIHJldHVybiB1cmwuc3RhcnRzV2l0aCgnLi8nKSB8fCBkZWZhdWx0VmFsaWRhdGUodXJsKVxuICAgKiB9XG4gICAqL1xuICBpc0FsbG93ZWRVcmk6IChcbiAgICAvKipcbiAgICAgKiBUaGUgVVJMIHRvIGJlIHZhbGlkYXRlZC5cbiAgICAgKi9cbiAgICB1cmw6IHN0cmluZyxcbiAgICBjdHg6IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRlZmF1bHQgdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAgICAgICAqL1xuICAgICAgZGVmYXVsdFZhbGlkYXRlOiAodXJsOiBzdHJpbmcpID0+IGJvb2xlYW5cbiAgICAgIC8qKlxuICAgICAgICogQW4gYXJyYXkgb2YgYWxsb3dlZCBwcm90b2NvbHMgZm9yIHRoZSBVUkwgKGUuZy4sIFwiaHR0cFwiLCBcImh0dHBzXCIpLiBBcyBkZWZpbmVkIGluIHRoZSBgcHJvdG9jb2xzYCBvcHRpb24uXG4gICAgICAgKi9cbiAgICAgIHByb3RvY29sczogQXJyYXk8TGlua1Byb3RvY29sT3B0aW9ucyB8IHN0cmluZz5cbiAgICAgIC8qKlxuICAgICAgICogQSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBkZWZhdWx0IHByb3RvY29sIChlLmcuLCAnaHR0cCcpLiBBcyBkZWZpbmVkIGluIHRoZSBgZGVmYXVsdFByb3RvY29sYCBvcHRpb24uXG4gICAgICAgKi9cbiAgICAgIGRlZmF1bHRQcm90b2NvbDogc3RyaW5nXG4gICAgfSxcbiAgKSA9PiBib29sZWFuXG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHZhbGlkIGxpbmsgc2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgbGlua2VkIGluIHRoZSBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBsaW5rIHNob3VsZCBiZSBhdXRvLWxpbmtlZDsgZmFsc2UgaWYgaXQgc2hvdWxkIG5vdCBiZSBhdXRvLWxpbmtlZC5cbiAgICovXG4gIHNob3VsZEF1dG9MaW5rOiAodXJsOiBzdHJpbmcpID0+IGJvb2xlYW5cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIGxpbms6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgbGluayBtYXJrXG4gICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgbGluayBhdHRyaWJ1dGVzXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0TGluayh7IGhyZWY6ICdodHRwczovL3RpcHRhcC5kZXYnIH0pXG4gICAgICAgKi9cbiAgICAgIHNldExpbms6IChhdHRyaWJ1dGVzOiB7XG4gICAgICAgIGhyZWY6IHN0cmluZ1xuICAgICAgICB0YXJnZXQ/OiBzdHJpbmcgfCBudWxsXG4gICAgICAgIHJlbD86IHN0cmluZyB8IG51bGxcbiAgICAgICAgY2xhc3M/OiBzdHJpbmcgfCBudWxsXG4gICAgICB9KSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGxpbmsgbWFya1xuICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGxpbmsgYXR0cmlidXRlc1xuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUxpbmsoeyBocmVmOiAnaHR0cHM6Ly90aXB0YXAuZGV2JyB9KVxuICAgICAgICovXG4gICAgICB0b2dnbGVMaW5rOiAoYXR0cmlidXRlczoge1xuICAgICAgICBocmVmOiBzdHJpbmdcbiAgICAgICAgdGFyZ2V0Pzogc3RyaW5nIHwgbnVsbFxuICAgICAgICByZWw/OiBzdHJpbmcgfCBudWxsXG4gICAgICAgIGNsYXNzPzogc3RyaW5nIHwgbnVsbFxuICAgICAgfSkgPT4gUmV0dXJuVHlwZVxuICAgICAgLyoqXG4gICAgICAgKiBVbnNldCBhIGxpbmsgbWFya1xuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnVuc2V0TGluaygpXG4gICAgICAgKi9cbiAgICAgIHVuc2V0TGluazogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG4vLyBGcm9tIERPTVB1cmlmeVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2N1cmU1My9ET01QdXJpZnkvYmxvYi9tYWluL3NyYy9yZWdleHAuanNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5jb25zdCBBVFRSX1dISVRFU1BBQ0UgPSAvW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNUZcXHUzMDAwXS9nXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FsbG93ZWRVcmkodXJpOiBzdHJpbmcgfCB1bmRlZmluZWQsIHByb3RvY29scz86IExpbmtPcHRpb25zWydwcm90b2NvbHMnXSkge1xuICBjb25zdCBhbGxvd2VkUHJvdG9jb2xzOiBzdHJpbmdbXSA9IFsnaHR0cCcsICdodHRwcycsICdmdHAnLCAnZnRwcycsICdtYWlsdG8nLCAndGVsJywgJ2NhbGx0bycsICdzbXMnLCAnY2lkJywgJ3htcHAnXVxuXG4gIGlmIChwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMuZm9yRWFjaChwcm90b2NvbCA9PiB7XG4gICAgICBjb25zdCBuZXh0UHJvdG9jb2wgPSB0eXBlb2YgcHJvdG9jb2wgPT09ICdzdHJpbmcnID8gcHJvdG9jb2wgOiBwcm90b2NvbC5zY2hlbWVcblxuICAgICAgaWYgKG5leHRQcm90b2NvbCkge1xuICAgICAgICBhbGxvd2VkUHJvdG9jb2xzLnB1c2gobmV4dFByb3RvY29sKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gKFxuICAgICF1cmkgfHxcbiAgICB1cmkucmVwbGFjZShBVFRSX1dISVRFU1BBQ0UsICcnKS5tYXRjaChcbiAgICAgIG5ldyBSZWdFeHAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgICAgICBgXig/Oig/OiR7YWxsb3dlZFByb3RvY29scy5qb2luKCd8Jyl9KTp8W15hLXpdfFthLXowLTkrLlxcLV0rKD86W15hLXorLlxcLTpdfCQpKWAsXG4gICAgICAgICdpJyxcbiAgICAgICksXG4gICAgKVxuICApXG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgbGlua3MuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL2xpbmtcbiAqL1xuZXhwb3J0IGNvbnN0IExpbmsgPSBNYXJrLmNyZWF0ZTxMaW5rT3B0aW9ucz4oe1xuICBuYW1lOiAnbGluaycsXG5cbiAgcHJpb3JpdHk6IDEwMDAsXG5cbiAga2VlcE9uU3BsaXQ6IGZhbHNlLFxuXG4gIGV4aXRhYmxlOiB0cnVlLFxuXG4gIG9uQ3JlYXRlKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGUgJiYgIXRoaXMub3B0aW9ucy5zaG91bGRBdXRvTGluaykge1xuICAgICAgLy8gQ29weSB0aGUgdmFsaWRhdGUgZnVuY3Rpb24gdG8gdGhlIHNob3VsZEF1dG9MaW5rIG9wdGlvblxuICAgICAgdGhpcy5vcHRpb25zLnNob3VsZEF1dG9MaW5rID0gdGhpcy5vcHRpb25zLnZhbGlkYXRlXG4gICAgICBjb25zb2xlLndhcm4oJ1RoZSBgdmFsaWRhdGVgIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBSZW5hbWUgdG8gdGhlIGBzaG91bGRBdXRvTGlua2Agb3B0aW9uIGluc3RlYWQuJylcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLnByb3RvY29scy5mb3JFYWNoKHByb3RvY29sID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wocHJvdG9jb2wpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmVnaXN0ZXJDdXN0b21Qcm90b2NvbChwcm90b2NvbC5zY2hlbWUsIHByb3RvY29sLm9wdGlvbmFsU2xhc2hlcylcbiAgICB9KVxuICB9LFxuXG4gIG9uRGVzdHJveSgpIHtcbiAgICByZXNldCgpXG4gIH0sXG5cbiAgaW5jbHVzaXZlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXV0b2xpbmtcbiAgfSxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuT25DbGljazogdHJ1ZSxcbiAgICAgIGxpbmtPblBhc3RlOiB0cnVlLFxuICAgICAgYXV0b2xpbms6IHRydWUsXG4gICAgICBwcm90b2NvbHM6IFtdLFxuICAgICAgZGVmYXVsdFByb3RvY29sOiAnaHR0cCcsXG4gICAgICBIVE1MQXR0cmlidXRlczoge1xuICAgICAgICB0YXJnZXQ6ICdfYmxhbmsnLFxuICAgICAgICByZWw6ICdub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93JyxcbiAgICAgICAgY2xhc3M6IG51bGwsXG4gICAgICB9LFxuICAgICAgaXNBbGxvd2VkVXJpOiAodXJsLCBjdHgpID0+ICEhaXNBbGxvd2VkVXJpKHVybCwgY3R4LnByb3RvY29scyksXG4gICAgICB2YWxpZGF0ZTogdXJsID0+ICEhdXJsLFxuICAgICAgc2hvdWxkQXV0b0xpbms6IHVybCA9PiAhIXVybCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHJlZjoge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUwoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdGFyZ2V0OiB7XG4gICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcy50YXJnZXQsXG4gICAgICB9LFxuICAgICAgcmVsOiB7XG4gICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcy5yZWwsXG4gICAgICB9LFxuICAgICAgY2xhc3M6IHtcbiAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLmNsYXNzLFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2FbaHJlZl0nLFxuICAgICAgICBnZXRBdHRyczogZG9tID0+IHtcbiAgICAgICAgICBjb25zdCBocmVmID0gKGRvbSBhcyBIVE1MRWxlbWVudCkuZ2V0QXR0cmlidXRlKCdocmVmJylcblxuICAgICAgICAgIC8vIHByZXZlbnQgWFNTIGF0dGFja3NcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhaHJlZiB8fFxuICAgICAgICAgICAgIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaHJlZiwge1xuICAgICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6IHVybCA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgLy8gcHJldmVudCBYU1MgYXR0YWNrc1xuICAgIGlmIChcbiAgICAgICF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKEhUTUxBdHRyaWJ1dGVzLmhyZWYsIHtcbiAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiBocmVmID0+ICEhaXNBbGxvd2VkVXJpKGhyZWYsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbCxcbiAgICAgIH0pXG4gICAgKSB7XG4gICAgICAvLyBzdHJpcCBvdXQgdGhlIGhyZWZcbiAgICAgIHJldHVybiBbJ2EnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCB7IC4uLkhUTUxBdHRyaWJ1dGVzLCBocmVmOiAnJyB9KSwgMF1cbiAgICB9XG5cbiAgICByZXR1cm4gWydhJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRMaW5rOlxuICAgICAgICBhdHRyaWJ1dGVzID0+XG4gICAgICAgICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGhyZWYgfSA9IGF0dHJpYnV0ZXNcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKGhyZWYsIHtcbiAgICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiB1cmwgPT4gISFpc0FsbG93ZWRVcmkodXJsLCB0aGlzLm9wdGlvbnMucHJvdG9jb2xzKSxcbiAgICAgICAgICAgICAgcHJvdG9jb2xzOiB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLFxuICAgICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNoYWluKCkuc2V0TWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpLnNldE1ldGEoJ3ByZXZlbnRBdXRvbGluaycsIHRydWUpLnJ1bigpXG4gICAgICAgIH0sXG5cbiAgICAgIHRvZ2dsZUxpbms6XG4gICAgICAgIGF0dHJpYnV0ZXMgPT5cbiAgICAgICAgKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgaHJlZiB9ID0gYXR0cmlidXRlc1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaHJlZiwge1xuICAgICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6IHVybCA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAgICAgLnRvZ2dsZU1hcmsodGhpcy5uYW1lLCBhdHRyaWJ1dGVzLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlOiB0cnVlIH0pXG4gICAgICAgICAgICAuc2V0TWV0YSgncHJldmVudEF1dG9saW5rJywgdHJ1ZSlcbiAgICAgICAgICAgIC5ydW4oKVxuICAgICAgICB9LFxuXG4gICAgICB1bnNldExpbms6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4oKS51bnNldE1hcmsodGhpcy5uYW1lLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlOiB0cnVlIH0pLnNldE1ldGEoJ3ByZXZlbnRBdXRvbGluaycsIHRydWUpLnJ1bigpXG4gICAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiB0ZXh0ID0+IHtcbiAgICAgICAgICBjb25zdCBmb3VuZExpbmtzOiBQYXN0ZVJ1bGVNYXRjaFtdID0gW11cblxuICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3RvY29scywgZGVmYXVsdFByb3RvY29sIH0gPSB0aGlzLm9wdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gZmluZCh0ZXh0KS5maWx0ZXIoXG4gICAgICAgICAgICAgIGl0ZW0gPT5cbiAgICAgICAgICAgICAgICBpdGVtLmlzTGluayAmJlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaXRlbS52YWx1ZSwge1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiBocmVmID0+ICEhaXNBbGxvd2VkVXJpKGhyZWYsIHByb3RvY29scyksXG4gICAgICAgICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbGlua3MuZm9yRWFjaChsaW5rID0+XG4gICAgICAgICAgICAgICAgZm91bmRMaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmsudmFsdWUsXG4gICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZixcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBpbmRleDogbGluay5zdGFydCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmb3VuZExpbmtzXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBocmVmOiBtYXRjaC5kYXRhPy5ocmVmLFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgY29uc3QgcGx1Z2luczogUGx1Z2luW10gPSBbXVxuICAgIGNvbnN0IHsgcHJvdG9jb2xzLCBkZWZhdWx0UHJvdG9jb2wgfSA9IHRoaXMub3B0aW9uc1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvbGluaykge1xuICAgICAgcGx1Z2lucy5wdXNoKFxuICAgICAgICBhdXRvbGluayh7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbCxcbiAgICAgICAgICB2YWxpZGF0ZTogdXJsID0+XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKHVybCwge1xuICAgICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6IGhyZWYgPT4gISFpc0FsbG93ZWRVcmkoaHJlZiwgcHJvdG9jb2xzKSxcbiAgICAgICAgICAgICAgcHJvdG9jb2xzLFxuICAgICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICBzaG91bGRBdXRvTGluazogdGhpcy5vcHRpb25zLnNob3VsZEF1dG9MaW5rLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9wZW5PbkNsaWNrID09PSB0cnVlKSB7XG4gICAgICBwbHVnaW5zLnB1c2goXG4gICAgICAgIGNsaWNrSGFuZGxlcih7XG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbmtPblBhc3RlKSB7XG4gICAgICBwbHVnaW5zLnB1c2goXG4gICAgICAgIHBhc3RlSGFuZGxlcih7XG4gICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luc1xuICB9LFxufSlcbiIsICJpbXBvcnQgdHlwZSB7IE5vZGVXaXRoUG9zIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgY29tYmluZVRyYW5zYWN0aW9uU3RlcHMsIGZpbmRDaGlsZHJlbkluUmFuZ2UsIGdldENoYW5nZWRSYW5nZXMsIGdldE1hcmtzQmV0d2VlbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB0eXBlIHsgTWFya1R5cGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHR5cGUgeyBNdWx0aVRva2VuIH0gZnJvbSAnbGlua2lmeWpzJ1xuaW1wb3J0IHsgdG9rZW5pemUgfSBmcm9tICdsaW5raWZ5anMnXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHByb3ZpZGVkIHRva2VucyBmb3JtIGEgdmFsaWQgbGluayBzdHJ1Y3R1cmUsIHdoaWNoIGNhbiBlaXRoZXIgYmUgYSBzaW5nbGUgbGluayB0b2tlblxuICogb3IgYSBsaW5rIHRva2VuIHN1cnJvdW5kZWQgYnkgcGFyZW50aGVzZXMgb3Igc3F1YXJlIGJyYWNrZXRzLlxuICpcbiAqIFRoaXMgZW5zdXJlcyB0aGF0IG9ubHkgY29tcGxldGUgYW5kIHZhbGlkIHRleHQgaXMgaHlwZXJsaW5rZWQsIHByZXZlbnRpbmcgY2FzZXMgd2hlcmUgYSB2YWxpZFxuICogdG9wLWxldmVsIGRvbWFpbiAoVExEKSBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBpbnZhbGlkIGNoYXJhY3RlciwgbGlrZSBhIG51bWJlci4gRm9yXG4gKiBleGFtcGxlLCB3aXRoIHRoZSBgZmluZGAgbWV0aG9kIGZyb20gTGlua2lmeSwgZW50ZXJpbmcgYGV4YW1wbGUuY29tMWAgd291bGQgcmVzdWx0IGluXG4gKiBgZXhhbXBsZS5jb21gIGJlaW5nIGxpbmtlZCBhbmQgdGhlIHRyYWlsaW5nIGAxYCBsZWZ0IGFzIHBsYWluIHRleHQuIEJ5IHVzaW5nIHRoZSBgdG9rZW5pemVgXG4gKiBtZXRob2QsIHdlIGNhbiBwZXJmb3JtIG1vcmUgY29tcHJlaGVuc2l2ZSB2YWxpZGF0aW9uIG9uIHRoZSBpbnB1dCB0ZXh0LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkTGlua1N0cnVjdHVyZSh0b2tlbnM6IEFycmF5PFJldHVyblR5cGU8TXVsdGlUb2tlblsndG9PYmplY3QnXT4+KSB7XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRva2Vuc1swXS5pc0xpbmtcbiAgfVxuXG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAzICYmIHRva2Vuc1sxXS5pc0xpbmspIHtcbiAgICByZXR1cm4gWycoKScsICdbXSddLmluY2x1ZGVzKHRva2Vuc1swXS52YWx1ZSArIHRva2Vuc1syXS52YWx1ZSlcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG50eXBlIEF1dG9saW5rT3B0aW9ucyA9IHtcbiAgdHlwZTogTWFya1R5cGVcbiAgZGVmYXVsdFByb3RvY29sOiBzdHJpbmdcbiAgdmFsaWRhdGU6ICh1cmw6IHN0cmluZykgPT4gYm9vbGVhblxuICBzaG91bGRBdXRvTGluazogKHVybDogc3RyaW5nKSA9PiBib29sZWFuXG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gYWxsb3dzIHlvdSB0byBhdXRvbWF0aWNhbGx5IGFkZCBsaW5rcyB0byB5b3VyIGVkaXRvci5cbiAqIEBwYXJhbSBvcHRpb25zIFRoZSBwbHVnaW4gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIHBsdWdpbiBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXV0b2xpbmsob3B0aW9uczogQXV0b2xpbmtPcHRpb25zKTogUGx1Z2luIHtcbiAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgIGtleTogbmV3IFBsdWdpbktleSgnYXV0b2xpbmsnKSxcbiAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIERvZXMgdGhlIHRyYW5zYWN0aW9uIGNoYW5nZSB0aGUgZG9jdW1lbnQ/XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkKSAmJiAhb2xkU3RhdGUuZG9jLmVxKG5ld1N0YXRlLmRvYylcblxuICAgICAgLyoqXG4gICAgICAgKiBQcmV2ZW50IGF1dG9saW5rIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBub3QgYSBkb2N1bWVudCBjaGFuZ2Ugb3IgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyB0aGUgbWV0YSBgcHJldmVudEF1dG9saW5rYC5cbiAgICAgICAqL1xuICAgICAgY29uc3QgcHJldmVudEF1dG9saW5rID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZ2V0TWV0YSgncHJldmVudEF1dG9saW5rJykpXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJldmVudCBhdXRvbGluayBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgbm90IGEgZG9jdW1lbnQgY2hhbmdlXG4gICAgICAgKiBvciBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIHRoZSBtZXRhIGBwcmV2ZW50QXV0b2xpbmtgLlxuICAgICAgICovXG4gICAgICBpZiAoIWRvY0NoYW5nZXMgfHwgcHJldmVudEF1dG9saW5rKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHRyIH0gPSBuZXdTdGF0ZVxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gY29tYmluZVRyYW5zYWN0aW9uU3RlcHMob2xkU3RhdGUuZG9jLCBbLi4udHJhbnNhY3Rpb25zXSlcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSBnZXRDaGFuZ2VkUmFuZ2VzKHRyYW5zZm9ybSlcblxuICAgICAgY2hhbmdlcy5mb3JFYWNoKCh7IG5ld1JhbmdlIH0pID0+IHtcbiAgICAgICAgLy8gTm93IGxldOKAmXMgc2VlIGlmIHdlIGNhbiBhZGQgbmV3IGxpbmtzLlxuICAgICAgICBjb25zdCBub2Rlc0luQ2hhbmdlZFJhbmdlcyA9IGZpbmRDaGlsZHJlbkluUmFuZ2UobmV3U3RhdGUuZG9jLCBuZXdSYW5nZSwgbm9kZSA9PiBub2RlLmlzVGV4dGJsb2NrKVxuXG4gICAgICAgIGxldCB0ZXh0QmxvY2s6IE5vZGVXaXRoUG9zIHwgdW5kZWZpbmVkXG4gICAgICAgIGxldCB0ZXh0QmVmb3JlV2hpdGVzcGFjZTogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKG5vZGVzSW5DaGFuZ2VkUmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBHcmFiIHRoZSBmaXJzdCBub2RlIHdpdGhpbiB0aGUgY2hhbmdlZCByYW5nZXMgKGV4LiB0aGUgZmlyc3Qgb2YgdHdvIHBhcmFncmFwaHMgd2hlbiBoaXR0aW5nIGVudGVyKS5cbiAgICAgICAgICB0ZXh0QmxvY2sgPSBub2Rlc0luQ2hhbmdlZFJhbmdlc1swXVxuICAgICAgICAgIHRleHRCZWZvcmVXaGl0ZXNwYWNlID0gbmV3U3RhdGUuZG9jLnRleHRCZXR3ZWVuKFxuICAgICAgICAgICAgdGV4dEJsb2NrLnBvcyxcbiAgICAgICAgICAgIHRleHRCbG9jay5wb3MgKyB0ZXh0QmxvY2subm9kZS5ub2RlU2l6ZSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICcgJyxcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgbm9kZXNJbkNoYW5nZWRSYW5nZXMubGVuZ3RoICYmXG4gICAgICAgICAgLy8gV2Ugd2FudCB0byBtYWtlIHN1cmUgdG8gaW5jbHVkZSB0aGUgYmxvY2sgc2VwZXJhdG9yIGFyZ3VtZW50IHRvIHRyZWF0IGhhcmQgYnJlYWtzIGxpa2Ugc3BhY2VzLlxuICAgICAgICAgIG5ld1N0YXRlLmRvYy50ZXh0QmV0d2VlbihuZXdSYW5nZS5mcm9tLCBuZXdSYW5nZS50bywgJyAnLCAnICcpLmVuZHNXaXRoKCcgJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGV4dEJsb2NrID0gbm9kZXNJbkNoYW5nZWRSYW5nZXNbMF1cbiAgICAgICAgICB0ZXh0QmVmb3JlV2hpdGVzcGFjZSA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2Vlbih0ZXh0QmxvY2sucG9zLCBuZXdSYW5nZS50bywgdW5kZWZpbmVkLCAnICcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dEJsb2NrICYmIHRleHRCZWZvcmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgY29uc3Qgd29yZHNCZWZvcmVXaGl0ZXNwYWNlID0gdGV4dEJlZm9yZVdoaXRlc3BhY2Uuc3BsaXQoJyAnKS5maWx0ZXIocyA9PiBzICE9PSAnJylcblxuICAgICAgICAgIGlmICh3b3Jkc0JlZm9yZVdoaXRlc3BhY2UubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGxhc3RXb3JkQmVmb3JlU3BhY2UgPSB3b3Jkc0JlZm9yZVdoaXRlc3BhY2Vbd29yZHNCZWZvcmVXaGl0ZXNwYWNlLmxlbmd0aCAtIDFdXG4gICAgICAgICAgY29uc3QgbGFzdFdvcmRBbmRCbG9ja09mZnNldCA9IHRleHRCbG9jay5wb3MgKyB0ZXh0QmVmb3JlV2hpdGVzcGFjZS5sYXN0SW5kZXhPZihsYXN0V29yZEJlZm9yZVNwYWNlKVxuXG4gICAgICAgICAgaWYgKCFsYXN0V29yZEJlZm9yZVNwYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBsaW5rc0JlZm9yZVNwYWNlID0gdG9rZW5pemUobGFzdFdvcmRCZWZvcmVTcGFjZSkubWFwKHQgPT4gdC50b09iamVjdChvcHRpb25zLmRlZmF1bHRQcm90b2NvbCkpXG5cbiAgICAgICAgICBpZiAoIWlzVmFsaWRMaW5rU3RydWN0dXJlKGxpbmtzQmVmb3JlU3BhY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5rc0JlZm9yZVNwYWNlXG4gICAgICAgICAgICAuZmlsdGVyKGxpbmsgPT4gbGluay5pc0xpbmspXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgbGluayBwb3NpdGlvbi5cbiAgICAgICAgICAgIC5tYXAobGluayA9PiAoe1xuICAgICAgICAgICAgICAuLi5saW5rLFxuICAgICAgICAgICAgICBmcm9tOiBsYXN0V29yZEFuZEJsb2NrT2Zmc2V0ICsgbGluay5zdGFydCArIDEsXG4gICAgICAgICAgICAgIHRvOiBsYXN0V29yZEFuZEJsb2NrT2Zmc2V0ICsgbGluay5lbmQgKyAxLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAvLyBpZ25vcmUgbGluayBpbnNpZGUgY29kZSBtYXJrXG4gICAgICAgICAgICAuZmlsdGVyKGxpbmsgPT4ge1xuICAgICAgICAgICAgICBpZiAoIW5ld1N0YXRlLnNjaGVtYS5tYXJrcy5jb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiAhbmV3U3RhdGUuZG9jLnJhbmdlSGFzTWFyayhsaW5rLmZyb20sIGxpbmsudG8sIG5ld1N0YXRlLnNjaGVtYS5tYXJrcy5jb2RlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlIGxpbmtcbiAgICAgICAgICAgIC5maWx0ZXIobGluayA9PiBvcHRpb25zLnZhbGlkYXRlKGxpbmsudmFsdWUpKVxuICAgICAgICAgICAgLy8gY2hlY2sgd2hldGhlciBzaG91bGQgYXV0b2xpbmtcbiAgICAgICAgICAgIC5maWx0ZXIobGluayA9PiBvcHRpb25zLnNob3VsZEF1dG9MaW5rKGxpbmsudmFsdWUpKVxuICAgICAgICAgICAgLy8gQWRkIGxpbmsgbWFyay5cbiAgICAgICAgICAgIC5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgICBpZiAoZ2V0TWFya3NCZXR3ZWVuKGxpbmsuZnJvbSwgbGluay50bywgbmV3U3RhdGUuZG9jKS5zb21lKGl0ZW0gPT4gaXRlbS5tYXJrLnR5cGUgPT09IG9wdGlvbnMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRyLmFkZE1hcmsoXG4gICAgICAgICAgICAgICAgbGluay5mcm9tLFxuICAgICAgICAgICAgICAgIGxpbmsudG8sXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICBocmVmOiBsaW5rLmhyZWYsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmICghdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB7IGdldEF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgdHlwZSB7IE1hcmtUeXBlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxudHlwZSBDbGlja0hhbmRsZXJPcHRpb25zID0ge1xuICB0eXBlOiBNYXJrVHlwZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpY2tIYW5kbGVyKG9wdGlvbnM6IENsaWNrSGFuZGxlck9wdGlvbnMpOiBQbHVnaW4ge1xuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAga2V5OiBuZXcgUGx1Z2luS2V5KCdoYW5kbGVDbGlja0xpbmsnKSxcbiAgICBwcm9wczoge1xuICAgICAgaGFuZGxlQ2xpY2s6ICh2aWV3LCBwb3MsIGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmlldy5lZGl0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxpbms6IEhUTUxBbmNob3JFbGVtZW50IHwgbnVsbCA9IG51bGxcblxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQpIHtcbiAgICAgICAgICBsaW5rID0gZXZlbnQudGFyZ2V0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGEgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcbiAgICAgICAgICBjb25zdCBlbHMgPSBbXVxuXG4gICAgICAgICAgd2hpbGUgKGEubm9kZU5hbWUgIT09ICdESVYnKSB7XG4gICAgICAgICAgICBlbHMucHVzaChhKVxuICAgICAgICAgICAgYSA9IGEucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5rID0gZWxzLmZpbmQodmFsdWUgPT4gdmFsdWUubm9kZU5hbWUgPT09ICdBJykgYXMgSFRNTEFuY2hvckVsZW1lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXR0cnMgPSBnZXRBdHRyaWJ1dGVzKHZpZXcuc3RhdGUsIG9wdGlvbnMudHlwZS5uYW1lKVxuICAgICAgICBjb25zdCBocmVmID0gbGluaz8uaHJlZiA/PyBhdHRycy5ocmVmXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGxpbms/LnRhcmdldCA/PyBhdHRycy50YXJnZXRcblxuICAgICAgICBpZiAobGluayAmJiBocmVmKSB7XG4gICAgICAgICAgd2luZG93Lm9wZW4oaHJlZiwgdGFyZ2V0KVxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSxcbiAgICB9LFxuICB9KVxufVxuIiwgImltcG9ydCB0eXBlIHsgRWRpdG9yIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHR5cGUgeyBNYXJrVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBmaW5kIH0gZnJvbSAnbGlua2lmeWpzJ1xuXG50eXBlIFBhc3RlSGFuZGxlck9wdGlvbnMgPSB7XG4gIGVkaXRvcjogRWRpdG9yXG4gIGRlZmF1bHRQcm90b2NvbDogc3RyaW5nXG4gIHR5cGU6IE1hcmtUeXBlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXN0ZUhhbmRsZXIob3B0aW9uczogUGFzdGVIYW5kbGVyT3B0aW9ucyk6IFBsdWdpbiB7XG4gIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2hhbmRsZVBhc3RlTGluaycpLFxuICAgIHByb3BzOiB7XG4gICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIGV2ZW50LCBzbGljZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSB2aWV3XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgICAgICBjb25zdCB7IGVtcHR5IH0gPSBzZWxlY3Rpb25cblxuICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0ZXh0Q29udGVudCA9ICcnXG5cbiAgICAgICAgc2xpY2UuY29udGVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgIHRleHRDb250ZW50ICs9IG5vZGUudGV4dENvbnRlbnRcbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBsaW5rID0gZmluZCh0ZXh0Q29udGVudCwgeyBkZWZhdWx0UHJvdG9jb2w6IG9wdGlvbnMuZGVmYXVsdFByb3RvY29sIH0pLmZpbmQoXG4gICAgICAgICAgaXRlbSA9PiBpdGVtLmlzTGluayAmJiBpdGVtLnZhbHVlID09PSB0ZXh0Q29udGVudCxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmICghdGV4dENvbnRlbnQgfHwgIWxpbmspIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zLmVkaXRvci5jb21tYW5kcy5zZXRNYXJrKG9wdGlvbnMudHlwZSwge1xuICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZixcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgfSxcbiAgfSlcbn1cbiIsICJpbXBvcnQgeyBMaW5rIH0gZnJvbSAnLi9saW5rLmpzJ1xuXG5leHBvcnQgKiBmcm9tICcuL2xpbmsuanMnXG5cbmV4cG9ydCBkZWZhdWx0IExpbmtcbiIsICJpbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5jb25zdCBMaXN0SXRlbU5hbWUgPSAnbGlzdEl0ZW0nXG5jb25zdCBUZXh0U3R5bGVOYW1lID0gJ3RleHRTdHlsZSdcblxuZXhwb3J0IGludGVyZmFjZSBCdWxsZXRMaXN0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgbm9kZSBuYW1lIGZvciB0aGUgbGlzdCBpdGVtc1xuICAgKiBAZGVmYXVsdCAnbGlzdEl0ZW0nXG4gICAqIEBleGFtcGxlICdwYXJhZ3JhcGgnXG4gICAqL1xuICBpdGVtVHlwZU5hbWU6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBIVE1MIGF0dHJpYnV0ZXMgdG8gYWRkIHRvIHRoZSBidWxsZXQgbGlzdCBlbGVtZW50XG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBleGFtcGxlIHsgY2xhc3M6ICdmb28nIH1cbiAgICovXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5cbiAgLyoqXG4gICAqIEtlZXAgdGhlIG1hcmtzIHdoZW4gc3BsaXR0aW5nIHRoZSBsaXN0XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGtlZXBNYXJrczogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBLZWVwIHRoZSBhdHRyaWJ1dGVzIHdoZW4gc3BsaXR0aW5nIHRoZSBsaXN0XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGtlZXBBdHRyaWJ1dGVzOiBib29sZWFuXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBidWxsZXRMaXN0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIGJ1bGxldCBsaXN0XG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUJ1bGxldExpc3Q6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYXRjaGVzIGEgYnVsbGV0IGxpc3QgdG8gYSBkYXNoIG9yIGFzdGVyaXNrLlxuICovXG5leHBvcnQgY29uc3QgYnVsbGV0TGlzdElucHV0UmVnZXggPSAvXlxccyooWy0rKl0pXFxzJC9cblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBidWxsZXQgbGlzdHMuXG4gKiBUaGlzIHJlcXVpcmVzIHRoZSBMaXN0SXRlbSBleHRlbnNpb25cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9ub2Rlcy9idWxsZXQtbGlzdFxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL25vZGVzL2xpc3QtaXRlbS5cbiAqL1xuZXhwb3J0IGNvbnN0IEJ1bGxldExpc3QgPSBOb2RlLmNyZWF0ZTxCdWxsZXRMaXN0T3B0aW9ucz4oe1xuICBuYW1lOiAnYnVsbGV0TGlzdCcsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbVR5cGVOYW1lOiAnbGlzdEl0ZW0nLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAga2VlcE1hcmtzOiBmYWxzZSxcbiAgICAgIGtlZXBBdHRyaWJ1dGVzOiBmYWxzZSxcbiAgICB9XG4gIH0sXG5cbiAgZ3JvdXA6ICdibG9jayBsaXN0JyxcblxuICBjb250ZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgXG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6ICd1bCcgfV1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3VsJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGVCdWxsZXRMaXN0OlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBjb21tYW5kcywgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAgIC50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcylcbiAgICAgICAgICAgICAgLnVwZGF0ZUF0dHJpYnV0ZXMoTGlzdEl0ZW1OYW1lLCB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZU5hbWUpKVxuICAgICAgICAgICAgICAucnVuKClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKVxuICAgICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1TaGlmdC04JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQnVsbGV0TGlzdCgpLFxuICAgIH1cbiAgfSxcblxuICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICBmaW5kOiBidWxsZXRMaXN0SW5wdXRSZWdleCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwTWFya3MgfHwgdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGJ1bGxldExpc3RJbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGtlZXBNYXJrczogdGhpcy5vcHRpb25zLmtlZXBNYXJrcyxcbiAgICAgICAga2VlcEF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcyxcbiAgICAgICAgZ2V0QXR0cmlidXRlczogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZU5hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gW2lucHV0UnVsZV1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIExpc3RJdGVtT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgSFRNTCBhdHRyaWJ1dGVzIGZvciBhIGxpc3QgaXRlbSBub2RlLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAZXhhbXBsZSB7IGNsYXNzOiAnZm9vJyB9XG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxuXG4gIC8qKlxuICAgKiBUaGUgbm9kZSB0eXBlIGZvciBidWxsZXRMaXN0IG5vZGVzXG4gICAqIEBkZWZhdWx0ICdidWxsZXRMaXN0J1xuICAgKiBAZXhhbXBsZSAnbXlDdXN0b21CdWxsZXRMaXN0J1xuICAgKi9cbiAgYnVsbGV0TGlzdFR5cGVOYW1lOiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIG5vZGUgdHlwZSBmb3Igb3JkZXJlZExpc3Qgbm9kZXNcbiAgICogQGRlZmF1bHQgJ29yZGVyZWRMaXN0J1xuICAgKiBAZXhhbXBsZSAnbXlDdXN0b21PcmRlcmVkTGlzdCdcbiAgICovXG4gIG9yZGVyZWRMaXN0VHlwZU5hbWU6IHN0cmluZ1xufVxuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGxpc3QgaXRlbXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2xpc3QtaXRlbVxuICovXG5leHBvcnQgY29uc3QgTGlzdEl0ZW0gPSBOb2RlLmNyZWF0ZTxMaXN0SXRlbU9wdGlvbnM+KHtcbiAgbmFtZTogJ2xpc3RJdGVtJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBidWxsZXRMaXN0VHlwZU5hbWU6ICdidWxsZXRMaXN0JyxcbiAgICAgIG9yZGVyZWRMaXN0VHlwZU5hbWU6ICdvcmRlcmVkTGlzdCcsXG4gICAgfVxuICB9LFxuXG4gIGNvbnRlbnQ6ICdwYXJhZ3JhcGggYmxvY2sqJyxcblxuICBkZWZpbmluZzogdHJ1ZSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnbGknLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydsaScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgIFRhYjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICAnU2hpZnQtVGFiJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmltcG9ydCB7IGhhbmRsZUJhY2tzcGFjZSwgaGFuZGxlRGVsZXRlIH0gZnJvbSAnLi9saXN0SGVscGVycy9pbmRleC5qcydcblxuZXhwb3J0IHR5cGUgTGlzdEtleW1hcE9wdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBsaXN0IHR5cGVzLiBUaGlzIGlzIHVzZWQgZm9yIGl0ZW0gYW5kIHdyYXBwZXIgbGlzdCBtYXRjaGluZy5cbiAgICogQGRlZmF1bHQgW11cbiAgICogQGV4YW1wbGUgW3sgaXRlbU5hbWU6ICdsaXN0SXRlbScsIHdyYXBwZXJOYW1lczogWydidWxsZXRMaXN0JywgJ29yZGVyZWRMaXN0J10gfV1cbiAgICovXG4gIGxpc3RUeXBlczogQXJyYXk8e1xuICAgIGl0ZW1OYW1lOiBzdHJpbmdcbiAgICB3cmFwcGVyTmFtZXM6IHN0cmluZ1tdXG4gIH0+XG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gcmVnaXN0ZXJzIGN1c3RvbSBrZXltYXBzIHRvIGNoYW5nZSB0aGUgYmVoYXZpb3VyIG9mIHRoZSBiYWNrc3BhY2UgYW5kIGRlbGV0ZSBrZXlzLlxuICogQnkgZGVmYXVsdCBQcm9zZW1pcnJvciBrZXloYW5kbGluZyB3aWxsIGFsd2F5cyBsaWZ0IG9yIHNpbmsgaXRlbXMgc28gcGFyYWdyYXBocyBhcmUgam9pbmVkIGludG9cbiAqIHRoZSBhZGphY2VudCBvciBwcmV2aW91cyBsaXN0IGl0ZW0uIFRoaXMgZXh0ZW5zaW9uIHdpbGwgcHJldmVudCB0aGlzIGJlaGF2aW91ciBhbmQgaW5zdGVhZCB3aWxsXG4gKiB0cnkgdG8gam9pbiBwYXJhZ3JhcGhzIGZyb20gdHdvIGxpc3QgaXRlbXMgaW50byBhIHNpbmdsZSBsaXN0IGl0ZW0uXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvbGlzdC1rZXltYXBcbiAqL1xuZXhwb3J0IGNvbnN0IExpc3RLZXltYXAgPSBFeHRlbnNpb24uY3JlYXRlPExpc3RLZXltYXBPcHRpb25zPih7XG4gIG5hbWU6ICdsaXN0S2V5bWFwJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaXN0VHlwZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGl0ZW1OYW1lOiAnbGlzdEl0ZW0nLFxuICAgICAgICAgIHdyYXBwZXJOYW1lczogWydidWxsZXRMaXN0JywgJ29yZGVyZWRMaXN0J10sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpdGVtTmFtZTogJ3Rhc2tJdGVtJyxcbiAgICAgICAgICB3cmFwcGVyTmFtZXM6IFsndGFza0xpc3QnXSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBEZWxldGU6ICh7IGVkaXRvciB9KSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVkID0gZmFsc2VcblxuICAgICAgICB0aGlzLm9wdGlvbnMubGlzdFR5cGVzLmZvckVhY2goKHsgaXRlbU5hbWUgfSkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuc2NoZW1hLm5vZGVzW2l0ZW1OYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlRGVsZXRlKGVkaXRvciwgaXRlbU5hbWUpKSB7XG4gICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gaGFuZGxlZFxuICAgICAgfSxcbiAgICAgICdNb2QtRGVsZXRlJzogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZVxuXG4gICAgICAgIHRoaXMub3B0aW9ucy5saXN0VHlwZXMuZm9yRWFjaCgoeyBpdGVtTmFtZSB9KSA9PiB7XG4gICAgICAgICAgaWYgKGVkaXRvci5zdGF0ZS5zY2hlbWEubm9kZXNbaXRlbU5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVEZWxldGUoZWRpdG9yLCBpdGVtTmFtZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBoYW5kbGVkXG4gICAgICB9LFxuICAgICAgQmFja3NwYWNlOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlXG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmxpc3RUeXBlcy5mb3JFYWNoKCh7IGl0ZW1OYW1lLCB3cmFwcGVyTmFtZXMgfSkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuc2NoZW1hLm5vZGVzW2l0ZW1OYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlQmFja3NwYWNlKGVkaXRvciwgaXRlbU5hbWUsIHdyYXBwZXJOYW1lcykpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBoYW5kbGVkXG4gICAgICB9LFxuICAgICAgJ01vZC1CYWNrc3BhY2UnOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlXG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmxpc3RUeXBlcy5mb3JFYWNoKCh7IGl0ZW1OYW1lLCB3cmFwcGVyTmFtZXMgfSkgPT4ge1xuICAgICAgICAgIGlmIChlZGl0b3Iuc3RhdGUuc2NoZW1hLm5vZGVzW2l0ZW1OYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlQmFja3NwYWNlKGVkaXRvciwgaXRlbU5hbWUsIHdyYXBwZXJOYW1lcykpIHtcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiBoYW5kbGVkXG4gICAgICB9LFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiZXhwb3J0ICogZnJvbSAnLi9maW5kTGlzdEl0ZW1Qb3MuanMnXG5leHBvcnQgKiBmcm9tICcuL2dldE5leHRMaXN0RGVwdGguanMnXG5leHBvcnQgKiBmcm9tICcuL2hhbmRsZUJhY2tzcGFjZS5qcydcbmV4cG9ydCAqIGZyb20gJy4vaGFuZGxlRGVsZXRlLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9oYXNMaXN0QmVmb3JlLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9oYXNMaXN0SXRlbUFmdGVyLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9oYXNMaXN0SXRlbUJlZm9yZS5qcydcbmV4cG9ydCAqIGZyb20gJy4vbGlzdEl0ZW1IYXNTdWJMaXN0LmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9uZXh0TGlzdElzRGVlcGVyLmpzJ1xuZXhwb3J0ICogZnJvbSAnLi9uZXh0TGlzdElzSGlnaGVyLmpzJ1xuIiwgImltcG9ydCB7IGdldE5vZGVUeXBlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHR5cGUgeyBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5pbXBvcnQgdHlwZSB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGNvbnN0IGZpbmRMaXN0SXRlbVBvcyA9ICh0eXBlT3JOYW1lOiBzdHJpbmcgfCBOb2RlVHlwZSwgc3RhdGU6IEVkaXRvclN0YXRlKSA9PiB7XG4gIGNvbnN0IHsgJGZyb20gfSA9IHN0YXRlLnNlbGVjdGlvblxuICBjb25zdCBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSlcblxuICBsZXQgY3VycmVudE5vZGUgPSBudWxsXG4gIGxldCBjdXJyZW50RGVwdGggPSAkZnJvbS5kZXB0aFxuICBsZXQgY3VycmVudFBvcyA9ICRmcm9tLnBvc1xuICBsZXQgdGFyZ2V0RGVwdGg6IG51bWJlciB8IG51bGwgPSBudWxsXG5cbiAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgdGFyZ2V0RGVwdGggPT09IG51bGwpIHtcbiAgICBjdXJyZW50Tm9kZSA9ICRmcm9tLm5vZGUoY3VycmVudERlcHRoKVxuXG4gICAgaWYgKGN1cnJlbnROb2RlLnR5cGUgPT09IG5vZGVUeXBlKSB7XG4gICAgICB0YXJnZXREZXB0aCA9IGN1cnJlbnREZXB0aFxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RGVwdGggLT0gMVxuICAgICAgY3VycmVudFBvcyAtPSAxXG4gICAgfVxuICB9XG5cbiAgaWYgKHRhcmdldERlcHRoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiB7ICRwb3M6IHN0YXRlLmRvYy5yZXNvbHZlKGN1cnJlbnRQb3MpLCBkZXB0aDogdGFyZ2V0RGVwdGggfVxufVxuIiwgImltcG9ydCB7IGdldE5vZGVBdFBvc2l0aW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHR5cGUgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmltcG9ydCB7IGZpbmRMaXN0SXRlbVBvcyB9IGZyb20gJy4vZmluZExpc3RJdGVtUG9zLmpzJ1xuXG5leHBvcnQgY29uc3QgZ2V0TmV4dExpc3REZXB0aCA9ICh0eXBlT3JOYW1lOiBzdHJpbmcsIHN0YXRlOiBFZGl0b3JTdGF0ZSkgPT4ge1xuICBjb25zdCBsaXN0SXRlbVBvcyA9IGZpbmRMaXN0SXRlbVBvcyh0eXBlT3JOYW1lLCBzdGF0ZSlcblxuICBpZiAoIWxpc3RJdGVtUG9zKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBbLCBkZXB0aF0gPSBnZXROb2RlQXRQb3NpdGlvbihzdGF0ZSwgdHlwZU9yTmFtZSwgbGlzdEl0ZW1Qb3MuJHBvcy5wb3MgKyA0KVxuXG4gIHJldHVybiBkZXB0aFxufVxuIiwgImltcG9ydCB0eXBlIHsgRWRpdG9yIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHsgaXNBdFN0YXJ0T2ZOb2RlLCBpc05vZGVBY3RpdmUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgdHlwZSB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5pbXBvcnQgeyBmaW5kTGlzdEl0ZW1Qb3MgfSBmcm9tICcuL2ZpbmRMaXN0SXRlbVBvcy5qcydcbmltcG9ydCB7IGhhc0xpc3RCZWZvcmUgfSBmcm9tICcuL2hhc0xpc3RCZWZvcmUuanMnXG5pbXBvcnQgeyBoYXNMaXN0SXRlbUJlZm9yZSB9IGZyb20gJy4vaGFzTGlzdEl0ZW1CZWZvcmUuanMnXG5pbXBvcnQgeyBsaXN0SXRlbUhhc1N1Ykxpc3QgfSBmcm9tICcuL2xpc3RJdGVtSGFzU3ViTGlzdC5qcydcblxuZXhwb3J0IGNvbnN0IGhhbmRsZUJhY2tzcGFjZSA9IChlZGl0b3I6IEVkaXRvciwgbmFtZTogc3RyaW5nLCBwYXJlbnRMaXN0VHlwZXM6IHN0cmluZ1tdKSA9PiB7XG4gIC8vIHRoaXMgaXMgcmVxdWlyZWQgdG8gc3RpbGwgaGFuZGxlIHRoZSB1bmRvIGhhbmRsaW5nXG4gIGlmIChlZGl0b3IuY29tbWFuZHMudW5kb0lucHV0UnVsZSgpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIGlmIHRoZSBzZWxlY3Rpb24gaXMgbm90IGNvbGxhcHNlZFxuICAvLyB3ZSBjYW4gcmVseSBvbiB0aGUgZGVmYXVsdCBiYWNrc3BhY2UgYmVoYXZpb3JcbiAgaWYgKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbSAhPT0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi50bykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gaWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBOT1QgaW5zaWRlIGEgbGlzdCBpdGVtICZcbiAgLy8gdGhlIHByZXZpb3VzIGl0ZW0gaXMgYSBsaXN0IChvcmRlcmVkTGlzdCBvciBidWxsZXRMaXN0KVxuICAvLyBtb3ZlIHRoZSBjdXJzb3IgaW50byB0aGUgbGlzdCBhbmQgZGVsZXRlIHRoZSBjdXJyZW50IGl0ZW1cbiAgaWYgKCFpc05vZGVBY3RpdmUoZWRpdG9yLnN0YXRlLCBuYW1lKSAmJiBoYXNMaXN0QmVmb3JlKGVkaXRvci5zdGF0ZSwgbmFtZSwgcGFyZW50TGlzdFR5cGVzKSkge1xuICAgIGNvbnN0IHsgJGFuY2hvciB9ID0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvblxuXG4gICAgY29uc3QgJGxpc3RQb3MgPSBlZGl0b3Iuc3RhdGUuZG9jLnJlc29sdmUoJGFuY2hvci5iZWZvcmUoKSAtIDEpXG5cbiAgICBjb25zdCBsaXN0RGVzY2VuZGFudHM6IEFycmF5PHsgbm9kZTogTm9kZTsgcG9zOiBudW1iZXIgfT4gPSBbXVxuXG4gICAgJGxpc3RQb3Mubm9kZSgpLmRlc2NlbmRhbnRzKChub2RlLCBwb3MpID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0RGVzY2VuZGFudHMucHVzaCh7IG5vZGUsIHBvcyB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBsYXN0SXRlbSA9IGxpc3REZXNjZW5kYW50cy5hdCgtMSlcblxuICAgIGlmICghbGFzdEl0ZW0pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0ICRsYXN0SXRlbVBvcyA9IGVkaXRvci5zdGF0ZS5kb2MucmVzb2x2ZSgkbGlzdFBvcy5zdGFydCgpICsgbGFzdEl0ZW0ucG9zICsgMSlcblxuICAgIHJldHVybiBlZGl0b3JcbiAgICAgIC5jaGFpbigpXG4gICAgICAuY3V0KHsgZnJvbTogJGFuY2hvci5zdGFydCgpIC0gMSwgdG86ICRhbmNob3IuZW5kKCkgKyAxIH0sICRsYXN0SXRlbVBvcy5lbmQoKSlcbiAgICAgIC5qb2luRm9yd2FyZCgpXG4gICAgICAucnVuKClcbiAgfVxuXG4gIC8vIGlmIHRoZSBjdXJzb3IgaXMgbm90IGluc2lkZSB0aGUgY3VycmVudCBub2RlIHR5cGVcbiAgLy8gZG8gbm90aGluZyBhbmQgcHJvY2VlZFxuICBpZiAoIWlzTm9kZUFjdGl2ZShlZGl0b3Iuc3RhdGUsIG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBpZiB0aGUgY3Vyc29yIGlzIG5vdCBhdCB0aGUgc3RhcnQgb2YgYSBub2RlXG4gIC8vIGRvIG5vdGhpbmcgYW5kIHByb2NlZWRcbiAgaWYgKCFpc0F0U3RhcnRPZk5vZGUoZWRpdG9yLnN0YXRlKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgbGlzdEl0ZW1Qb3MgPSBmaW5kTGlzdEl0ZW1Qb3MobmFtZSwgZWRpdG9yLnN0YXRlKVxuXG4gIGlmICghbGlzdEl0ZW1Qb3MpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0ICRwcmV2ID0gZWRpdG9yLnN0YXRlLmRvYy5yZXNvbHZlKGxpc3RJdGVtUG9zLiRwb3MucG9zIC0gMilcbiAgY29uc3QgcHJldk5vZGUgPSAkcHJldi5ub2RlKGxpc3RJdGVtUG9zLmRlcHRoKVxuXG4gIGNvbnN0IHByZXZpb3VzTGlzdEl0ZW1IYXNTdWJMaXN0ID0gbGlzdEl0ZW1IYXNTdWJMaXN0KG5hbWUsIGVkaXRvci5zdGF0ZSwgcHJldk5vZGUpXG5cbiAgLy8gaWYgdGhlIHByZXZpb3VzIGl0ZW0gaXMgYSBsaXN0IGl0ZW0gYW5kIGRvZXNuJ3QgaGF2ZSBhIHN1Ymxpc3QsIGpvaW4gdGhlIGxpc3QgaXRlbXNcbiAgaWYgKGhhc0xpc3RJdGVtQmVmb3JlKG5hbWUsIGVkaXRvci5zdGF0ZSkgJiYgIXByZXZpb3VzTGlzdEl0ZW1IYXNTdWJMaXN0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5qb2luSXRlbUJhY2t3YXJkKClcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSBpbiB0aGUgZW5kLCBhIGJhY2tzcGFjZSBzaG91bGRcbiAgLy8gYWx3YXlzIGp1c3QgbGlmdCB0aGUgbGlzdCBpdGVtIGlmXG4gIC8vIGpvaW5pbmcgLyBtZXJnaW5nIGlzIG5vdCBwb3NzaWJsZVxuICByZXR1cm4gZWRpdG9yLmNoYWluKCkubGlmdExpc3RJdGVtKG5hbWUpLnJ1bigpXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBjb25zdCBoYXNMaXN0QmVmb3JlID0gKGVkaXRvclN0YXRlOiBFZGl0b3JTdGF0ZSwgbmFtZTogc3RyaW5nLCBwYXJlbnRMaXN0VHlwZXM6IHN0cmluZ1tdKSA9PiB7XG4gIGNvbnN0IHsgJGFuY2hvciB9ID0gZWRpdG9yU3RhdGUuc2VsZWN0aW9uXG5cbiAgY29uc3QgcHJldmlvdXNOb2RlUG9zID0gTWF0aC5tYXgoMCwgJGFuY2hvci5wb3MgLSAyKVxuXG4gIGNvbnN0IHByZXZpb3VzTm9kZSA9IGVkaXRvclN0YXRlLmRvYy5yZXNvbHZlKHByZXZpb3VzTm9kZVBvcykubm9kZSgpXG5cbiAgaWYgKCFwcmV2aW91c05vZGUgfHwgIXBhcmVudExpc3RUeXBlcy5pbmNsdWRlcyhwcmV2aW91c05vZGUudHlwZS5uYW1lKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcblxuZXhwb3J0IGNvbnN0IGhhc0xpc3RJdGVtQmVmb3JlID0gKHR5cGVPck5hbWU6IHN0cmluZywgc3RhdGU6IEVkaXRvclN0YXRlKTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IHsgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uXG5cbiAgY29uc3QgJHRhcmdldFBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKCRhbmNob3IucG9zIC0gMilcblxuICBpZiAoJHRhcmdldFBvcy5pbmRleCgpID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoJHRhcmdldFBvcy5ub2RlQmVmb3JlPy50eXBlLm5hbWUgIT09IHR5cGVPck5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgZ2V0Tm9kZVR5cGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgdHlwZSB7IE5vZGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuaW1wb3J0IHR5cGUgeyBFZGl0b3JTdGF0ZSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmV4cG9ydCBjb25zdCBsaXN0SXRlbUhhc1N1Ykxpc3QgPSAodHlwZU9yTmFtZTogc3RyaW5nLCBzdGF0ZTogRWRpdG9yU3RhdGUsIG5vZGU/OiBOb2RlKSA9PiB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3Qgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpXG5cbiAgbGV0IGhhc1N1Ykxpc3QgPSBmYWxzZVxuXG4gIG5vZGUuZGVzY2VuZGFudHMoY2hpbGQgPT4ge1xuICAgIGlmIChjaGlsZC50eXBlID09PSBub2RlVHlwZSkge1xuICAgICAgaGFzU3ViTGlzdCA9IHRydWVcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGhhc1N1Ykxpc3Rcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEVkaXRvciB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IGlzQXRFbmRPZk5vZGUsIGlzTm9kZUFjdGl2ZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuaW1wb3J0IHsgbmV4dExpc3RJc0RlZXBlciB9IGZyb20gJy4vbmV4dExpc3RJc0RlZXBlci5qcydcbmltcG9ydCB7IG5leHRMaXN0SXNIaWdoZXIgfSBmcm9tICcuL25leHRMaXN0SXNIaWdoZXIuanMnXG5cbmV4cG9ydCBjb25zdCBoYW5kbGVEZWxldGUgPSAoZWRpdG9yOiBFZGl0b3IsIG5hbWU6IHN0cmluZykgPT4ge1xuICAvLyBpZiB0aGUgY3Vyc29yIGlzIG5vdCBpbnNpZGUgdGhlIGN1cnJlbnQgbm9kZSB0eXBlXG4gIC8vIGRvIG5vdGhpbmcgYW5kIHByb2NlZWRcbiAgaWYgKCFpc05vZGVBY3RpdmUoZWRpdG9yLnN0YXRlLCBuYW1lKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gaWYgdGhlIGN1cnNvciBpcyBub3QgYXQgdGhlIGVuZCBvZiBhIG5vZGVcbiAgLy8gZG8gbm90aGluZyBhbmQgcHJvY2VlZFxuICBpZiAoIWlzQXRFbmRPZk5vZGUoZWRpdG9yLnN0YXRlLCBuYW1lKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gaWYgdGhlIHNlbGVjdGlvbiBpcyBub3QgY29sbGFwc2VkLCBvciBub3Qgd2l0aGluIGEgc2luZ2xlIG5vZGVcbiAgLy8gZG8gbm90aGluZyBhbmQgcHJvY2VlZFxuICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gZWRpdG9yLnN0YXRlXG4gIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uXG5cbiAgaWYgKCFzZWxlY3Rpb24uZW1wdHkgJiYgJGZyb20uc2FtZVBhcmVudCgkdG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBjaGVjayBpZiB0aGUgbmV4dCBub2RlIGlzIGEgbGlzdCB3aXRoIGEgZGVlcGVyIGRlcHRoXG4gIGlmIChuZXh0TGlzdElzRGVlcGVyKG5hbWUsIGVkaXRvci5zdGF0ZSkpIHtcbiAgICByZXR1cm4gZWRpdG9yXG4gICAgICAuY2hhaW4oKVxuICAgICAgLmZvY3VzKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZnJvbSArIDQpXG4gICAgICAubGlmdChuYW1lKVxuICAgICAgLmpvaW5CYWNrd2FyZCgpXG4gICAgICAucnVuKClcbiAgfVxuXG4gIGlmIChuZXh0TGlzdElzSGlnaGVyKG5hbWUsIGVkaXRvci5zdGF0ZSkpIHtcbiAgICByZXR1cm4gZWRpdG9yLmNoYWluKCkuam9pbkZvcndhcmQoKS5qb2luQmFja3dhcmQoKS5ydW4oKVxuICB9XG5cbiAgcmV0dXJuIGVkaXRvci5jb21tYW5kcy5qb2luSXRlbUZvcndhcmQoKVxufVxuIiwgImltcG9ydCB0eXBlIHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBmaW5kTGlzdEl0ZW1Qb3MgfSBmcm9tICcuL2ZpbmRMaXN0SXRlbVBvcy5qcydcbmltcG9ydCB7IGdldE5leHRMaXN0RGVwdGggfSBmcm9tICcuL2dldE5leHRMaXN0RGVwdGguanMnXG5cbmV4cG9ydCBjb25zdCBuZXh0TGlzdElzRGVlcGVyID0gKHR5cGVPck5hbWU6IHN0cmluZywgc3RhdGU6IEVkaXRvclN0YXRlKSA9PiB7XG4gIGNvbnN0IGxpc3REZXB0aCA9IGdldE5leHRMaXN0RGVwdGgodHlwZU9yTmFtZSwgc3RhdGUpXG4gIGNvbnN0IGxpc3RJdGVtUG9zID0gZmluZExpc3RJdGVtUG9zKHR5cGVPck5hbWUsIHN0YXRlKVxuXG4gIGlmICghbGlzdEl0ZW1Qb3MgfHwgIWxpc3REZXB0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGxpc3REZXB0aCA+IGxpc3RJdGVtUG9zLmRlcHRoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB0eXBlIHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5pbXBvcnQgeyBmaW5kTGlzdEl0ZW1Qb3MgfSBmcm9tICcuL2ZpbmRMaXN0SXRlbVBvcy5qcydcbmltcG9ydCB7IGdldE5leHRMaXN0RGVwdGggfSBmcm9tICcuL2dldE5leHRMaXN0RGVwdGguanMnXG5cbmV4cG9ydCBjb25zdCBuZXh0TGlzdElzSGlnaGVyID0gKHR5cGVPck5hbWU6IHN0cmluZywgc3RhdGU6IEVkaXRvclN0YXRlKSA9PiB7XG4gIGNvbnN0IGxpc3REZXB0aCA9IGdldE5leHRMaXN0RGVwdGgodHlwZU9yTmFtZSwgc3RhdGUpXG4gIGNvbnN0IGxpc3RJdGVtUG9zID0gZmluZExpc3RJdGVtUG9zKHR5cGVPck5hbWUsIHN0YXRlKVxuXG4gIGlmICghbGlzdEl0ZW1Qb3MgfHwgIWxpc3REZXB0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKGxpc3REZXB0aCA8IGxpc3RJdGVtUG9zLmRlcHRoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB0eXBlIHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuXG5leHBvcnQgY29uc3QgaGFzTGlzdEl0ZW1BZnRlciA9ICh0eXBlT3JOYW1lOiBzdHJpbmcsIHN0YXRlOiBFZGl0b3JTdGF0ZSk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCB7ICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvblxuXG4gIGNvbnN0ICR0YXJnZXRQb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZSgkYW5jaG9yLnBvcyAtICRhbmNob3IucGFyZW50T2Zmc2V0IC0gMilcblxuICBpZiAoJHRhcmdldFBvcy5pbmRleCgpID09PSAkdGFyZ2V0UG9zLnBhcmVudC5jaGlsZENvdW50IC0gMSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKCR0YXJnZXRQb3Mubm9kZUFmdGVyPy50eXBlLm5hbWUgIT09IHR5cGVPck5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5pbXBvcnQgdHlwZSB7IEJ1bGxldExpc3RPcHRpb25zIH0gZnJvbSAnLi4vYnVsbGV0LWxpc3QvaW5kZXguanMnXG5pbXBvcnQgeyBCdWxsZXRMaXN0IH0gZnJvbSAnLi4vYnVsbGV0LWxpc3QvaW5kZXguanMnXG5pbXBvcnQgdHlwZSB7IExpc3RJdGVtT3B0aW9ucyB9IGZyb20gJy4uL2l0ZW0vaW5kZXguanMnXG5pbXBvcnQgeyBMaXN0SXRlbSB9IGZyb20gJy4uL2l0ZW0vaW5kZXguanMnXG5pbXBvcnQgdHlwZSB7IExpc3RLZXltYXBPcHRpb25zIH0gZnJvbSAnLi4va2V5bWFwL2luZGV4LmpzJ1xuaW1wb3J0IHsgTGlzdEtleW1hcCB9IGZyb20gJy4uL2tleW1hcC9pbmRleC5qcydcbmltcG9ydCB0eXBlIHsgT3JkZXJlZExpc3RPcHRpb25zIH0gZnJvbSAnLi4vb3JkZXJlZC1saXN0L2luZGV4LmpzJ1xuaW1wb3J0IHsgT3JkZXJlZExpc3QgfSBmcm9tICcuLi9vcmRlcmVkLWxpc3QvaW5kZXguanMnXG5pbXBvcnQgdHlwZSB7IFRhc2tJdGVtT3B0aW9ucyB9IGZyb20gJy4uL3Rhc2staXRlbS9pbmRleC5qcydcbmltcG9ydCB7IFRhc2tJdGVtIH0gZnJvbSAnLi4vdGFzay1pdGVtL2luZGV4LmpzJ1xuaW1wb3J0IHR5cGUgeyBUYXNrTGlzdE9wdGlvbnMgfSBmcm9tICcuLi90YXNrLWxpc3QvaW5kZXguanMnXG5pbXBvcnQgeyBUYXNrTGlzdCB9IGZyb20gJy4uL3Rhc2stbGlzdC9pbmRleC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBMaXN0S2l0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gZmFsc2UsIHRoZSBidWxsZXRMaXN0IGV4dGVuc2lvbiB3aWxsIG5vdCBiZSByZWdpc3RlcmVkXG4gICAqIEBleGFtcGxlIHRhYmxlOiBmYWxzZVxuICAgKi9cbiAgYnVsbGV0TGlzdDogUGFydGlhbDxCdWxsZXRMaXN0T3B0aW9ucz4gfCBmYWxzZVxuICAvKipcbiAgICogSWYgc2V0IHRvIGZhbHNlLCB0aGUgbGlzdEl0ZW0gZXh0ZW5zaW9uIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWRcbiAgICovXG4gIGxpc3RJdGVtOiBQYXJ0aWFsPExpc3RJdGVtT3B0aW9ucz4gfCBmYWxzZVxuICAvKipcbiAgICogSWYgc2V0IHRvIGZhbHNlLCB0aGUgbGlzdEtleW1hcCBleHRlbnNpb24gd2lsbCBub3QgYmUgcmVnaXN0ZXJlZFxuICAgKi9cbiAgbGlzdEtleW1hcDogUGFydGlhbDxMaXN0S2V5bWFwT3B0aW9ucz4gfCBmYWxzZVxuICAvKipcbiAgICogSWYgc2V0IHRvIGZhbHNlLCB0aGUgb3JkZXJlZExpc3QgZXh0ZW5zaW9uIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWRcbiAgICovXG4gIG9yZGVyZWRMaXN0OiBQYXJ0aWFsPE9yZGVyZWRMaXN0T3B0aW9ucz4gfCBmYWxzZVxuICAvKipcbiAgICogSWYgc2V0IHRvIGZhbHNlLCB0aGUgdGFza0l0ZW0gZXh0ZW5zaW9uIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWRcbiAgICovXG4gIHRhc2tJdGVtOiBQYXJ0aWFsPFRhc2tJdGVtT3B0aW9ucz4gfCBmYWxzZVxuICAvKipcbiAgICogSWYgc2V0IHRvIGZhbHNlLCB0aGUgdGFza0xpc3QgZXh0ZW5zaW9uIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWRcbiAgICovXG4gIHRhc2tMaXN0OiBQYXJ0aWFsPFRhc2tMaXN0T3B0aW9ucz4gfCBmYWxzZVxufVxuXG4vKipcbiAqIFRoZSB0YWJsZSBraXQgaXMgYSBjb2xsZWN0aW9uIG9mIHRhYmxlIGVkaXRvciBleHRlbnNpb25zLlxuICpcbiAqIEl04oCZcyBhIGdvb2Qgc3RhcnRpbmcgcG9pbnQgZm9yIGJ1aWxkaW5nIHlvdXIgb3duIHRhYmxlIGluIFRpcHRhcC5cbiAqL1xuZXhwb3J0IGNvbnN0IExpc3RLaXQgPSBFeHRlbnNpb24uY3JlYXRlPExpc3RLaXRPcHRpb25zPih7XG4gIG5hbWU6ICdsaXN0S2l0JyxcblxuICBhZGRFeHRlbnNpb25zKCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBbXVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJ1bGxldExpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0KSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpc3RJdGVtICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKExpc3RJdGVtLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMubGlzdEl0ZW0pKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubGlzdEtleW1hcCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChMaXN0S2V5bWFwLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMubGlzdEtleW1hcCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vcmRlcmVkTGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChPcmRlcmVkTGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0KSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRhc2tJdGVtICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFRhc2tJdGVtLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMudGFza0l0ZW0pKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFza0xpc3QgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goVGFza0xpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucy50YXNrTGlzdCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dGVuc2lvbnNcbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuY29uc3QgTGlzdEl0ZW1OYW1lID0gJ2xpc3RJdGVtJ1xuY29uc3QgVGV4dFN0eWxlTmFtZSA9ICd0ZXh0U3R5bGUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgT3JkZXJlZExpc3RPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBub2RlIHR5cGUgbmFtZSBmb3IgbGlzdCBpdGVtcy5cbiAgICogQGRlZmF1bHQgJ2xpc3RJdGVtJ1xuICAgKiBAZXhhbXBsZSAnbXlMaXN0SXRlbSdcbiAgICovXG4gIGl0ZW1UeXBlTmFtZTogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBIVE1MIGF0dHJpYnV0ZXMgZm9yIGFuIG9yZGVyZWQgbGlzdCBub2RlLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAZXhhbXBsZSB7IGNsYXNzOiAnZm9vJyB9XG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxuXG4gIC8qKlxuICAgKiBLZWVwIHRoZSBtYXJrcyB3aGVuIHNwbGl0dGluZyBhIGxpc3QgaXRlbS5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAga2VlcE1hcmtzOiBib29sZWFuXG5cbiAgLyoqXG4gICAqIEtlZXAgdGhlIGF0dHJpYnV0ZXMgd2hlbiBzcGxpdHRpbmcgYSBsaXN0IGl0ZW0uXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGtlZXBBdHRyaWJ1dGVzOiBib29sZWFuXG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICBvcmRlcmVkTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYW4gb3JkZXJlZCBsaXN0XG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudG9nZ2xlT3JkZXJlZExpc3QoKVxuICAgICAgICovXG4gICAgICB0b2dnbGVPcmRlcmVkTGlzdDogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hdGNoZXMgYW4gb3JkZXJlZCBsaXN0IHRvIGEgMS4gb24gaW5wdXQgKG9yIGFueSBudW1iZXIgZm9sbG93ZWQgYnkgYSBkb3QpLlxuICovXG5leHBvcnQgY29uc3Qgb3JkZXJlZExpc3RJbnB1dFJlZ2V4ID0gL14oXFxkKylcXC5cXHMkL1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIG9yZGVyZWQgbGlzdHMuXG4gKiBUaGlzIHJlcXVpcmVzIHRoZSBMaXN0SXRlbSBleHRlbnNpb25cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbm9kZXMvb3JkZXJlZC1saXN0XG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2xpc3QtaXRlbVxuICovXG5leHBvcnQgY29uc3QgT3JkZXJlZExpc3QgPSBOb2RlLmNyZWF0ZTxPcmRlcmVkTGlzdE9wdGlvbnM+KHtcbiAgbmFtZTogJ29yZGVyZWRMaXN0JyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtVHlwZU5hbWU6ICdsaXN0SXRlbScsXG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICBrZWVwTWFya3M6IGZhbHNlLFxuICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlLFxuICAgIH1cbiAgfSxcblxuICBncm91cDogJ2Jsb2NrIGxpc3QnLFxuXG4gIGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWV9K2BcbiAgfSxcblxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc3RhcnQnKSA/IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdGFydCcpIHx8ICcnLCAxMCkgOiAxXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdHlwZToge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdvbCcsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIGNvbnN0IHsgc3RhcnQsIC4uLmF0dHJpYnV0ZXNXaXRob3V0U3RhcnQgfSA9IEhUTUxBdHRyaWJ1dGVzXG5cbiAgICByZXR1cm4gc3RhcnQgPT09IDFcbiAgICAgID8gWydvbCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNXaXRob3V0U3RhcnQpLCAwXVxuICAgICAgOiBbJ29sJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGVPcmRlcmVkTGlzdDpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMsIGNoYWluIH0pID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAgICAgICAudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpXG4gICAgICAgICAgICAgIC51cGRhdGVBdHRyaWJ1dGVzKExpc3RJdGVtTmFtZSwgdGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lKSlcbiAgICAgICAgICAgICAgLnJ1bigpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcylcbiAgICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtU2hpZnQtNyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZU9yZGVyZWRMaXN0KCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgbGV0IGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgIGZpbmQ6IG9yZGVyZWRMaXN0SW5wdXRSZWdleCxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7IHN0YXJ0OiArbWF0Y2hbMV0gfSksXG4gICAgICBqb2luUHJlZGljYXRlOiAobWF0Y2gsIG5vZGUpID0+IG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMuc3RhcnQgPT09ICttYXRjaFsxXSxcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwTWFya3MgfHwgdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IG9yZGVyZWRMaXN0SW5wdXRSZWdleCxcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7IHN0YXJ0OiArbWF0Y2hbMV0sIC4uLnRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZSkgfSksXG4gICAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdLFxuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIFtpbnB1dFJ1bGVdXG4gIH0sXG59KVxuIiwgImltcG9ydCB0eXBlIHsgS2V5Ym9hcmRTaG9ydGN1dENvbW1hbmQgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHR5cGUgeyBOb2RlIGFzIFByb3NlTWlycm9yTm9kZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFza0l0ZW1PcHRpb25zIHtcbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgY2hlY2tib3ggaXMgY2xpY2tlZCB3aGlsZSB0aGUgZWRpdG9yIGlzIGluIHJlYWRvbmx5IG1vZGUuXG4gICAqIEBwYXJhbSBub2RlIFRoZSBwcm9zZW1pcnJvciBub2RlIG9mIHRoZSB0YXNrIGl0ZW1cbiAgICogQHBhcmFtIGNoZWNrZWQgVGhlIG5ldyBjaGVja2VkIHN0YXRlXG4gICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICovXG4gIG9uUmVhZE9ubHlDaGVja2VkPzogKG5vZGU6IFByb3NlTWlycm9yTm9kZSwgY2hlY2tlZDogYm9vbGVhbikgPT4gYm9vbGVhblxuXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGV0aGVyIHRoZSB0YXNrIGl0ZW1zIGNhbiBiZSBuZXN0ZWQgb3Igbm90LlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICBuZXN0ZWQ6IGJvb2xlYW5cblxuICAvKipcbiAgICogSFRNTCBhdHRyaWJ1dGVzIHRvIGFkZCB0byB0aGUgdGFzayBpdGVtIGVsZW1lbnQuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBleGFtcGxlIHsgY2xhc3M6ICdmb28nIH1cbiAgICovXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5cbiAgLyoqXG4gICAqIFRoZSBub2RlIHR5cGUgZm9yIHRhc2tMaXN0IG5vZGVzXG4gICAqIEBkZWZhdWx0ICd0YXNrTGlzdCdcbiAgICogQGV4YW1wbGUgJ215Q3VzdG9tVGFza0xpc3QnXG4gICAqL1xuICB0YXNrTGlzdFR5cGVOYW1lOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBNYXRjaGVzIGEgdGFzayBpdGVtIHRvIGEgLSBbIF0gb24gaW5wdXQuXG4gKi9cbmV4cG9ydCBjb25zdCBpbnB1dFJlZ2V4ID0gL15cXHMqKFxcWyhbKCB8eF0pP1xcXSlcXHMkL1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHRhc2sgaXRlbXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3Rhc2staXRlbVxuICovXG5leHBvcnQgY29uc3QgVGFza0l0ZW0gPSBOb2RlLmNyZWF0ZTxUYXNrSXRlbU9wdGlvbnM+KHtcbiAgbmFtZTogJ3Rhc2tJdGVtJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXN0ZWQ6IGZhbHNlLFxuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgdGFza0xpc3RUeXBlTmFtZTogJ3Rhc2tMaXN0JyxcbiAgICB9XG4gIH0sXG5cbiAgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLm5lc3RlZCA/ICdwYXJhZ3JhcGggYmxvY2sqJyA6ICdwYXJhZ3JhcGgrJ1xuICB9LFxuXG4gIGRlZmluaW5nOiB0cnVlLFxuXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoZWNrZWQ6IHtcbiAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGtlZXBPblNwbGl0OiBmYWxzZSxcbiAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhQ2hlY2tlZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNoZWNrZWQnKVxuXG4gICAgICAgICAgcmV0dXJuIGRhdGFDaGVja2VkID09PSAnJyB8fCBkYXRhQ2hlY2tlZCA9PT0gJ3RydWUnXG4gICAgICAgIH0sXG4gICAgICAgIHJlbmRlckhUTUw6IGF0dHJpYnV0ZXMgPT4gKHtcbiAgICAgICAgICAnZGF0YS1jaGVja2VkJzogYXR0cmlidXRlcy5jaGVja2VkLFxuICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6IGBsaVtkYXRhLXR5cGU9XCIke3RoaXMubmFtZX1cIl1gLFxuICAgICAgICBwcmlvcml0eTogNTEsXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbXG4gICAgICAnbGknLFxuICAgICAgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMsIHtcbiAgICAgICAgJ2RhdGEtdHlwZSc6IHRoaXMubmFtZSxcbiAgICAgIH0pLFxuICAgICAgW1xuICAgICAgICAnbGFiZWwnLFxuICAgICAgICBbXG4gICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICAgICAgY2hlY2tlZDogbm9kZS5hdHRycy5jaGVja2VkID8gJ2NoZWNrZWQnIDogbnVsbCxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBbJ3NwYW4nXSxcbiAgICAgIF0sXG4gICAgICBbJ2RpdicsIDBdLFxuICAgIF1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICBjb25zdCBzaG9ydGN1dHM6IHtcbiAgICAgIFtrZXk6IHN0cmluZ106IEtleWJvYXJkU2hvcnRjdXRDb21tYW5kXG4gICAgfSA9IHtcbiAgICAgIEVudGVyOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zcGxpdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICAnU2hpZnQtVGFiJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubmVzdGVkKSB7XG4gICAgICByZXR1cm4gc2hvcnRjdXRzXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNob3J0Y3V0cyxcbiAgICAgIFRhYjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgfVxuICB9LFxuXG4gIGFkZE5vZGVWaWV3KCkge1xuICAgIHJldHVybiAoeyBub2RlLCBIVE1MQXR0cmlidXRlcywgZ2V0UG9zLCBlZGl0b3IgfSkgPT4ge1xuICAgICAgY29uc3QgbGlzdEl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpXG4gICAgICBjb25zdCBjaGVja2JveFdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpXG4gICAgICBjb25zdCBjaGVja2JveFN0eWxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgICAgY29uc3QgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICAgICAgY2hlY2tib3hXcmFwcGVyLmNvbnRlbnRFZGl0YWJsZSA9ICdmYWxzZSdcbiAgICAgIGNoZWNrYm94LnR5cGUgPSAnY2hlY2tib3gnXG4gICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBldmVudCA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpKVxuICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXZlbnQgPT4ge1xuICAgICAgICAvLyBpZiB0aGUgZWRpdG9yIGlzbuKAmXQgZWRpdGFibGUgYW5kIHdlIGRvbid0IGhhdmUgYSBoYW5kbGVyIGZvclxuICAgICAgICAvLyByZWFkb25seSBjaGVja3Mgd2UgaGF2ZSB0byB1bmRvIHRoZSBsYXRlc3QgY2hhbmdlXG4gICAgICAgIGlmICghZWRpdG9yLmlzRWRpdGFibGUgJiYgIXRoaXMub3B0aW9ucy5vblJlYWRPbmx5Q2hlY2tlZCkge1xuICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSAhY2hlY2tib3guY2hlY2tlZFxuXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGV2ZW50LnRhcmdldCBhcyBhbnlcblxuICAgICAgICBpZiAoZWRpdG9yLmlzRWRpdGFibGUgJiYgdHlwZW9mIGdldFBvcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgLmNoYWluKClcbiAgICAgICAgICAgIC5mb2N1cyh1bmRlZmluZWQsIHsgc2Nyb2xsSW50b1ZpZXc6IGZhbHNlIH0pXG4gICAgICAgICAgICAuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UG9zKClcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gdHIuZG9jLm5vZGVBdChwb3NpdGlvbilcblxuICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvc2l0aW9uLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAuLi5jdXJyZW50Tm9kZT8uYXR0cnMsXG4gICAgICAgICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5ydW4oKVxuICAgICAgICB9XG4gICAgICAgIGlmICghZWRpdG9yLmlzRWRpdGFibGUgJiYgdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKSB7XG4gICAgICAgICAgLy8gUmVzZXQgc3RhdGUgaWYgb25SZWFkT25seUNoZWNrZWQgcmV0dXJucyBmYWxzZVxuICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKG5vZGUsIGNoZWNrZWQpKSB7XG4gICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gIWNoZWNrYm94LmNoZWNrZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGxpc3RJdGVtLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgICAgfSlcblxuICAgICAgbGlzdEl0ZW0uZGF0YXNldC5jaGVja2VkID0gbm9kZS5hdHRycy5jaGVja2VkXG4gICAgICBjaGVja2JveC5jaGVja2VkID0gbm9kZS5hdHRycy5jaGVja2VkXG5cbiAgICAgIGNoZWNrYm94V3JhcHBlci5hcHBlbmQoY2hlY2tib3gsIGNoZWNrYm94U3R5bGVyKVxuICAgICAgbGlzdEl0ZW0uYXBwZW5kKGNoZWNrYm94V3JhcHBlciwgY29udGVudClcblxuICAgICAgT2JqZWN0LmVudHJpZXMoSFRNTEF0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBsaXN0SXRlbS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbTogbGlzdEl0ZW0sXG4gICAgICAgIGNvbnRlbnRET006IGNvbnRlbnQsXG4gICAgICAgIHVwZGF0ZTogdXBkYXRlZE5vZGUgPT4ge1xuICAgICAgICAgIGlmICh1cGRhdGVkTm9kZS50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RJdGVtLmRhdGFzZXQuY2hlY2tlZCA9IHVwZGF0ZWROb2RlLmF0dHJzLmNoZWNrZWRcbiAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdXBkYXRlZE5vZGUuYXR0cnMuY2hlY2tlZFxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7XG4gICAgICAgICAgY2hlY2tlZDogbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV0gPT09ICd4JyxcbiAgICAgICAgfSksXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG59KVxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBUYXNrTGlzdE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIG5vZGUgdHlwZSBuYW1lIGZvciBhIHRhc2sgaXRlbS5cbiAgICogQGRlZmF1bHQgJ3Rhc2tJdGVtJ1xuICAgKiBAZXhhbXBsZSAnbXlDdXN0b21UYXNrSXRlbSdcbiAgICovXG4gIGl0ZW1UeXBlTmFtZTogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBIVE1MIGF0dHJpYnV0ZXMgZm9yIGEgdGFzayBsaXN0IG5vZGUuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBleGFtcGxlIHsgY2xhc3M6ICdmb28nIH1cbiAgICovXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbmRlY2xhcmUgbW9kdWxlICdAdGlwdGFwL2NvcmUnIHtcbiAgaW50ZXJmYWNlIENvbW1hbmRzPFJldHVyblR5cGU+IHtcbiAgICB0YXNrTGlzdDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSB0YXNrIGxpc3RcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy50b2dnbGVUYXNrTGlzdCgpXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZVRhc2tMaXN0OiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgdGFzayBsaXN0cy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbm9kZXMvdGFzay1saXN0XG4gKi9cbmV4cG9ydCBjb25zdCBUYXNrTGlzdCA9IE5vZGUuY3JlYXRlPFRhc2tMaXN0T3B0aW9ucz4oe1xuICBuYW1lOiAndGFza0xpc3QnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1UeXBlTmFtZTogJ3Rhc2tJdGVtJyxcbiAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICB9XG4gIH0sXG5cbiAgZ3JvdXA6ICdibG9jayBsaXN0JyxcblxuICBjb250ZW50KCkge1xuICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgXG4gIH0sXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHRhZzogYHVsW2RhdGEtdHlwZT1cIiR7dGhpcy5uYW1lfVwiXWAsXG4gICAgICAgIHByaW9yaXR5OiA1MSxcbiAgICAgIH0sXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsndWwnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcywgeyAnZGF0YS10eXBlJzogdGhpcy5uYW1lIH0pLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGVUYXNrTGlzdDpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSlcbiAgICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdNb2QtU2hpZnQtOSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVRhc2tMaXN0KCksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5cbmNvbnN0IGFsbG93ZWRNaW1lVHlwZXMgPSBbJ2ltYWdlL3BuZycsICdpbWFnZS9qcGVnJywgJ2ltYWdlL2dpZicsICdpbWFnZS93ZWJwJ11cblxuY29uc3QgZGlzcGF0Y2hGb3JtRXZlbnQgPSAoZWRpdG9yVmlldywgbmFtZSwgZGV0YWlsID0ge30pID0+IHtcbiAgICBlZGl0b3JWaWV3LmRvbS5jbG9zZXN0KCdmb3JtJyk/LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudChuYW1lLCB7XG4gICAgICAgICAgICBjb21wb3NlZDogdHJ1ZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBkZXRhaWwsXG4gICAgICAgIH0pLFxuICAgIClcbn1cblxuY29uc3QgTG9jYWxGaWxlc1BsdWdpbiA9ICh7XG4gICAgZWRpdG9yLFxuICAgIGdldCRXaXJlVXNpbmcsXG4gICAga2V5LFxuICAgIHN0YXRlUGF0aCxcbiAgICB1cGxvYWRpbmdNZXNzYWdlLFxufSkgPT4ge1xuICAgIGNvbnN0IGdldEZpbGVBdHRhY2htZW50VXJsID0gKGZpbGVLZXkpID0+XG4gICAgICAgIGdldCRXaXJlVXNpbmcoKS5jYWxsU2NoZW1hQ29tcG9uZW50TWV0aG9kKFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgJ2dldFVwbG9hZGVkRmlsZUF0dGFjaG1lbnRUZW1wb3JhcnlVcmwnLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQ6IGZpbGVLZXksXG4gICAgICAgICAgICB9LFxuICAgICAgICApXG5cbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnbG9jYWxGaWxlcycpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlRHJvcChlZGl0b3JWaWV3LCBldmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyPy5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBBcnJheS5mcm9tKGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcykuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAoZmlsZSkgPT4gYWxsb3dlZE1pbWVUeXBlcy5pbmNsdWRlcyhmaWxlLnR5cGUpLFxuICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpc3BhdGNoRm9ybUV2ZW50KGVkaXRvclZpZXcsICdmb3JtLXByb2Nlc3Npbmctc3RhcnRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdXBsb2FkaW5nTWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGVkaXRvclZpZXcucG9zQXRDb29yZHMoe1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IGV2ZW50LmNsaWVudFksXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUsIGZpbGVJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0RWRpdGFibGUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvclZpZXcuZG9tLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ3JpY2gtZWRpdG9yLXVwbG9hZGluZy1maWxlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGl2ZXdpcmVJZDogZ2V0JFdpcmVVc2luZygpLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cbiAgICAgICAgICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpXG4gICAgICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNoYWluKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0Q29udGVudEF0KHBvc2l0aW9uPy5wb3MgPz8gMCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdmaS1sb2FkaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogZmlsZVJlYWRlci5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucnVuKClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlS2V5ID0gKFsxZTddICsgLTFlMyArIC00ZTMgKyAtOGUzICsgLTFlMTEpLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAvWzAxOF0vZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYyBeXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEpKVswXSAmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMTUgPj4gKGMgLyA0KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKS50b1N0cmluZygxNiksXG4gICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICBnZXQkV2lyZVVzaW5nKCkudXBsb2FkKFxuICAgICAgICAgICAgICAgICAgICAgICAgYGNvbXBvbmVudEZpbGVBdHRhY2htZW50cy4ke3N0YXRlUGF0aH0uJHtmaWxlS2V5fWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEZpbGVBdHRhY2htZW50VXJsKGZpbGVLZXkpLnRoZW4oKHVybCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jaGFpbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudXBkYXRlQXR0cmlidXRlcygnaW1hZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGZpbGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJ1bigpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldEVkaXRhYmxlKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvclZpZXcuZG9tLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JpY2gtZWRpdG9yLXVwbG9hZGVkLWZpbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXZld2lyZUlkOiBnZXQkV2lyZVVzaW5nKCkuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUluZGV4ID09PSBmaWxlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEZvcm1FdmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3JWaWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmb3JtLXByb2Nlc3NpbmctZmluaXNoZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVQYXN0ZShlZGl0b3JWaWV3LCBldmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuY2xpcGJvYXJkRGF0YT8uZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gQXJyYXkuZnJvbShldmVudC5jbGlwYm9hcmREYXRhLmZpbGVzKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgIChmaWxlKSA9PiBhbGxvd2VkTWltZVR5cGVzLmluY2x1ZGVzKGZpbGUudHlwZSksXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICAgICAgICAgICAgICBkaXNwYXRjaEZvcm1FdmVudChlZGl0b3JWaWV3LCAnZm9ybS1wcm9jZXNzaW5nLXN0YXJ0ZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHVwbG9hZGluZ01lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIGZpbGVzLmZvckVhY2goKGZpbGUsIGZpbGVJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0RWRpdGFibGUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvclZpZXcuZG9tLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ3JpY2gtZWRpdG9yLXVwbG9hZGluZy1maWxlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGl2ZXdpcmVJZDogZ2V0JFdpcmVVc2luZygpLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cbiAgICAgICAgICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpXG4gICAgICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNoYWluKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0Q29udGVudEF0KGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2ZpLWxvYWRpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBmaWxlUmVhZGVyLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ydW4oKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVLZXkgPSAoWzFlN10gKyAtMWUzICsgLTRlMyArIC04ZTMgKyAtMWUxMSkucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIC9bMDE4XS9nLFxuICAgICAgICAgICAgICAgICAgICAgICAgKGMpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjIF5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMSkpWzBdICZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgxNSA+PiAoYyAvIDQpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApLnRvU3RyaW5nKDE2KSxcbiAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgIGdldCRXaXJlVXNpbmcoKS51cGxvYWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBgY29tcG9uZW50RmlsZUF0dGFjaG1lbnRzLiR7c3RhdGVQYXRofS4ke2ZpbGVLZXl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RmlsZUF0dGFjaG1lbnRVcmwoZmlsZUtleSkudGhlbigodXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNoYWluKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGVBdHRyaWJ1dGVzKCdpbWFnZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZmlsZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucnVuKClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0RWRpdGFibGUodHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yVmlldy5kb20uZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmljaC1lZGl0b3ItdXBsb2FkZWQtZmlsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpdmV3aXJlSWQ6IGdldCRXaXJlVXNpbmcoKS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlSW5kZXggPT09IGZpbGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoRm9ybUV2ZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvclZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Zvcm0tcHJvY2Vzc2luZy1maW5pc2hlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnbG9jYWxGaWxlcycsXG5cbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBudWxsLFxuICAgICAgICAgICAgc3RhdGVQYXRoOiBudWxsLFxuICAgICAgICAgICAgdXBsb2FkaW5nTWVzc2FnZTogbnVsbCxcbiAgICAgICAgICAgIGdldCRXaXJlVXNpbmc6IG51bGwsXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgTG9jYWxGaWxlc1BsdWdpbih7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXVxuICAgIH0sXG59KVxuIiwgImltcG9ydCB0eXBlIHsgRWRpdG9yLCBSYW5nZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB0eXBlIHsgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHR5cGUgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3J1xuaW1wb3J0IHsgRGVjb3JhdGlvbiwgRGVjb3JhdGlvblNldCB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgZmluZFN1Z2dlc3Rpb25NYXRjaCBhcyBkZWZhdWx0RmluZFN1Z2dlc3Rpb25NYXRjaCB9IGZyb20gJy4vZmluZFN1Z2dlc3Rpb25NYXRjaC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBTdWdnZXN0aW9uT3B0aW9uczxJID0gYW55LCBUU2VsZWN0ZWQgPSBhbnk+IHtcbiAgLyoqXG4gICAqIFRoZSBwbHVnaW4ga2V5IGZvciB0aGUgc3VnZ2VzdGlvbiBwbHVnaW4uXG4gICAqIEBkZWZhdWx0ICdzdWdnZXN0aW9uJ1xuICAgKiBAZXhhbXBsZSAnbWVudGlvbidcbiAgICovXG4gIHBsdWdpbktleT86IFBsdWdpbktleVxuXG4gIC8qKlxuICAgKiBUaGUgZWRpdG9yIGluc3RhbmNlLlxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBlZGl0b3I6IEVkaXRvclxuXG4gIC8qKlxuICAgKiBUaGUgY2hhcmFjdGVyIHRoYXQgdHJpZ2dlcnMgdGhlIHN1Z2dlc3Rpb24uXG4gICAqIEBkZWZhdWx0ICdAJ1xuICAgKiBAZXhhbXBsZSAnIydcbiAgICovXG4gIGNoYXI/OiBzdHJpbmdcblxuICAvKipcbiAgICogQWxsb3cgc3BhY2VzIGluIHRoZSBzdWdnZXN0aW9uIHF1ZXJ5LiBOb3QgY29tcGF0aWJsZSB3aXRoIGBhbGxvd1RvSW5jbHVkZUNoYXJgLiBXaWxsIGJlIGRpc2FibGVkIGlmIGBhbGxvd1RvSW5jbHVkZUNoYXJgIGlzIHNldCB0byBgdHJ1ZWAuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIGFsbG93U3BhY2VzPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgY2hhcmFjdGVyIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBzdWdnZXN0aW9uIHF1ZXJ5LiBOb3QgY29tcGF0aWJsZSB3aXRoIGBhbGxvd1NwYWNlc2AuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhbGxvd1RvSW5jbHVkZUNoYXI/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIEFsbG93IHByZWZpeGVzIGluIHRoZSBzdWdnZXN0aW9uIHF1ZXJ5LlxuICAgKiBAZGVmYXVsdCBbJyAnXVxuICAgKiBAZXhhbXBsZSBbJyAnLCAnQCddXG4gICAqL1xuICBhbGxvd2VkUHJlZml4ZXM/OiBzdHJpbmdbXSB8IG51bGxcblxuICAvKipcbiAgICogT25seSBtYXRjaCBzdWdnZXN0aW9ucyBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBleGFtcGxlIHRydWVcbiAgICovXG4gIHN0YXJ0T2ZMaW5lPzogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBUaGUgdGFnIG5hbWUgb2YgdGhlIGRlY29yYXRpb24gbm9kZS5cbiAgICogQGRlZmF1bHQgJ3NwYW4nXG4gICAqIEBleGFtcGxlICdkaXYnXG4gICAqL1xuICBkZWNvcmF0aW9uVGFnPzogc3RyaW5nXG5cbiAgLyoqXG4gICAqIFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBkZWNvcmF0aW9uIG5vZGUuXG4gICAqIEBkZWZhdWx0ICdzdWdnZXN0aW9uJ1xuICAgKiBAZXhhbXBsZSAnbWVudGlvbidcbiAgICovXG4gIGRlY29yYXRpb25DbGFzcz86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBzdWdnZXN0aW9uIGlzIHNlbGVjdGVkLlxuICAgKiBAcGFyYW0gcHJvcHMgVGhlIHByb3BzIG9iamVjdC5cbiAgICogQHBhcmFtIHByb3BzLmVkaXRvciBUaGUgZWRpdG9yIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gcHJvcHMucmFuZ2UgVGhlIHJhbmdlIG9mIHRoZSBzdWdnZXN0aW9uLlxuICAgKiBAcGFyYW0gcHJvcHMucHJvcHMgVGhlIHByb3BzIG9mIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqIEBleGFtcGxlICh7IGVkaXRvciwgcmFuZ2UsIHByb3BzIH0pID0+IHsgcHJvcHMuY29tbWFuZChwcm9wcy5wcm9wcykgfVxuICAgKi9cbiAgY29tbWFuZD86IChwcm9wczogeyBlZGl0b3I6IEVkaXRvcjsgcmFuZ2U6IFJhbmdlOyBwcm9wczogVFNlbGVjdGVkIH0pID0+IHZvaWRcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHN1Z2dlc3Rpb24gaXRlbXMgaW4gZm9ybSBvZiBhbiBhcnJheS5cbiAgICogQHBhcmFtIHByb3BzIFRoZSBwcm9wcyBvYmplY3QuXG4gICAqIEBwYXJhbSBwcm9wcy5lZGl0b3IgVGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHByb3BzLnF1ZXJ5IFRoZSBjdXJyZW50IHN1Z2dlc3Rpb24gcXVlcnkuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN1Z2dlc3Rpb24gaXRlbXMuXG4gICAqIEBleGFtcGxlICh7IGVkaXRvciwgcXVlcnkgfSkgPT4gW3sgaWQ6IDEsIGxhYmVsOiAnSm9obiBEb2UnIH1dXG4gICAqL1xuICBpdGVtcz86IChwcm9wczogeyBxdWVyeTogc3RyaW5nOyBlZGl0b3I6IEVkaXRvciB9KSA9PiBJW10gfCBQcm9taXNlPElbXT5cblxuICAvKipcbiAgICogVGhlIHJlbmRlciBmdW5jdGlvbiBmb3IgdGhlIHN1Z2dlc3Rpb24uXG4gICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIHJlbmRlciBmdW5jdGlvbnMuXG4gICAqL1xuICByZW5kZXI/OiAoKSA9PiB7XG4gICAgb25CZWZvcmVTdGFydD86IChwcm9wczogU3VnZ2VzdGlvblByb3BzPEksIFRTZWxlY3RlZD4pID0+IHZvaWRcbiAgICBvblN0YXJ0PzogKHByb3BzOiBTdWdnZXN0aW9uUHJvcHM8SSwgVFNlbGVjdGVkPikgPT4gdm9pZFxuICAgIG9uQmVmb3JlVXBkYXRlPzogKHByb3BzOiBTdWdnZXN0aW9uUHJvcHM8SSwgVFNlbGVjdGVkPikgPT4gdm9pZFxuICAgIG9uVXBkYXRlPzogKHByb3BzOiBTdWdnZXN0aW9uUHJvcHM8SSwgVFNlbGVjdGVkPikgPT4gdm9pZFxuICAgIG9uRXhpdD86IChwcm9wczogU3VnZ2VzdGlvblByb3BzPEksIFRTZWxlY3RlZD4pID0+IHZvaWRcbiAgICBvbktleURvd24/OiAocHJvcHM6IFN1Z2dlc3Rpb25LZXlEb3duUHJvcHMpID0+IGJvb2xlYW5cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgaWYgdGhlIHN1Z2dlc3Rpb24gc2hvdWxkIGJlIGFjdGl2ZS5cbiAgICogQHBhcmFtIHByb3BzIFRoZSBwcm9wcyBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgYWxsb3c/OiAocHJvcHM6IHsgZWRpdG9yOiBFZGl0b3I7IHN0YXRlOiBFZGl0b3JTdGF0ZTsgcmFuZ2U6IFJhbmdlOyBpc0FjdGl2ZT86IGJvb2xlYW4gfSkgPT4gYm9vbGVhblxuICBmaW5kU3VnZ2VzdGlvbk1hdGNoPzogdHlwZW9mIGRlZmF1bHRGaW5kU3VnZ2VzdGlvbk1hdGNoXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VnZ2VzdGlvblByb3BzPEkgPSBhbnksIFRTZWxlY3RlZCA9IGFueT4ge1xuICAvKipcbiAgICogVGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICovXG4gIGVkaXRvcjogRWRpdG9yXG5cbiAgLyoqXG4gICAqIFRoZSByYW5nZSBvZiB0aGUgc3VnZ2VzdGlvbi5cbiAgICovXG4gIHJhbmdlOiBSYW5nZVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdWdnZXN0aW9uIHF1ZXJ5LlxuICAgKi9cbiAgcXVlcnk6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdWdnZXN0aW9uIHRleHQuXG4gICAqL1xuICB0ZXh0OiBzdHJpbmdcblxuICAvKipcbiAgICogVGhlIHN1Z2dlc3Rpb24gaXRlbXMgYXJyYXkuXG4gICAqL1xuICBpdGVtczogSVtdXG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBhIHN1Z2dlc3Rpb24gaXMgc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSBwcm9wcyBUaGUgcHJvcHMgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB2b2lkXG4gICAqL1xuICBjb21tYW5kOiAocHJvcHM6IFRTZWxlY3RlZCkgPT4gdm9pZFxuXG4gIC8qKlxuICAgKiBUaGUgZGVjb3JhdGlvbiBub2RlIEhUTUwgZWxlbWVudFxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBkZWNvcmF0aW9uTm9kZTogRWxlbWVudCB8IG51bGxcblxuICAvKipcbiAgICogVGhlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY2xpZW50IHJlY3RcbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKiBAZXhhbXBsZSAoKSA9PiBuZXcgRE9NUmVjdCgwLCAwLCAwLCAwKVxuICAgKi9cbiAgY2xpZW50UmVjdD86ICgoKSA9PiBET01SZWN0IHwgbnVsbCkgfCBudWxsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3VnZ2VzdGlvbktleURvd25Qcm9wcyB7XG4gIHZpZXc6IEVkaXRvclZpZXdcbiAgZXZlbnQ6IEtleWJvYXJkRXZlbnRcbiAgcmFuZ2U6IFJhbmdlXG59XG5cbmV4cG9ydCBjb25zdCBTdWdnZXN0aW9uUGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleSgnc3VnZ2VzdGlvbicpXG5cbi8qKlxuICogVGhpcyB1dGlsaXR5IGFsbG93cyB5b3UgdG8gY3JlYXRlIHN1Z2dlc3Rpb25zLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL3V0aWxpdGllcy9zdWdnZXN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTdWdnZXN0aW9uPEkgPSBhbnksIFRTZWxlY3RlZCA9IGFueT4oe1xuICBwbHVnaW5LZXkgPSBTdWdnZXN0aW9uUGx1Z2luS2V5LFxuICBlZGl0b3IsXG4gIGNoYXIgPSAnQCcsXG4gIGFsbG93U3BhY2VzID0gZmFsc2UsXG4gIGFsbG93VG9JbmNsdWRlQ2hhciA9IGZhbHNlLFxuICBhbGxvd2VkUHJlZml4ZXMgPSBbJyAnXSxcbiAgc3RhcnRPZkxpbmUgPSBmYWxzZSxcbiAgZGVjb3JhdGlvblRhZyA9ICdzcGFuJyxcbiAgZGVjb3JhdGlvbkNsYXNzID0gJ3N1Z2dlc3Rpb24nLFxuICBjb21tYW5kID0gKCkgPT4gbnVsbCxcbiAgaXRlbXMgPSAoKSA9PiBbXSxcbiAgcmVuZGVyID0gKCkgPT4gKHt9KSxcbiAgYWxsb3cgPSAoKSA9PiB0cnVlLFxuICBmaW5kU3VnZ2VzdGlvbk1hdGNoID0gZGVmYXVsdEZpbmRTdWdnZXN0aW9uTWF0Y2gsXG59OiBTdWdnZXN0aW9uT3B0aW9uczxJLCBUU2VsZWN0ZWQ+KSB7XG4gIGxldCBwcm9wczogU3VnZ2VzdGlvblByb3BzPEksIFRTZWxlY3RlZD4gfCB1bmRlZmluZWRcbiAgY29uc3QgcmVuZGVyZXIgPSByZW5kZXI/LigpXG5cbiAgY29uc3QgcGx1Z2luOiBQbHVnaW48YW55PiA9IG5ldyBQbHVnaW4oe1xuICAgIGtleTogcGx1Z2luS2V5LFxuXG4gICAgdmlldygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogYXN5bmMgKHZpZXcsIHByZXZTdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLmtleT8uZ2V0U3RhdGUocHJldlN0YXRlKVxuICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmtleT8uZ2V0U3RhdGUodmlldy5zdGF0ZSlcblxuICAgICAgICAgIC8vIFNlZSBob3cgdGhlIHN0YXRlIGNoYW5nZWRcbiAgICAgICAgICBjb25zdCBtb3ZlZCA9IHByZXYuYWN0aXZlICYmIG5leHQuYWN0aXZlICYmIHByZXYucmFuZ2UuZnJvbSAhPT0gbmV4dC5yYW5nZS5mcm9tXG4gICAgICAgICAgY29uc3Qgc3RhcnRlZCA9ICFwcmV2LmFjdGl2ZSAmJiBuZXh0LmFjdGl2ZVxuICAgICAgICAgIGNvbnN0IHN0b3BwZWQgPSBwcmV2LmFjdGl2ZSAmJiAhbmV4dC5hY3RpdmVcbiAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gIXN0YXJ0ZWQgJiYgIXN0b3BwZWQgJiYgcHJldi5xdWVyeSAhPT0gbmV4dC5xdWVyeVxuXG4gICAgICAgICAgY29uc3QgaGFuZGxlU3RhcnQgPSBzdGFydGVkIHx8IChtb3ZlZCAmJiBjaGFuZ2VkKVxuICAgICAgICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IGNoYW5nZWQgfHwgbW92ZWRcbiAgICAgICAgICBjb25zdCBoYW5kbGVFeGl0ID0gc3RvcHBlZCB8fCAobW92ZWQgJiYgY2hhbmdlZClcblxuICAgICAgICAgIC8vIENhbmNlbCB3aGVuIHN1Z2dlc3Rpb24gaXNuJ3QgYWN0aXZlXG4gICAgICAgICAgaWYgKCFoYW5kbGVTdGFydCAmJiAhaGFuZGxlQ2hhbmdlICYmICFoYW5kbGVFeGl0KSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IGhhbmRsZUV4aXQgJiYgIWhhbmRsZVN0YXJ0ID8gcHJldiA6IG5leHRcbiAgICAgICAgICBjb25zdCBkZWNvcmF0aW9uTm9kZSA9IHZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWRlY29yYXRpb24taWQ9XCIke3N0YXRlLmRlY29yYXRpb25JZH1cIl1gKVxuXG4gICAgICAgICAgcHJvcHMgPSB7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICByYW5nZTogc3RhdGUucmFuZ2UsXG4gICAgICAgICAgICBxdWVyeTogc3RhdGUucXVlcnksXG4gICAgICAgICAgICB0ZXh0OiBzdGF0ZS50ZXh0LFxuICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZFByb3BzID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQoe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICByYW5nZTogc3RhdGUucmFuZ2UsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGNvbW1hbmRQcm9wcyxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvcmF0aW9uTm9kZSxcbiAgICAgICAgICAgIC8vIHZpcnR1YWwgbm9kZSBmb3IgcG9zaXRpb25pbmdcbiAgICAgICAgICAgIC8vIHRoaXMgY2FuIGJlIHVzZWQgZm9yIGJ1aWxkaW5nIHBvcHVwcyB3aXRob3V0IGEgRE9NIG5vZGVcbiAgICAgICAgICAgIGNsaWVudFJlY3Q6IGRlY29yYXRpb25Ob2RlXG4gICAgICAgICAgICAgID8gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBvZiBgaXRlbXNgIGNhbiBiZSBhc3luY2hyb3Vub3VzIHdl4oCZbGwgc2VhcmNoIGZvciB0aGUgY3VycmVudCBkZWNvcmF0aW9uIG5vZGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVjb3JhdGlvbklkIH0gPSB0aGlzLmtleT8uZ2V0U3RhdGUoZWRpdG9yLnN0YXRlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RGVjb3JhdGlvbk5vZGUgPSB2aWV3LmRvbS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kZWNvcmF0aW9uLWlkPVwiJHtkZWNvcmF0aW9uSWR9XCJdYClcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZWNvcmF0aW9uTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfHwgbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVTdGFydCkge1xuICAgICAgICAgICAgcmVuZGVyZXI/Lm9uQmVmb3JlU3RhcnQ/Lihwcm9wcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlQ2hhbmdlKSB7XG4gICAgICAgICAgICByZW5kZXJlcj8ub25CZWZvcmVVcGRhdGU/Lihwcm9wcylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFuZGxlQ2hhbmdlIHx8IGhhbmRsZVN0YXJ0KSB7XG4gICAgICAgICAgICBwcm9wcy5pdGVtcyA9IGF3YWl0IGl0ZW1zKHtcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBxdWVyeTogc3RhdGUucXVlcnksXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoYW5kbGVFeGl0KSB7XG4gICAgICAgICAgICByZW5kZXJlcj8ub25FeGl0Py4ocHJvcHMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhbmRsZUNoYW5nZSkge1xuICAgICAgICAgICAgcmVuZGVyZXI/Lm9uVXBkYXRlPy4ocHJvcHMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhbmRsZVN0YXJ0KSB7XG4gICAgICAgICAgICByZW5kZXJlcj8ub25TdGFydD8uKHByb3BzKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVuZGVyZXI/Lm9uRXhpdD8uKHByb3BzKVxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0ZToge1xuICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcGx1Z2luJ3MgaW50ZXJuYWwgc3RhdGUuXG4gICAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBzdGF0ZToge1xuICAgICAgICAgIGFjdGl2ZTogYm9vbGVhblxuICAgICAgICAgIHJhbmdlOiBSYW5nZVxuICAgICAgICAgIHF1ZXJ5OiBudWxsIHwgc3RyaW5nXG4gICAgICAgICAgdGV4dDogbnVsbCB8IHN0cmluZ1xuICAgICAgICAgIGNvbXBvc2luZzogYm9vbGVhblxuICAgICAgICAgIGRlY29yYXRpb25JZD86IHN0cmluZyB8IG51bGxcbiAgICAgICAgfSA9IHtcbiAgICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICBmcm9tOiAwLFxuICAgICAgICAgICAgdG86IDAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBxdWVyeTogbnVsbCxcbiAgICAgICAgICB0ZXh0OiBudWxsLFxuICAgICAgICAgIGNvbXBvc2luZzogZmFsc2UsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgIH0sXG5cbiAgICAgIC8vIEFwcGx5IGNoYW5nZXMgdG8gdGhlIHBsdWdpbiBzdGF0ZSBmcm9tIGEgdmlldyB0cmFuc2FjdGlvbi5cbiAgICAgIGFwcGx5KHRyYW5zYWN0aW9uLCBwcmV2LCBfb2xkU3RhdGUsIHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gZWRpdG9yXG4gICAgICAgIGNvbnN0IHsgY29tcG9zaW5nIH0gPSBlZGl0b3Iudmlld1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSB9ID0gc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IG5leHQgPSB7IC4uLnByZXYgfVxuXG4gICAgICAgIG5leHQuY29tcG9zaW5nID0gY29tcG9zaW5nXG5cbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgYmUgc3VnZ2VzdGluZyBpZiB0aGUgdmlldyBpcyBlZGl0YWJsZSwgYW5kOlxuICAgICAgICAvLyAgICogdGhlcmUgaXMgbm8gc2VsZWN0aW9uLCBvclxuICAgICAgICAvLyAgICogYSBjb21wb3NpdGlvbiBpcyBhY3RpdmUgKHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xNDQ5KVxuICAgICAgICBpZiAoaXNFZGl0YWJsZSAmJiAoZW1wdHkgfHwgZWRpdG9yLnZpZXcuY29tcG9zaW5nKSkge1xuICAgICAgICAgIC8vIFJlc2V0IGFjdGl2ZSBzdGF0ZSBpZiB3ZSBqdXN0IGxlZnQgdGhlIHByZXZpb3VzIHN1Z2dlc3Rpb24gcmFuZ2VcbiAgICAgICAgICBpZiAoKGZyb20gPCBwcmV2LnJhbmdlLmZyb20gfHwgZnJvbSA+IHByZXYucmFuZ2UudG8pICYmICFjb21wb3NpbmcgJiYgIXByZXYuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICBuZXh0LmFjdGl2ZSA9IGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIGFnYWluc3Qgd2hlcmUgb3VyIGN1cnNvciBjdXJyZW50bHkgaXNcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IGZpbmRTdWdnZXN0aW9uTWF0Y2goe1xuICAgICAgICAgICAgY2hhcixcbiAgICAgICAgICAgIGFsbG93U3BhY2VzLFxuICAgICAgICAgICAgYWxsb3dUb0luY2x1ZGVDaGFyLFxuICAgICAgICAgICAgYWxsb3dlZFByZWZpeGVzLFxuICAgICAgICAgICAgc3RhcnRPZkxpbmUsXG4gICAgICAgICAgICAkcG9zaXRpb246IHNlbGVjdGlvbi4kZnJvbSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIGNvbnN0IGRlY29yYXRpb25JZCA9IGBpZF8ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYpfWBcblxuICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgbWF0Y2gsIHVwZGF0ZSB0aGUgY3VycmVudCBzdGF0ZSB0byBzaG93IGl0XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbWF0Y2ggJiZcbiAgICAgICAgICAgIGFsbG93KHtcbiAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgcmFuZ2U6IG1hdGNoLnJhbmdlLFxuICAgICAgICAgICAgICBpc0FjdGl2ZTogcHJldi5hY3RpdmUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbmV4dC5hY3RpdmUgPSB0cnVlXG4gICAgICAgICAgICBuZXh0LmRlY29yYXRpb25JZCA9IHByZXYuZGVjb3JhdGlvbklkID8gcHJldi5kZWNvcmF0aW9uSWQgOiBkZWNvcmF0aW9uSWRcbiAgICAgICAgICAgIG5leHQucmFuZ2UgPSBtYXRjaC5yYW5nZVxuICAgICAgICAgICAgbmV4dC5xdWVyeSA9IG1hdGNoLnF1ZXJ5XG4gICAgICAgICAgICBuZXh0LnRleHQgPSBtYXRjaC50ZXh0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQuYWN0aXZlID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dC5hY3RpdmUgPSBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRvIGVtcHR5IHRoZSByYW5nZSBpZiBzdWdnZXN0aW9uIGlzIGluYWN0aXZlXG4gICAgICAgIGlmICghbmV4dC5hY3RpdmUpIHtcbiAgICAgICAgICBuZXh0LmRlY29yYXRpb25JZCA9IG51bGxcbiAgICAgICAgICBuZXh0LnJhbmdlID0geyBmcm9tOiAwLCB0bzogMCB9XG4gICAgICAgICAgbmV4dC5xdWVyeSA9IG51bGxcbiAgICAgICAgICBuZXh0LnRleHQgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dFxuICAgICAgfSxcbiAgICB9LFxuXG4gICAgcHJvcHM6IHtcbiAgICAgIC8vIENhbGwgdGhlIGtleWRvd24gaG9vayBpZiBzdWdnZXN0aW9uIGlzIGFjdGl2ZS5cbiAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyBhY3RpdmUsIHJhbmdlIH0gPSBwbHVnaW4uZ2V0U3RhdGUodmlldy5zdGF0ZSlcblxuICAgICAgICBpZiAoIWFjdGl2ZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyPy5vbktleURvd24/Lih7IHZpZXcsIGV2ZW50LCByYW5nZSB9KSB8fCBmYWxzZVxuICAgICAgfSxcblxuICAgICAgLy8gU2V0dXAgZGVjb3JhdG9yIG9uIHRoZSBjdXJyZW50bHkgYWN0aXZlIHN1Z2dlc3Rpb24uXG4gICAgICBkZWNvcmF0aW9ucyhzdGF0ZSkge1xuICAgICAgICBjb25zdCB7IGFjdGl2ZSwgcmFuZ2UsIGRlY29yYXRpb25JZCB9ID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKVxuXG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtcbiAgICAgICAgICBEZWNvcmF0aW9uLmlubGluZShyYW5nZS5mcm9tLCByYW5nZS50bywge1xuICAgICAgICAgICAgbm9kZU5hbWU6IGRlY29yYXRpb25UYWcsXG4gICAgICAgICAgICBjbGFzczogZGVjb3JhdGlvbkNsYXNzLFxuICAgICAgICAgICAgJ2RhdGEtZGVjb3JhdGlvbi1pZCc6IGRlY29yYXRpb25JZCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgXSlcbiAgICAgIH0sXG4gICAgfSxcbiAgfSlcblxuICByZXR1cm4gcGx1Z2luXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBSYW5nZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IGVzY2FwZUZvclJlZ0V4IH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHR5cGUgeyBSZXNvbHZlZFBvcyB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJpZ2dlciB7XG4gIGNoYXI6IHN0cmluZ1xuICBhbGxvd1NwYWNlczogYm9vbGVhblxuICBhbGxvd1RvSW5jbHVkZUNoYXI6IGJvb2xlYW5cbiAgYWxsb3dlZFByZWZpeGVzOiBzdHJpbmdbXSB8IG51bGxcbiAgc3RhcnRPZkxpbmU6IGJvb2xlYW5cbiAgJHBvc2l0aW9uOiBSZXNvbHZlZFBvc1xufVxuXG5leHBvcnQgdHlwZSBTdWdnZXN0aW9uTWF0Y2ggPSB7XG4gIHJhbmdlOiBSYW5nZVxuICBxdWVyeTogc3RyaW5nXG4gIHRleHQ6IHN0cmluZ1xufSB8IG51bGxcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRTdWdnZXN0aW9uTWF0Y2goY29uZmlnOiBUcmlnZ2VyKTogU3VnZ2VzdGlvbk1hdGNoIHtcbiAgY29uc3QgeyBjaGFyLCBhbGxvd1NwYWNlczogYWxsb3dTcGFjZXNPcHRpb24sIGFsbG93VG9JbmNsdWRlQ2hhciwgYWxsb3dlZFByZWZpeGVzLCBzdGFydE9mTGluZSwgJHBvc2l0aW9uIH0gPSBjb25maWdcblxuICBjb25zdCBhbGxvd1NwYWNlcyA9IGFsbG93U3BhY2VzT3B0aW9uICYmICFhbGxvd1RvSW5jbHVkZUNoYXJcblxuICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZUZvclJlZ0V4KGNoYXIpXG4gIGNvbnN0IHN1ZmZpeCA9IG5ldyBSZWdFeHAoYFxcXFxzJHtlc2NhcGVkQ2hhcn0kYClcbiAgY29uc3QgcHJlZml4ID0gc3RhcnRPZkxpbmUgPyAnXicgOiAnJ1xuICBjb25zdCBmaW5hbEVzY2FwZWRDaGFyID0gYWxsb3dUb0luY2x1ZGVDaGFyID8gJycgOiBlc2NhcGVkQ2hhclxuICBjb25zdCByZWdleHAgPSBhbGxvd1NwYWNlc1xuICAgID8gbmV3IFJlZ0V4cChgJHtwcmVmaXh9JHtlc2NhcGVkQ2hhcn0uKj8oPz1cXFxccyR7ZmluYWxFc2NhcGVkQ2hhcn18JClgLCAnZ20nKVxuICAgIDogbmV3IFJlZ0V4cChgJHtwcmVmaXh9KD86Xik/JHtlc2NhcGVkQ2hhcn1bXlxcXFxzJHtmaW5hbEVzY2FwZWRDaGFyfV0qYCwgJ2dtJylcblxuICBjb25zdCB0ZXh0ID0gJHBvc2l0aW9uLm5vZGVCZWZvcmU/LmlzVGV4dCAmJiAkcG9zaXRpb24ubm9kZUJlZm9yZS50ZXh0XG5cbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHRleHRGcm9tID0gJHBvc2l0aW9uLnBvcyAtIHRleHQubGVuZ3RoXG4gIGNvbnN0IG1hdGNoID0gQXJyYXkuZnJvbSh0ZXh0Lm1hdGNoQWxsKHJlZ2V4cCkpLnBvcCgpXG5cbiAgaWYgKCFtYXRjaCB8fCBtYXRjaC5pbnB1dCA9PT0gdW5kZWZpbmVkIHx8IG1hdGNoLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gSmF2YVNjcmlwdCBkb2Vzbid0IGhhdmUgbG9va2JlaGluZHMuIFRoaXMgaGFja3MgYSBjaGVjayB0aGF0IGZpcnN0IGNoYXJhY3RlclxuICAvLyBpcyBhIHNwYWNlIG9yIHRoZSBzdGFydCBvZiB0aGUgbGluZVxuICBjb25zdCBtYXRjaFByZWZpeCA9IG1hdGNoLmlucHV0LnNsaWNlKE1hdGgubWF4KDAsIG1hdGNoLmluZGV4IC0gMSksIG1hdGNoLmluZGV4KVxuICBjb25zdCBtYXRjaFByZWZpeElzQWxsb3dlZCA9IG5ldyBSZWdFeHAoYF5bJHthbGxvd2VkUHJlZml4ZXM/LmpvaW4oJycpfVxcMF0/JGApLnRlc3QobWF0Y2hQcmVmaXgpXG5cbiAgaWYgKGFsbG93ZWRQcmVmaXhlcyAhPT0gbnVsbCAmJiAhbWF0Y2hQcmVmaXhJc0FsbG93ZWQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBtYXRjaCBpbiB0aGUgZG9jdW1lbnRcbiAgY29uc3QgZnJvbSA9IHRleHRGcm9tICsgbWF0Y2guaW5kZXhcbiAgbGV0IHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aFxuXG4gIC8vIEVkZ2UgY2FzZSBoYW5kbGluZzsgaWYgc3BhY2VzIGFyZSBhbGxvd2VkIGFuZCB3ZSdyZSBkaXJlY3RseSBpbiBiZXR3ZWVuXG4gIC8vIHR3byB0cmlnZ2Vyc1xuICBpZiAoYWxsb3dTcGFjZXMgJiYgc3VmZml4LnRlc3QodGV4dC5zbGljZSh0byAtIDEsIHRvICsgMSkpKSB7XG4gICAgbWF0Y2hbMF0gKz0gJyAnXG4gICAgdG8gKz0gMVxuICB9XG5cbiAgLy8gSWYgdGhlICRwb3NpdGlvbiBpcyBsb2NhdGVkIHdpdGhpbiB0aGUgbWF0Y2hlZCBzdWJzdHJpbmcsIHJldHVybiB0aGF0IHJhbmdlXG4gIGlmIChmcm9tIDwgJHBvc2l0aW9uLnBvcyAmJiB0byA+PSAkcG9zaXRpb24ucG9zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgfSxcbiAgICAgIHF1ZXJ5OiBtYXRjaFswXS5zbGljZShjaGFyLmxlbmd0aCksXG4gICAgICB0ZXh0OiBtYXRjaFswXSxcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwgImltcG9ydCB7IFN1Z2dlc3Rpb24gfSBmcm9tICcuL3N1Z2dlc3Rpb24uanMnXG5cbmV4cG9ydCAqIGZyb20gJy4vZmluZFN1Z2dlc3Rpb25NYXRjaC5qcydcbmV4cG9ydCAqIGZyb20gJy4vc3VnZ2VzdGlvbi5qcydcblxuZXhwb3J0IGRlZmF1bHQgU3VnZ2VzdGlvblxuIiwgImltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSdcbmltcG9ydCBTdWdnZXN0aW9uIGZyb20gJ0B0aXB0YXAvc3VnZ2VzdGlvbidcblxuY29uc3QgZ2V0U3VnZ2VzdGlvbk9wdGlvbnMgPSBmdW5jdGlvbiAoe1xuICAgIGVkaXRvcjogdGlwdGFwRWRpdG9yLFxuICAgIG92ZXJyaWRlU3VnZ2VzdGlvbk9wdGlvbnMsXG4gICAgZXh0ZW5zaW9uTmFtZSxcbn0pIHtcbiAgICBjb25zdCBwbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KClcblxuICAgIHJldHVybiB7XG4gICAgICAgIGVkaXRvcjogdGlwdGFwRWRpdG9yLFxuICAgICAgICBjaGFyOiAne3snLFxuICAgICAgICBwbHVnaW5LZXksXG4gICAgICAgIGNvbW1hbmQ6ICh7IGVkaXRvciwgcmFuZ2UsIHByb3BzIH0pID0+IHtcbiAgICAgICAgICAgIC8vIGluY3JlYXNlIHJhbmdlLnRvIGJ5IG9uZSB3aGVuIHRoZSBuZXh0IG5vZGUgaXMgb2YgdHlwZSBcInRleHRcIlxuICAgICAgICAgICAgLy8gYW5kIHN0YXJ0cyB3aXRoIGEgc3BhY2UgY2hhcmFjdGVyXG4gICAgICAgICAgICBjb25zdCBub2RlQWZ0ZXIgPSBlZGl0b3Iudmlldy5zdGF0ZS5zZWxlY3Rpb24uJHRvLm5vZGVBZnRlclxuICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGVTcGFjZSA9IG5vZGVBZnRlcj8udGV4dD8uc3RhcnRzV2l0aCgnICcpXG5cbiAgICAgICAgICAgIGlmIChvdmVycmlkZVNwYWNlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UudG8gKz0gMVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgICAgICAuY2hhaW4oKVxuICAgICAgICAgICAgICAgIC5mb2N1cygpXG4gICAgICAgICAgICAgICAgLmluc2VydENvbnRlbnRBdChyYW5nZSwgW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBleHRlbnNpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgLi4ucHJvcHMgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJyAnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLnJ1bigpXG5cbiAgICAgICAgICAgIC8vIGdldCByZWZlcmVuY2UgdG8gYHdpbmRvd2Agb2JqZWN0IGZyb20gZWRpdG9yIGVsZW1lbnQsIHRvIHN1cHBvcnQgY3Jvc3MtZnJhbWUgSlMgdXNhZ2VcbiAgICAgICAgICAgIGVkaXRvci52aWV3LmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3XG4gICAgICAgICAgICAgICAgPy5nZXRTZWxlY3Rpb24oKVxuICAgICAgICAgICAgICAgID8uY29sbGFwc2VUb0VuZCgpXG4gICAgICAgIH0sXG4gICAgICAgIGFsbG93OiAoeyBzdGF0ZSwgcmFuZ2UgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgJGZyb20gPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5mcm9tKVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHN0YXRlLnNjaGVtYS5ub2Rlc1tleHRlbnNpb25OYW1lXVxuICAgICAgICAgICAgY29uc3QgYWxsb3cgPSAhISRmcm9tLnBhcmVudC50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUodHlwZSlcblxuICAgICAgICAgICAgcmV0dXJuIGFsbG93XG4gICAgICAgIH0sXG4gICAgICAgIC4uLm92ZXJyaWRlU3VnZ2VzdGlvbk9wdGlvbnMsXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ21lcmdlVGFnJyxcblxuICAgIHByaW9yaXR5OiAxMDEsXG5cbiAgICBhZGRTdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VnZ2VzdGlvbnM6IFtdLFxuICAgICAgICAgICAgZ2V0U3VnZ2VzdGlvbkZyb21DaGFyOiAoKSA9PiBudWxsLFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgICAgICByZW5kZXJUZXh0KHsgbm9kZSB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGB7eyAke25vZGUuYXR0cnMubGFiZWwgPz8gbm9kZS5hdHRycy5pZH0gfX1gXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVsZXRlVHJpZ2dlcldpdGhCYWNrc3BhY2U6IGZhbHNlLFxuICAgICAgICAgICAgcmVuZGVySFRNTCh7IG9wdGlvbnMsIG5vZGUgfSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5IVE1MQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGAke25vZGUuYXR0cnMubGFiZWwgPz8gbm9kZS5hdHRycy5pZH1gLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWdnZXN0aW9uczogW10sXG4gICAgICAgICAgICBzdWdnZXN0aW9uOiB7fSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBncm91cDogJ2lubGluZScsXG5cbiAgICBpbmxpbmU6IHRydWUsXG5cbiAgICBzZWxlY3RhYmxlOiBmYWxzZSxcblxuICAgIGF0b206IHRydWUsXG5cbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWlkJyksXG4gICAgICAgICAgICAgICAgcmVuZGVySFRNTDogKGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1pZCc6IGF0dHJpYnV0ZXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWxhYmVsJyksXG4gICAgICAgICAgICAgICAgcmVuZGVySFRNTDogKGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge31cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1sYWJlbCc6IGF0dHJpYnV0ZXMubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiBgc3BhbltkYXRhLXR5cGU9XCIke3RoaXMubmFtZX1cIl1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXVxuICAgIH0sXG5cbiAgICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIHRoZSBgdGhpcy5zdG9yYWdlYCBwcm9wZXJ0eSBoZXJlIGJlY2F1c2UsIHdoZW4gYWNjZXNzZWQgdGhpcyBtZXRob2QsXG4gICAgICAgIC8vIGl0IHJldHVybnMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGV4dGVuc2lvbiBzdG9yYWdlXG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb24gPVxuICAgICAgICAgICAgdGhpcy5lZGl0b3I/LmV4dGVuc2lvblN0b3JhZ2U/Llt0aGlzLm5hbWVdPy5nZXRTdWdnZXN0aW9uRnJvbUNoYXIoXG4gICAgICAgICAgICAgICAgJ3t7JyxcbiAgICAgICAgICAgIClcblxuICAgICAgICBjb25zdCBtZXJnZWRPcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMgfVxuXG4gICAgICAgIG1lcmdlZE9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMgPSBtZXJnZUF0dHJpYnV0ZXMoXG4gICAgICAgICAgICB7ICdkYXRhLXR5cGUnOiB0aGlzLm5hbWUgfSxcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcyxcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICApXG5cbiAgICAgICAgY29uc3QgaHRtbCA9IHRoaXMub3B0aW9ucy5yZW5kZXJIVE1MKHtcbiAgICAgICAgICAgIG9wdGlvbnM6IG1lcmdlZE9wdGlvbnMsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc3VnZ2VzdGlvbixcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAodHlwZW9mIGh0bWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdzcGFuJyxcbiAgICAgICAgICAgICAgICBtZXJnZUF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICAgIHsgJ2RhdGEtdHlwZSc6IHRoaXMubmFtZSB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaHRtbCxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbFxuICAgIH0sXG5cbiAgICByZW5kZXJUZXh0KHsgbm9kZSB9KSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgc3VnZ2VzdGlvbjpcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvcj8uZXh0ZW5zaW9uU3RvcmFnZT8uW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWVcbiAgICAgICAgICAgICAgICBdPy5nZXRTdWdnZXN0aW9uRnJvbUNoYXIoJ3t7JyksXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJlbmRlclRleHQoYXJncylcbiAgICB9LFxuXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBCYWNrc3BhY2U6ICgpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciwgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNNZXJnZVRhZyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGVtcHR5LCBhbmNob3IgfSA9IHNlbGVjdGlvblxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgbm9kZSBhbmQgcG9zaXRpb24gZm9yIGxhdGVyIHVzZVxuICAgICAgICAgICAgICAgICAgICBsZXQgbWVyZ2VUYWdOb2RlID0gbmV3IFByb3NlTWlycm9yTm9kZSgpXG4gICAgICAgICAgICAgICAgICAgIGxldCBtZXJnZVRhZ1BvcyA9IDBcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGFuY2hvciAtIDEsIGFuY2hvciwgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5uYW1lID09PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc01lcmdlVGFnID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlVGFnTm9kZSA9IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZVRhZ1BvcyA9IHBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01lcmdlVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5pbnNlcnRUZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kZWxldGVUcmlnZ2VyV2l0aEJhY2tzcGFjZSA/ICcnIDogJ3t7JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZVRhZ1BvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZVRhZ1BvcyArIG1lcmdlVGFnTm9kZS5ub2RlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc01lcmdlVGFnXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udGhpcy5zdG9yYWdlLnN1Z2dlc3Rpb25zLm1hcChTdWdnZXN0aW9uKSwgLy8gQ3JlYXRlIGEgcGx1Z2luIGZvciBlYWNoIHN1Z2dlc3Rpb24gY29uZmlndXJhdGlvblxuICAgICAgICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRHJvcCh2aWV3LCBldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoJ21lcmdlVGFnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VUYWdJZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoJ21lcmdlVGFnJylcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnN0YXRlLnRyLmluc2VydChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5wb3NBdENvb3Jkcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBldmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuc3RhdGUuc2NoZW1hLm5vZGVzLm1lcmdlVGFnLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbWVyZ2VUYWdJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdXG4gICAgfSxcblxuICAgIG9uQmVmb3JlQ3JlYXRlKCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc3VnZ2VzdGlvbnMgPSAoXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3VnZ2VzdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyB0aGlzLm9wdGlvbnMuc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgICAgICA6IFt0aGlzLm9wdGlvbnMuc3VnZ2VzdGlvbl1cbiAgICAgICAgKS5tYXAoKHN1Z2dlc3Rpb24pID0+XG4gICAgICAgICAgICBnZXRTdWdnZXN0aW9uT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICBvdmVycmlkZVN1Z2dlc3Rpb25PcHRpb25zOiBzdWdnZXN0aW9uLFxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbk5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICApXG5cbiAgICAgICAgdGhpcy5zdG9yYWdlLmdldFN1Z2dlc3Rpb25Gcm9tQ2hhciA9IChjaGFyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWdnZXN0aW9uID0gdGhpcy5zdG9yYWdlLnN1Z2dlc3Rpb25zLmZpbmQoXG4gICAgICAgICAgICAgICAgKHMpID0+IHMuY2hhciA9PT0gY2hhcixcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChzdWdnZXN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Z2dlc3Rpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JhZ2Uuc3VnZ2VzdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zdWdnZXN0aW9uc1swXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhcmFncmFwaE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIEhUTUwgYXR0cmlidXRlcyBmb3IgYSBwYXJhZ3JhcGggbm9kZS5cbiAgICogQGRlZmF1bHQge31cbiAgICogQGV4YW1wbGUgeyBjbGFzczogJ2ZvbycgfVxuICAgKi9cbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHBhcmFncmFwaDoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBwYXJhZ3JhcGhcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy50b2dnbGVQYXJhZ3JhcGgoKVxuICAgICAgICovXG4gICAgICBzZXRQYXJhZ3JhcGg6ICgpID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBwYXJhZ3JhcGhzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9wYXJhZ3JhcGhcbiAqL1xuZXhwb3J0IGNvbnN0IFBhcmFncmFwaCA9IE5vZGUuY3JlYXRlPFBhcmFncmFwaE9wdGlvbnM+KHtcbiAgbmFtZTogJ3BhcmFncmFwaCcsXG5cbiAgcHJpb3JpdHk6IDEwMDAsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBncm91cDogJ2Jsb2NrJyxcblxuICBjb250ZW50OiAnaW5saW5lKicsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6ICdwJyB9XVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsncCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0UGFyYWdyYXBoOlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodGhpcy5uYW1lKVxuICAgICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1BbHQtMCc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFBhcmFncmFwaCgpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgUGFyYWdyYXBoIH0gZnJvbSAnLi9wYXJhZ3JhcGguanMnXG5cbmV4cG9ydCAqIGZyb20gJy4vcGFyYWdyYXBoLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBQYXJhZ3JhcGhcbiIsICJpbXBvcnQgeyBQbGFjZWhvbGRlciB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9ucydcblxuZXhwb3J0IHR5cGUgeyBQbGFjZWhvbGRlck9wdGlvbnMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbnMnXG5leHBvcnQgeyBQbGFjZWhvbGRlciB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9ucydcblxuZXhwb3J0IGRlZmF1bHQgUGxhY2Vob2xkZXJcbiIsICJpbXBvcnQgeyBNYXJrLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RyaWtlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBIVE1MIGF0dHJpYnV0ZXMgdG8gYWRkIHRvIHRoZSBzdHJpa2UgZWxlbWVudC5cbiAgICogQGRlZmF1bHQge31cbiAgICogQGV4YW1wbGUgeyBjbGFzczogJ2ZvbycgfVxuICAgKi9cbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHN0cmlrZToge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBzdHJpa2UgbWFya1xuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNldFN0cmlrZSgpXG4gICAgICAgKi9cbiAgICAgIHNldFN0cmlrZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgYSBzdHJpa2UgbWFya1xuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVN0cmlrZSgpXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZVN0cmlrZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgICAgLyoqXG4gICAgICAgKiBVbnNldCBhIHN0cmlrZSBtYXJrXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudW5zZXRTdHJpa2UoKVxuICAgICAgICovXG4gICAgICB1bnNldFN0cmlrZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hdGNoZXMgYSBzdHJpa2UgdG8gYSB+fnN0cmlrZX5+IG9uIGlucHV0LlxuICovXG5leHBvcnQgY29uc3QgaW5wdXRSZWdleCA9IC8oPzpefFxccykofn4oPyFcXHMrfn4pKCg/Oltefl0rKSl+fig/IVxccyt+fikpJC9cblxuLyoqXG4gKiBNYXRjaGVzIGEgc3RyaWtlIHRvIGEgfn5zdHJpa2V+fiBvbiBwYXN0ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhc3RlUmVnZXggPSAvKD86XnxcXHMpKH5+KD8hXFxzK35+KSgoPzpbXn5dKykpfn4oPyFcXHMrfn4pKS9nXG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgc3RyaWtlIHRleHQuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL3N0cmlrZVxuICovXG5leHBvcnQgY29uc3QgU3RyaWtlID0gTWFyay5jcmVhdGU8U3RyaWtlT3B0aW9ucz4oe1xuICBuYW1lOiAnc3RyaWtlJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRhZzogJ2RlbCcsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0YWc6ICdzdHJpa2UnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICBjb25zdW1pbmc6IGZhbHNlLFxuICAgICAgICBnZXRBdHRyczogc3R5bGUgPT4gKChzdHlsZSBhcyBzdHJpbmcpLmluY2x1ZGVzKCdsaW5lLXRocm91Z2gnKSA/IHt9IDogZmFsc2UpLFxuICAgICAgfSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydzJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRTdHJpa2U6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICAgIH0sXG4gICAgICB0b2dnbGVTdHJpa2U6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICAgIH0sXG4gICAgICB1bnNldFN0cmlrZTpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC1TaGlmdC1zJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlU3RyaWtlKCksXG4gICAgfVxuICB9LFxuXG4gIGFkZElucHV0UnVsZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICB9KSxcbiAgICBdXG4gIH0sXG5cbiAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgU3RyaWtlIH0gZnJvbSAnLi9zdHJpa2UuanMnXG5cbmV4cG9ydCAqIGZyb20gJy4vc3RyaWtlLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBTdHJpa2VcbiIsICJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgdHlwZSB7IFN0eWxlUGFyc2VSdWxlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuZXhwb3J0IGludGVyZmFjZSBTdWJzY3JpcHRFeHRlbnNpb25PcHRpb25zIHtcbiAgLyoqXG4gICAqIEhUTUwgYXR0cmlidXRlcyB0byBhZGQgdG8gdGhlIHN1YnNjcmlwdCBlbGVtZW50LlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAZXhhbXBsZSB7IGNsYXNzOiAnZm9vJyB9XG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc3Vic2NyaXB0OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNldCBhIHN1YnNjcmlwdCBtYXJrXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0U3Vic2NyaXB0KClcbiAgICAgICAqL1xuICAgICAgc2V0U3Vic2NyaXB0OiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSBhIHN1YnNjcmlwdCBtYXJrXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudG9nZ2xlU3Vic2NyaXB0KClcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlU3Vic2NyaXB0OiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGEgc3Vic2NyaXB0IG1hcmtcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy51bnNldFN1YnNjcmlwdCgpXG4gICAgICAgKi9cbiAgICAgIHVuc2V0U3Vic2NyaXB0OiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgc3Vic2NyaXB0IHRleHQuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL3N1YnNjcmlwdFxuICovXG5leHBvcnQgY29uc3QgU3Vic2NyaXB0ID0gTWFyay5jcmVhdGU8U3Vic2NyaXB0RXh0ZW5zaW9uT3B0aW9ucz4oe1xuICBuYW1lOiAnc3Vic2NyaXB0JyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0YWc6ICdzdWInLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3R5bGU6ICd2ZXJ0aWNhbC1hbGlnbicsXG4gICAgICAgIGdldEF0dHJzKHZhbHVlKSB7XG4gICAgICAgICAgLy8gRG9u4oCZdCBtYXRjaCB0aGlzIHJ1bGUgaWYgdGhlIHZlcnRpY2FsIGFsaWduIGlzbuKAmXQgc3ViLlxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJ3N1YicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGl0IGZhbGxzIHRocm91Z2ggd2XigJlsbCBtYXRjaCwgYW5kIHRoaXMgbWFyayB3aWxsIGJlIGFwcGxpZWQuXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSxcbiAgICAgIH0gYXMgU3R5bGVQYXJzZVJ1bGUsXG4gICAgXVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgcmV0dXJuIFsnc3ViJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxuXG4gIGFkZENvbW1hbmRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXRTdWJzY3JpcHQ6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICAgIH0sXG4gICAgICB0b2dnbGVTdWJzY3JpcHQ6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICAgIH0sXG4gICAgICB1bnNldFN1YnNjcmlwdDpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgICB9LFxuICAgIH1cbiAgfSxcblxuICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ01vZC0sJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlU3Vic2NyaXB0KCksXG4gICAgfVxuICB9LFxufSlcbiIsICJpbXBvcnQgeyBTdWJzY3JpcHQgfSBmcm9tICcuL3N1YnNjcmlwdC5qcydcblxuZXhwb3J0ICogZnJvbSAnLi9zdWJzY3JpcHQuanMnXG5cbmV4cG9ydCBkZWZhdWx0IFN1YnNjcmlwdFxuIiwgImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB0eXBlIHsgU3R5bGVQYXJzZVJ1bGUgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFN1cGVyc2NyaXB0RXh0ZW5zaW9uT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBIVE1MIGF0dHJpYnV0ZXMgdG8gYWRkIHRvIHRoZSBzdXBlcnNjcmlwdCBlbGVtZW50LlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAZXhhbXBsZSB7IGNsYXNzOiAnZm9vJyB9XG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG5kZWNsYXJlIG1vZHVsZSAnQHRpcHRhcC9jb3JlJyB7XG4gIGludGVyZmFjZSBDb21tYW5kczxSZXR1cm5UeXBlPiB7XG4gICAgc3VwZXJzY3JpcHQ6IHtcbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgc3VwZXJzY3JpcHQgbWFya1xuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNldFN1cGVyc2NyaXB0KClcbiAgICAgICAqL1xuICAgICAgc2V0U3VwZXJzY3JpcHQ6ICgpID0+IFJldHVyblR5cGVcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGEgc3VwZXJzY3JpcHQgbWFya1xuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVN1cGVyc2NyaXB0KClcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlU3VwZXJzY3JpcHQ6ICgpID0+IFJldHVyblR5cGVcbiAgICAgIC8qKlxuICAgICAgICogVW5zZXQgYSBzdXBlcnNjcmlwdCBtYXJrXG4gICAgICAgKiAgQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnVuc2V0U3VwZXJzY3JpcHQoKVxuICAgICAgICovXG4gICAgICB1bnNldFN1cGVyc2NyaXB0OiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgc3VwZXJzY3JpcHQgdGV4dC5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbWFya3Mvc3VwZXJzY3JpcHRcbiAqL1xuZXhwb3J0IGNvbnN0IFN1cGVyc2NyaXB0ID0gTWFyay5jcmVhdGU8U3VwZXJzY3JpcHRFeHRlbnNpb25PcHRpb25zPih7XG4gIG5hbWU6ICdzdXBlcnNjcmlwdCcsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAnc3VwJyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHN0eWxlOiAndmVydGljYWwtYWxpZ24nLFxuICAgICAgICBnZXRBdHRycyh2YWx1ZSkge1xuICAgICAgICAgIC8vIERvbuKAmXQgbWF0Y2ggdGhpcyBydWxlIGlmIHRoZSB2ZXJ0aWNhbCBhbGlnbiBpc27igJl0IHN1cGVyLlxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJ3N1cGVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgaXQgZmFsbHMgdGhyb3VnaCB3ZeKAmWxsIG1hdGNoLCBhbmQgdGhpcyBtYXJrIHdpbGwgYmUgYXBwbGllZC5cbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9LFxuICAgICAgfSBhcyBTdHlsZVBhcnNlUnVsZSxcbiAgICBdXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWydzdXAnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFN1cGVyc2NyaXB0OlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKVxuICAgICAgICB9LFxuICAgICAgdG9nZ2xlU3VwZXJzY3JpcHQ6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpXG4gICAgICAgIH0sXG4gICAgICB1bnNldFN1cGVyc2NyaXB0OlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLS4nOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVTdXBlcnNjcmlwdCgpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgU3VwZXJzY3JpcHQgfSBmcm9tICcuL3N1cGVyc2NyaXB0LmpzJ1xuXG5leHBvcnQgKiBmcm9tICcuL3N1cGVyc2NyaXB0LmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBTdXBlcnNjcmlwdFxuIiwgIi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgUGx1Z2luIGFzIFBsdWdpbjIgfSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcblxuLy8gc3JjL2NlbGxzZWxlY3Rpb24udHNcbmltcG9ydCB7IEZyYWdtZW50LCBTbGljZSB9IGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuaW1wb3J0IHtcbiAgTm9kZVNlbGVjdGlvbiBhcyBOb2RlU2VsZWN0aW9uMixcbiAgU2VsZWN0aW9uLFxuICBTZWxlY3Rpb25SYW5nZSxcbiAgVGV4dFNlbGVjdGlvblxufSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjtcbmltcG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQgfSBmcm9tIFwicHJvc2VtaXJyb3Itdmlld1wiO1xuXG4vLyBzcmMvdGFibGVtYXAudHNcbnZhciByZWFkRnJvbUNhY2hlO1xudmFyIGFkZFRvQ2FjaGU7XG5pZiAodHlwZW9mIFdlYWtNYXAgIT0gXCJ1bmRlZmluZWRcIikge1xuICBsZXQgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgcmVhZEZyb21DYWNoZSA9IChrZXkpID0+IGNhY2hlLmdldChrZXkpO1xuICBhZGRUb0NhY2hlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufSBlbHNlIHtcbiAgY29uc3QgY2FjaGUgPSBbXTtcbiAgY29uc3QgY2FjaGVTaXplID0gMTA7XG4gIGxldCBjYWNoZVBvcyA9IDA7XG4gIHJlYWRGcm9tQ2FjaGUgPSAoa2V5KSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWNoZS5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGlmIChjYWNoZVtpXSA9PSBrZXkpIHJldHVybiBjYWNoZVtpICsgMV07XG4gIH07XG4gIGFkZFRvQ2FjaGUgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmIChjYWNoZVBvcyA9PSBjYWNoZVNpemUpIGNhY2hlUG9zID0gMDtcbiAgICBjYWNoZVtjYWNoZVBvcysrXSA9IGtleTtcbiAgICByZXR1cm4gY2FjaGVbY2FjaGVQb3MrK10gPSB2YWx1ZTtcbiAgfTtcbn1cbnZhciBUYWJsZU1hcCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgbWFwLCBwcm9ibGVtcykge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICB0aGlzLnByb2JsZW1zID0gcHJvYmxlbXM7XG4gIH1cbiAgLy8gRmluZCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgY2VsbCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gIGZpbmRDZWxsKHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1clBvcyA9IHRoaXMubWFwW2ldO1xuICAgICAgaWYgKGN1clBvcyAhPSBwb3MpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbGVmdCA9IGkgJSB0aGlzLndpZHRoO1xuICAgICAgY29uc3QgdG9wID0gaSAvIHRoaXMud2lkdGggfCAwO1xuICAgICAgbGV0IHJpZ2h0ID0gbGVmdCArIDE7XG4gICAgICBsZXQgYm90dG9tID0gdG9wICsgMTtcbiAgICAgIGZvciAobGV0IGogPSAxOyByaWdodCA8IHRoaXMud2lkdGggJiYgdGhpcy5tYXBbaSArIGpdID09IGN1clBvczsgaisrKSB7XG4gICAgICAgIHJpZ2h0Kys7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBqID0gMTsgYm90dG9tIDwgdGhpcy5oZWlnaHQgJiYgdGhpcy5tYXBbaSArIHRoaXMud2lkdGggKiBqXSA9PSBjdXJQb3M7IGorKykge1xuICAgICAgICBib3R0b20rKztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gY2VsbCB3aXRoIG9mZnNldCAke3Bvc30gZm91bmRgKTtcbiAgfVxuICAvLyBGaW5kIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGNlbGwgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICBjb2xDb3VudChwb3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5tYXBbaV0gPT0gcG9zKSB7XG4gICAgICAgIHJldHVybiBpICUgdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIGNlbGwgd2l0aCBvZmZzZXQgJHtwb3N9IGZvdW5kYCk7XG4gIH1cbiAgLy8gRmluZCB0aGUgbmV4dCBjZWxsIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24sIHN0YXJ0aW5nIGZyb20gdGhlIGNlbGxcbiAgLy8gYXQgYHBvc2AsIGlmIGFueS5cbiAgbmV4dENlbGwocG9zLCBheGlzLCBkaXIpIHtcbiAgICBjb25zdCB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gdGhpcy5maW5kQ2VsbChwb3MpO1xuICAgIGlmIChheGlzID09IFwiaG9yaXpcIikge1xuICAgICAgaWYgKGRpciA8IDAgPyBsZWZ0ID09IDAgOiByaWdodCA9PSB0aGlzLndpZHRoKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLm1hcFt0b3AgKiB0aGlzLndpZHRoICsgKGRpciA8IDAgPyBsZWZ0IC0gMSA6IHJpZ2h0KV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaXIgPCAwID8gdG9wID09IDAgOiBib3R0b20gPT0gdGhpcy5oZWlnaHQpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMubWFwW2xlZnQgKyB0aGlzLndpZHRoICogKGRpciA8IDAgPyB0b3AgLSAxIDogYm90dG9tKV07XG4gICAgfVxuICB9XG4gIC8vIEdldCB0aGUgcmVjdGFuZ2xlIHNwYW5uaW5nIHRoZSB0d28gZ2l2ZW4gY2VsbHMuXG4gIHJlY3RCZXR3ZWVuKGEsIGIpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0OiBsZWZ0QSxcbiAgICAgIHJpZ2h0OiByaWdodEEsXG4gICAgICB0b3A6IHRvcEEsXG4gICAgICBib3R0b206IGJvdHRvbUFcbiAgICB9ID0gdGhpcy5maW5kQ2VsbChhKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0OiBsZWZ0QixcbiAgICAgIHJpZ2h0OiByaWdodEIsXG4gICAgICB0b3A6IHRvcEIsXG4gICAgICBib3R0b206IGJvdHRvbUJcbiAgICB9ID0gdGhpcy5maW5kQ2VsbChiKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogTWF0aC5taW4obGVmdEEsIGxlZnRCKSxcbiAgICAgIHRvcDogTWF0aC5taW4odG9wQSwgdG9wQiksXG4gICAgICByaWdodDogTWF0aC5tYXgocmlnaHRBLCByaWdodEIpLFxuICAgICAgYm90dG9tOiBNYXRoLm1heChib3R0b21BLCBib3R0b21CKVxuICAgIH07XG4gIH1cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiBhbGwgY2VsbHMgdGhhdCBoYXZlIHRoZSB0b3AgbGVmdCBjb3JuZXIgaW5cbiAgLy8gdGhlIGdpdmVuIHJlY3RhbmdsZS5cbiAgY2VsbHNJblJlY3QocmVjdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHNlZW4gPSB7fTtcbiAgICBmb3IgKGxldCByb3cgPSByZWN0LnRvcDsgcm93IDwgcmVjdC5ib3R0b207IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSByZWN0LmxlZnQ7IGNvbCA8IHJlY3QucmlnaHQ7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcm93ICogdGhpcy53aWR0aCArIGNvbDtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5tYXBbaW5kZXhdO1xuICAgICAgICBpZiAoc2Vlbltwb3NdKSBjb250aW51ZTtcbiAgICAgICAgc2Vlbltwb3NdID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNvbCA9PSByZWN0LmxlZnQgJiYgY29sICYmIHRoaXMubWFwW2luZGV4IC0gMV0gPT0gcG9zIHx8IHJvdyA9PSByZWN0LnRvcCAmJiByb3cgJiYgdGhpcy5tYXBbaW5kZXggLSB0aGlzLndpZHRoXSA9PSBwb3MpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChwb3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIGNlbGwgYXQgdGhlIGdpdmVuIHJvdyBhbmQgY29sdW1uXG4gIC8vIHN0YXJ0cywgb3Igd291bGQgc3RhcnQsIGlmIGEgY2VsbCBzdGFydGVkIHRoZXJlLlxuICBwb3NpdGlvbkF0KHJvdywgY29sLCB0YWJsZSkge1xuICAgIGZvciAobGV0IGkgPSAwLCByb3dTdGFydCA9IDA7IDsgaSsrKSB7XG4gICAgICBjb25zdCByb3dFbmQgPSByb3dTdGFydCArIHRhYmxlLmNoaWxkKGkpLm5vZGVTaXplO1xuICAgICAgaWYgKGkgPT0gcm93KSB7XG4gICAgICAgIGxldCBpbmRleCA9IGNvbCArIHJvdyAqIHRoaXMud2lkdGg7XG4gICAgICAgIGNvbnN0IHJvd0VuZEluZGV4ID0gKHJvdyArIDEpICogdGhpcy53aWR0aDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgcm93RW5kSW5kZXggJiYgdGhpcy5tYXBbaW5kZXhdIDwgcm93U3RhcnQpIGluZGV4Kys7XG4gICAgICAgIHJldHVybiBpbmRleCA9PSByb3dFbmRJbmRleCA/IHJvd0VuZCAtIDEgOiB0aGlzLm1hcFtpbmRleF07XG4gICAgICB9XG4gICAgICByb3dTdGFydCA9IHJvd0VuZDtcbiAgICB9XG4gIH1cbiAgLy8gRmluZCB0aGUgdGFibGUgbWFwIGZvciB0aGUgZ2l2ZW4gdGFibGUgbm9kZS5cbiAgc3RhdGljIGdldCh0YWJsZSkge1xuICAgIHJldHVybiByZWFkRnJvbUNhY2hlKHRhYmxlKSB8fCBhZGRUb0NhY2hlKHRhYmxlLCBjb21wdXRlTWFwKHRhYmxlKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBjb21wdXRlTWFwKHRhYmxlKSB7XG4gIGlmICh0YWJsZS50eXBlLnNwZWMudGFibGVSb2xlICE9IFwidGFibGVcIilcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vdCBhIHRhYmxlIG5vZGU6IFwiICsgdGFibGUudHlwZS5uYW1lKTtcbiAgY29uc3Qgd2lkdGggPSBmaW5kV2lkdGgodGFibGUpLCBoZWlnaHQgPSB0YWJsZS5jaGlsZENvdW50O1xuICBjb25zdCBtYXAgPSBbXTtcbiAgbGV0IG1hcFBvcyA9IDA7XG4gIGxldCBwcm9ibGVtcyA9IG51bGw7XG4gIGNvbnN0IGNvbFdpZHRocyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgZSA9IHdpZHRoICogaGVpZ2h0OyBpIDwgZTsgaSsrKSBtYXBbaV0gPSAwO1xuICBmb3IgKGxldCByb3cgPSAwLCBwb3MgPSAwOyByb3cgPCBoZWlnaHQ7IHJvdysrKSB7XG4gICAgY29uc3Qgcm93Tm9kZSA9IHRhYmxlLmNoaWxkKHJvdyk7XG4gICAgcG9zKys7XG4gICAgZm9yIChsZXQgaSA9IDA7IDsgaSsrKSB7XG4gICAgICB3aGlsZSAobWFwUG9zIDwgbWFwLmxlbmd0aCAmJiBtYXBbbWFwUG9zXSAhPSAwKSBtYXBQb3MrKztcbiAgICAgIGlmIChpID09IHJvd05vZGUuY2hpbGRDb3VudCkgYnJlYWs7XG4gICAgICBjb25zdCBjZWxsTm9kZSA9IHJvd05vZGUuY2hpbGQoaSk7XG4gICAgICBjb25zdCB7IGNvbHNwYW4sIHJvd3NwYW4sIGNvbHdpZHRoIH0gPSBjZWxsTm9kZS5hdHRycztcbiAgICAgIGZvciAobGV0IGggPSAwOyBoIDwgcm93c3BhbjsgaCsrKSB7XG4gICAgICAgIGlmIChoICsgcm93ID49IGhlaWdodCkge1xuICAgICAgICAgIChwcm9ibGVtcyB8fCAocHJvYmxlbXMgPSBbXSkpLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJvdmVybG9uZ19yb3dzcGFuXCIsXG4gICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICBuOiByb3dzcGFuIC0gaFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbWFwUG9zICsgaCAqIHdpZHRoO1xuICAgICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IGNvbHNwYW47IHcrKykge1xuICAgICAgICAgIGlmIChtYXBbc3RhcnQgKyB3XSA9PSAwKSBtYXBbc3RhcnQgKyB3XSA9IHBvcztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAocHJvYmxlbXMgfHwgKHByb2JsZW1zID0gW10pKS5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJjb2xsaXNpb25cIixcbiAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgIG46IGNvbHNwYW4gLSB3XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBjb2xXID0gY29sd2lkdGggJiYgY29sd2lkdGhbd107XG4gICAgICAgICAgaWYgKGNvbFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoSW5kZXggPSAoc3RhcnQgKyB3KSAlIHdpZHRoICogMiwgcHJldiA9IGNvbFdpZHRoc1t3aWR0aEluZGV4XTtcbiAgICAgICAgICAgIGlmIChwcmV2ID09IG51bGwgfHwgcHJldiAhPSBjb2xXICYmIGNvbFdpZHRoc1t3aWR0aEluZGV4ICsgMV0gPT0gMSkge1xuICAgICAgICAgICAgICBjb2xXaWR0aHNbd2lkdGhJbmRleF0gPSBjb2xXO1xuICAgICAgICAgICAgICBjb2xXaWR0aHNbd2lkdGhJbmRleCArIDFdID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldiA9PSBjb2xXKSB7XG4gICAgICAgICAgICAgIGNvbFdpZHRoc1t3aWR0aEluZGV4ICsgMV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hcFBvcyArPSBjb2xzcGFuO1xuICAgICAgcG9zICs9IGNlbGxOb2RlLm5vZGVTaXplO1xuICAgIH1cbiAgICBjb25zdCBleHBlY3RlZFBvcyA9IChyb3cgKyAxKSAqIHdpZHRoO1xuICAgIGxldCBtaXNzaW5nID0gMDtcbiAgICB3aGlsZSAobWFwUG9zIDwgZXhwZWN0ZWRQb3MpIGlmIChtYXBbbWFwUG9zKytdID09IDApIG1pc3NpbmcrKztcbiAgICBpZiAobWlzc2luZylcbiAgICAgIChwcm9ibGVtcyB8fCAocHJvYmxlbXMgPSBbXSkpLnB1c2goeyB0eXBlOiBcIm1pc3NpbmdcIiwgcm93LCBuOiBtaXNzaW5nIH0pO1xuICAgIHBvcysrO1xuICB9XG4gIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApXG4gICAgKHByb2JsZW1zIHx8IChwcm9ibGVtcyA9IFtdKSkucHVzaCh7IHR5cGU6IFwiemVyb19zaXplZFwiIH0pO1xuICBjb25zdCB0YWJsZU1hcCA9IG5ldyBUYWJsZU1hcCh3aWR0aCwgaGVpZ2h0LCBtYXAsIHByb2JsZW1zKTtcbiAgbGV0IGJhZFdpZHRocyA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgIWJhZFdpZHRocyAmJiBpIDwgY29sV2lkdGhzLmxlbmd0aDsgaSArPSAyKVxuICAgIGlmIChjb2xXaWR0aHNbaV0gIT0gbnVsbCAmJiBjb2xXaWR0aHNbaSArIDFdIDwgaGVpZ2h0KSBiYWRXaWR0aHMgPSB0cnVlO1xuICBpZiAoYmFkV2lkdGhzKSBmaW5kQmFkQ29sV2lkdGhzKHRhYmxlTWFwLCBjb2xXaWR0aHMsIHRhYmxlKTtcbiAgcmV0dXJuIHRhYmxlTWFwO1xufVxuZnVuY3Rpb24gZmluZFdpZHRoKHRhYmxlKSB7XG4gIGxldCB3aWR0aCA9IC0xO1xuICBsZXQgaGFzUm93U3BhbiA9IGZhbHNlO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0YWJsZS5jaGlsZENvdW50OyByb3crKykge1xuICAgIGNvbnN0IHJvd05vZGUgPSB0YWJsZS5jaGlsZChyb3cpO1xuICAgIGxldCByb3dXaWR0aCA9IDA7XG4gICAgaWYgKGhhc1Jvd1NwYW4pXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvdzsgaisrKSB7XG4gICAgICAgIGNvbnN0IHByZXZSb3cgPSB0YWJsZS5jaGlsZChqKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Um93LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNlbGwgPSBwcmV2Um93LmNoaWxkKGkpO1xuICAgICAgICAgIGlmIChqICsgY2VsbC5hdHRycy5yb3dzcGFuID4gcm93KSByb3dXaWR0aCArPSBjZWxsLmF0dHJzLmNvbHNwYW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd05vZGUuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBjZWxsID0gcm93Tm9kZS5jaGlsZChpKTtcbiAgICAgIHJvd1dpZHRoICs9IGNlbGwuYXR0cnMuY29sc3BhbjtcbiAgICAgIGlmIChjZWxsLmF0dHJzLnJvd3NwYW4gPiAxKSBoYXNSb3dTcGFuID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHdpZHRoID09IC0xKSB3aWR0aCA9IHJvd1dpZHRoO1xuICAgIGVsc2UgaWYgKHdpZHRoICE9IHJvd1dpZHRoKSB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCByb3dXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIHdpZHRoO1xufVxuZnVuY3Rpb24gZmluZEJhZENvbFdpZHRocyhtYXAsIGNvbFdpZHRocywgdGFibGUpIHtcbiAgaWYgKCFtYXAucHJvYmxlbXMpIG1hcC5wcm9ibGVtcyA9IFtdO1xuICBjb25zdCBzZWVuID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwLm1hcC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBvcyA9IG1hcC5tYXBbaV07XG4gICAgaWYgKHNlZW5bcG9zXSkgY29udGludWU7XG4gICAgc2Vlbltwb3NdID0gdHJ1ZTtcbiAgICBjb25zdCBub2RlID0gdGFibGUubm9kZUF0KHBvcyk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTm8gY2VsbCB3aXRoIG9mZnNldCAke3Bvc30gZm91bmRgKTtcbiAgICB9XG4gICAgbGV0IHVwZGF0ZWQgPSBudWxsO1xuICAgIGNvbnN0IGF0dHJzID0gbm9kZS5hdHRycztcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGF0dHJzLmNvbHNwYW47IGorKykge1xuICAgICAgY29uc3QgY29sID0gKGkgKyBqKSAlIG1hcC53aWR0aDtcbiAgICAgIGNvbnN0IGNvbFdpZHRoID0gY29sV2lkdGhzW2NvbCAqIDJdO1xuICAgICAgaWYgKGNvbFdpZHRoICE9IG51bGwgJiYgKCFhdHRycy5jb2x3aWR0aCB8fCBhdHRycy5jb2x3aWR0aFtqXSAhPSBjb2xXaWR0aCkpXG4gICAgICAgICh1cGRhdGVkIHx8ICh1cGRhdGVkID0gZnJlc2hDb2xXaWR0aChhdHRycykpKVtqXSA9IGNvbFdpZHRoO1xuICAgIH1cbiAgICBpZiAodXBkYXRlZClcbiAgICAgIG1hcC5wcm9ibGVtcy51bnNoaWZ0KHtcbiAgICAgICAgdHlwZTogXCJjb2x3aWR0aCBtaXNtYXRjaFwiLFxuICAgICAgICBwb3MsXG4gICAgICAgIGNvbHdpZHRoOiB1cGRhdGVkXG4gICAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZnJlc2hDb2xXaWR0aChhdHRycykge1xuICBpZiAoYXR0cnMuY29sd2lkdGgpIHJldHVybiBhdHRycy5jb2x3aWR0aC5zbGljZSgpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRycy5jb2xzcGFuOyBpKyspIHJlc3VsdC5wdXNoKDApO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvdXRpbC50c1xuaW1wb3J0IHsgUGx1Z2luS2V5IH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG5cbi8vIHNyYy9zY2hlbWEudHNcbmZ1bmN0aW9uIGdldENlbGxBdHRycyhkb20sIGV4dHJhQXR0cnMpIHtcbiAgaWYgKHR5cGVvZiBkb20gPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3Qgd2lkdGhBdHRyID0gZG9tLmdldEF0dHJpYnV0ZShcImRhdGEtY29sd2lkdGhcIik7XG4gIGNvbnN0IHdpZHRocyA9IHdpZHRoQXR0ciAmJiAvXlxcZCsoLFxcZCspKiQvLnRlc3Qod2lkdGhBdHRyKSA/IHdpZHRoQXR0ci5zcGxpdChcIixcIikubWFwKChzKSA9PiBOdW1iZXIocykpIDogbnVsbDtcbiAgY29uc3QgY29sc3BhbiA9IE51bWJlcihkb20uZ2V0QXR0cmlidXRlKFwiY29sc3BhblwiKSB8fCAxKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGNvbHNwYW4sXG4gICAgcm93c3BhbjogTnVtYmVyKGRvbS5nZXRBdHRyaWJ1dGUoXCJyb3dzcGFuXCIpIHx8IDEpLFxuICAgIGNvbHdpZHRoOiB3aWR0aHMgJiYgd2lkdGhzLmxlbmd0aCA9PSBjb2xzcGFuID8gd2lkdGhzIDogbnVsbFxuICB9O1xuICBmb3IgKGNvbnN0IHByb3AgaW4gZXh0cmFBdHRycykge1xuICAgIGNvbnN0IGdldHRlciA9IGV4dHJhQXR0cnNbcHJvcF0uZ2V0RnJvbURPTTtcbiAgICBjb25zdCB2YWx1ZSA9IGdldHRlciAmJiBnZXR0ZXIoZG9tKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0W3Byb3BdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzZXRDZWxsQXR0cnMobm9kZSwgZXh0cmFBdHRycykge1xuICBjb25zdCBhdHRycyA9IHt9O1xuICBpZiAobm9kZS5hdHRycy5jb2xzcGFuICE9IDEpIGF0dHJzLmNvbHNwYW4gPSBub2RlLmF0dHJzLmNvbHNwYW47XG4gIGlmIChub2RlLmF0dHJzLnJvd3NwYW4gIT0gMSkgYXR0cnMucm93c3BhbiA9IG5vZGUuYXR0cnMucm93c3BhbjtcbiAgaWYgKG5vZGUuYXR0cnMuY29sd2lkdGgpXG4gICAgYXR0cnNbXCJkYXRhLWNvbHdpZHRoXCJdID0gbm9kZS5hdHRycy5jb2x3aWR0aC5qb2luKFwiLFwiKTtcbiAgZm9yIChjb25zdCBwcm9wIGluIGV4dHJhQXR0cnMpIHtcbiAgICBjb25zdCBzZXR0ZXIgPSBleHRyYUF0dHJzW3Byb3BdLnNldERPTUF0dHI7XG4gICAgaWYgKHNldHRlcikgc2V0dGVyKG5vZGUuYXR0cnNbcHJvcF0sIGF0dHJzKTtcbiAgfVxuICByZXR1cm4gYXR0cnM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNvbHdpZHRoKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvbHdpZHRoIG11c3QgYmUgbnVsbCBvciBhbiBhcnJheVwiKTtcbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjb2x3aWR0aCBtdXN0IGJlIG51bGwgb3IgYW4gYXJyYXkgb2YgbnVtYmVyc1wiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRhYmxlTm9kZXMob3B0aW9ucykge1xuICBjb25zdCBleHRyYUF0dHJzID0gb3B0aW9ucy5jZWxsQXR0cmlidXRlcyB8fCB7fTtcbiAgY29uc3QgY2VsbEF0dHJzID0ge1xuICAgIGNvbHNwYW46IHsgZGVmYXVsdDogMSwgdmFsaWRhdGU6IFwibnVtYmVyXCIgfSxcbiAgICByb3dzcGFuOiB7IGRlZmF1bHQ6IDEsIHZhbGlkYXRlOiBcIm51bWJlclwiIH0sXG4gICAgY29sd2lkdGg6IHsgZGVmYXVsdDogbnVsbCwgdmFsaWRhdGU6IHZhbGlkYXRlQ29sd2lkdGggfVxuICB9O1xuICBmb3IgKGNvbnN0IHByb3AgaW4gZXh0cmFBdHRycylcbiAgICBjZWxsQXR0cnNbcHJvcF0gPSB7XG4gICAgICBkZWZhdWx0OiBleHRyYUF0dHJzW3Byb3BdLmRlZmF1bHQsXG4gICAgICB2YWxpZGF0ZTogZXh0cmFBdHRyc1twcm9wXS52YWxpZGF0ZVxuICAgIH07XG4gIHJldHVybiB7XG4gICAgdGFibGU6IHtcbiAgICAgIGNvbnRlbnQ6IFwidGFibGVfcm93K1wiLFxuICAgICAgdGFibGVSb2xlOiBcInRhYmxlXCIsXG4gICAgICBpc29sYXRpbmc6IHRydWUsXG4gICAgICBncm91cDogb3B0aW9ucy50YWJsZUdyb3VwLFxuICAgICAgcGFyc2VET006IFt7IHRhZzogXCJ0YWJsZVwiIH1dLFxuICAgICAgdG9ET00oKSB7XG4gICAgICAgIHJldHVybiBbXCJ0YWJsZVwiLCBbXCJ0Ym9keVwiLCAwXV07XG4gICAgICB9XG4gICAgfSxcbiAgICB0YWJsZV9yb3c6IHtcbiAgICAgIGNvbnRlbnQ6IFwiKHRhYmxlX2NlbGwgfCB0YWJsZV9oZWFkZXIpKlwiLFxuICAgICAgdGFibGVSb2xlOiBcInJvd1wiLFxuICAgICAgcGFyc2VET006IFt7IHRhZzogXCJ0clwiIH1dLFxuICAgICAgdG9ET00oKSB7XG4gICAgICAgIHJldHVybiBbXCJ0clwiLCAwXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlX2NlbGw6IHtcbiAgICAgIGNvbnRlbnQ6IG9wdGlvbnMuY2VsbENvbnRlbnQsXG4gICAgICBhdHRyczogY2VsbEF0dHJzLFxuICAgICAgdGFibGVSb2xlOiBcImNlbGxcIixcbiAgICAgIGlzb2xhdGluZzogdHJ1ZSxcbiAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgIHsgdGFnOiBcInRkXCIsIGdldEF0dHJzOiAoZG9tKSA9PiBnZXRDZWxsQXR0cnMoZG9tLCBleHRyYUF0dHJzKSB9XG4gICAgICBdLFxuICAgICAgdG9ET00obm9kZSkge1xuICAgICAgICByZXR1cm4gW1widGRcIiwgc2V0Q2VsbEF0dHJzKG5vZGUsIGV4dHJhQXR0cnMpLCAwXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlX2hlYWRlcjoge1xuICAgICAgY29udGVudDogb3B0aW9ucy5jZWxsQ29udGVudCxcbiAgICAgIGF0dHJzOiBjZWxsQXR0cnMsXG4gICAgICB0YWJsZVJvbGU6IFwiaGVhZGVyX2NlbGxcIixcbiAgICAgIGlzb2xhdGluZzogdHJ1ZSxcbiAgICAgIHBhcnNlRE9NOiBbXG4gICAgICAgIHsgdGFnOiBcInRoXCIsIGdldEF0dHJzOiAoZG9tKSA9PiBnZXRDZWxsQXR0cnMoZG9tLCBleHRyYUF0dHJzKSB9XG4gICAgICBdLFxuICAgICAgdG9ET00obm9kZSkge1xuICAgICAgICByZXR1cm4gW1widGhcIiwgc2V0Q2VsbEF0dHJzKG5vZGUsIGV4dHJhQXR0cnMpLCAwXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0YWJsZU5vZGVUeXBlcyhzY2hlbWEpIHtcbiAgbGV0IHJlc3VsdCA9IHNjaGVtYS5jYWNoZWQudGFibGVOb2RlVHlwZXM7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gc2NoZW1hLmNhY2hlZC50YWJsZU5vZGVUeXBlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzY2hlbWEubm9kZXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEubm9kZXNbbmFtZV0sIHJvbGUgPSB0eXBlLnNwZWMudGFibGVSb2xlO1xuICAgICAgaWYgKHJvbGUpIHJlc3VsdFtyb2xlXSA9IHR5cGU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlsLnRzXG52YXIgdGFibGVFZGl0aW5nS2V5ID0gbmV3IFBsdWdpbktleShcInNlbGVjdGluZ0NlbGxzXCIpO1xuZnVuY3Rpb24gY2VsbEFyb3VuZCgkcG9zKSB7XG4gIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+IDA7IGQtLSlcbiAgICBpZiAoJHBvcy5ub2RlKGQpLnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJyb3dcIilcbiAgICAgIHJldHVybiAkcG9zLm5vZGUoMCkucmVzb2x2ZSgkcG9zLmJlZm9yZShkICsgMSkpO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNlbGxXcmFwcGluZygkcG9zKSB7XG4gIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID4gMDsgZC0tKSB7XG4gICAgY29uc3Qgcm9sZSA9ICRwb3Mubm9kZShkKS50eXBlLnNwZWMudGFibGVSb2xlO1xuICAgIGlmIChyb2xlID09PSBcImNlbGxcIiB8fCByb2xlID09PSBcImhlYWRlcl9jZWxsXCIpIHJldHVybiAkcG9zLm5vZGUoZCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0luVGFibGUoc3RhdGUpIHtcbiAgY29uc3QgJGhlYWQgPSBzdGF0ZS5zZWxlY3Rpb24uJGhlYWQ7XG4gIGZvciAobGV0IGQgPSAkaGVhZC5kZXB0aDsgZCA+IDA7IGQtLSlcbiAgICBpZiAoJGhlYWQubm9kZShkKS50eXBlLnNwZWMudGFibGVSb2xlID09IFwicm93XCIpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25DZWxsKHN0YXRlKSB7XG4gIGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKFwiJGFuY2hvckNlbGxcIiBpbiBzZWwgJiYgc2VsLiRhbmNob3JDZWxsKSB7XG4gICAgcmV0dXJuIHNlbC4kYW5jaG9yQ2VsbC5wb3MgPiBzZWwuJGhlYWRDZWxsLnBvcyA/IHNlbC4kYW5jaG9yQ2VsbCA6IHNlbC4kaGVhZENlbGw7XG4gIH0gZWxzZSBpZiAoXCJub2RlXCIgaW4gc2VsICYmIHNlbC5ub2RlICYmIHNlbC5ub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJjZWxsXCIpIHtcbiAgICByZXR1cm4gc2VsLiRhbmNob3I7XG4gIH1cbiAgY29uc3QgJGNlbGwgPSBjZWxsQXJvdW5kKHNlbC4kaGVhZCkgfHwgY2VsbE5lYXIoc2VsLiRoZWFkKTtcbiAgaWYgKCRjZWxsKSB7XG4gICAgcmV0dXJuICRjZWxsO1xuICB9XG4gIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBjZWxsIGZvdW5kIGFyb3VuZCBwb3NpdGlvbiAke3NlbC5oZWFkfWApO1xufVxuZnVuY3Rpb24gY2VsbE5lYXIoJHBvcykge1xuICBmb3IgKGxldCBhZnRlciA9ICRwb3Mubm9kZUFmdGVyLCBwb3MgPSAkcG9zLnBvczsgYWZ0ZXI7IGFmdGVyID0gYWZ0ZXIuZmlyc3RDaGlsZCwgcG9zKyspIHtcbiAgICBjb25zdCByb2xlID0gYWZ0ZXIudHlwZS5zcGVjLnRhYmxlUm9sZTtcbiAgICBpZiAocm9sZSA9PSBcImNlbGxcIiB8fCByb2xlID09IFwiaGVhZGVyX2NlbGxcIikgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgfVxuICBmb3IgKGxldCBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsIHBvcyA9ICRwb3MucG9zOyBiZWZvcmU7IGJlZm9yZSA9IGJlZm9yZS5sYXN0Q2hpbGQsIHBvcy0tKSB7XG4gICAgY29uc3Qgcm9sZSA9IGJlZm9yZS50eXBlLnNwZWMudGFibGVSb2xlO1xuICAgIGlmIChyb2xlID09IFwiY2VsbFwiIHx8IHJvbGUgPT0gXCJoZWFkZXJfY2VsbFwiKVxuICAgICAgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUocG9zIC0gYmVmb3JlLm5vZGVTaXplKTtcbiAgfVxufVxuZnVuY3Rpb24gcG9pbnRzQXRDZWxsKCRwb3MpIHtcbiAgcmV0dXJuICRwb3MucGFyZW50LnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJyb3dcIiAmJiAhISRwb3Mubm9kZUFmdGVyO1xufVxuZnVuY3Rpb24gbW92ZUNlbGxGb3J3YXJkKCRwb3MpIHtcbiAgcmV0dXJuICRwb3Mubm9kZSgwKS5yZXNvbHZlKCRwb3MucG9zICsgJHBvcy5ub2RlQWZ0ZXIubm9kZVNpemUpO1xufVxuZnVuY3Rpb24gaW5TYW1lVGFibGUoJGNlbGxBLCAkY2VsbEIpIHtcbiAgcmV0dXJuICRjZWxsQS5kZXB0aCA9PSAkY2VsbEIuZGVwdGggJiYgJGNlbGxBLnBvcyA+PSAkY2VsbEIuc3RhcnQoLTEpICYmICRjZWxsQS5wb3MgPD0gJGNlbGxCLmVuZCgtMSk7XG59XG5mdW5jdGlvbiBmaW5kQ2VsbCgkcG9zKSB7XG4gIHJldHVybiBUYWJsZU1hcC5nZXQoJHBvcy5ub2RlKC0xKSkuZmluZENlbGwoJHBvcy5wb3MgLSAkcG9zLnN0YXJ0KC0xKSk7XG59XG5mdW5jdGlvbiBjb2xDb3VudCgkcG9zKSB7XG4gIHJldHVybiBUYWJsZU1hcC5nZXQoJHBvcy5ub2RlKC0xKSkuY29sQ291bnQoJHBvcy5wb3MgLSAkcG9zLnN0YXJ0KC0xKSk7XG59XG5mdW5jdGlvbiBuZXh0Q2VsbCgkcG9zLCBheGlzLCBkaXIpIHtcbiAgY29uc3QgdGFibGUgPSAkcG9zLm5vZGUoLTEpO1xuICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICBjb25zdCB0YWJsZVN0YXJ0ID0gJHBvcy5zdGFydCgtMSk7XG4gIGNvbnN0IG1vdmVkID0gbWFwLm5leHRDZWxsKCRwb3MucG9zIC0gdGFibGVTdGFydCwgYXhpcywgZGlyKTtcbiAgcmV0dXJuIG1vdmVkID09IG51bGwgPyBudWxsIDogJHBvcy5ub2RlKDApLnJlc29sdmUodGFibGVTdGFydCArIG1vdmVkKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNvbFNwYW4oYXR0cnMsIHBvcywgbiA9IDEpIHtcbiAgY29uc3QgcmVzdWx0ID0geyAuLi5hdHRycywgY29sc3BhbjogYXR0cnMuY29sc3BhbiAtIG4gfTtcbiAgaWYgKHJlc3VsdC5jb2x3aWR0aCkge1xuICAgIHJlc3VsdC5jb2x3aWR0aCA9IHJlc3VsdC5jb2x3aWR0aC5zbGljZSgpO1xuICAgIHJlc3VsdC5jb2x3aWR0aC5zcGxpY2UocG9zLCBuKTtcbiAgICBpZiAoIXJlc3VsdC5jb2x3aWR0aC5zb21lKCh3KSA9PiB3ID4gMCkpIHJlc3VsdC5jb2x3aWR0aCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFkZENvbFNwYW4oYXR0cnMsIHBvcywgbiA9IDEpIHtcbiAgY29uc3QgcmVzdWx0ID0geyAuLi5hdHRycywgY29sc3BhbjogYXR0cnMuY29sc3BhbiArIG4gfTtcbiAgaWYgKHJlc3VsdC5jb2x3aWR0aCkge1xuICAgIHJlc3VsdC5jb2x3aWR0aCA9IHJlc3VsdC5jb2x3aWR0aC5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSByZXN1bHQuY29sd2lkdGguc3BsaWNlKHBvcywgMCwgMCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbHVtbklzSGVhZGVyKG1hcCwgdGFibGUsIGNvbCkge1xuICBjb25zdCBoZWFkZXJDZWxsID0gdGFibGVOb2RlVHlwZXModGFibGUudHlwZS5zY2hlbWEpLmhlYWRlcl9jZWxsO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyByb3crKylcbiAgICBpZiAodGFibGUubm9kZUF0KG1hcC5tYXBbY29sICsgcm93ICogbWFwLndpZHRoXSkudHlwZSAhPSBoZWFkZXJDZWxsKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL2NlbGxzZWxlY3Rpb24udHNcbnZhciBDZWxsU2VsZWN0aW9uID0gY2xhc3MgX0NlbGxTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAvLyBBIHRhYmxlIHNlbGVjdGlvbiBpcyBpZGVudGlmaWVkIGJ5IGl0cyBhbmNob3IgYW5kIGhlYWQgY2VsbHMuIFRoZVxuICAvLyBwb3NpdGlvbnMgZ2l2ZW4gdG8gdGhpcyBjb25zdHJ1Y3RvciBzaG91bGQgcG9pbnQgX2JlZm9yZV8gdHdvXG4gIC8vIGNlbGxzIGluIHRoZSBzYW1lIHRhYmxlLiBUaGV5IG1heSBiZSB0aGUgc2FtZSwgdG8gc2VsZWN0IGEgc2luZ2xlXG4gIC8vIGNlbGwuXG4gIGNvbnN0cnVjdG9yKCRhbmNob3JDZWxsLCAkaGVhZENlbGwgPSAkYW5jaG9yQ2VsbCkge1xuICAgIGNvbnN0IHRhYmxlID0gJGFuY2hvckNlbGwubm9kZSgtMSk7XG4gICAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgICBjb25zdCB0YWJsZVN0YXJ0ID0gJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuICAgIGNvbnN0IHJlY3QgPSBtYXAucmVjdEJldHdlZW4oXG4gICAgICAkYW5jaG9yQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0LFxuICAgICAgJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnRcbiAgICApO1xuICAgIGNvbnN0IGRvYyA9ICRhbmNob3JDZWxsLm5vZGUoMCk7XG4gICAgY29uc3QgY2VsbHMgPSBtYXAuY2VsbHNJblJlY3QocmVjdCkuZmlsdGVyKChwKSA9PiBwICE9ICRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgICBjZWxscy51bnNoaWZ0KCRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgICBjb25zdCByYW5nZXMgPSBjZWxscy5tYXAoKHBvcykgPT4ge1xuICAgICAgY29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwb3MpO1xuICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoYE5vIGNlbGwgd2l0aCBvZmZzZXQgJHtwb3N9IGZvdW5kYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBmcm9tID0gdGFibGVTdGFydCArIHBvcyArIDE7XG4gICAgICByZXR1cm4gbmV3IFNlbGVjdGlvblJhbmdlKFxuICAgICAgICBkb2MucmVzb2x2ZShmcm9tKSxcbiAgICAgICAgZG9jLnJlc29sdmUoZnJvbSArIGNlbGwuY29udGVudC5zaXplKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBzdXBlcihyYW5nZXNbMF0uJGZyb20sIHJhbmdlc1swXS4kdG8sIHJhbmdlcyk7XG4gICAgdGhpcy4kYW5jaG9yQ2VsbCA9ICRhbmNob3JDZWxsO1xuICAgIHRoaXMuJGhlYWRDZWxsID0gJGhlYWRDZWxsO1xuICB9XG4gIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICBjb25zdCAkYW5jaG9yQ2VsbCA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuJGFuY2hvckNlbGwucG9zKSk7XG4gICAgY29uc3QgJGhlYWRDZWxsID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy4kaGVhZENlbGwucG9zKSk7XG4gICAgaWYgKHBvaW50c0F0Q2VsbCgkYW5jaG9yQ2VsbCkgJiYgcG9pbnRzQXRDZWxsKCRoZWFkQ2VsbCkgJiYgaW5TYW1lVGFibGUoJGFuY2hvckNlbGwsICRoZWFkQ2VsbCkpIHtcbiAgICAgIGNvbnN0IHRhYmxlQ2hhbmdlZCA9IHRoaXMuJGFuY2hvckNlbGwubm9kZSgtMSkgIT0gJGFuY2hvckNlbGwubm9kZSgtMSk7XG4gICAgICBpZiAodGFibGVDaGFuZ2VkICYmIHRoaXMuaXNSb3dTZWxlY3Rpb24oKSlcbiAgICAgICAgcmV0dXJuIF9DZWxsU2VsZWN0aW9uLnJvd1NlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsKTtcbiAgICAgIGVsc2UgaWYgKHRhYmxlQ2hhbmdlZCAmJiB0aGlzLmlzQ29sU2VsZWN0aW9uKCkpXG4gICAgICAgIHJldHVybiBfQ2VsbFNlbGVjdGlvbi5jb2xTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG4gICAgICBlbHNlIHJldHVybiBuZXcgX0NlbGxTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG4gICAgfVxuICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmJldHdlZW4oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG4gIH1cbiAgLy8gUmV0dXJucyBhIHJlY3Rhbmd1bGFyIHNsaWNlIG9mIHRhYmxlIHJvd3MgY29udGFpbmluZyB0aGUgc2VsZWN0ZWRcbiAgLy8gY2VsbHMuXG4gIGNvbnRlbnQoKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLiRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgY29uc3QgdGFibGVTdGFydCA9IHRoaXMuJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuICAgIGNvbnN0IHJlY3QgPSBtYXAucmVjdEJldHdlZW4oXG4gICAgICB0aGlzLiRhbmNob3JDZWxsLnBvcyAtIHRhYmxlU3RhcnQsXG4gICAgICB0aGlzLiRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0XG4gICAgKTtcbiAgICBjb25zdCBzZWVuID0ge307XG4gICAgY29uc3Qgcm93cyA9IFtdO1xuICAgIGZvciAobGV0IHJvdyA9IHJlY3QudG9wOyByb3cgPCByZWN0LmJvdHRvbTsgcm93KyspIHtcbiAgICAgIGNvbnN0IHJvd0NvbnRlbnQgPSBbXTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gcm93ICogbWFwLndpZHRoICsgcmVjdC5sZWZ0LCBjb2wgPSByZWN0LmxlZnQ7IGNvbCA8IHJlY3QucmlnaHQ7IGNvbCsrLCBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuICAgICAgICBpZiAoc2Vlbltwb3NdKSBjb250aW51ZTtcbiAgICAgICAgc2Vlbltwb3NdID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY2VsbFJlY3QgPSBtYXAuZmluZENlbGwocG9zKTtcbiAgICAgICAgbGV0IGNlbGwgPSB0YWJsZS5ub2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihgTm8gY2VsbCB3aXRoIG9mZnNldCAke3Bvc30gZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRyYUxlZnQgPSByZWN0LmxlZnQgLSBjZWxsUmVjdC5sZWZ0O1xuICAgICAgICBjb25zdCBleHRyYVJpZ2h0ID0gY2VsbFJlY3QucmlnaHQgLSByZWN0LnJpZ2h0O1xuICAgICAgICBpZiAoZXh0cmFMZWZ0ID4gMCB8fCBleHRyYVJpZ2h0ID4gMCkge1xuICAgICAgICAgIGxldCBhdHRycyA9IGNlbGwuYXR0cnM7XG4gICAgICAgICAgaWYgKGV4dHJhTGVmdCA+IDApIHtcbiAgICAgICAgICAgIGF0dHJzID0gcmVtb3ZlQ29sU3BhbihhdHRycywgMCwgZXh0cmFMZWZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhUmlnaHQgPiAwKSB7XG4gICAgICAgICAgICBhdHRycyA9IHJlbW92ZUNvbFNwYW4oXG4gICAgICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgICAgICBhdHRycy5jb2xzcGFuIC0gZXh0cmFSaWdodCxcbiAgICAgICAgICAgICAgZXh0cmFSaWdodFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNlbGxSZWN0LmxlZnQgPCByZWN0LmxlZnQpIHtcbiAgICAgICAgICAgIGNlbGwgPSBjZWxsLnR5cGUuY3JlYXRlQW5kRmlsbChhdHRycyk7XG4gICAgICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgICAgICBgQ291bGQgbm90IGNyZWF0ZSBjZWxsIHdpdGggYXR0cnMgJHtKU09OLnN0cmluZ2lmeShhdHRycyl9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZWxsID0gY2VsbC50eXBlLmNyZWF0ZShhdHRycywgY2VsbC5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbGxSZWN0LnRvcCA8IHJlY3QudG9wIHx8IGNlbGxSZWN0LmJvdHRvbSA+IHJlY3QuYm90dG9tKSB7XG4gICAgICAgICAgY29uc3QgYXR0cnMgPSB7XG4gICAgICAgICAgICAuLi5jZWxsLmF0dHJzLFxuICAgICAgICAgICAgcm93c3BhbjogTWF0aC5taW4oY2VsbFJlY3QuYm90dG9tLCByZWN0LmJvdHRvbSkgLSBNYXRoLm1heChjZWxsUmVjdC50b3AsIHJlY3QudG9wKVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGNlbGxSZWN0LnRvcCA8IHJlY3QudG9wKSB7XG4gICAgICAgICAgICBjZWxsID0gY2VsbC50eXBlLmNyZWF0ZUFuZEZpbGwoYXR0cnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZWxsID0gY2VsbC50eXBlLmNyZWF0ZShhdHRycywgY2VsbC5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcm93Q29udGVudC5wdXNoKGNlbGwpO1xuICAgICAgfVxuICAgICAgcm93cy5wdXNoKHRhYmxlLmNoaWxkKHJvdykuY29weShGcmFnbWVudC5mcm9tKHJvd0NvbnRlbnQpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pc0NvbFNlbGVjdGlvbigpICYmIHRoaXMuaXNSb3dTZWxlY3Rpb24oKSA/IHRhYmxlIDogcm93cztcbiAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oZnJhZ21lbnQpLCAxLCAxKTtcbiAgfVxuICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICBjb25zdCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV0sIG1hcHBpbmcgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pO1xuICAgICAgdHIucmVwbGFjZShcbiAgICAgICAgbWFwcGluZy5tYXAoJGZyb20ucG9zKSxcbiAgICAgICAgbWFwcGluZy5tYXAoJHRvLnBvcyksXG4gICAgICAgIGkgPyBTbGljZS5lbXB0eSA6IGNvbnRlbnRcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHNlbCA9IFNlbGVjdGlvbi5maW5kRnJvbShcbiAgICAgIHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHRoaXMudG8pKSxcbiAgICAgIC0xXG4gICAgKTtcbiAgICBpZiAoc2VsKSB0ci5zZXRTZWxlY3Rpb24oc2VsKTtcbiAgfVxuICByZXBsYWNlV2l0aCh0ciwgbm9kZSkge1xuICAgIHRoaXMucmVwbGFjZSh0ciwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obm9kZSksIDAsIDApKTtcbiAgfVxuICBmb3JFYWNoQ2VsbChmKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLiRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgY29uc3QgdGFibGVTdGFydCA9IHRoaXMuJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuICAgIGNvbnN0IGNlbGxzID0gbWFwLmNlbGxzSW5SZWN0KFxuICAgICAgbWFwLnJlY3RCZXR3ZWVuKFxuICAgICAgICB0aGlzLiRhbmNob3JDZWxsLnBvcyAtIHRhYmxlU3RhcnQsXG4gICAgICAgIHRoaXMuJGhlYWRDZWxsLnBvcyAtIHRhYmxlU3RhcnRcbiAgICAgIClcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGYodGFibGUubm9kZUF0KGNlbGxzW2ldKSwgdGFibGVTdGFydCArIGNlbGxzW2ldKTtcbiAgICB9XG4gIH1cbiAgLy8gVHJ1ZSBpZiB0aGlzIHNlbGVjdGlvbiBnb2VzIGFsbCB0aGUgd2F5IGZyb20gdGhlIHRvcCB0byB0aGVcbiAgLy8gYm90dG9tIG9mIHRoZSB0YWJsZS5cbiAgaXNDb2xTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgYW5jaG9yVG9wID0gdGhpcy4kYW5jaG9yQ2VsbC5pbmRleCgtMSk7XG4gICAgY29uc3QgaGVhZFRvcCA9IHRoaXMuJGhlYWRDZWxsLmluZGV4KC0xKTtcbiAgICBpZiAoTWF0aC5taW4oYW5jaG9yVG9wLCBoZWFkVG9wKSA+IDApIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBhbmNob3JCb3R0b20gPSBhbmNob3JUb3AgKyB0aGlzLiRhbmNob3JDZWxsLm5vZGVBZnRlci5hdHRycy5yb3dzcGFuO1xuICAgIGNvbnN0IGhlYWRCb3R0b20gPSBoZWFkVG9wICsgdGhpcy4kaGVhZENlbGwubm9kZUFmdGVyLmF0dHJzLnJvd3NwYW47XG4gICAgcmV0dXJuIE1hdGgubWF4KGFuY2hvckJvdHRvbSwgaGVhZEJvdHRvbSkgPT0gdGhpcy4kaGVhZENlbGwubm9kZSgtMSkuY2hpbGRDb3VudDtcbiAgfVxuICAvLyBSZXR1cm5zIHRoZSBzbWFsbGVzdCBjb2x1bW4gc2VsZWN0aW9uIHRoYXQgY292ZXJzIHRoZSBnaXZlbiBhbmNob3JcbiAgLy8gYW5kIGhlYWQgY2VsbC5cbiAgc3RhdGljIGNvbFNlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsID0gJGFuY2hvckNlbGwpIHtcbiAgICBjb25zdCB0YWJsZSA9ICRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgY29uc3QgdGFibGVTdGFydCA9ICRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcbiAgICBjb25zdCBhbmNob3JSZWN0ID0gbWFwLmZpbmRDZWxsKCRhbmNob3JDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuICAgIGNvbnN0IGhlYWRSZWN0ID0gbWFwLmZpbmRDZWxsKCRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgICBjb25zdCBkb2MgPSAkYW5jaG9yQ2VsbC5ub2RlKDApO1xuICAgIGlmIChhbmNob3JSZWN0LnRvcCA8PSBoZWFkUmVjdC50b3ApIHtcbiAgICAgIGlmIChhbmNob3JSZWN0LnRvcCA+IDApXG4gICAgICAgICRhbmNob3JDZWxsID0gZG9jLnJlc29sdmUodGFibGVTdGFydCArIG1hcC5tYXBbYW5jaG9yUmVjdC5sZWZ0XSk7XG4gICAgICBpZiAoaGVhZFJlY3QuYm90dG9tIDwgbWFwLmhlaWdodClcbiAgICAgICAgJGhlYWRDZWxsID0gZG9jLnJlc29sdmUoXG4gICAgICAgICAgdGFibGVTdGFydCArIG1hcC5tYXBbbWFwLndpZHRoICogKG1hcC5oZWlnaHQgLSAxKSArIGhlYWRSZWN0LnJpZ2h0IC0gMV1cbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhlYWRSZWN0LnRvcCA+IDApXG4gICAgICAgICRoZWFkQ2VsbCA9IGRvYy5yZXNvbHZlKHRhYmxlU3RhcnQgKyBtYXAubWFwW2hlYWRSZWN0LmxlZnRdKTtcbiAgICAgIGlmIChhbmNob3JSZWN0LmJvdHRvbSA8IG1hcC5oZWlnaHQpXG4gICAgICAgICRhbmNob3JDZWxsID0gZG9jLnJlc29sdmUoXG4gICAgICAgICAgdGFibGVTdGFydCArIG1hcC5tYXBbbWFwLndpZHRoICogKG1hcC5oZWlnaHQgLSAxKSArIGFuY2hvclJlY3QucmlnaHQgLSAxXVxuICAgICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9DZWxsU2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpO1xuICB9XG4gIC8vIFRydWUgaWYgdGhpcyBzZWxlY3Rpb24gZ29lcyBhbGwgdGhlIHdheSBmcm9tIHRoZSBsZWZ0IHRvIHRoZVxuICAvLyByaWdodCBvZiB0aGUgdGFibGUuXG4gIGlzUm93U2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy4kYW5jaG9yQ2VsbC5ub2RlKC0xKTtcbiAgICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICAgIGNvbnN0IHRhYmxlU3RhcnQgPSB0aGlzLiRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcbiAgICBjb25zdCBhbmNob3JMZWZ0ID0gbWFwLmNvbENvdW50KHRoaXMuJGFuY2hvckNlbGwucG9zIC0gdGFibGVTdGFydCk7XG4gICAgY29uc3QgaGVhZExlZnQgPSBtYXAuY29sQ291bnQodGhpcy4kaGVhZENlbGwucG9zIC0gdGFibGVTdGFydCk7XG4gICAgaWYgKE1hdGgubWluKGFuY2hvckxlZnQsIGhlYWRMZWZ0KSA+IDApIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBhbmNob3JSaWdodCA9IGFuY2hvckxlZnQgKyB0aGlzLiRhbmNob3JDZWxsLm5vZGVBZnRlci5hdHRycy5jb2xzcGFuO1xuICAgIGNvbnN0IGhlYWRSaWdodCA9IGhlYWRMZWZ0ICsgdGhpcy4kaGVhZENlbGwubm9kZUFmdGVyLmF0dHJzLmNvbHNwYW47XG4gICAgcmV0dXJuIE1hdGgubWF4KGFuY2hvclJpZ2h0LCBoZWFkUmlnaHQpID09IG1hcC53aWR0aDtcbiAgfVxuICBlcShvdGhlcikge1xuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIF9DZWxsU2VsZWN0aW9uICYmIG90aGVyLiRhbmNob3JDZWxsLnBvcyA9PSB0aGlzLiRhbmNob3JDZWxsLnBvcyAmJiBvdGhlci4kaGVhZENlbGwucG9zID09IHRoaXMuJGhlYWRDZWxsLnBvcztcbiAgfVxuICAvLyBSZXR1cm5zIHRoZSBzbWFsbGVzdCByb3cgc2VsZWN0aW9uIHRoYXQgY292ZXJzIHRoZSBnaXZlbiBhbmNob3JcbiAgLy8gYW5kIGhlYWQgY2VsbC5cbiAgc3RhdGljIHJvd1NlbGVjdGlvbigkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsID0gJGFuY2hvckNlbGwpIHtcbiAgICBjb25zdCB0YWJsZSA9ICRhbmNob3JDZWxsLm5vZGUoLTEpO1xuICAgIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gICAgY29uc3QgdGFibGVTdGFydCA9ICRhbmNob3JDZWxsLnN0YXJ0KC0xKTtcbiAgICBjb25zdCBhbmNob3JSZWN0ID0gbWFwLmZpbmRDZWxsKCRhbmNob3JDZWxsLnBvcyAtIHRhYmxlU3RhcnQpO1xuICAgIGNvbnN0IGhlYWRSZWN0ID0gbWFwLmZpbmRDZWxsKCRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgICBjb25zdCBkb2MgPSAkYW5jaG9yQ2VsbC5ub2RlKDApO1xuICAgIGlmIChhbmNob3JSZWN0LmxlZnQgPD0gaGVhZFJlY3QubGVmdCkge1xuICAgICAgaWYgKGFuY2hvclJlY3QubGVmdCA+IDApXG4gICAgICAgICRhbmNob3JDZWxsID0gZG9jLnJlc29sdmUoXG4gICAgICAgICAgdGFibGVTdGFydCArIG1hcC5tYXBbYW5jaG9yUmVjdC50b3AgKiBtYXAud2lkdGhdXG4gICAgICAgICk7XG4gICAgICBpZiAoaGVhZFJlY3QucmlnaHQgPCBtYXAud2lkdGgpXG4gICAgICAgICRoZWFkQ2VsbCA9IGRvYy5yZXNvbHZlKFxuICAgICAgICAgIHRhYmxlU3RhcnQgKyBtYXAubWFwW21hcC53aWR0aCAqIChoZWFkUmVjdC50b3AgKyAxKSAtIDFdXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoZWFkUmVjdC5sZWZ0ID4gMClcbiAgICAgICAgJGhlYWRDZWxsID0gZG9jLnJlc29sdmUodGFibGVTdGFydCArIG1hcC5tYXBbaGVhZFJlY3QudG9wICogbWFwLndpZHRoXSk7XG4gICAgICBpZiAoYW5jaG9yUmVjdC5yaWdodCA8IG1hcC53aWR0aClcbiAgICAgICAgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZShcbiAgICAgICAgICB0YWJsZVN0YXJ0ICsgbWFwLm1hcFttYXAud2lkdGggKiAoYW5jaG9yUmVjdC50b3AgKyAxKSAtIDFdXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0NlbGxTZWxlY3Rpb24oJGFuY2hvckNlbGwsICRoZWFkQ2VsbCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNlbGxcIixcbiAgICAgIGFuY2hvcjogdGhpcy4kYW5jaG9yQ2VsbC5wb3MsXG4gICAgICBoZWFkOiB0aGlzLiRoZWFkQ2VsbC5wb3NcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IF9DZWxsU2VsZWN0aW9uKGRvYy5yZXNvbHZlKGpzb24uYW5jaG9yKSwgZG9jLnJlc29sdmUoanNvbi5oZWFkKSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShkb2MsIGFuY2hvckNlbGwsIGhlYWRDZWxsID0gYW5jaG9yQ2VsbCkge1xuICAgIHJldHVybiBuZXcgX0NlbGxTZWxlY3Rpb24oZG9jLnJlc29sdmUoYW5jaG9yQ2VsbCksIGRvYy5yZXNvbHZlKGhlYWRDZWxsKSk7XG4gIH1cbiAgZ2V0Qm9va21hcmsoKSB7XG4gICAgcmV0dXJuIG5ldyBDZWxsQm9va21hcmsodGhpcy4kYW5jaG9yQ2VsbC5wb3MsIHRoaXMuJGhlYWRDZWxsLnBvcyk7XG4gIH1cbn07XG5DZWxsU2VsZWN0aW9uLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5TZWxlY3Rpb24uanNvbklEKFwiY2VsbFwiLCBDZWxsU2VsZWN0aW9uKTtcbnZhciBDZWxsQm9va21hcmsgPSBjbGFzcyBfQ2VsbEJvb2ttYXJrIHtcbiAgY29uc3RydWN0b3IoYW5jaG9yLCBoZWFkKSB7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgdGhpcy5oZWFkID0gaGVhZDtcbiAgfVxuICBtYXAobWFwcGluZykge1xuICAgIHJldHVybiBuZXcgX0NlbGxCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLmFuY2hvciksIG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICB9XG4gIHJlc29sdmUoZG9jKSB7XG4gICAgY29uc3QgJGFuY2hvckNlbGwgPSBkb2MucmVzb2x2ZSh0aGlzLmFuY2hvciksICRoZWFkQ2VsbCA9IGRvYy5yZXNvbHZlKHRoaXMuaGVhZCk7XG4gICAgaWYgKCRhbmNob3JDZWxsLnBhcmVudC50eXBlLnNwZWMudGFibGVSb2xlID09IFwicm93XCIgJiYgJGhlYWRDZWxsLnBhcmVudC50eXBlLnNwZWMudGFibGVSb2xlID09IFwicm93XCIgJiYgJGFuY2hvckNlbGwuaW5kZXgoKSA8ICRhbmNob3JDZWxsLnBhcmVudC5jaGlsZENvdW50ICYmICRoZWFkQ2VsbC5pbmRleCgpIDwgJGhlYWRDZWxsLnBhcmVudC5jaGlsZENvdW50ICYmIGluU2FtZVRhYmxlKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpKVxuICAgICAgcmV0dXJuIG5ldyBDZWxsU2VsZWN0aW9uKCRhbmNob3JDZWxsLCAkaGVhZENlbGwpO1xuICAgIGVsc2UgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRoZWFkQ2VsbCwgMSk7XG4gIH1cbn07XG5mdW5jdGlvbiBkcmF3Q2VsbFNlbGVjdGlvbihzdGF0ZSkge1xuICBpZiAoIShzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGNlbGxzID0gW107XG4gIHN0YXRlLnNlbGVjdGlvbi5mb3JFYWNoQ2VsbCgobm9kZSwgcG9zKSA9PiB7XG4gICAgY2VsbHMucHVzaChcbiAgICAgIERlY29yYXRpb24ubm9kZShwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHsgY2xhc3M6IFwic2VsZWN0ZWRDZWxsXCIgfSlcbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIERlY29yYXRpb25TZXQuY3JlYXRlKHN0YXRlLmRvYywgY2VsbHMpO1xufVxuZnVuY3Rpb24gaXNDZWxsQm91bmRhcnlTZWxlY3Rpb24oeyAkZnJvbSwgJHRvIH0pIHtcbiAgaWYgKCRmcm9tLnBvcyA9PSAkdG8ucG9zIHx8ICRmcm9tLnBvcyA8ICR0by5wb3MgLSA2KSByZXR1cm4gZmFsc2U7XG4gIGxldCBhZnRlckZyb20gPSAkZnJvbS5wb3M7XG4gIGxldCBiZWZvcmVUbyA9ICR0by5wb3M7XG4gIGxldCBkZXB0aCA9ICRmcm9tLmRlcHRoO1xuICBmb3IgKDsgZGVwdGggPj0gMDsgZGVwdGgtLSwgYWZ0ZXJGcm9tKyspXG4gICAgaWYgKCRmcm9tLmFmdGVyKGRlcHRoICsgMSkgPCAkZnJvbS5lbmQoZGVwdGgpKSBicmVhaztcbiAgZm9yIChsZXQgZCA9ICR0by5kZXB0aDsgZCA+PSAwOyBkLS0sIGJlZm9yZVRvLS0pXG4gICAgaWYgKCR0by5iZWZvcmUoZCArIDEpID4gJHRvLnN0YXJ0KGQpKSBicmVhaztcbiAgcmV0dXJuIGFmdGVyRnJvbSA9PSBiZWZvcmVUbyAmJiAvcm93fHRhYmxlLy50ZXN0KCRmcm9tLm5vZGUoZGVwdGgpLnR5cGUuc3BlYy50YWJsZVJvbGUpO1xufVxuZnVuY3Rpb24gaXNUZXh0U2VsZWN0aW9uQWNyb3NzQ2VsbHMoeyAkZnJvbSwgJHRvIH0pIHtcbiAgbGV0IGZyb21DZWxsQm91bmRhcnlOb2RlO1xuICBsZXQgdG9DZWxsQm91bmRhcnlOb2RlO1xuICBmb3IgKGxldCBpID0gJGZyb20uZGVwdGg7IGkgPiAwOyBpLS0pIHtcbiAgICBjb25zdCBub2RlID0gJGZyb20ubm9kZShpKTtcbiAgICBpZiAobm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09PSBcImNlbGxcIiB8fCBub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUgPT09IFwiaGVhZGVyX2NlbGxcIikge1xuICAgICAgZnJvbUNlbGxCb3VuZGFyeU5vZGUgPSBub2RlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAkdG8uZGVwdGg7IGkgPiAwOyBpLS0pIHtcbiAgICBjb25zdCBub2RlID0gJHRvLm5vZGUoaSk7XG4gICAgaWYgKG5vZGUudHlwZS5zcGVjLnRhYmxlUm9sZSA9PT0gXCJjZWxsXCIgfHwgbm9kZS50eXBlLnNwZWMudGFibGVSb2xlID09PSBcImhlYWRlcl9jZWxsXCIpIHtcbiAgICAgIHRvQ2VsbEJvdW5kYXJ5Tm9kZSA9IG5vZGU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb21DZWxsQm91bmRhcnlOb2RlICE9PSB0b0NlbGxCb3VuZGFyeU5vZGUgJiYgJHRvLnBhcmVudE9mZnNldCA9PT0gMDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihzdGF0ZSwgdHIsIGFsbG93VGFibGVOb2RlU2VsZWN0aW9uKSB7XG4gIGNvbnN0IHNlbCA9ICh0ciB8fCBzdGF0ZSkuc2VsZWN0aW9uO1xuICBjb25zdCBkb2MgPSAodHIgfHwgc3RhdGUpLmRvYztcbiAgbGV0IG5vcm1hbGl6ZTtcbiAgbGV0IHJvbGU7XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uMiAmJiAocm9sZSA9IHNlbC5ub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUpKSB7XG4gICAgaWYgKHJvbGUgPT0gXCJjZWxsXCIgfHwgcm9sZSA9PSBcImhlYWRlcl9jZWxsXCIpIHtcbiAgICAgIG5vcm1hbGl6ZSA9IENlbGxTZWxlY3Rpb24uY3JlYXRlKGRvYywgc2VsLmZyb20pO1xuICAgIH0gZWxzZSBpZiAocm9sZSA9PSBcInJvd1wiKSB7XG4gICAgICBjb25zdCAkY2VsbCA9IGRvYy5yZXNvbHZlKHNlbC5mcm9tICsgMSk7XG4gICAgICBub3JtYWxpemUgPSBDZWxsU2VsZWN0aW9uLnJvd1NlbGVjdGlvbigkY2VsbCwgJGNlbGwpO1xuICAgIH0gZWxzZSBpZiAoIWFsbG93VGFibGVOb2RlU2VsZWN0aW9uKSB7XG4gICAgICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQoc2VsLm5vZGUpO1xuICAgICAgY29uc3Qgc3RhcnQgPSBzZWwuZnJvbSArIDE7XG4gICAgICBjb25zdCBsYXN0Q2VsbCA9IHN0YXJ0ICsgbWFwLm1hcFttYXAud2lkdGggKiBtYXAuaGVpZ2h0IC0gMV07XG4gICAgICBub3JtYWxpemUgPSBDZWxsU2VsZWN0aW9uLmNyZWF0ZShkb2MsIHN0YXJ0ICsgMSwgbGFzdENlbGwpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmIGlzQ2VsbEJvdW5kYXJ5U2VsZWN0aW9uKHNlbCkpIHtcbiAgICBub3JtYWxpemUgPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHNlbC5mcm9tKTtcbiAgfSBlbHNlIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmIGlzVGV4dFNlbGVjdGlvbkFjcm9zc0NlbGxzKHNlbCkpIHtcbiAgICBub3JtYWxpemUgPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHNlbC4kZnJvbS5zdGFydCgpLCBzZWwuJGZyb20uZW5kKCkpO1xuICB9XG4gIGlmIChub3JtYWxpemUpICh0ciB8fCAodHIgPSBzdGF0ZS50cikpLnNldFNlbGVjdGlvbihub3JtYWxpemUpO1xuICByZXR1cm4gdHI7XG59XG5cbi8vIHNyYy9maXh0YWJsZXMudHNcbmltcG9ydCB7IFBsdWdpbktleSBhcyBQbHVnaW5LZXkyIH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG52YXIgZml4VGFibGVzS2V5ID0gbmV3IFBsdWdpbktleTIoXCJmaXgtdGFibGVzXCIpO1xuZnVuY3Rpb24gY2hhbmdlZERlc2NlbmRhbnRzKG9sZCwgY3VyLCBvZmZzZXQsIGYpIHtcbiAgY29uc3Qgb2xkU2l6ZSA9IG9sZC5jaGlsZENvdW50LCBjdXJTaXplID0gY3VyLmNoaWxkQ291bnQ7XG4gIG91dGVyOiBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBjdXJTaXplOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGN1ci5jaGlsZChpKTtcbiAgICBmb3IgKGxldCBzY2FuID0gaiwgZSA9IE1hdGgubWluKG9sZFNpemUsIGkgKyAzKTsgc2NhbiA8IGU7IHNjYW4rKykge1xuICAgICAgaWYgKG9sZC5jaGlsZChzY2FuKSA9PSBjaGlsZCkge1xuICAgICAgICBqID0gc2NhbiArIDE7XG4gICAgICAgIG9mZnNldCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIGYoY2hpbGQsIG9mZnNldCk7XG4gICAgaWYgKGogPCBvbGRTaXplICYmIG9sZC5jaGlsZChqKS5zYW1lTWFya3VwKGNoaWxkKSlcbiAgICAgIGNoYW5nZWREZXNjZW5kYW50cyhvbGQuY2hpbGQoaiksIGNoaWxkLCBvZmZzZXQgKyAxLCBmKTtcbiAgICBlbHNlIGNoaWxkLm5vZGVzQmV0d2VlbigwLCBjaGlsZC5jb250ZW50LnNpemUsIGYsIG9mZnNldCArIDEpO1xuICAgIG9mZnNldCArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgfVxufVxuZnVuY3Rpb24gZml4VGFibGVzKHN0YXRlLCBvbGRTdGF0ZSkge1xuICBsZXQgdHI7XG4gIGNvbnN0IGNoZWNrID0gKG5vZGUsIHBvcykgPT4ge1xuICAgIGlmIChub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJ0YWJsZVwiKVxuICAgICAgdHIgPSBmaXhUYWJsZShzdGF0ZSwgbm9kZSwgcG9zLCB0cik7XG4gIH07XG4gIGlmICghb2xkU3RhdGUpIHN0YXRlLmRvYy5kZXNjZW5kYW50cyhjaGVjayk7XG4gIGVsc2UgaWYgKG9sZFN0YXRlLmRvYyAhPSBzdGF0ZS5kb2MpXG4gICAgY2hhbmdlZERlc2NlbmRhbnRzKG9sZFN0YXRlLmRvYywgc3RhdGUuZG9jLCAwLCBjaGVjayk7XG4gIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGZpeFRhYmxlKHN0YXRlLCB0YWJsZSwgdGFibGVQb3MsIHRyKSB7XG4gIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gIGlmICghbWFwLnByb2JsZW1zKSByZXR1cm4gdHI7XG4gIGlmICghdHIpIHRyID0gc3RhdGUudHI7XG4gIGNvbnN0IG11c3RBZGQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXAuaGVpZ2h0OyBpKyspIG11c3RBZGQucHVzaCgwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXAucHJvYmxlbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9iID0gbWFwLnByb2JsZW1zW2ldO1xuICAgIGlmIChwcm9iLnR5cGUgPT0gXCJjb2xsaXNpb25cIikge1xuICAgICAgY29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwcm9iLnBvcyk7XG4gICAgICBpZiAoIWNlbGwpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYXR0cnMgPSBjZWxsLmF0dHJzO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhdHRycy5yb3dzcGFuOyBqKyspIG11c3RBZGRbcHJvYi5yb3cgKyBqXSArPSBwcm9iLm47XG4gICAgICB0ci5zZXROb2RlTWFya3VwKFxuICAgICAgICB0ci5tYXBwaW5nLm1hcCh0YWJsZVBvcyArIDEgKyBwcm9iLnBvcyksXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJlbW92ZUNvbFNwYW4oYXR0cnMsIGF0dHJzLmNvbHNwYW4gLSBwcm9iLm4sIHByb2IubilcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChwcm9iLnR5cGUgPT0gXCJtaXNzaW5nXCIpIHtcbiAgICAgIG11c3RBZGRbcHJvYi5yb3ddICs9IHByb2IubjtcbiAgICB9IGVsc2UgaWYgKHByb2IudHlwZSA9PSBcIm92ZXJsb25nX3Jvd3NwYW5cIikge1xuICAgICAgY29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwcm9iLnBvcyk7XG4gICAgICBpZiAoIWNlbGwpIGNvbnRpbnVlO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCh0YWJsZVBvcyArIDEgKyBwcm9iLnBvcyksIG51bGwsIHtcbiAgICAgICAgLi4uY2VsbC5hdHRycyxcbiAgICAgICAgcm93c3BhbjogY2VsbC5hdHRycy5yb3dzcGFuIC0gcHJvYi5uXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHByb2IudHlwZSA9PSBcImNvbHdpZHRoIG1pc21hdGNoXCIpIHtcbiAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocHJvYi5wb3MpO1xuICAgICAgaWYgKCFjZWxsKSBjb250aW51ZTtcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAodGFibGVQb3MgKyAxICsgcHJvYi5wb3MpLCBudWxsLCB7XG4gICAgICAgIC4uLmNlbGwuYXR0cnMsXG4gICAgICAgIGNvbHdpZHRoOiBwcm9iLmNvbHdpZHRoXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHByb2IudHlwZSA9PSBcInplcm9fc2l6ZWRcIikge1xuICAgICAgY29uc3QgcG9zID0gdHIubWFwcGluZy5tYXAodGFibGVQb3MpO1xuICAgICAgdHIuZGVsZXRlKHBvcywgcG9zICsgdGFibGUubm9kZVNpemUpO1xuICAgIH1cbiAgfVxuICBsZXQgZmlyc3QsIGxhc3Q7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbXVzdEFkZC5sZW5ndGg7IGkrKylcbiAgICBpZiAobXVzdEFkZFtpXSkge1xuICAgICAgaWYgKGZpcnN0ID09IG51bGwpIGZpcnN0ID0gaTtcbiAgICAgIGxhc3QgPSBpO1xuICAgIH1cbiAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHRhYmxlUG9zICsgMTsgaSA8IG1hcC5oZWlnaHQ7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IHRhYmxlLmNoaWxkKGkpO1xuICAgIGNvbnN0IGVuZCA9IHBvcyArIHJvdy5ub2RlU2l6ZTtcbiAgICBjb25zdCBhZGQgPSBtdXN0QWRkW2ldO1xuICAgIGlmIChhZGQgPiAwKSB7XG4gICAgICBsZXQgcm9sZSA9IFwiY2VsbFwiO1xuICAgICAgaWYgKHJvdy5maXJzdENoaWxkKSB7XG4gICAgICAgIHJvbGUgPSByb3cuZmlyc3RDaGlsZC50eXBlLnNwZWMudGFibGVSb2xlO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYWRkOyBqKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRhYmxlTm9kZVR5cGVzKHN0YXRlLnNjaGVtYSlbcm9sZV0uY3JlYXRlQW5kRmlsbCgpO1xuICAgICAgICBpZiAobm9kZSkgbm9kZXMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZGUgPSAoaSA9PSAwIHx8IGZpcnN0ID09IGkgLSAxKSAmJiBsYXN0ID09IGkgPyBwb3MgKyAxIDogZW5kIC0gMTtcbiAgICAgIHRyLmluc2VydCh0ci5tYXBwaW5nLm1hcChzaWRlKSwgbm9kZXMpO1xuICAgIH1cbiAgICBwb3MgPSBlbmQ7XG4gIH1cbiAgcmV0dXJuIHRyLnNldE1ldGEoZml4VGFibGVzS2V5LCB7IGZpeFRhYmxlczogdHJ1ZSB9KTtcbn1cblxuLy8gc3JjL2lucHV0LnRzXG5pbXBvcnQgeyBrZXlkb3duSGFuZGxlciB9IGZyb20gXCJwcm9zZW1pcnJvci1rZXltYXBcIjtcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50NCB9IGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuaW1wb3J0IHtcbiAgU2VsZWN0aW9uIGFzIFNlbGVjdGlvbjIsXG4gIFRleHRTZWxlY3Rpb24gYXMgVGV4dFNlbGVjdGlvbjNcbn0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG5cbi8vIHNyYy9jb21tYW5kcy50c1xuaW1wb3J0IHtcbiAgRnJhZ21lbnQgYXMgRnJhZ21lbnQyLFxuICBTbGljZSBhcyBTbGljZTJcbn0gZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG5pbXBvcnQge1xuICBUZXh0U2VsZWN0aW9uIGFzIFRleHRTZWxlY3Rpb24yXG59IGZyb20gXCJwcm9zZW1pcnJvci1zdGF0ZVwiO1xuZnVuY3Rpb24gc2VsZWN0ZWRSZWN0KHN0YXRlKSB7XG4gIGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgY29uc3QgJHBvcyA9IHNlbGVjdGlvbkNlbGwoc3RhdGUpO1xuICBjb25zdCB0YWJsZSA9ICRwb3Mubm9kZSgtMSk7XG4gIGNvbnN0IHRhYmxlU3RhcnQgPSAkcG9zLnN0YXJ0KC0xKTtcbiAgY29uc3QgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgY29uc3QgcmVjdCA9IHNlbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24gPyBtYXAucmVjdEJldHdlZW4oXG4gICAgc2VsLiRhbmNob3JDZWxsLnBvcyAtIHRhYmxlU3RhcnQsXG4gICAgc2VsLiRoZWFkQ2VsbC5wb3MgLSB0YWJsZVN0YXJ0XG4gICkgOiBtYXAuZmluZENlbGwoJHBvcy5wb3MgLSB0YWJsZVN0YXJ0KTtcbiAgcmV0dXJuIHsgLi4ucmVjdCwgdGFibGVTdGFydCwgbWFwLCB0YWJsZSB9O1xufVxuZnVuY3Rpb24gYWRkQ29sdW1uKHRyLCB7IG1hcCwgdGFibGVTdGFydCwgdGFibGUgfSwgY29sKSB7XG4gIGxldCByZWZDb2x1bW4gPSBjb2wgPiAwID8gLTEgOiAwO1xuICBpZiAoY29sdW1uSXNIZWFkZXIobWFwLCB0YWJsZSwgY29sICsgcmVmQ29sdW1uKSkge1xuICAgIHJlZkNvbHVtbiA9IGNvbCA9PSAwIHx8IGNvbCA9PSBtYXAud2lkdGggPyBudWxsIDogMDtcbiAgfVxuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyByb3crKykge1xuICAgIGNvbnN0IGluZGV4ID0gcm93ICogbWFwLndpZHRoICsgY29sO1xuICAgIGlmIChjb2wgPiAwICYmIGNvbCA8IG1hcC53aWR0aCAmJiBtYXAubWFwW2luZGV4IC0gMV0gPT0gbWFwLm1hcFtpbmRleF0pIHtcbiAgICAgIGNvbnN0IHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuICAgICAgY29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwb3MpO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgdHIubWFwcGluZy5tYXAodGFibGVTdGFydCArIHBvcyksXG4gICAgICAgIG51bGwsXG4gICAgICAgIGFkZENvbFNwYW4oY2VsbC5hdHRycywgY29sIC0gbWFwLmNvbENvdW50KHBvcykpXG4gICAgICApO1xuICAgICAgcm93ICs9IGNlbGwuYXR0cnMucm93c3BhbiAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSByZWZDb2x1bW4gPT0gbnVsbCA/IHRhYmxlTm9kZVR5cGVzKHRhYmxlLnR5cGUuc2NoZW1hKS5jZWxsIDogdGFibGUubm9kZUF0KG1hcC5tYXBbaW5kZXggKyByZWZDb2x1bW5dKS50eXBlO1xuICAgICAgY29uc3QgcG9zID0gbWFwLnBvc2l0aW9uQXQocm93LCBjb2wsIHRhYmxlKTtcbiAgICAgIHRyLmluc2VydCh0ci5tYXBwaW5nLm1hcCh0YWJsZVN0YXJ0ICsgcG9zKSwgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBhZGRDb2x1bW5CZWZvcmUoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKTtcbiAgICBkaXNwYXRjaChhZGRDb2x1bW4oc3RhdGUudHIsIHJlY3QsIHJlY3QubGVmdCkpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYWRkQ29sdW1uQWZ0ZXIoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICBjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKTtcbiAgICBkaXNwYXRjaChhZGRDb2x1bW4oc3RhdGUudHIsIHJlY3QsIHJlY3QucmlnaHQpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNvbHVtbih0ciwgeyBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0IH0sIGNvbCkge1xuICBjb25zdCBtYXBTdGFydCA9IHRyLm1hcHBpbmcubWFwcy5sZW5ndGg7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1hcC5oZWlnaHQ7ICkge1xuICAgIGNvbnN0IGluZGV4ID0gcm93ICogbWFwLndpZHRoICsgY29sO1xuICAgIGNvbnN0IHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocG9zKTtcbiAgICBjb25zdCBhdHRycyA9IGNlbGwuYXR0cnM7XG4gICAgaWYgKGNvbCA+IDAgJiYgbWFwLm1hcFtpbmRleCAtIDFdID09IHBvcyB8fCBjb2wgPCBtYXAud2lkdGggLSAxICYmIG1hcC5tYXBbaW5kZXggKyAxXSA9PSBwb3MpIHtcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAoXG4gICAgICAgIHRyLm1hcHBpbmcuc2xpY2UobWFwU3RhcnQpLm1hcCh0YWJsZVN0YXJ0ICsgcG9zKSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcmVtb3ZlQ29sU3BhbihhdHRycywgY29sIC0gbWFwLmNvbENvdW50KHBvcykpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGFydCA9IHRyLm1hcHBpbmcuc2xpY2UobWFwU3RhcnQpLm1hcCh0YWJsZVN0YXJ0ICsgcG9zKTtcbiAgICAgIHRyLmRlbGV0ZShzdGFydCwgc3RhcnQgKyBjZWxsLm5vZGVTaXplKTtcbiAgICB9XG4gICAgcm93ICs9IGF0dHJzLnJvd3NwYW47XG4gIH1cbn1cbmZ1bmN0aW9uIGRlbGV0ZUNvbHVtbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKCFpc0luVGFibGUoc3RhdGUpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpO1xuICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgaWYgKHJlY3QubGVmdCA9PSAwICYmIHJlY3QucmlnaHQgPT0gcmVjdC5tYXAud2lkdGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gcmVjdC5yaWdodCAtIDE7IDsgaS0tKSB7XG4gICAgICByZW1vdmVDb2x1bW4odHIsIHJlY3QsIGkpO1xuICAgICAgaWYgKGkgPT0gcmVjdC5sZWZ0KSBicmVhaztcbiAgICAgIGNvbnN0IHRhYmxlID0gcmVjdC50YWJsZVN0YXJ0ID8gdHIuZG9jLm5vZGVBdChyZWN0LnRhYmxlU3RhcnQgLSAxKSA6IHRyLmRvYztcbiAgICAgIGlmICghdGFibGUpIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIk5vIHRhYmxlIGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgcmVjdC50YWJsZSA9IHRhYmxlO1xuICAgICAgcmVjdC5tYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICAgIH1cbiAgICBkaXNwYXRjaCh0cik7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByb3dJc0hlYWRlcihtYXAsIHRhYmxlLCByb3cpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBoZWFkZXJDZWxsID0gdGFibGVOb2RlVHlwZXModGFibGUudHlwZS5zY2hlbWEpLmhlYWRlcl9jZWxsO1xuICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBtYXAud2lkdGg7IGNvbCsrKVxuICAgIGlmICgoKF9hID0gdGFibGUubm9kZUF0KG1hcC5tYXBbY29sICsgcm93ICogbWFwLndpZHRoXSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS50eXBlKSAhPSBoZWFkZXJDZWxsKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFkZFJvdyh0ciwgeyBtYXAsIHRhYmxlU3RhcnQsIHRhYmxlIH0sIHJvdykge1xuICB2YXIgX2E7XG4gIGxldCByb3dQb3MgPSB0YWJsZVN0YXJ0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdzsgaSsrKSByb3dQb3MgKz0gdGFibGUuY2hpbGQoaSkubm9kZVNpemU7XG4gIGNvbnN0IGNlbGxzID0gW107XG4gIGxldCByZWZSb3cgPSByb3cgPiAwID8gLTEgOiAwO1xuICBpZiAocm93SXNIZWFkZXIobWFwLCB0YWJsZSwgcm93ICsgcmVmUm93KSlcbiAgICByZWZSb3cgPSByb3cgPT0gMCB8fCByb3cgPT0gbWFwLmhlaWdodCA/IG51bGwgOiAwO1xuICBmb3IgKGxldCBjb2wgPSAwLCBpbmRleCA9IG1hcC53aWR0aCAqIHJvdzsgY29sIDwgbWFwLndpZHRoOyBjb2wrKywgaW5kZXgrKykge1xuICAgIGlmIChyb3cgPiAwICYmIHJvdyA8IG1hcC5oZWlnaHQgJiYgbWFwLm1hcFtpbmRleF0gPT0gbWFwLm1hcFtpbmRleCAtIG1hcC53aWR0aF0pIHtcbiAgICAgIGNvbnN0IHBvcyA9IG1hcC5tYXBbaW5kZXhdO1xuICAgICAgY29uc3QgYXR0cnMgPSB0YWJsZS5ub2RlQXQocG9zKS5hdHRycztcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAodGFibGVTdGFydCArIHBvcywgbnVsbCwge1xuICAgICAgICAuLi5hdHRycyxcbiAgICAgICAgcm93c3BhbjogYXR0cnMucm93c3BhbiArIDFcbiAgICAgIH0pO1xuICAgICAgY29sICs9IGF0dHJzLmNvbHNwYW4gLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gcmVmUm93ID09IG51bGwgPyB0YWJsZU5vZGVUeXBlcyh0YWJsZS50eXBlLnNjaGVtYSkuY2VsbCA6IChfYSA9IHRhYmxlLm5vZGVBdChtYXAubWFwW2luZGV4ICsgcmVmUm93ICogbWFwLndpZHRoXSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS50eXBlO1xuICAgICAgY29uc3Qgbm9kZSA9IHR5cGUgPT0gbnVsbCA/IHZvaWQgMCA6IHR5cGUuY3JlYXRlQW5kRmlsbCgpO1xuICAgICAgaWYgKG5vZGUpIGNlbGxzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHRyLmluc2VydChyb3dQb3MsIHRhYmxlTm9kZVR5cGVzKHRhYmxlLnR5cGUuc2NoZW1hKS5yb3cuY3JlYXRlKG51bGwsIGNlbGxzKSk7XG4gIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGFkZFJvd0JlZm9yZShzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKCFpc0luVGFibGUoc3RhdGUpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpO1xuICAgIGRpc3BhdGNoKGFkZFJvdyhzdGF0ZS50ciwgcmVjdCwgcmVjdC50b3ApKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFkZFJvd0FmdGVyKHN0YXRlLCBkaXNwYXRjaCkge1xuICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSk7XG4gICAgZGlzcGF0Y2goYWRkUm93KHN0YXRlLnRyLCByZWN0LCByZWN0LmJvdHRvbSkpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlUm93KHRyLCB7IG1hcCwgdGFibGUsIHRhYmxlU3RhcnQgfSwgcm93KSB7XG4gIGxldCByb3dQb3MgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdzsgaSsrKSByb3dQb3MgKz0gdGFibGUuY2hpbGQoaSkubm9kZVNpemU7XG4gIGNvbnN0IG5leHRSb3cgPSByb3dQb3MgKyB0YWJsZS5jaGlsZChyb3cpLm5vZGVTaXplO1xuICBjb25zdCBtYXBGcm9tID0gdHIubWFwcGluZy5tYXBzLmxlbmd0aDtcbiAgdHIuZGVsZXRlKHJvd1BvcyArIHRhYmxlU3RhcnQsIG5leHRSb3cgKyB0YWJsZVN0YXJ0KTtcbiAgY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAobGV0IGNvbCA9IDAsIGluZGV4ID0gcm93ICogbWFwLndpZHRoOyBjb2wgPCBtYXAud2lkdGg7IGNvbCsrLCBpbmRleCsrKSB7XG4gICAgY29uc3QgcG9zID0gbWFwLm1hcFtpbmRleF07XG4gICAgaWYgKHNlZW4uaGFzKHBvcykpIGNvbnRpbnVlO1xuICAgIHNlZW4uYWRkKHBvcyk7XG4gICAgaWYgKHJvdyA+IDAgJiYgcG9zID09IG1hcC5tYXBbaW5kZXggLSBtYXAud2lkdGhdKSB7XG4gICAgICBjb25zdCBhdHRycyA9IHRhYmxlLm5vZGVBdChwb3MpLmF0dHJzO1xuICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MgKyB0YWJsZVN0YXJ0KSwgbnVsbCwge1xuICAgICAgICAuLi5hdHRycyxcbiAgICAgICAgcm93c3BhbjogYXR0cnMucm93c3BhbiAtIDFcbiAgICAgIH0pO1xuICAgICAgY29sICs9IGF0dHJzLmNvbHNwYW4gLSAxO1xuICAgIH0gZWxzZSBpZiAocm93IDwgbWFwLmhlaWdodCAmJiBwb3MgPT0gbWFwLm1hcFtpbmRleCArIG1hcC53aWR0aF0pIHtcbiAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocG9zKTtcbiAgICAgIGNvbnN0IGF0dHJzID0gY2VsbC5hdHRycztcbiAgICAgIGNvbnN0IGNvcHkgPSBjZWxsLnR5cGUuY3JlYXRlKFxuICAgICAgICB7IC4uLmF0dHJzLCByb3dzcGFuOiBjZWxsLmF0dHJzLnJvd3NwYW4gLSAxIH0sXG4gICAgICAgIGNlbGwuY29udGVudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG5ld1BvcyA9IG1hcC5wb3NpdGlvbkF0KHJvdyArIDEsIGNvbCwgdGFibGUpO1xuICAgICAgdHIuaW5zZXJ0KHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHRhYmxlU3RhcnQgKyBuZXdQb3MpLCBjb3B5KTtcbiAgICAgIGNvbCArPSBhdHRycy5jb2xzcGFuIC0gMTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRlbGV0ZVJvdyhzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKCFpc0luVGFibGUoc3RhdGUpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpLCB0ciA9IHN0YXRlLnRyO1xuICAgIGlmIChyZWN0LnRvcCA9PSAwICYmIHJlY3QuYm90dG9tID09IHJlY3QubWFwLmhlaWdodCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSByZWN0LmJvdHRvbSAtIDE7IDsgaS0tKSB7XG4gICAgICByZW1vdmVSb3codHIsIHJlY3QsIGkpO1xuICAgICAgaWYgKGkgPT0gcmVjdC50b3ApIGJyZWFrO1xuICAgICAgY29uc3QgdGFibGUgPSByZWN0LnRhYmxlU3RhcnQgPyB0ci5kb2Mubm9kZUF0KHJlY3QudGFibGVTdGFydCAtIDEpIDogdHIuZG9jO1xuICAgICAgaWYgKCF0YWJsZSkge1xuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiTm8gdGFibGUgZm91bmRcIik7XG4gICAgICB9XG4gICAgICByZWN0LnRhYmxlID0gdGFibGU7XG4gICAgICByZWN0Lm1hcCA9IFRhYmxlTWFwLmdldChyZWN0LnRhYmxlKTtcbiAgICB9XG4gICAgZGlzcGF0Y2godHIpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNFbXB0eShjZWxsKSB7XG4gIGNvbnN0IGMgPSBjZWxsLmNvbnRlbnQ7XG4gIHJldHVybiBjLmNoaWxkQ291bnQgPT0gMSAmJiBjLmNoaWxkKDApLmlzVGV4dGJsb2NrICYmIGMuY2hpbGQoMCkuY2hpbGRDb3VudCA9PSAwO1xufVxuZnVuY3Rpb24gY2VsbHNPdmVybGFwUmVjdGFuZ2xlKHsgd2lkdGgsIGhlaWdodCwgbWFwIH0sIHJlY3QpIHtcbiAgbGV0IGluZGV4VG9wID0gcmVjdC50b3AgKiB3aWR0aCArIHJlY3QubGVmdCwgaW5kZXhMZWZ0ID0gaW5kZXhUb3A7XG4gIGxldCBpbmRleEJvdHRvbSA9IChyZWN0LmJvdHRvbSAtIDEpICogd2lkdGggKyByZWN0LmxlZnQsIGluZGV4UmlnaHQgPSBpbmRleFRvcCArIChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0IC0gMSk7XG4gIGZvciAobGV0IGkgPSByZWN0LnRvcDsgaSA8IHJlY3QuYm90dG9tOyBpKyspIHtcbiAgICBpZiAocmVjdC5sZWZ0ID4gMCAmJiBtYXBbaW5kZXhMZWZ0XSA9PSBtYXBbaW5kZXhMZWZ0IC0gMV0gfHwgcmVjdC5yaWdodCA8IHdpZHRoICYmIG1hcFtpbmRleFJpZ2h0XSA9PSBtYXBbaW5kZXhSaWdodCArIDFdKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaW5kZXhMZWZ0ICs9IHdpZHRoO1xuICAgIGluZGV4UmlnaHQgKz0gd2lkdGg7XG4gIH1cbiAgZm9yIChsZXQgaSA9IHJlY3QubGVmdDsgaSA8IHJlY3QucmlnaHQ7IGkrKykge1xuICAgIGlmIChyZWN0LnRvcCA+IDAgJiYgbWFwW2luZGV4VG9wXSA9PSBtYXBbaW5kZXhUb3AgLSB3aWR0aF0gfHwgcmVjdC5ib3R0b20gPCBoZWlnaHQgJiYgbWFwW2luZGV4Qm90dG9tXSA9PSBtYXBbaW5kZXhCb3R0b20gKyB3aWR0aF0pXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpbmRleFRvcCsrO1xuICAgIGluZGV4Qm90dG9tKys7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWVyZ2VDZWxscyhzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgY29uc3Qgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICBpZiAoIShzZWwgaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKSB8fCBzZWwuJGFuY2hvckNlbGwucG9zID09IHNlbC4kaGVhZENlbGwucG9zKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSksIHsgbWFwIH0gPSByZWN0O1xuICBpZiAoY2VsbHNPdmVybGFwUmVjdGFuZ2xlKG1hcCwgcmVjdCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgdHIgPSBzdGF0ZS50cjtcbiAgICBjb25zdCBzZWVuID0ge307XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudDIuZW1wdHk7XG4gICAgbGV0IG1lcmdlZFBvcztcbiAgICBsZXQgbWVyZ2VkQ2VsbDtcbiAgICBmb3IgKGxldCByb3cgPSByZWN0LnRvcDsgcm93IDwgcmVjdC5ib3R0b207IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSByZWN0LmxlZnQ7IGNvbCA8IHJlY3QucmlnaHQ7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IGNlbGxQb3MgPSBtYXAubWFwW3JvdyAqIG1hcC53aWR0aCArIGNvbF07XG4gICAgICAgIGNvbnN0IGNlbGwgPSByZWN0LnRhYmxlLm5vZGVBdChjZWxsUG9zKTtcbiAgICAgICAgaWYgKHNlZW5bY2VsbFBvc10gfHwgIWNlbGwpIGNvbnRpbnVlO1xuICAgICAgICBzZWVuW2NlbGxQb3NdID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1lcmdlZFBvcyA9PSBudWxsKSB7XG4gICAgICAgICAgbWVyZ2VkUG9zID0gY2VsbFBvcztcbiAgICAgICAgICBtZXJnZWRDZWxsID0gY2VsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWlzRW1wdHkoY2VsbCkpIGNvbnRlbnQgPSBjb250ZW50LmFwcGVuZChjZWxsLmNvbnRlbnQpO1xuICAgICAgICAgIGNvbnN0IG1hcHBlZCA9IHRyLm1hcHBpbmcubWFwKGNlbGxQb3MgKyByZWN0LnRhYmxlU3RhcnQpO1xuICAgICAgICAgIHRyLmRlbGV0ZShtYXBwZWQsIG1hcHBlZCArIGNlbGwubm9kZVNpemUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtZXJnZWRQb3MgPT0gbnVsbCB8fCBtZXJnZWRDZWxsID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0ci5zZXROb2RlTWFya3VwKG1lcmdlZFBvcyArIHJlY3QudGFibGVTdGFydCwgbnVsbCwge1xuICAgICAgLi4uYWRkQ29sU3BhbihcbiAgICAgICAgbWVyZ2VkQ2VsbC5hdHRycyxcbiAgICAgICAgbWVyZ2VkQ2VsbC5hdHRycy5jb2xzcGFuLFxuICAgICAgICByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0IC0gbWVyZ2VkQ2VsbC5hdHRycy5jb2xzcGFuXG4gICAgICApLFxuICAgICAgcm93c3BhbjogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICAgIH0pO1xuICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgIGNvbnN0IGVuZCA9IG1lcmdlZFBvcyArIDEgKyBtZXJnZWRDZWxsLmNvbnRlbnQuc2l6ZTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaXNFbXB0eShtZXJnZWRDZWxsKSA/IG1lcmdlZFBvcyArIDEgOiBlbmQ7XG4gICAgICB0ci5yZXBsYWNlV2l0aChzdGFydCArIHJlY3QudGFibGVTdGFydCwgZW5kICsgcmVjdC50YWJsZVN0YXJ0LCBjb250ZW50KTtcbiAgICB9XG4gICAgdHIuc2V0U2VsZWN0aW9uKFxuICAgICAgbmV3IENlbGxTZWxlY3Rpb24odHIuZG9jLnJlc29sdmUobWVyZ2VkUG9zICsgcmVjdC50YWJsZVN0YXJ0KSlcbiAgICApO1xuICAgIGRpc3BhdGNoKHRyKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNwbGl0Q2VsbChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgY29uc3Qgbm9kZVR5cGVzID0gdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKTtcbiAgcmV0dXJuIHNwbGl0Q2VsbFdpdGhUeXBlKCh7IG5vZGUgfSkgPT4ge1xuICAgIHJldHVybiBub2RlVHlwZXNbbm9kZS50eXBlLnNwZWMudGFibGVSb2xlXTtcbiAgfSkoc3RhdGUsIGRpc3BhdGNoKTtcbn1cbmZ1bmN0aW9uIHNwbGl0Q2VsbFdpdGhUeXBlKGdldENlbGxUeXBlKSB7XG4gIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgY2VsbE5vZGU7XG4gICAgbGV0IGNlbGxQb3M7XG4gICAgaWYgKCEoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikpIHtcbiAgICAgIGNlbGxOb2RlID0gY2VsbFdyYXBwaW5nKHNlbC4kZnJvbSk7XG4gICAgICBpZiAoIWNlbGxOb2RlKSByZXR1cm4gZmFsc2U7XG4gICAgICBjZWxsUG9zID0gKF9hID0gY2VsbEFyb3VuZChzZWwuJGZyb20pKSA9PSBudWxsID8gdm9pZCAwIDogX2EucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2VsLiRhbmNob3JDZWxsLnBvcyAhPSBzZWwuJGhlYWRDZWxsLnBvcykgcmV0dXJuIGZhbHNlO1xuICAgICAgY2VsbE5vZGUgPSBzZWwuJGFuY2hvckNlbGwubm9kZUFmdGVyO1xuICAgICAgY2VsbFBvcyA9IHNlbC4kYW5jaG9yQ2VsbC5wb3M7XG4gICAgfVxuICAgIGlmIChjZWxsTm9kZSA9PSBudWxsIHx8IGNlbGxQb3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY2VsbE5vZGUuYXR0cnMuY29sc3BhbiA9PSAxICYmIGNlbGxOb2RlLmF0dHJzLnJvd3NwYW4gPT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGxldCBiYXNlQXR0cnMgPSBjZWxsTm9kZS5hdHRycztcbiAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICBjb25zdCBjb2x3aWR0aCA9IGJhc2VBdHRycy5jb2x3aWR0aDtcbiAgICAgIGlmIChiYXNlQXR0cnMucm93c3BhbiA+IDEpIGJhc2VBdHRycyA9IHsgLi4uYmFzZUF0dHJzLCByb3dzcGFuOiAxIH07XG4gICAgICBpZiAoYmFzZUF0dHJzLmNvbHNwYW4gPiAxKSBiYXNlQXR0cnMgPSB7IC4uLmJhc2VBdHRycywgY29sc3BhbjogMSB9O1xuICAgICAgY29uc3QgcmVjdCA9IHNlbGVjdGVkUmVjdChzdGF0ZSksIHRyID0gc3RhdGUudHI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7IGkrKylcbiAgICAgICAgYXR0cnMucHVzaChcbiAgICAgICAgICBjb2x3aWR0aCA/IHtcbiAgICAgICAgICAgIC4uLmJhc2VBdHRycyxcbiAgICAgICAgICAgIGNvbHdpZHRoOiBjb2x3aWR0aCAmJiBjb2x3aWR0aFtpXSA/IFtjb2x3aWR0aFtpXV0gOiBudWxsXG4gICAgICAgICAgfSA6IGJhc2VBdHRyc1xuICAgICAgICApO1xuICAgICAgbGV0IGxhc3RDZWxsO1xuICAgICAgZm9yIChsZXQgcm93ID0gcmVjdC50b3A7IHJvdyA8IHJlY3QuYm90dG9tOyByb3crKykge1xuICAgICAgICBsZXQgcG9zID0gcmVjdC5tYXAucG9zaXRpb25BdChyb3csIHJlY3QubGVmdCwgcmVjdC50YWJsZSk7XG4gICAgICAgIGlmIChyb3cgPT0gcmVjdC50b3ApIHBvcyArPSBjZWxsTm9kZS5ub2RlU2l6ZTtcbiAgICAgICAgZm9yIChsZXQgY29sID0gcmVjdC5sZWZ0LCBpID0gMDsgY29sIDwgcmVjdC5yaWdodDsgY29sKyssIGkrKykge1xuICAgICAgICAgIGlmIChjb2wgPT0gcmVjdC5sZWZ0ICYmIHJvdyA9PSByZWN0LnRvcCkgY29udGludWU7XG4gICAgICAgICAgdHIuaW5zZXJ0KFxuICAgICAgICAgICAgbGFzdENlbGwgPSB0ci5tYXBwaW5nLm1hcChwb3MgKyByZWN0LnRhYmxlU3RhcnQsIDEpLFxuICAgICAgICAgICAgZ2V0Q2VsbFR5cGUoeyBub2RlOiBjZWxsTm9kZSwgcm93LCBjb2wgfSkuY3JlYXRlQW5kRmlsbChhdHRyc1tpXSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ci5zZXROb2RlTWFya3VwKFxuICAgICAgICBjZWxsUG9zLFxuICAgICAgICBnZXRDZWxsVHlwZSh7IG5vZGU6IGNlbGxOb2RlLCByb3c6IHJlY3QudG9wLCBjb2w6IHJlY3QubGVmdCB9KSxcbiAgICAgICAgYXR0cnNbMF1cbiAgICAgICk7XG4gICAgICBpZiAoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbilcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFxuICAgICAgICAgIG5ldyBDZWxsU2VsZWN0aW9uKFxuICAgICAgICAgICAgdHIuZG9jLnJlc29sdmUoc2VsLiRhbmNob3JDZWxsLnBvcyksXG4gICAgICAgICAgICBsYXN0Q2VsbCA/IHRyLmRvYy5yZXNvbHZlKGxhc3RDZWxsKSA6IHZvaWQgMFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5mdW5jdGlvbiBzZXRDZWxsQXR0cihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgaWYgKCFpc0luVGFibGUoc3RhdGUpKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgJGNlbGwgPSBzZWxlY3Rpb25DZWxsKHN0YXRlKTtcbiAgICBpZiAoJGNlbGwubm9kZUFmdGVyLmF0dHJzW25hbWVdID09PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgY29uc3QgdHIgPSBzdGF0ZS50cjtcbiAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBDZWxsU2VsZWN0aW9uKVxuICAgICAgICBzdGF0ZS5zZWxlY3Rpb24uZm9yRWFjaENlbGwoKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgIGlmIChub2RlLmF0dHJzW25hbWVdICE9PSB2YWx1ZSlcbiAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCBudWxsLCB7XG4gICAgICAgICAgICAgIC4uLm5vZGUuYXR0cnMsXG4gICAgICAgICAgICAgIFtuYW1lXTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIGVsc2VcbiAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCgkY2VsbC5wb3MsIG51bGwsIHtcbiAgICAgICAgICAuLi4kY2VsbC5ub2RlQWZ0ZXIuYXR0cnMsXG4gICAgICAgICAgW25hbWVdOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkX3RvZ2dsZUhlYWRlcih0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICBpZiAoIWlzSW5UYWJsZShzdGF0ZSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIGNvbnN0IHR5cGVzID0gdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBzZWxlY3RlZFJlY3Qoc3RhdGUpLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgY29uc3QgY2VsbHMgPSByZWN0Lm1hcC5jZWxsc0luUmVjdChcbiAgICAgICAgdHlwZSA9PSBcImNvbHVtblwiID8ge1xuICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQsXG4gICAgICAgICAgYm90dG9tOiByZWN0Lm1hcC5oZWlnaHRcbiAgICAgICAgfSA6IHR5cGUgPT0gXCJyb3dcIiA/IHtcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRvcDogcmVjdC50b3AsXG4gICAgICAgICAgcmlnaHQ6IHJlY3QubWFwLndpZHRoLFxuICAgICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b21cbiAgICAgICAgfSA6IHJlY3RcbiAgICAgICk7XG4gICAgICBjb25zdCBub2RlcyA9IGNlbGxzLm1hcCgocG9zKSA9PiByZWN0LnRhYmxlLm5vZGVBdChwb3MpKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChub2Rlc1tpXS50eXBlID09IHR5cGVzLmhlYWRlcl9jZWxsKVxuICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAoXG4gICAgICAgICAgICByZWN0LnRhYmxlU3RhcnQgKyBjZWxsc1tpXSxcbiAgICAgICAgICAgIHR5cGVzLmNlbGwsXG4gICAgICAgICAgICBub2Rlc1tpXS5hdHRyc1xuICAgICAgICAgICk7XG4gICAgICBpZiAodHIuc3RlcHMubGVuZ3RoID09IDApXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChcbiAgICAgICAgICAgIHJlY3QudGFibGVTdGFydCArIGNlbGxzW2ldLFxuICAgICAgICAgICAgdHlwZXMuaGVhZGVyX2NlbGwsXG4gICAgICAgICAgICBub2Rlc1tpXS5hdHRyc1xuICAgICAgICAgICk7XG4gICAgICBkaXNwYXRjaCh0cik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gaXNIZWFkZXJFbmFibGVkQnlUeXBlKHR5cGUsIHJlY3QsIHR5cGVzKSB7XG4gIGNvbnN0IGNlbGxQb3NpdGlvbnMgPSByZWN0Lm1hcC5jZWxsc0luUmVjdCh7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IHR5cGUgPT0gXCJyb3dcIiA/IHJlY3QubWFwLndpZHRoIDogMSxcbiAgICBib3R0b206IHR5cGUgPT0gXCJjb2x1bW5cIiA/IHJlY3QubWFwLmhlaWdodCA6IDFcbiAgfSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbFBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNlbGwgPSByZWN0LnRhYmxlLm5vZGVBdChjZWxsUG9zaXRpb25zW2ldKTtcbiAgICBpZiAoY2VsbCAmJiBjZWxsLnR5cGUgIT09IHR5cGVzLmhlYWRlcl9jZWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdG9nZ2xlSGVhZGVyKHR5cGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyB1c2VEZXByZWNhdGVkTG9naWM6IGZhbHNlIH07XG4gIGlmIChvcHRpb25zLnVzZURlcHJlY2F0ZWRMb2dpYykgcmV0dXJuIGRlcHJlY2F0ZWRfdG9nZ2xlSGVhZGVyKHR5cGUpO1xuICByZXR1cm4gZnVuY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgaWYgKCFpc0luVGFibGUoc3RhdGUpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBjb25zdCB0eXBlcyA9IHRhYmxlTm9kZVR5cGVzKHN0YXRlLnNjaGVtYSk7XG4gICAgICBjb25zdCByZWN0ID0gc2VsZWN0ZWRSZWN0KHN0YXRlKSwgdHIgPSBzdGF0ZS50cjtcbiAgICAgIGNvbnN0IGlzSGVhZGVyUm93RW5hYmxlZCA9IGlzSGVhZGVyRW5hYmxlZEJ5VHlwZShcInJvd1wiLCByZWN0LCB0eXBlcyk7XG4gICAgICBjb25zdCBpc0hlYWRlckNvbHVtbkVuYWJsZWQgPSBpc0hlYWRlckVuYWJsZWRCeVR5cGUoXG4gICAgICAgIFwiY29sdW1uXCIsXG4gICAgICAgIHJlY3QsXG4gICAgICAgIHR5cGVzXG4gICAgICApO1xuICAgICAgY29uc3QgaXNIZWFkZXJFbmFibGVkID0gdHlwZSA9PT0gXCJjb2x1bW5cIiA/IGlzSGVhZGVyUm93RW5hYmxlZCA6IHR5cGUgPT09IFwicm93XCIgPyBpc0hlYWRlckNvbHVtbkVuYWJsZWQgOiBmYWxzZTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0c0F0ID0gaXNIZWFkZXJFbmFibGVkID8gMSA6IDA7XG4gICAgICBjb25zdCBjZWxsc1JlY3QgPSB0eXBlID09IFwiY29sdW1uXCIgPyB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogc2VsZWN0aW9uU3RhcnRzQXQsXG4gICAgICAgIHJpZ2h0OiAxLFxuICAgICAgICBib3R0b206IHJlY3QubWFwLmhlaWdodFxuICAgICAgfSA6IHR5cGUgPT0gXCJyb3dcIiA/IHtcbiAgICAgICAgbGVmdDogc2VsZWN0aW9uU3RhcnRzQXQsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IHJlY3QubWFwLndpZHRoLFxuICAgICAgICBib3R0b206IDFcbiAgICAgIH0gOiByZWN0O1xuICAgICAgY29uc3QgbmV3VHlwZSA9IHR5cGUgPT0gXCJjb2x1bW5cIiA/IGlzSGVhZGVyQ29sdW1uRW5hYmxlZCA/IHR5cGVzLmNlbGwgOiB0eXBlcy5oZWFkZXJfY2VsbCA6IHR5cGUgPT0gXCJyb3dcIiA/IGlzSGVhZGVyUm93RW5hYmxlZCA/IHR5cGVzLmNlbGwgOiB0eXBlcy5oZWFkZXJfY2VsbCA6IHR5cGVzLmNlbGw7XG4gICAgICByZWN0Lm1hcC5jZWxsc0luUmVjdChjZWxsc1JlY3QpLmZvckVhY2goKHJlbGF0aXZlQ2VsbFBvcykgPT4ge1xuICAgICAgICBjb25zdCBjZWxsUG9zID0gcmVsYXRpdmVDZWxsUG9zICsgcmVjdC50YWJsZVN0YXJ0O1xuICAgICAgICBjb25zdCBjZWxsID0gdHIuZG9jLm5vZGVBdChjZWxsUG9zKTtcbiAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKGNlbGxQb3MsIG5ld1R5cGUsIGNlbGwuYXR0cnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG52YXIgdG9nZ2xlSGVhZGVyUm93ID0gdG9nZ2xlSGVhZGVyKFwicm93XCIsIHtcbiAgdXNlRGVwcmVjYXRlZExvZ2ljOiB0cnVlXG59KTtcbnZhciB0b2dnbGVIZWFkZXJDb2x1bW4gPSB0b2dnbGVIZWFkZXIoXCJjb2x1bW5cIiwge1xuICB1c2VEZXByZWNhdGVkTG9naWM6IHRydWVcbn0pO1xudmFyIHRvZ2dsZUhlYWRlckNlbGwgPSB0b2dnbGVIZWFkZXIoXCJjZWxsXCIsIHtcbiAgdXNlRGVwcmVjYXRlZExvZ2ljOiB0cnVlXG59KTtcbmZ1bmN0aW9uIGZpbmROZXh0Q2VsbCgkY2VsbCwgZGlyKSB7XG4gIGlmIChkaXIgPCAwKSB7XG4gICAgY29uc3QgYmVmb3JlID0gJGNlbGwubm9kZUJlZm9yZTtcbiAgICBpZiAoYmVmb3JlKSByZXR1cm4gJGNlbGwucG9zIC0gYmVmb3JlLm5vZGVTaXplO1xuICAgIGZvciAobGV0IHJvdyA9ICRjZWxsLmluZGV4KC0xKSAtIDEsIHJvd0VuZCA9ICRjZWxsLmJlZm9yZSgpOyByb3cgPj0gMDsgcm93LS0pIHtcbiAgICAgIGNvbnN0IHJvd05vZGUgPSAkY2VsbC5ub2RlKC0xKS5jaGlsZChyb3cpO1xuICAgICAgY29uc3QgbGFzdENoaWxkID0gcm93Tm9kZS5sYXN0Q2hpbGQ7XG4gICAgICBpZiAobGFzdENoaWxkKSB7XG4gICAgICAgIHJldHVybiByb3dFbmQgLSAxIC0gbGFzdENoaWxkLm5vZGVTaXplO1xuICAgICAgfVxuICAgICAgcm93RW5kIC09IHJvd05vZGUubm9kZVNpemU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICgkY2VsbC5pbmRleCgpIDwgJGNlbGwucGFyZW50LmNoaWxkQ291bnQgLSAxKSB7XG4gICAgICByZXR1cm4gJGNlbGwucG9zICsgJGNlbGwubm9kZUFmdGVyLm5vZGVTaXplO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZSA9ICRjZWxsLm5vZGUoLTEpO1xuICAgIGZvciAobGV0IHJvdyA9ICRjZWxsLmluZGV4QWZ0ZXIoLTEpLCByb3dTdGFydCA9ICRjZWxsLmFmdGVyKCk7IHJvdyA8IHRhYmxlLmNoaWxkQ291bnQ7IHJvdysrKSB7XG4gICAgICBjb25zdCByb3dOb2RlID0gdGFibGUuY2hpbGQocm93KTtcbiAgICAgIGlmIChyb3dOb2RlLmNoaWxkQ291bnQpIHJldHVybiByb3dTdGFydCArIDE7XG4gICAgICByb3dTdGFydCArPSByb3dOb2RlLm5vZGVTaXplO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdvVG9OZXh0Q2VsbChkaXJlY3Rpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIGlmICghaXNJblRhYmxlKHN0YXRlKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGNlbGwgPSBmaW5kTmV4dENlbGwoc2VsZWN0aW9uQ2VsbChzdGF0ZSksIGRpcmVjdGlvbik7XG4gICAgaWYgKGNlbGwgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgY29uc3QgJGNlbGwgPSBzdGF0ZS5kb2MucmVzb2x2ZShjZWxsKTtcbiAgICAgIGRpc3BhdGNoKFxuICAgICAgICBzdGF0ZS50ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbjIuYmV0d2VlbigkY2VsbCwgbW92ZUNlbGxGb3J3YXJkKCRjZWxsKSkpLnNjcm9sbEludG9WaWV3KClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlVGFibGUoc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGNvbnN0ICRwb3MgPSBzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvcjtcbiAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7IGQgPiAwOyBkLS0pIHtcbiAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGQpO1xuICAgIGlmIChub2RlLnR5cGUuc3BlYy50YWJsZVJvbGUgPT0gXCJ0YWJsZVwiKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgIHN0YXRlLnRyLmRlbGV0ZSgkcG9zLmJlZm9yZShkKSwgJHBvcy5hZnRlcihkKSkuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNlbGxTZWxlY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKCEoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSB7XG4gICAgY29uc3QgdHIgPSBzdGF0ZS50cjtcbiAgICBjb25zdCBiYXNlQ29udGVudCA9IHRhYmxlTm9kZVR5cGVzKHN0YXRlLnNjaGVtYSkuY2VsbC5jcmVhdGVBbmRGaWxsKCkuY29udGVudDtcbiAgICBzZWwuZm9yRWFjaENlbGwoKGNlbGwsIHBvcykgPT4ge1xuICAgICAgaWYgKCFjZWxsLmNvbnRlbnQuZXEoYmFzZUNvbnRlbnQpKVxuICAgICAgICB0ci5yZXBsYWNlKFxuICAgICAgICAgIHRyLm1hcHBpbmcubWFwKHBvcyArIDEpLFxuICAgICAgICAgIHRyLm1hcHBpbmcubWFwKHBvcyArIGNlbGwubm9kZVNpemUgLSAxKSxcbiAgICAgICAgICBuZXcgU2xpY2UyKGJhc2VDb250ZW50LCAwLCAwKVxuICAgICAgICApO1xuICAgIH0pO1xuICAgIGlmICh0ci5kb2NDaGFuZ2VkKSBkaXNwYXRjaCh0cik7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9jb3B5cGFzdGUudHNcbmltcG9ydCB7IEZyYWdtZW50IGFzIEZyYWdtZW50MywgU2xpY2UgYXMgU2xpY2UzIH0gZnJvbSBcInByb3NlbWlycm9yLW1vZGVsXCI7XG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tIFwicHJvc2VtaXJyb3ItdHJhbnNmb3JtXCI7XG5mdW5jdGlvbiBwYXN0ZWRDZWxscyhzbGljZSkge1xuICBpZiAoIXNsaWNlLnNpemUpIHJldHVybiBudWxsO1xuICBsZXQgeyBjb250ZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IHNsaWNlO1xuICB3aGlsZSAoY29udGVudC5jaGlsZENvdW50ID09IDEgJiYgKG9wZW5TdGFydCA+IDAgJiYgb3BlbkVuZCA+IDAgfHwgY29udGVudC5jaGlsZCgwKS50eXBlLnNwZWMudGFibGVSb2xlID09IFwidGFibGVcIikpIHtcbiAgICBvcGVuU3RhcnQtLTtcbiAgICBvcGVuRW5kLS07XG4gICAgY29udGVudCA9IGNvbnRlbnQuY2hpbGQoMCkuY29udGVudDtcbiAgfVxuICBjb25zdCBmaXJzdCA9IGNvbnRlbnQuY2hpbGQoMCk7XG4gIGNvbnN0IHJvbGUgPSBmaXJzdC50eXBlLnNwZWMudGFibGVSb2xlO1xuICBjb25zdCBzY2hlbWEgPSBmaXJzdC50eXBlLnNjaGVtYSwgcm93cyA9IFtdO1xuICBpZiAocm9sZSA9PSBcInJvd1wiKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgbGV0IGNlbGxzID0gY29udGVudC5jaGlsZChpKS5jb250ZW50O1xuICAgICAgY29uc3QgbGVmdCA9IGkgPyAwIDogTWF0aC5tYXgoMCwgb3BlblN0YXJ0IC0gMSk7XG4gICAgICBjb25zdCByaWdodCA9IGkgPCBjb250ZW50LmNoaWxkQ291bnQgLSAxID8gMCA6IE1hdGgubWF4KDAsIG9wZW5FbmQgLSAxKTtcbiAgICAgIGlmIChsZWZ0IHx8IHJpZ2h0KVxuICAgICAgICBjZWxscyA9IGZpdFNsaWNlKFxuICAgICAgICAgIHRhYmxlTm9kZVR5cGVzKHNjaGVtYSkucm93LFxuICAgICAgICAgIG5ldyBTbGljZTMoY2VsbHMsIGxlZnQsIHJpZ2h0KVxuICAgICAgICApLmNvbnRlbnQ7XG4gICAgICByb3dzLnB1c2goY2VsbHMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyb2xlID09IFwiY2VsbFwiIHx8IHJvbGUgPT0gXCJoZWFkZXJfY2VsbFwiKSB7XG4gICAgcm93cy5wdXNoKFxuICAgICAgb3BlblN0YXJ0IHx8IG9wZW5FbmQgPyBmaXRTbGljZShcbiAgICAgICAgdGFibGVOb2RlVHlwZXMoc2NoZW1hKS5yb3csXG4gICAgICAgIG5ldyBTbGljZTMoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKVxuICAgICAgKS5jb250ZW50IDogY29udGVudFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGVuc3VyZVJlY3Rhbmd1bGFyKHNjaGVtYSwgcm93cyk7XG59XG5mdW5jdGlvbiBlbnN1cmVSZWN0YW5ndWxhcihzY2hlbWEsIHJvd3MpIHtcbiAgY29uc3Qgd2lkdGhzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IHJvd3NbaV07XG4gICAgZm9yIChsZXQgaiA9IHJvdy5jaGlsZENvdW50IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGNvbnN0IHsgcm93c3BhbiwgY29sc3BhbiB9ID0gcm93LmNoaWxkKGopLmF0dHJzO1xuICAgICAgZm9yIChsZXQgciA9IGk7IHIgPCBpICsgcm93c3BhbjsgcisrKVxuICAgICAgICB3aWR0aHNbcl0gPSAod2lkdGhzW3JdIHx8IDApICsgY29sc3BhbjtcbiAgICB9XG4gIH1cbiAgbGV0IHdpZHRoID0gMDtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB3aWR0aHMubGVuZ3RoOyByKyspIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHdpZHRoc1tyXSk7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgd2lkdGhzLmxlbmd0aDsgcisrKSB7XG4gICAgaWYgKHIgPj0gcm93cy5sZW5ndGgpIHJvd3MucHVzaChGcmFnbWVudDMuZW1wdHkpO1xuICAgIGlmICh3aWR0aHNbcl0gPCB3aWR0aCkge1xuICAgICAgY29uc3QgZW1wdHkgPSB0YWJsZU5vZGVUeXBlcyhzY2hlbWEpLmNlbGwuY3JlYXRlQW5kRmlsbCgpO1xuICAgICAgY29uc3QgY2VsbHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSB3aWR0aHNbcl07IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIGNlbGxzLnB1c2goZW1wdHkpO1xuICAgICAgfVxuICAgICAgcm93c1tyXSA9IHJvd3Nbcl0uYXBwZW5kKEZyYWdtZW50My5mcm9tKGNlbGxzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGhlaWdodDogcm93cy5sZW5ndGgsIHdpZHRoLCByb3dzIH07XG59XG5mdW5jdGlvbiBmaXRTbGljZShub2RlVHlwZSwgc2xpY2UpIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVUeXBlLmNyZWF0ZUFuZEZpbGwoKTtcbiAgY29uc3QgdHIgPSBuZXcgVHJhbnNmb3JtKG5vZGUpLnJlcGxhY2UoMCwgbm9kZS5jb250ZW50LnNpemUsIHNsaWNlKTtcbiAgcmV0dXJuIHRyLmRvYztcbn1cbmZ1bmN0aW9uIGNsaXBDZWxscyh7IHdpZHRoLCBoZWlnaHQsIHJvd3MgfSwgbmV3V2lkdGgsIG5ld0hlaWdodCkge1xuICBpZiAod2lkdGggIT0gbmV3V2lkdGgpIHtcbiAgICBjb25zdCBhZGRlZCA9IFtdO1xuICAgIGNvbnN0IG5ld1Jvd3MgPSBbXTtcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzLmxlbmd0aDsgcm93KyspIHtcbiAgICAgIGNvbnN0IGZyYWcgPSByb3dzW3Jvd10sIGNlbGxzID0gW107XG4gICAgICBmb3IgKGxldCBjb2wgPSBhZGRlZFtyb3ddIHx8IDAsIGkgPSAwOyBjb2wgPCBuZXdXaWR0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjZWxsID0gZnJhZy5jaGlsZChpICUgZnJhZy5jaGlsZENvdW50KTtcbiAgICAgICAgaWYgKGNvbCArIGNlbGwuYXR0cnMuY29sc3BhbiA+IG5ld1dpZHRoKVxuICAgICAgICAgIGNlbGwgPSBjZWxsLnR5cGUuY3JlYXRlQ2hlY2tlZChcbiAgICAgICAgICAgIHJlbW92ZUNvbFNwYW4oXG4gICAgICAgICAgICAgIGNlbGwuYXR0cnMsXG4gICAgICAgICAgICAgIGNlbGwuYXR0cnMuY29sc3BhbixcbiAgICAgICAgICAgICAgY29sICsgY2VsbC5hdHRycy5jb2xzcGFuIC0gbmV3V2lkdGhcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjZWxsLmNvbnRlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjZWxscy5wdXNoKGNlbGwpO1xuICAgICAgICBjb2wgKz0gY2VsbC5hdHRycy5jb2xzcGFuO1xuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGNlbGwuYXR0cnMucm93c3BhbjsgaisrKVxuICAgICAgICAgIGFkZGVkW3JvdyArIGpdID0gKGFkZGVkW3JvdyArIGpdIHx8IDApICsgY2VsbC5hdHRycy5jb2xzcGFuO1xuICAgICAgfVxuICAgICAgbmV3Um93cy5wdXNoKEZyYWdtZW50My5mcm9tKGNlbGxzKSk7XG4gICAgfVxuICAgIHJvd3MgPSBuZXdSb3dzO1xuICAgIHdpZHRoID0gbmV3V2lkdGg7XG4gIH1cbiAgaWYgKGhlaWdodCAhPSBuZXdIZWlnaHQpIHtcbiAgICBjb25zdCBuZXdSb3dzID0gW107XG4gICAgZm9yIChsZXQgcm93ID0gMCwgaSA9IDA7IHJvdyA8IG5ld0hlaWdodDsgcm93KyssIGkrKykge1xuICAgICAgY29uc3QgY2VsbHMgPSBbXSwgc291cmNlID0gcm93c1tpICUgaGVpZ2h0XTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc291cmNlLmNoaWxkQ291bnQ7IGorKykge1xuICAgICAgICBsZXQgY2VsbCA9IHNvdXJjZS5jaGlsZChqKTtcbiAgICAgICAgaWYgKHJvdyArIGNlbGwuYXR0cnMucm93c3BhbiA+IG5ld0hlaWdodClcbiAgICAgICAgICBjZWxsID0gY2VsbC50eXBlLmNyZWF0ZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uY2VsbC5hdHRycyxcbiAgICAgICAgICAgICAgcm93c3BhbjogTWF0aC5tYXgoMSwgbmV3SGVpZ2h0IC0gY2VsbC5hdHRycy5yb3dzcGFuKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNlbGwuY29udGVudFxuICAgICAgICAgICk7XG4gICAgICAgIGNlbGxzLnB1c2goY2VsbCk7XG4gICAgICB9XG4gICAgICBuZXdSb3dzLnB1c2goRnJhZ21lbnQzLmZyb20oY2VsbHMpKTtcbiAgICB9XG4gICAgcm93cyA9IG5ld1Jvd3M7XG4gICAgaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICB9XG4gIHJldHVybiB7IHdpZHRoLCBoZWlnaHQsIHJvd3MgfTtcbn1cbmZ1bmN0aW9uIGdyb3dUYWJsZSh0ciwgbWFwLCB0YWJsZSwgc3RhcnQsIHdpZHRoLCBoZWlnaHQsIG1hcEZyb20pIHtcbiAgY29uc3Qgc2NoZW1hID0gdHIuZG9jLnR5cGUuc2NoZW1hO1xuICBjb25zdCB0eXBlcyA9IHRhYmxlTm9kZVR5cGVzKHNjaGVtYSk7XG4gIGxldCBlbXB0eTtcbiAgbGV0IGVtcHR5SGVhZDtcbiAgaWYgKHdpZHRoID4gbWFwLndpZHRoKSB7XG4gICAgZm9yIChsZXQgcm93ID0gMCwgcm93RW5kID0gMDsgcm93IDwgbWFwLmhlaWdodDsgcm93KyspIHtcbiAgICAgIGNvbnN0IHJvd05vZGUgPSB0YWJsZS5jaGlsZChyb3cpO1xuICAgICAgcm93RW5kICs9IHJvd05vZGUubm9kZVNpemU7XG4gICAgICBjb25zdCBjZWxscyA9IFtdO1xuICAgICAgbGV0IGFkZDtcbiAgICAgIGlmIChyb3dOb2RlLmxhc3RDaGlsZCA9PSBudWxsIHx8IHJvd05vZGUubGFzdENoaWxkLnR5cGUgPT0gdHlwZXMuY2VsbClcbiAgICAgICAgYWRkID0gZW1wdHkgfHwgKGVtcHR5ID0gdHlwZXMuY2VsbC5jcmVhdGVBbmRGaWxsKCkpO1xuICAgICAgZWxzZSBhZGQgPSBlbXB0eUhlYWQgfHwgKGVtcHR5SGVhZCA9IHR5cGVzLmhlYWRlcl9jZWxsLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICBmb3IgKGxldCBpID0gbWFwLndpZHRoOyBpIDwgd2lkdGg7IGkrKykgY2VsbHMucHVzaChhZGQpO1xuICAgICAgdHIuaW5zZXJ0KHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHJvd0VuZCAtIDEgKyBzdGFydCksIGNlbGxzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGhlaWdodCA+IG1hcC5oZWlnaHQpIHtcbiAgICBjb25zdCBjZWxscyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBzdGFydDIgPSAobWFwLmhlaWdodCAtIDEpICogbWFwLndpZHRoOyBpIDwgTWF0aC5tYXgobWFwLndpZHRoLCB3aWR0aCk7IGkrKykge1xuICAgICAgY29uc3QgaGVhZGVyID0gaSA+PSBtYXAud2lkdGggPyBmYWxzZSA6IHRhYmxlLm5vZGVBdChtYXAubWFwW3N0YXJ0MiArIGldKS50eXBlID09IHR5cGVzLmhlYWRlcl9jZWxsO1xuICAgICAgY2VsbHMucHVzaChcbiAgICAgICAgaGVhZGVyID8gZW1wdHlIZWFkIHx8IChlbXB0eUhlYWQgPSB0eXBlcy5oZWFkZXJfY2VsbC5jcmVhdGVBbmRGaWxsKCkpIDogZW1wdHkgfHwgKGVtcHR5ID0gdHlwZXMuY2VsbC5jcmVhdGVBbmRGaWxsKCkpXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBlbXB0eVJvdyA9IHR5cGVzLnJvdy5jcmVhdGUobnVsbCwgRnJhZ21lbnQzLmZyb20oY2VsbHMpKSwgcm93cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBtYXAuaGVpZ2h0OyBpIDwgaGVpZ2h0OyBpKyspIHJvd3MucHVzaChlbXB0eVJvdyk7XG4gICAgdHIuaW5zZXJ0KHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHN0YXJ0ICsgdGFibGUubm9kZVNpemUgLSAyKSwgcm93cyk7XG4gIH1cbiAgcmV0dXJuICEhKGVtcHR5IHx8IGVtcHR5SGVhZCk7XG59XG5mdW5jdGlvbiBpc29sYXRlSG9yaXpvbnRhbCh0ciwgbWFwLCB0YWJsZSwgc3RhcnQsIGxlZnQsIHJpZ2h0LCB0b3AsIG1hcEZyb20pIHtcbiAgaWYgKHRvcCA9PSAwIHx8IHRvcCA9PSBtYXAuaGVpZ2h0KSByZXR1cm4gZmFsc2U7XG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuICBmb3IgKGxldCBjb2wgPSBsZWZ0OyBjb2wgPCByaWdodDsgY29sKyspIHtcbiAgICBjb25zdCBpbmRleCA9IHRvcCAqIG1hcC53aWR0aCArIGNvbCwgcG9zID0gbWFwLm1hcFtpbmRleF07XG4gICAgaWYgKG1hcC5tYXBbaW5kZXggLSBtYXAud2lkdGhdID09IHBvcykge1xuICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgY29uc3QgY2VsbCA9IHRhYmxlLm5vZGVBdChwb3MpO1xuICAgICAgY29uc3QgeyB0b3A6IGNlbGxUb3AsIGxlZnQ6IGNlbGxMZWZ0IH0gPSBtYXAuZmluZENlbGwocG9zKTtcbiAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgc3RhcnQpLCBudWxsLCB7XG4gICAgICAgIC4uLmNlbGwuYXR0cnMsXG4gICAgICAgIHJvd3NwYW46IHRvcCAtIGNlbGxUb3BcbiAgICAgIH0pO1xuICAgICAgdHIuaW5zZXJ0KFxuICAgICAgICB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChtYXAucG9zaXRpb25BdCh0b3AsIGNlbGxMZWZ0LCB0YWJsZSkpLFxuICAgICAgICBjZWxsLnR5cGUuY3JlYXRlQW5kRmlsbCh7XG4gICAgICAgICAgLi4uY2VsbC5hdHRycyxcbiAgICAgICAgICByb3dzcGFuOiBjZWxsVG9wICsgY2VsbC5hdHRycy5yb3dzcGFuIC0gdG9wXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgY29sICs9IGNlbGwuYXR0cnMuY29sc3BhbiAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGlzb2xhdGVWZXJ0aWNhbCh0ciwgbWFwLCB0YWJsZSwgc3RhcnQsIHRvcCwgYm90dG9tLCBsZWZ0LCBtYXBGcm9tKSB7XG4gIGlmIChsZWZ0ID09IDAgfHwgbGVmdCA9PSBtYXAud2lkdGgpIHJldHVybiBmYWxzZTtcbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIGZvciAobGV0IHJvdyA9IHRvcDsgcm93IDwgYm90dG9tOyByb3crKykge1xuICAgIGNvbnN0IGluZGV4ID0gcm93ICogbWFwLndpZHRoICsgbGVmdCwgcG9zID0gbWFwLm1hcFtpbmRleF07XG4gICAgaWYgKG1hcC5tYXBbaW5kZXggLSAxXSA9PSBwb3MpIHtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZS5ub2RlQXQocG9zKTtcbiAgICAgIGNvbnN0IGNlbGxMZWZ0ID0gbWFwLmNvbENvdW50KHBvcyk7XG4gICAgICBjb25zdCB1cGRhdGVQb3MgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MgKyBzdGFydCk7XG4gICAgICB0ci5zZXROb2RlTWFya3VwKFxuICAgICAgICB1cGRhdGVQb3MsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHJlbW92ZUNvbFNwYW4oXG4gICAgICAgICAgY2VsbC5hdHRycyxcbiAgICAgICAgICBsZWZ0IC0gY2VsbExlZnQsXG4gICAgICAgICAgY2VsbC5hdHRycy5jb2xzcGFuIC0gKGxlZnQgLSBjZWxsTGVmdClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRyLmluc2VydChcbiAgICAgICAgdXBkYXRlUG9zICsgY2VsbC5ub2RlU2l6ZSxcbiAgICAgICAgY2VsbC50eXBlLmNyZWF0ZUFuZEZpbGwoXG4gICAgICAgICAgcmVtb3ZlQ29sU3BhbihjZWxsLmF0dHJzLCAwLCBsZWZ0IC0gY2VsbExlZnQpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICByb3cgKz0gY2VsbC5hdHRycy5yb3dzcGFuIC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gaW5zZXJ0Q2VsbHMoc3RhdGUsIGRpc3BhdGNoLCB0YWJsZVN0YXJ0LCByZWN0LCBjZWxscykge1xuICBsZXQgdGFibGUgPSB0YWJsZVN0YXJ0ID8gc3RhdGUuZG9jLm5vZGVBdCh0YWJsZVN0YXJ0IC0gMSkgOiBzdGF0ZS5kb2M7XG4gIGlmICghdGFibGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB0YWJsZSBmb3VuZFwiKTtcbiAgfVxuICBsZXQgbWFwID0gVGFibGVNYXAuZ2V0KHRhYmxlKTtcbiAgY29uc3QgeyB0b3AsIGxlZnQgfSA9IHJlY3Q7XG4gIGNvbnN0IHJpZ2h0ID0gbGVmdCArIGNlbGxzLndpZHRoLCBib3R0b20gPSB0b3AgKyBjZWxscy5oZWlnaHQ7XG4gIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gIGxldCBtYXBGcm9tID0gMDtcbiAgZnVuY3Rpb24gcmVjb21wKCkge1xuICAgIHRhYmxlID0gdGFibGVTdGFydCA/IHRyLmRvYy5ub2RlQXQodGFibGVTdGFydCAtIDEpIDogdHIuZG9jO1xuICAgIGlmICghdGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRhYmxlIGZvdW5kXCIpO1xuICAgIH1cbiAgICBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICAgIG1hcEZyb20gPSB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoO1xuICB9XG4gIGlmIChncm93VGFibGUodHIsIG1hcCwgdGFibGUsIHRhYmxlU3RhcnQsIHJpZ2h0LCBib3R0b20sIG1hcEZyb20pKSByZWNvbXAoKTtcbiAgaWYgKGlzb2xhdGVIb3Jpem9udGFsKHRyLCBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0LCBsZWZ0LCByaWdodCwgdG9wLCBtYXBGcm9tKSlcbiAgICByZWNvbXAoKTtcbiAgaWYgKGlzb2xhdGVIb3Jpem9udGFsKHRyLCBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0LCBsZWZ0LCByaWdodCwgYm90dG9tLCBtYXBGcm9tKSlcbiAgICByZWNvbXAoKTtcbiAgaWYgKGlzb2xhdGVWZXJ0aWNhbCh0ciwgbWFwLCB0YWJsZSwgdGFibGVTdGFydCwgdG9wLCBib3R0b20sIGxlZnQsIG1hcEZyb20pKVxuICAgIHJlY29tcCgpO1xuICBpZiAoaXNvbGF0ZVZlcnRpY2FsKHRyLCBtYXAsIHRhYmxlLCB0YWJsZVN0YXJ0LCB0b3AsIGJvdHRvbSwgcmlnaHQsIG1hcEZyb20pKVxuICAgIHJlY29tcCgpO1xuICBmb3IgKGxldCByb3cgPSB0b3A7IHJvdyA8IGJvdHRvbTsgcm93KyspIHtcbiAgICBjb25zdCBmcm9tID0gbWFwLnBvc2l0aW9uQXQocm93LCBsZWZ0LCB0YWJsZSksIHRvID0gbWFwLnBvc2l0aW9uQXQocm93LCByaWdodCwgdGFibGUpO1xuICAgIHRyLnJlcGxhY2UoXG4gICAgICB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChmcm9tICsgdGFibGVTdGFydCksXG4gICAgICB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcCh0byArIHRhYmxlU3RhcnQpLFxuICAgICAgbmV3IFNsaWNlMyhjZWxscy5yb3dzW3JvdyAtIHRvcF0sIDAsIDApXG4gICAgKTtcbiAgfVxuICByZWNvbXAoKTtcbiAgdHIuc2V0U2VsZWN0aW9uKFxuICAgIG5ldyBDZWxsU2VsZWN0aW9uKFxuICAgICAgdHIuZG9jLnJlc29sdmUodGFibGVTdGFydCArIG1hcC5wb3NpdGlvbkF0KHRvcCwgbGVmdCwgdGFibGUpKSxcbiAgICAgIHRyLmRvYy5yZXNvbHZlKHRhYmxlU3RhcnQgKyBtYXAucG9zaXRpb25BdChib3R0b20gLSAxLCByaWdodCAtIDEsIHRhYmxlKSlcbiAgICApXG4gICk7XG4gIGRpc3BhdGNoKHRyKTtcbn1cblxuLy8gc3JjL2lucHV0LnRzXG52YXIgaGFuZGxlS2V5RG93biA9IGtleWRvd25IYW5kbGVyKHtcbiAgQXJyb3dMZWZ0OiBhcnJvdyhcImhvcml6XCIsIC0xKSxcbiAgQXJyb3dSaWdodDogYXJyb3coXCJob3JpelwiLCAxKSxcbiAgQXJyb3dVcDogYXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgQXJyb3dEb3duOiBhcnJvdyhcInZlcnRcIiwgMSksXG4gIFwiU2hpZnQtQXJyb3dMZWZ0XCI6IHNoaWZ0QXJyb3coXCJob3JpelwiLCAtMSksXG4gIFwiU2hpZnQtQXJyb3dSaWdodFwiOiBzaGlmdEFycm93KFwiaG9yaXpcIiwgMSksXG4gIFwiU2hpZnQtQXJyb3dVcFwiOiBzaGlmdEFycm93KFwidmVydFwiLCAtMSksXG4gIFwiU2hpZnQtQXJyb3dEb3duXCI6IHNoaWZ0QXJyb3coXCJ2ZXJ0XCIsIDEpLFxuICBCYWNrc3BhY2U6IGRlbGV0ZUNlbGxTZWxlY3Rpb24sXG4gIFwiTW9kLUJhY2tzcGFjZVwiOiBkZWxldGVDZWxsU2VsZWN0aW9uLFxuICBEZWxldGU6IGRlbGV0ZUNlbGxTZWxlY3Rpb24sXG4gIFwiTW9kLURlbGV0ZVwiOiBkZWxldGVDZWxsU2VsZWN0aW9uXG59KTtcbmZ1bmN0aW9uIG1heWJlU2V0U2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCwgc2VsZWN0aW9uKSB7XG4gIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFycm93KGF4aXMsIGRpcikge1xuICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGlmICghdmlldykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikge1xuICAgICAgcmV0dXJuIG1heWJlU2V0U2VsZWN0aW9uKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIFNlbGVjdGlvbjIubmVhcihzZWwuJGhlYWRDZWxsLCBkaXIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYXhpcyAhPSBcImhvcml6XCIgJiYgIXNlbC5lbXB0eSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGVuZCA9IGF0RW5kT2ZDZWxsKHZpZXcsIGF4aXMsIGRpcik7XG4gICAgaWYgKGVuZCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGF4aXMgPT0gXCJob3JpelwiKSB7XG4gICAgICByZXR1cm4gbWF5YmVTZXRTZWxlY3Rpb24oXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgU2VsZWN0aW9uMi5uZWFyKHN0YXRlLmRvYy5yZXNvbHZlKHNlbC5oZWFkICsgZGlyKSwgZGlyKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgJGNlbGwgPSBzdGF0ZS5kb2MucmVzb2x2ZShlbmQpO1xuICAgICAgY29uc3QgJG5leHQgPSBuZXh0Q2VsbCgkY2VsbCwgYXhpcywgZGlyKTtcbiAgICAgIGxldCBuZXdTZWw7XG4gICAgICBpZiAoJG5leHQpIG5ld1NlbCA9IFNlbGVjdGlvbjIubmVhcigkbmV4dCwgMSk7XG4gICAgICBlbHNlIGlmIChkaXIgPCAwKVxuICAgICAgICBuZXdTZWwgPSBTZWxlY3Rpb24yLm5lYXIoc3RhdGUuZG9jLnJlc29sdmUoJGNlbGwuYmVmb3JlKC0xKSksIC0xKTtcbiAgICAgIGVsc2UgbmV3U2VsID0gU2VsZWN0aW9uMi5uZWFyKHN0YXRlLmRvYy5yZXNvbHZlKCRjZWxsLmFmdGVyKC0xKSksIDEpO1xuICAgICAgcmV0dXJuIG1heWJlU2V0U2VsZWN0aW9uKHN0YXRlLCBkaXNwYXRjaCwgbmV3U2VsKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzaGlmdEFycm93KGF4aXMsIGRpcikge1xuICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGlmICghdmlldykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgY2VsbFNlbDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikge1xuICAgICAgY2VsbFNlbCA9IHNlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZW5kID0gYXRFbmRPZkNlbGwodmlldywgYXhpcywgZGlyKTtcbiAgICAgIGlmIChlbmQgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgY2VsbFNlbCA9IG5ldyBDZWxsU2VsZWN0aW9uKHN0YXRlLmRvYy5yZXNvbHZlKGVuZCkpO1xuICAgIH1cbiAgICBjb25zdCAkaGVhZCA9IG5leHRDZWxsKGNlbGxTZWwuJGhlYWRDZWxsLCBheGlzLCBkaXIpO1xuICAgIGlmICghJGhlYWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gbWF5YmVTZXRTZWxlY3Rpb24oXG4gICAgICBzdGF0ZSxcbiAgICAgIGRpc3BhdGNoLFxuICAgICAgbmV3IENlbGxTZWxlY3Rpb24oY2VsbFNlbC4kYW5jaG9yQ2VsbCwgJGhlYWQpXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRyaXBsZUNsaWNrKHZpZXcsIHBvcykge1xuICBjb25zdCBkb2MgPSB2aWV3LnN0YXRlLmRvYywgJGNlbGwgPSBjZWxsQXJvdW5kKGRvYy5yZXNvbHZlKHBvcykpO1xuICBpZiAoISRjZWxsKSByZXR1cm4gZmFsc2U7XG4gIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IENlbGxTZWxlY3Rpb24oJGNlbGwpKSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaGFuZGxlUGFzdGUodmlldywgXywgc2xpY2UpIHtcbiAgaWYgKCFpc0luVGFibGUodmlldy5zdGF0ZSkpIHJldHVybiBmYWxzZTtcbiAgbGV0IGNlbGxzID0gcGFzdGVkQ2VsbHMoc2xpY2UpO1xuICBjb25zdCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKHNlbCBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pIHtcbiAgICBpZiAoIWNlbGxzKVxuICAgICAgY2VsbHMgPSB7XG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgIHJvd3M6IFtcbiAgICAgICAgICBGcmFnbWVudDQuZnJvbShcbiAgICAgICAgICAgIGZpdFNsaWNlKHRhYmxlTm9kZVR5cGVzKHZpZXcuc3RhdGUuc2NoZW1hKS5jZWxsLCBzbGljZSlcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgY29uc3QgdGFibGUgPSBzZWwuJGFuY2hvckNlbGwubm9kZSgtMSk7XG4gICAgY29uc3Qgc3RhcnQgPSBzZWwuJGFuY2hvckNlbGwuc3RhcnQoLTEpO1xuICAgIGNvbnN0IHJlY3QgPSBUYWJsZU1hcC5nZXQodGFibGUpLnJlY3RCZXR3ZWVuKFxuICAgICAgc2VsLiRhbmNob3JDZWxsLnBvcyAtIHN0YXJ0LFxuICAgICAgc2VsLiRoZWFkQ2VsbC5wb3MgLSBzdGFydFxuICAgICk7XG4gICAgY2VsbHMgPSBjbGlwQ2VsbHMoY2VsbHMsIHJlY3QucmlnaHQgLSByZWN0LmxlZnQsIHJlY3QuYm90dG9tIC0gcmVjdC50b3ApO1xuICAgIGluc2VydENlbGxzKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHN0YXJ0LCByZWN0LCBjZWxscyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoY2VsbHMpIHtcbiAgICBjb25zdCAkY2VsbCA9IHNlbGVjdGlvbkNlbGwodmlldy5zdGF0ZSk7XG4gICAgY29uc3Qgc3RhcnQgPSAkY2VsbC5zdGFydCgtMSk7XG4gICAgaW5zZXJ0Q2VsbHMoXG4gICAgICB2aWV3LnN0YXRlLFxuICAgICAgdmlldy5kaXNwYXRjaCxcbiAgICAgIHN0YXJ0LFxuICAgICAgVGFibGVNYXAuZ2V0KCRjZWxsLm5vZGUoLTEpKS5maW5kQ2VsbCgkY2VsbC5wb3MgLSBzdGFydCksXG4gICAgICBjZWxsc1xuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVNb3VzZURvd24odmlldywgc3RhcnRFdmVudCkge1xuICB2YXIgX2E7XG4gIGlmIChzdGFydEV2ZW50LmN0cmxLZXkgfHwgc3RhcnRFdmVudC5tZXRhS2V5KSByZXR1cm47XG4gIGNvbnN0IHN0YXJ0RE9NQ2VsbCA9IGRvbUluQ2VsbCh2aWV3LCBzdGFydEV2ZW50LnRhcmdldCk7XG4gIGxldCAkYW5jaG9yO1xuICBpZiAoc3RhcnRFdmVudC5zaGlmdEtleSAmJiB2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb24pIHtcbiAgICBzZXRDZWxsU2VsZWN0aW9uKHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRhbmNob3JDZWxsLCBzdGFydEV2ZW50KTtcbiAgICBzdGFydEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0gZWxzZSBpZiAoc3RhcnRFdmVudC5zaGlmdEtleSAmJiBzdGFydERPTUNlbGwgJiYgKCRhbmNob3IgPSBjZWxsQXJvdW5kKHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRhbmNob3IpKSAhPSBudWxsICYmICgoX2EgPSBjZWxsVW5kZXJNb3VzZSh2aWV3LCBzdGFydEV2ZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnBvcykgIT0gJGFuY2hvci5wb3MpIHtcbiAgICBzZXRDZWxsU2VsZWN0aW9uKCRhbmNob3IsIHN0YXJ0RXZlbnQpO1xuICAgIHN0YXJ0RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSBlbHNlIGlmICghc3RhcnRET01DZWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZ1bmN0aW9uIHNldENlbGxTZWxlY3Rpb24oJGFuY2hvcjIsIGV2ZW50KSB7XG4gICAgbGV0ICRoZWFkID0gY2VsbFVuZGVyTW91c2UodmlldywgZXZlbnQpO1xuICAgIGNvbnN0IHN0YXJ0aW5nID0gdGFibGVFZGl0aW5nS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpID09IG51bGw7XG4gICAgaWYgKCEkaGVhZCB8fCAhaW5TYW1lVGFibGUoJGFuY2hvcjIsICRoZWFkKSkge1xuICAgICAgaWYgKHN0YXJ0aW5nKSAkaGVhZCA9ICRhbmNob3IyO1xuICAgICAgZWxzZSByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBDZWxsU2VsZWN0aW9uKCRhbmNob3IyLCAkaGVhZCk7XG4gICAgaWYgKHN0YXJ0aW5nIHx8ICF2aWV3LnN0YXRlLnNlbGVjdGlvbi5lcShzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICBpZiAoc3RhcnRpbmcpIHRyLnNldE1ldGEodGFibGVFZGl0aW5nS2V5LCAkYW5jaG9yMi5wb3MpO1xuICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgdmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHN0b3ApO1xuICAgIHZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZHJhZ3N0YXJ0XCIsIHN0b3ApO1xuICAgIHZpZXcucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuICAgIGlmICh0YWJsZUVkaXRpbmdLZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSkgIT0gbnVsbClcbiAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5zZXRNZXRhKHRhYmxlRWRpdGluZ0tleSwgLTEpKTtcbiAgfVxuICBmdW5jdGlvbiBtb3ZlKF9ldmVudCkge1xuICAgIGNvbnN0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGNvbnN0IGFuY2hvciA9IHRhYmxlRWRpdGluZ0tleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICBsZXQgJGFuY2hvcjI7XG4gICAgaWYgKGFuY2hvciAhPSBudWxsKSB7XG4gICAgICAkYW5jaG9yMiA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgICB9IGVsc2UgaWYgKGRvbUluQ2VsbCh2aWV3LCBldmVudC50YXJnZXQpICE9IHN0YXJ0RE9NQ2VsbCkge1xuICAgICAgJGFuY2hvcjIgPSBjZWxsVW5kZXJNb3VzZSh2aWV3LCBzdGFydEV2ZW50KTtcbiAgICAgIGlmICghJGFuY2hvcjIpIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIGlmICgkYW5jaG9yMikgc2V0Q2VsbFNlbGVjdGlvbigkYW5jaG9yMiwgZXZlbnQpO1xuICB9XG4gIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBzdG9wKTtcbiAgdmlldy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJkcmFnc3RhcnRcIiwgc3RvcCk7XG4gIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xufVxuZnVuY3Rpb24gYXRFbmRPZkNlbGwodmlldywgYXhpcywgZGlyKSB7XG4gIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbjMpKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgeyAkaGVhZCB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gIGZvciAobGV0IGQgPSAkaGVhZC5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgY29uc3QgcGFyZW50ID0gJGhlYWQubm9kZShkKSwgaW5kZXggPSBkaXIgPCAwID8gJGhlYWQuaW5kZXgoZCkgOiAkaGVhZC5pbmRleEFmdGVyKGQpO1xuICAgIGlmIChpbmRleCAhPSAoZGlyIDwgMCA/IDAgOiBwYXJlbnQuY2hpbGRDb3VudCkpIHJldHVybiBudWxsO1xuICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcImNlbGxcIiB8fCBwYXJlbnQudHlwZS5zcGVjLnRhYmxlUm9sZSA9PSBcImhlYWRlcl9jZWxsXCIpIHtcbiAgICAgIGNvbnN0IGNlbGxQb3MgPSAkaGVhZC5iZWZvcmUoZCk7XG4gICAgICBjb25zdCBkaXJTdHIgPSBheGlzID09IFwidmVydFwiID8gZGlyID4gMCA/IFwiZG93blwiIDogXCJ1cFwiIDogZGlyID4gMCA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICAgICAgcmV0dXJuIHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyU3RyKSA/IGNlbGxQb3MgOiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRvbUluQ2VsbCh2aWV3LCBkb20pIHtcbiAgZm9yICg7IGRvbSAmJiBkb20gIT0gdmlldy5kb207IGRvbSA9IGRvbS5wYXJlbnROb2RlKSB7XG4gICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIlREXCIgfHwgZG9tLm5vZGVOYW1lID09IFwiVEhcIikge1xuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjZWxsVW5kZXJNb3VzZSh2aWV3LCBldmVudCkge1xuICBjb25zdCBtb3VzZVBvcyA9IHZpZXcucG9zQXRDb29yZHMoe1xuICAgIGxlZnQ6IGV2ZW50LmNsaWVudFgsXG4gICAgdG9wOiBldmVudC5jbGllbnRZXG4gIH0pO1xuICBpZiAoIW1vdXNlUG9zKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIG1vdXNlUG9zID8gY2VsbEFyb3VuZCh2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKG1vdXNlUG9zLnBvcykpIDogbnVsbDtcbn1cblxuLy8gc3JjL2NvbHVtbnJlc2l6aW5nLnRzXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSBhcyBQbHVnaW5LZXkzIH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG5pbXBvcnQge1xuICBEZWNvcmF0aW9uIGFzIERlY29yYXRpb24yLFxuICBEZWNvcmF0aW9uU2V0IGFzIERlY29yYXRpb25TZXQyXG59IGZyb20gXCJwcm9zZW1pcnJvci12aWV3XCI7XG5cbi8vIHNyYy90YWJsZXZpZXcudHNcbnZhciBUYWJsZVZpZXcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG5vZGUsIGRlZmF1bHRDZWxsTWluV2lkdGgpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuZGVmYXVsdENlbGxNaW5XaWR0aCA9IGRlZmF1bHRDZWxsTWluV2lkdGg7XG4gICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwidGFibGVXcmFwcGVyXCI7XG4gICAgdGhpcy50YWJsZSA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKSk7XG4gICAgdGhpcy50YWJsZS5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgIFwiLS1kZWZhdWx0LWNlbGwtbWluLXdpZHRoXCIsXG4gICAgICBgJHtkZWZhdWx0Q2VsbE1pbldpZHRofXB4YFxuICAgICk7XG4gICAgdGhpcy5jb2xncm91cCA9IHRoaXMudGFibGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNvbGdyb3VwXCIpKTtcbiAgICB1cGRhdGVDb2x1bW5zT25SZXNpemUobm9kZSwgdGhpcy5jb2xncm91cCwgdGhpcy50YWJsZSwgZGVmYXVsdENlbGxNaW5XaWR0aCk7XG4gICAgdGhpcy5jb250ZW50RE9NID0gdGhpcy50YWJsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIikpO1xuICB9XG4gIHVwZGF0ZShub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPSB0aGlzLm5vZGUudHlwZSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdXBkYXRlQ29sdW1uc09uUmVzaXplKFxuICAgICAgbm9kZSxcbiAgICAgIHRoaXMuY29sZ3JvdXAsXG4gICAgICB0aGlzLnRhYmxlLFxuICAgICAgdGhpcy5kZWZhdWx0Q2VsbE1pbldpZHRoXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZ25vcmVNdXRhdGlvbihyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIgJiYgKHJlY29yZC50YXJnZXQgPT0gdGhpcy50YWJsZSB8fCB0aGlzLmNvbGdyb3VwLmNvbnRhaW5zKHJlY29yZC50YXJnZXQpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVwZGF0ZUNvbHVtbnNPblJlc2l6ZShub2RlLCBjb2xncm91cCwgdGFibGUsIGRlZmF1bHRDZWxsTWluV2lkdGgsIG92ZXJyaWRlQ29sLCBvdmVycmlkZVZhbHVlKSB7XG4gIHZhciBfYTtcbiAgbGV0IHRvdGFsV2lkdGggPSAwO1xuICBsZXQgZml4ZWRXaWR0aCA9IHRydWU7XG4gIGxldCBuZXh0RE9NID0gY29sZ3JvdXAuZmlyc3RDaGlsZDtcbiAgY29uc3Qgcm93ID0gbm9kZS5maXJzdENoaWxkO1xuICBpZiAoIXJvdykgcmV0dXJuO1xuICBmb3IgKGxldCBpID0gMCwgY29sID0gMDsgaSA8IHJvdy5jaGlsZENvdW50OyBpKyspIHtcbiAgICBjb25zdCB7IGNvbHNwYW4sIGNvbHdpZHRoIH0gPSByb3cuY2hpbGQoaSkuYXR0cnM7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzcGFuOyBqKyssIGNvbCsrKSB7XG4gICAgICBjb25zdCBoYXNXaWR0aCA9IG92ZXJyaWRlQ29sID09IGNvbCA/IG92ZXJyaWRlVmFsdWUgOiBjb2x3aWR0aCAmJiBjb2x3aWR0aFtqXTtcbiAgICAgIGNvbnN0IGNzc1dpZHRoID0gaGFzV2lkdGggPyBoYXNXaWR0aCArIFwicHhcIiA6IFwiXCI7XG4gICAgICB0b3RhbFdpZHRoICs9IGhhc1dpZHRoIHx8IGRlZmF1bHRDZWxsTWluV2lkdGg7XG4gICAgICBpZiAoIWhhc1dpZHRoKSBmaXhlZFdpZHRoID0gZmFsc2U7XG4gICAgICBpZiAoIW5leHRET00pIHtcbiAgICAgICAgY29uc3QgY29sMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjb2xcIik7XG4gICAgICAgIGNvbDIuc3R5bGUud2lkdGggPSBjc3NXaWR0aDtcbiAgICAgICAgY29sZ3JvdXAuYXBwZW5kQ2hpbGQoY29sMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmV4dERPTS5zdHlsZS53aWR0aCAhPSBjc3NXaWR0aCkge1xuICAgICAgICAgIG5leHRET00uc3R5bGUud2lkdGggPSBjc3NXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBuZXh0RE9NID0gbmV4dERPTS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgd2hpbGUgKG5leHRET00pIHtcbiAgICBjb25zdCBhZnRlciA9IG5leHRET00ubmV4dFNpYmxpbmc7XG4gICAgKF9hID0gbmV4dERPTS5wYXJlbnROb2RlKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVtb3ZlQ2hpbGQobmV4dERPTSk7XG4gICAgbmV4dERPTSA9IGFmdGVyO1xuICB9XG4gIGlmIChmaXhlZFdpZHRoKSB7XG4gICAgdGFibGUuc3R5bGUud2lkdGggPSB0b3RhbFdpZHRoICsgXCJweFwiO1xuICAgIHRhYmxlLnN0eWxlLm1pbldpZHRoID0gXCJcIjtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZS5zdHlsZS53aWR0aCA9IFwiXCI7XG4gICAgdGFibGUuc3R5bGUubWluV2lkdGggPSB0b3RhbFdpZHRoICsgXCJweFwiO1xuICB9XG59XG5cbi8vIHNyYy9jb2x1bW5yZXNpemluZy50c1xudmFyIGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5ID0gbmV3IFBsdWdpbktleTMoXG4gIFwidGFibGVDb2x1bW5SZXNpemluZ1wiXG4pO1xuZnVuY3Rpb24gY29sdW1uUmVzaXppbmcoe1xuICBoYW5kbGVXaWR0aCA9IDUsXG4gIGNlbGxNaW5XaWR0aCA9IDI1LFxuICBkZWZhdWx0Q2VsbE1pbldpZHRoID0gMTAwLFxuICBWaWV3ID0gVGFibGVWaWV3LFxuICBsYXN0Q29sdW1uUmVzaXphYmxlID0gdHJ1ZVxufSA9IHt9KSB7XG4gIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIGtleTogY29sdW1uUmVzaXppbmdQbHVnaW5LZXksXG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQoXywgc3RhdGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgbm9kZVZpZXdzID0gKF9iID0gKF9hID0gcGx1Z2luLnNwZWMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5vZGVWaWV3cztcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gdGFibGVOb2RlVHlwZXMoc3RhdGUuc2NoZW1hKS50YWJsZS5uYW1lO1xuICAgICAgICBpZiAoVmlldyAmJiBub2RlVmlld3MpIHtcbiAgICAgICAgICBub2RlVmlld3NbdGFibGVOYW1lXSA9IChub2RlLCB2aWV3KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZpZXcobm9kZSwgZGVmYXVsdENlbGxNaW5XaWR0aCwgdmlldyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc2l6ZVN0YXRlKC0xLCBmYWxzZSk7XG4gICAgICB9LFxuICAgICAgYXBwbHkodHIsIHByZXYpIHtcbiAgICAgICAgcmV0dXJuIHByZXYuYXBwbHkodHIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGF0dHJpYnV0ZXM6IChzdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBwbHVnaW5TdGF0ZSA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHBsdWdpblN0YXRlICYmIHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSA+IC0xID8geyBjbGFzczogXCJyZXNpemUtY3Vyc29yXCIgfSA6IHt9O1xuICAgICAgfSxcbiAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICBtb3VzZW1vdmU6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBldmVudCwgaGFuZGxlV2lkdGgsIGxhc3RDb2x1bW5SZXNpemFibGUpO1xuICAgICAgICB9LFxuICAgICAgICBtb3VzZWxlYXZlOiAodmlldykgPT4ge1xuICAgICAgICAgIGhhbmRsZU1vdXNlTGVhdmUodmlldyk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlZG93bjogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgaGFuZGxlTW91c2VEb3duMih2aWV3LCBldmVudCwgY2VsbE1pbldpZHRoLCBkZWZhdWx0Q2VsbE1pbldpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlY29yYXRpb25zOiAoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgcGx1Z2luU3RhdGUgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIGlmIChwbHVnaW5TdGF0ZSAmJiBwbHVnaW5TdGF0ZS5hY3RpdmVIYW5kbGUgPiAtMSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVEZWNvcmF0aW9ucyhzdGF0ZSwgcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vZGVWaWV3czoge31cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcGx1Z2luO1xufVxudmFyIFJlc2l6ZVN0YXRlID0gY2xhc3MgX1Jlc2l6ZVN0YXRlIHtcbiAgY29uc3RydWN0b3IoYWN0aXZlSGFuZGxlLCBkcmFnZ2luZykge1xuICAgIHRoaXMuYWN0aXZlSGFuZGxlID0gYWN0aXZlSGFuZGxlO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBkcmFnZ2luZztcbiAgfVxuICBhcHBseSh0cikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcztcbiAgICBjb25zdCBhY3Rpb24gPSB0ci5nZXRNZXRhKGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5KTtcbiAgICBpZiAoYWN0aW9uICYmIGFjdGlvbi5zZXRIYW5kbGUgIT0gbnVsbClcbiAgICAgIHJldHVybiBuZXcgX1Jlc2l6ZVN0YXRlKGFjdGlvbi5zZXRIYW5kbGUsIGZhbHNlKTtcbiAgICBpZiAoYWN0aW9uICYmIGFjdGlvbi5zZXREcmFnZ2luZyAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG5ldyBfUmVzaXplU3RhdGUoc3RhdGUuYWN0aXZlSGFuZGxlLCBhY3Rpb24uc2V0RHJhZ2dpbmcpO1xuICAgIGlmIChzdGF0ZS5hY3RpdmVIYW5kbGUgPiAtMSAmJiB0ci5kb2NDaGFuZ2VkKSB7XG4gICAgICBsZXQgaGFuZGxlID0gdHIubWFwcGluZy5tYXAoc3RhdGUuYWN0aXZlSGFuZGxlLCAtMSk7XG4gICAgICBpZiAoIXBvaW50c0F0Q2VsbCh0ci5kb2MucmVzb2x2ZShoYW5kbGUpKSkge1xuICAgICAgICBoYW5kbGUgPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgX1Jlc2l6ZVN0YXRlKGhhbmRsZSwgc3RhdGUuZHJhZ2dpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn07XG5mdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUodmlldywgZXZlbnQsIGhhbmRsZVdpZHRoLCBsYXN0Q29sdW1uUmVzaXphYmxlKSB7XG4gIGlmICghdmlldy5lZGl0YWJsZSkgcmV0dXJuO1xuICBjb25zdCBwbHVnaW5TdGF0ZSA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuICBpZiAoIXBsdWdpblN0YXRlKSByZXR1cm47XG4gIGlmICghcGx1Z2luU3RhdGUuZHJhZ2dpbmcpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBkb21DZWxsQXJvdW5kKGV2ZW50LnRhcmdldCk7XG4gICAgbGV0IGNlbGwgPSAtMTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoZXZlbnQuY2xpZW50WCAtIGxlZnQgPD0gaGFuZGxlV2lkdGgpXG4gICAgICAgIGNlbGwgPSBlZGdlQ2VsbCh2aWV3LCBldmVudCwgXCJsZWZ0XCIsIGhhbmRsZVdpZHRoKTtcbiAgICAgIGVsc2UgaWYgKHJpZ2h0IC0gZXZlbnQuY2xpZW50WCA8PSBoYW5kbGVXaWR0aClcbiAgICAgICAgY2VsbCA9IGVkZ2VDZWxsKHZpZXcsIGV2ZW50LCBcInJpZ2h0XCIsIGhhbmRsZVdpZHRoKTtcbiAgICB9XG4gICAgaWYgKGNlbGwgIT0gcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlKSB7XG4gICAgICBpZiAoIWxhc3RDb2x1bW5SZXNpemFibGUgJiYgY2VsbCAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgJGNlbGwgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGNlbGwpO1xuICAgICAgICBjb25zdCB0YWJsZSA9ICRjZWxsLm5vZGUoLTEpO1xuICAgICAgICBjb25zdCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpO1xuICAgICAgICBjb25zdCB0YWJsZVN0YXJ0ID0gJGNlbGwuc3RhcnQoLTEpO1xuICAgICAgICBjb25zdCBjb2wgPSBtYXAuY29sQ291bnQoJGNlbGwucG9zIC0gdGFibGVTdGFydCkgKyAkY2VsbC5ub2RlQWZ0ZXIuYXR0cnMuY29sc3BhbiAtIDE7XG4gICAgICAgIGlmIChjb2wgPT0gbWFwLndpZHRoIC0gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlSGFuZGxlKHZpZXcsIGNlbGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlTW91c2VMZWF2ZSh2aWV3KSB7XG4gIGlmICghdmlldy5lZGl0YWJsZSkgcmV0dXJuO1xuICBjb25zdCBwbHVnaW5TdGF0ZSA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuICBpZiAocGx1Z2luU3RhdGUgJiYgcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlID4gLTEgJiYgIXBsdWdpblN0YXRlLmRyYWdnaW5nKVxuICAgIHVwZGF0ZUhhbmRsZSh2aWV3LCAtMSk7XG59XG5mdW5jdGlvbiBoYW5kbGVNb3VzZURvd24yKHZpZXcsIGV2ZW50LCBjZWxsTWluV2lkdGgsIGRlZmF1bHRDZWxsTWluV2lkdGgpIHtcbiAgdmFyIF9hO1xuICBpZiAoIXZpZXcuZWRpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgd2luID0gKF9hID0gdmlldy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgIT0gbnVsbCA/IF9hIDogd2luZG93O1xuICBjb25zdCBwbHVnaW5TdGF0ZSA9IGNvbHVtblJlc2l6aW5nUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpO1xuICBpZiAoIXBsdWdpblN0YXRlIHx8IHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSA9PSAtMSB8fCBwbHVnaW5TdGF0ZS5kcmFnZ2luZylcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGNlbGwgPSB2aWV3LnN0YXRlLmRvYy5ub2RlQXQocGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlKTtcbiAgY29uc3Qgd2lkdGggPSBjdXJyZW50Q29sV2lkdGgodmlldywgcGx1Z2luU3RhdGUuYWN0aXZlSGFuZGxlLCBjZWxsLmF0dHJzKTtcbiAgdmlldy5kaXNwYXRjaChcbiAgICB2aWV3LnN0YXRlLnRyLnNldE1ldGEoY29sdW1uUmVzaXppbmdQbHVnaW5LZXksIHtcbiAgICAgIHNldERyYWdnaW5nOiB7IHN0YXJ0WDogZXZlbnQuY2xpZW50WCwgc3RhcnRXaWR0aDogd2lkdGggfVxuICAgIH0pXG4gICk7XG4gIGZ1bmN0aW9uIGZpbmlzaChldmVudDIpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgZmluaXNoKTtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgICBjb25zdCBwbHVnaW5TdGF0ZTIgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICBpZiAocGx1Z2luU3RhdGUyID09IG51bGwgPyB2b2lkIDAgOiBwbHVnaW5TdGF0ZTIuZHJhZ2dpbmcpIHtcbiAgICAgIHVwZGF0ZUNvbHVtbldpZHRoKFxuICAgICAgICB2aWV3LFxuICAgICAgICBwbHVnaW5TdGF0ZTIuYWN0aXZlSGFuZGxlLFxuICAgICAgICBkcmFnZ2VkV2lkdGgocGx1Z2luU3RhdGUyLmRyYWdnaW5nLCBldmVudDIsIGNlbGxNaW5XaWR0aClcbiAgICAgICk7XG4gICAgICB2aWV3LmRpc3BhdGNoKFxuICAgICAgICB2aWV3LnN0YXRlLnRyLnNldE1ldGEoY29sdW1uUmVzaXppbmdQbHVnaW5LZXksIHsgc2V0RHJhZ2dpbmc6IG51bGwgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1vdmUoZXZlbnQyKSB7XG4gICAgaWYgKCFldmVudDIud2hpY2gpIHJldHVybiBmaW5pc2goZXZlbnQyKTtcbiAgICBjb25zdCBwbHVnaW5TdGF0ZTIgPSBjb2x1bW5SZXNpemluZ1BsdWdpbktleS5nZXRTdGF0ZSh2aWV3LnN0YXRlKTtcbiAgICBpZiAoIXBsdWdpblN0YXRlMikgcmV0dXJuO1xuICAgIGlmIChwbHVnaW5TdGF0ZTIuZHJhZ2dpbmcpIHtcbiAgICAgIGNvbnN0IGRyYWdnZWQgPSBkcmFnZ2VkV2lkdGgocGx1Z2luU3RhdGUyLmRyYWdnaW5nLCBldmVudDIsIGNlbGxNaW5XaWR0aCk7XG4gICAgICBkaXNwbGF5Q29sdW1uV2lkdGgoXG4gICAgICAgIHZpZXcsXG4gICAgICAgIHBsdWdpblN0YXRlMi5hY3RpdmVIYW5kbGUsXG4gICAgICAgIGRyYWdnZWQsXG4gICAgICAgIGRlZmF1bHRDZWxsTWluV2lkdGhcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGRpc3BsYXlDb2x1bW5XaWR0aChcbiAgICB2aWV3LFxuICAgIHBsdWdpblN0YXRlLmFjdGl2ZUhhbmRsZSxcbiAgICB3aWR0aCxcbiAgICBkZWZhdWx0Q2VsbE1pbldpZHRoXG4gICk7XG4gIHdpbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmaW5pc2gpO1xuICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjdXJyZW50Q29sV2lkdGgodmlldywgY2VsbFBvcywgeyBjb2xzcGFuLCBjb2x3aWR0aCB9KSB7XG4gIGNvbnN0IHdpZHRoID0gY29sd2lkdGggJiYgY29sd2lkdGhbY29sd2lkdGgubGVuZ3RoIC0gMV07XG4gIGlmICh3aWR0aCkgcmV0dXJuIHdpZHRoO1xuICBjb25zdCBkb20gPSB2aWV3LmRvbUF0UG9zKGNlbGxQb3MpO1xuICBjb25zdCBub2RlID0gZG9tLm5vZGUuY2hpbGROb2Rlc1tkb20ub2Zmc2V0XTtcbiAgbGV0IGRvbVdpZHRoID0gbm9kZS5vZmZzZXRXaWR0aCwgcGFydHMgPSBjb2xzcGFuO1xuICBpZiAoY29sd2lkdGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHNwYW47IGkrKylcbiAgICAgIGlmIChjb2x3aWR0aFtpXSkge1xuICAgICAgICBkb21XaWR0aCAtPSBjb2x3aWR0aFtpXTtcbiAgICAgICAgcGFydHMtLTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZG9tV2lkdGggLyBwYXJ0cztcbn1cbmZ1bmN0aW9uIGRvbUNlbGxBcm91bmQodGFyZ2V0KSB7XG4gIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0Lm5vZGVOYW1lICE9IFwiVERcIiAmJiB0YXJnZXQubm9kZU5hbWUgIT0gXCJUSFwiKVxuICAgIHRhcmdldCA9IHRhcmdldC5jbGFzc0xpc3QgJiYgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcIlByb3NlTWlycm9yXCIpID8gbnVsbCA6IHRhcmdldC5wYXJlbnROb2RlO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gZWRnZUNlbGwodmlldywgZXZlbnQsIHNpZGUsIGhhbmRsZVdpZHRoKSB7XG4gIGNvbnN0IG9mZnNldCA9IHNpZGUgPT0gXCJyaWdodFwiID8gLWhhbmRsZVdpZHRoIDogaGFuZGxlV2lkdGg7XG4gIGNvbnN0IGZvdW5kID0gdmlldy5wb3NBdENvb3Jkcyh7XG4gICAgbGVmdDogZXZlbnQuY2xpZW50WCArIG9mZnNldCxcbiAgICB0b3A6IGV2ZW50LmNsaWVudFlcbiAgfSk7XG4gIGlmICghZm91bmQpIHJldHVybiAtMTtcbiAgY29uc3QgeyBwb3MgfSA9IGZvdW5kO1xuICBjb25zdCAkY2VsbCA9IGNlbGxBcm91bmQodmlldy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpKTtcbiAgaWYgKCEkY2VsbCkgcmV0dXJuIC0xO1xuICBpZiAoc2lkZSA9PSBcInJpZ2h0XCIpIHJldHVybiAkY2VsbC5wb3M7XG4gIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCgkY2VsbC5ub2RlKC0xKSksIHN0YXJ0ID0gJGNlbGwuc3RhcnQoLTEpO1xuICBjb25zdCBpbmRleCA9IG1hcC5tYXAuaW5kZXhPZigkY2VsbC5wb3MgLSBzdGFydCk7XG4gIHJldHVybiBpbmRleCAlIG1hcC53aWR0aCA9PSAwID8gLTEgOiBzdGFydCArIG1hcC5tYXBbaW5kZXggLSAxXTtcbn1cbmZ1bmN0aW9uIGRyYWdnZWRXaWR0aChkcmFnZ2luZywgZXZlbnQsIHJlc2l6ZU1pbldpZHRoKSB7XG4gIGNvbnN0IG9mZnNldCA9IGV2ZW50LmNsaWVudFggLSBkcmFnZ2luZy5zdGFydFg7XG4gIHJldHVybiBNYXRoLm1heChyZXNpemVNaW5XaWR0aCwgZHJhZ2dpbmcuc3RhcnRXaWR0aCArIG9mZnNldCk7XG59XG5mdW5jdGlvbiB1cGRhdGVIYW5kbGUodmlldywgdmFsdWUpIHtcbiAgdmlldy5kaXNwYXRjaChcbiAgICB2aWV3LnN0YXRlLnRyLnNldE1ldGEoY29sdW1uUmVzaXppbmdQbHVnaW5LZXksIHsgc2V0SGFuZGxlOiB2YWx1ZSB9KVxuICApO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29sdW1uV2lkdGgodmlldywgY2VsbCwgd2lkdGgpIHtcbiAgY29uc3QgJGNlbGwgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKGNlbGwpO1xuICBjb25zdCB0YWJsZSA9ICRjZWxsLm5vZGUoLTEpLCBtYXAgPSBUYWJsZU1hcC5nZXQodGFibGUpLCBzdGFydCA9ICRjZWxsLnN0YXJ0KC0xKTtcbiAgY29uc3QgY29sID0gbWFwLmNvbENvdW50KCRjZWxsLnBvcyAtIHN0YXJ0KSArICRjZWxsLm5vZGVBZnRlci5hdHRycy5jb2xzcGFuIC0gMTtcbiAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyByb3crKykge1xuICAgIGNvbnN0IG1hcEluZGV4ID0gcm93ICogbWFwLndpZHRoICsgY29sO1xuICAgIGlmIChyb3cgJiYgbWFwLm1hcFttYXBJbmRleF0gPT0gbWFwLm1hcFttYXBJbmRleCAtIG1hcC53aWR0aF0pIGNvbnRpbnVlO1xuICAgIGNvbnN0IHBvcyA9IG1hcC5tYXBbbWFwSW5kZXhdO1xuICAgIGNvbnN0IGF0dHJzID0gdGFibGUubm9kZUF0KHBvcykuYXR0cnM7XG4gICAgY29uc3QgaW5kZXggPSBhdHRycy5jb2xzcGFuID09IDEgPyAwIDogY29sIC0gbWFwLmNvbENvdW50KHBvcyk7XG4gICAgaWYgKGF0dHJzLmNvbHdpZHRoICYmIGF0dHJzLmNvbHdpZHRoW2luZGV4XSA9PSB3aWR0aCkgY29udGludWU7XG4gICAgY29uc3QgY29sd2lkdGggPSBhdHRycy5jb2x3aWR0aCA/IGF0dHJzLmNvbHdpZHRoLnNsaWNlKCkgOiB6ZXJvZXMoYXR0cnMuY29sc3Bhbik7XG4gICAgY29sd2lkdGhbaW5kZXhdID0gd2lkdGg7XG4gICAgdHIuc2V0Tm9kZU1hcmt1cChzdGFydCArIHBvcywgbnVsbCwgeyAuLi5hdHRycywgY29sd2lkdGggfSk7XG4gIH1cbiAgaWYgKHRyLmRvY0NoYW5nZWQpIHZpZXcuZGlzcGF0Y2godHIpO1xufVxuZnVuY3Rpb24gZGlzcGxheUNvbHVtbldpZHRoKHZpZXcsIGNlbGwsIHdpZHRoLCBkZWZhdWx0Q2VsbE1pbldpZHRoKSB7XG4gIGNvbnN0ICRjZWxsID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShjZWxsKTtcbiAgY29uc3QgdGFibGUgPSAkY2VsbC5ub2RlKC0xKSwgc3RhcnQgPSAkY2VsbC5zdGFydCgtMSk7XG4gIGNvbnN0IGNvbCA9IFRhYmxlTWFwLmdldCh0YWJsZSkuY29sQ291bnQoJGNlbGwucG9zIC0gc3RhcnQpICsgJGNlbGwubm9kZUFmdGVyLmF0dHJzLmNvbHNwYW4gLSAxO1xuICBsZXQgZG9tID0gdmlldy5kb21BdFBvcygkY2VsbC5zdGFydCgtMSkpLm5vZGU7XG4gIHdoaWxlIChkb20gJiYgZG9tLm5vZGVOYW1lICE9IFwiVEFCTEVcIikge1xuICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICB9XG4gIGlmICghZG9tKSByZXR1cm47XG4gIHVwZGF0ZUNvbHVtbnNPblJlc2l6ZShcbiAgICB0YWJsZSxcbiAgICBkb20uZmlyc3RDaGlsZCxcbiAgICBkb20sXG4gICAgZGVmYXVsdENlbGxNaW5XaWR0aCxcbiAgICBjb2wsXG4gICAgd2lkdGhcbiAgKTtcbn1cbmZ1bmN0aW9uIHplcm9lcyhuKSB7XG4gIHJldHVybiBBcnJheShuKS5maWxsKDApO1xufVxuZnVuY3Rpb24gaGFuZGxlRGVjb3JhdGlvbnMoc3RhdGUsIGNlbGwpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBkZWNvcmF0aW9ucyA9IFtdO1xuICBjb25zdCAkY2VsbCA9IHN0YXRlLmRvYy5yZXNvbHZlKGNlbGwpO1xuICBjb25zdCB0YWJsZSA9ICRjZWxsLm5vZGUoLTEpO1xuICBpZiAoIXRhYmxlKSB7XG4gICAgcmV0dXJuIERlY29yYXRpb25TZXQyLmVtcHR5O1xuICB9XG4gIGNvbnN0IG1hcCA9IFRhYmxlTWFwLmdldCh0YWJsZSk7XG4gIGNvbnN0IHN0YXJ0ID0gJGNlbGwuc3RhcnQoLTEpO1xuICBjb25zdCBjb2wgPSBtYXAuY29sQ291bnQoJGNlbGwucG9zIC0gc3RhcnQpICsgJGNlbGwubm9kZUFmdGVyLmF0dHJzLmNvbHNwYW4gLSAxO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAuaGVpZ2h0OyByb3crKykge1xuICAgIGNvbnN0IGluZGV4ID0gY29sICsgcm93ICogbWFwLndpZHRoO1xuICAgIGlmICgoY29sID09IG1hcC53aWR0aCAtIDEgfHwgbWFwLm1hcFtpbmRleF0gIT0gbWFwLm1hcFtpbmRleCArIDFdKSAmJiAocm93ID09IDAgfHwgbWFwLm1hcFtpbmRleF0gIT0gbWFwLm1hcFtpbmRleCAtIG1hcC53aWR0aF0pKSB7XG4gICAgICBjb25zdCBjZWxsUG9zID0gbWFwLm1hcFtpbmRleF07XG4gICAgICBjb25zdCBwb3MgPSBzdGFydCArIGNlbGxQb3MgKyB0YWJsZS5ub2RlQXQoY2VsbFBvcykubm9kZVNpemUgLSAxO1xuICAgICAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRvbS5jbGFzc05hbWUgPSBcImNvbHVtbi1yZXNpemUtaGFuZGxlXCI7XG4gICAgICBpZiAoKF9hID0gY29sdW1uUmVzaXppbmdQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZHJhZ2dpbmcpIHtcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaChcbiAgICAgICAgICBEZWNvcmF0aW9uMi5ub2RlKFxuICAgICAgICAgICAgc3RhcnQgKyBjZWxsUG9zLFxuICAgICAgICAgICAgc3RhcnQgKyBjZWxsUG9zICsgdGFibGUubm9kZUF0KGNlbGxQb3MpLm5vZGVTaXplLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzczogXCJjb2x1bW4tcmVzaXplLWRyYWdnaW5nXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWNvcmF0aW9ucy5wdXNoKERlY29yYXRpb24yLndpZGdldChwb3MsIGRvbSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gRGVjb3JhdGlvblNldDIuY3JlYXRlKHN0YXRlLmRvYywgZGVjb3JhdGlvbnMpO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbmZ1bmN0aW9uIHRhYmxlRWRpdGluZyh7XG4gIGFsbG93VGFibGVOb2RlU2VsZWN0aW9uID0gZmFsc2Vcbn0gPSB7fSkge1xuICByZXR1cm4gbmV3IFBsdWdpbjIoe1xuICAgIGtleTogdGFibGVFZGl0aW5nS2V5LFxuICAgIC8vIFRoaXMgcGllY2Ugb2Ygc3RhdGUgaXMgdXNlZCB0byByZW1lbWJlciB3aGVuIGEgbW91c2UtZHJhZ1xuICAgIC8vIGNlbGwtc2VsZWN0aW9uIGlzIGhhcHBlbmluZywgc28gdGhhdCBpdCBjYW4gY29udGludWUgZXZlbiBhc1xuICAgIC8vIHRyYW5zYWN0aW9ucyAod2hpY2ggbWlnaHQgbW92ZSBpdHMgYW5jaG9yIGNlbGwpIGNvbWUgaW4uXG4gICAgc3RhdGU6IHtcbiAgICAgIGluaXQoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIGFwcGx5KHRyLCBjdXIpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gdHIuZ2V0TWV0YSh0YWJsZUVkaXRpbmdLZXkpO1xuICAgICAgICBpZiAoc2V0ICE9IG51bGwpIHJldHVybiBzZXQgPT0gLTEgPyBudWxsIDogc2V0O1xuICAgICAgICBpZiAoY3VyID09IG51bGwgfHwgIXRyLmRvY0NoYW5nZWQpIHJldHVybiBjdXI7XG4gICAgICAgIGNvbnN0IHsgZGVsZXRlZCwgcG9zIH0gPSB0ci5tYXBwaW5nLm1hcFJlc3VsdChjdXIpO1xuICAgICAgICByZXR1cm4gZGVsZXRlZCA/IG51bGwgOiBwb3M7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wczoge1xuICAgICAgZGVjb3JhdGlvbnM6IGRyYXdDZWxsU2VsZWN0aW9uLFxuICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgIG1vdXNlZG93bjogaGFuZGxlTW91c2VEb3duXG4gICAgICB9LFxuICAgICAgY3JlYXRlU2VsZWN0aW9uQmV0d2Vlbih2aWV3KSB7XG4gICAgICAgIHJldHVybiB0YWJsZUVkaXRpbmdLZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSkgIT0gbnVsbCA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uIDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUcmlwbGVDbGljayxcbiAgICAgIGhhbmRsZUtleURvd24sXG4gICAgICBoYW5kbGVQYXN0ZVxuICAgIH0sXG4gICAgYXBwZW5kVHJhbnNhY3Rpb24oXywgb2xkU3RhdGUsIHN0YXRlKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU2VsZWN0aW9uKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZml4VGFibGVzKHN0YXRlLCBvbGRTdGF0ZSksXG4gICAgICAgIGFsbG93VGFibGVOb2RlU2VsZWN0aW9uXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59XG5leHBvcnQge1xuICBDZWxsQm9va21hcmssXG4gIENlbGxTZWxlY3Rpb24sXG4gIFJlc2l6ZVN0YXRlLFxuICBUYWJsZU1hcCxcbiAgVGFibGVWaWV3LFxuICBjbGlwQ2VsbHMgYXMgX19jbGlwQ2VsbHMsXG4gIGluc2VydENlbGxzIGFzIF9faW5zZXJ0Q2VsbHMsXG4gIHBhc3RlZENlbGxzIGFzIF9fcGFzdGVkQ2VsbHMsXG4gIGFkZENvbFNwYW4sXG4gIGFkZENvbHVtbixcbiAgYWRkQ29sdW1uQWZ0ZXIsXG4gIGFkZENvbHVtbkJlZm9yZSxcbiAgYWRkUm93LFxuICBhZGRSb3dBZnRlcixcbiAgYWRkUm93QmVmb3JlLFxuICBjZWxsQXJvdW5kLFxuICBjZWxsTmVhcixcbiAgY29sQ291bnQsXG4gIGNvbHVtbklzSGVhZGVyLFxuICBjb2x1bW5SZXNpemluZyxcbiAgY29sdW1uUmVzaXppbmdQbHVnaW5LZXksXG4gIGRlbGV0ZUNlbGxTZWxlY3Rpb24sXG4gIGRlbGV0ZUNvbHVtbixcbiAgZGVsZXRlUm93LFxuICBkZWxldGVUYWJsZSxcbiAgZmluZENlbGwsXG4gIGZpeFRhYmxlcyxcbiAgZml4VGFibGVzS2V5LFxuICBnb1RvTmV4dENlbGwsXG4gIGhhbmRsZVBhc3RlLFxuICBpblNhbWVUYWJsZSxcbiAgaXNJblRhYmxlLFxuICBtZXJnZUNlbGxzLFxuICBtb3ZlQ2VsbEZvcndhcmQsXG4gIG5leHRDZWxsLFxuICBwb2ludHNBdENlbGwsXG4gIHJlbW92ZUNvbFNwYW4sXG4gIHJlbW92ZUNvbHVtbixcbiAgcmVtb3ZlUm93LFxuICByb3dJc0hlYWRlcixcbiAgc2VsZWN0ZWRSZWN0LFxuICBzZWxlY3Rpb25DZWxsLFxuICBzZXRDZWxsQXR0cixcbiAgc3BsaXRDZWxsLFxuICBzcGxpdENlbGxXaXRoVHlwZSxcbiAgdGFibGVFZGl0aW5nLFxuICB0YWJsZUVkaXRpbmdLZXksXG4gIHRhYmxlTm9kZVR5cGVzLFxuICB0YWJsZU5vZGVzLFxuICB0b2dnbGVIZWFkZXIsXG4gIHRvZ2dsZUhlYWRlckNlbGwsXG4gIHRvZ2dsZUhlYWRlckNvbHVtbixcbiAgdG9nZ2xlSGVhZGVyUm93LFxuICB1cGRhdGVDb2x1bW5zT25SZXNpemVcbn07XG4iLCAiaW1wb3J0ICcuLi90eXBlcy5qcydcblxuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlQ2VsbE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIEhUTUwgYXR0cmlidXRlcyBmb3IgYSB0YWJsZSBjZWxsIG5vZGUuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqIEBleGFtcGxlIHsgY2xhc3M6ICdmb28nIH1cbiAgICovXG4gIEhUTUxBdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgdGFibGUgY2VsbHMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3RhYmxlLWNlbGxcbiAqL1xuZXhwb3J0IGNvbnN0IFRhYmxlQ2VsbCA9IE5vZGUuY3JlYXRlPFRhYmxlQ2VsbE9wdGlvbnM+KHtcbiAgbmFtZTogJ3RhYmxlQ2VsbCcsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAnYmxvY2srJyxcblxuICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb2xzcGFuOiB7XG4gICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICB9LFxuICAgICAgcm93c3Bhbjoge1xuICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgfSxcbiAgICAgIGNvbHdpZHRoOiB7XG4gICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiB7XG4gICAgICAgICAgY29uc3QgY29sd2lkdGggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY29sd2lkdGgnKVxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29sd2lkdGggPyBjb2x3aWR0aC5zcGxpdCgnLCcpLm1hcCh3aWR0aCA9PiBwYXJzZUludCh3aWR0aCwgMTApKSA6IG51bGxcblxuICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgdGFibGVSb2xlOiAnY2VsbCcsXG5cbiAgaXNvbGF0aW5nOiB0cnVlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiAndGQnIH1dXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWyd0ZCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0ICcuLi90eXBlcy5qcydcblxuaW1wb3J0IHsgbWVyZ2VBdHRyaWJ1dGVzLCBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlSGVhZGVyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgSFRNTCBhdHRyaWJ1dGVzIGZvciBhIHRhYmxlIGhlYWRlciBub2RlLlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKiBAZXhhbXBsZSB7IGNsYXNzOiAnZm9vJyB9XG4gICAqL1xuICBIVE1MQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHRhYmxlIGhlYWRlcnMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3RhYmxlLWhlYWRlclxuICovXG5leHBvcnQgY29uc3QgVGFibGVIZWFkZXIgPSBOb2RlLmNyZWF0ZTxUYWJsZUhlYWRlck9wdGlvbnM+KHtcbiAgbmFtZTogJ3RhYmxlSGVhZGVyJyxcblxuICBhZGRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgfVxuICB9LFxuXG4gIGNvbnRlbnQ6ICdibG9jaysnLFxuXG4gIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHNwYW46IHtcbiAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgIH0sXG4gICAgICByb3dzcGFuOiB7XG4gICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICB9LFxuICAgICAgY29sd2lkdGg6IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBjb2x3aWR0aCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjb2x3aWR0aCcpXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBjb2x3aWR0aCA/IGNvbHdpZHRoLnNwbGl0KCcsJykubWFwKHdpZHRoID0+IHBhcnNlSW50KHdpZHRoLCAxMCkpIDogbnVsbFxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgfSxcblxuICB0YWJsZVJvbGU6ICdoZWFkZXJfY2VsbCcsXG5cbiAgaXNvbGF0aW5nOiB0cnVlLFxuXG4gIHBhcnNlSFRNTCgpIHtcbiAgICByZXR1cm4gW3sgdGFnOiAndGgnIH1dXG4gIH0sXG5cbiAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICByZXR1cm4gWyd0aCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5pbXBvcnQgdHlwZSB7IFRhYmxlQ2VsbE9wdGlvbnMgfSBmcm9tICcuLi9jZWxsL2luZGV4LmpzJ1xuaW1wb3J0IHsgVGFibGVDZWxsIH0gZnJvbSAnLi4vY2VsbC9pbmRleC5qcydcbmltcG9ydCB0eXBlIHsgVGFibGVIZWFkZXJPcHRpb25zIH0gZnJvbSAnLi4vaGVhZGVyL2luZGV4LmpzJ1xuaW1wb3J0IHsgVGFibGVIZWFkZXIgfSBmcm9tICcuLi9oZWFkZXIvaW5kZXguanMnXG5pbXBvcnQgdHlwZSB7IFRhYmxlUm93T3B0aW9ucyB9IGZyb20gJy4uL3Jvdy9pbmRleC5qcydcbmltcG9ydCB7IFRhYmxlUm93IH0gZnJvbSAnLi4vcm93L2luZGV4LmpzJ1xuaW1wb3J0IHR5cGUgeyBUYWJsZU9wdGlvbnMgfSBmcm9tICcuLi90YWJsZS9pbmRleC5qcydcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSAnLi4vdGFibGUvaW5kZXguanMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVLaXRPcHRpb25zIHtcbiAgLyoqXG4gICAqIElmIHNldCB0byBmYWxzZSwgdGhlIHRhYmxlIGV4dGVuc2lvbiB3aWxsIG5vdCBiZSByZWdpc3RlcmVkXG4gICAqIEBleGFtcGxlIHRhYmxlOiBmYWxzZVxuICAgKi9cbiAgdGFibGU6IFBhcnRpYWw8VGFibGVPcHRpb25zPiB8IGZhbHNlXG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gZmFsc2UsIHRoZSB0YWJsZSBleHRlbnNpb24gd2lsbCBub3QgYmUgcmVnaXN0ZXJlZFxuICAgKiBAZXhhbXBsZSB0YWJsZUNlbGw6IGZhbHNlXG4gICAqL1xuICB0YWJsZUNlbGw6IFBhcnRpYWw8VGFibGVDZWxsT3B0aW9ucz4gfCBmYWxzZVxuICAvKipcbiAgICogSWYgc2V0IHRvIGZhbHNlLCB0aGUgdGFibGUgZXh0ZW5zaW9uIHdpbGwgbm90IGJlIHJlZ2lzdGVyZWRcbiAgICogQGV4YW1wbGUgdGFibGVIZWFkZXI6IGZhbHNlXG4gICAqL1xuICB0YWJsZUhlYWRlcjogUGFydGlhbDxUYWJsZUhlYWRlck9wdGlvbnM+IHwgZmFsc2VcbiAgLyoqXG4gICAqIElmIHNldCB0byBmYWxzZSwgdGhlIHRhYmxlIGV4dGVuc2lvbiB3aWxsIG5vdCBiZSByZWdpc3RlcmVkXG4gICAqIEBleGFtcGxlIHRhYmxlUm93OiBmYWxzZVxuICAgKi9cbiAgdGFibGVSb3c6IFBhcnRpYWw8VGFibGVSb3dPcHRpb25zPiB8IGZhbHNlXG59XG5cbi8qKlxuICogVGhlIHRhYmxlIGtpdCBpcyBhIGNvbGxlY3Rpb24gb2YgdGFibGUgZWRpdG9yIGV4dGVuc2lvbnMuXG4gKlxuICogSXTigJlzIGEgZ29vZCBzdGFydGluZyBwb2ludCBmb3IgYnVpbGRpbmcgeW91ciBvd24gdGFibGUgaW4gVGlwdGFwLlxuICovXG5leHBvcnQgY29uc3QgVGFibGVLaXQgPSBFeHRlbnNpb24uY3JlYXRlPFRhYmxlS2l0T3B0aW9ucz4oe1xuICBuYW1lOiAndGFibGVLaXQnLFxuXG4gIGFkZEV4dGVuc2lvbnMoKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IFtdXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRhYmxlICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFRhYmxlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMudGFibGUpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudGFibGVDZWxsICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFRhYmxlQ2VsbC5jb25maWd1cmUodGhpcy5vcHRpb25zLnRhYmxlQ2VsbCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50YWJsZUhlYWRlciAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaChUYWJsZUhlYWRlci5jb25maWd1cmUodGhpcy5vcHRpb25zLnRhYmxlSGVhZGVyKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRhYmxlUm93ICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5zaW9ucy5wdXNoKFRhYmxlUm93LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMudGFibGVSb3cpKVxuICAgIH1cblxuICAgIHJldHVybiBleHRlbnNpb25zXG4gIH0sXG59KVxuIiwgImltcG9ydCAnLi4vdHlwZXMuanMnXG5cbmltcG9ydCB7IG1lcmdlQXR0cmlidXRlcywgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVJvd09wdGlvbnMge1xuICAvKipcbiAgICogVGhlIEhUTUwgYXR0cmlidXRlcyBmb3IgYSB0YWJsZSByb3cgbm9kZS5cbiAgICogQGRlZmF1bHQge31cbiAgICogQGV4YW1wbGUgeyBjbGFzczogJ2ZvbycgfVxuICAgKi9cbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0YWJsZSByb3dzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy90YWJsZS1yb3dcbiAqL1xuZXhwb3J0IGNvbnN0IFRhYmxlUm93ID0gTm9kZS5jcmVhdGU8VGFibGVSb3dPcHRpb25zPih7XG4gIG5hbWU6ICd0YWJsZVJvdycsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBjb250ZW50OiAnKHRhYmxlQ2VsbCB8IHRhYmxlSGVhZGVyKSonLFxuXG4gIHRhYmxlUm9sZTogJ3JvdycsXG5cbiAgcGFyc2VIVE1MKCkge1xuICAgIHJldHVybiBbeyB0YWc6ICd0cicgfV1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3RyJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXVxuICB9LFxufSlcbiIsICJpbXBvcnQgJy4uL3R5cGVzLmpzJ1xuXG5pbXBvcnQgeyBjYWxsT3JSZXR1cm4sIGdldEV4dGVuc2lvbkZpZWxkLCBtZXJnZUF0dHJpYnV0ZXMsIE5vZGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5pbXBvcnQgdHlwZSB7IERPTU91dHB1dFNwZWMsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJ1xuaW1wb3J0IHtcbiAgYWRkQ29sdW1uQWZ0ZXIsXG4gIGFkZENvbHVtbkJlZm9yZSxcbiAgYWRkUm93QWZ0ZXIsXG4gIGFkZFJvd0JlZm9yZSxcbiAgQ2VsbFNlbGVjdGlvbixcbiAgY29sdW1uUmVzaXppbmcsXG4gIGRlbGV0ZUNvbHVtbixcbiAgZGVsZXRlUm93LFxuICBkZWxldGVUYWJsZSxcbiAgZml4VGFibGVzLFxuICBnb1RvTmV4dENlbGwsXG4gIG1lcmdlQ2VsbHMsXG4gIHNldENlbGxBdHRyLFxuICBzcGxpdENlbGwsXG4gIHRhYmxlRWRpdGluZyxcbiAgdG9nZ2xlSGVhZGVyLFxuICB0b2dnbGVIZWFkZXJDZWxsLFxufSBmcm9tICdAdGlwdGFwL3BtL3RhYmxlcydcbmltcG9ydCB0eXBlIHsgRWRpdG9yVmlldywgTm9kZVZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmltcG9ydCB7IFRhYmxlVmlldyB9IGZyb20gJy4vVGFibGVWaWV3LmpzJ1xuaW1wb3J0IHsgY3JlYXRlQ29sR3JvdXAgfSBmcm9tICcuL3V0aWxpdGllcy9jcmVhdGVDb2xHcm91cC5qcydcbmltcG9ydCB7IGNyZWF0ZVRhYmxlIH0gZnJvbSAnLi91dGlsaXRpZXMvY3JlYXRlVGFibGUuanMnXG5pbXBvcnQgeyBkZWxldGVUYWJsZVdoZW5BbGxDZWxsc1NlbGVjdGVkIH0gZnJvbSAnLi91dGlsaXRpZXMvZGVsZXRlVGFibGVXaGVuQWxsQ2VsbHNTZWxlY3RlZC5qcydcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZU9wdGlvbnMge1xuICAvKipcbiAgICogSFRNTCBhdHRyaWJ1dGVzIGZvciB0aGUgdGFibGUgZWxlbWVudC5cbiAgICogQGRlZmF1bHQge31cbiAgICogQGV4YW1wbGUgeyBjbGFzczogJ2ZvbycgfVxuICAgKi9cbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cblxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgcmVzaXppbmcgb2YgdGFibGVzLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZXhhbXBsZSB0cnVlXG4gICAqL1xuICByZXNpemFibGU6IGJvb2xlYW5cblxuICAvKipcbiAgICogVGhlIHdpZHRoIG9mIHRoZSByZXNpemUgaGFuZGxlLlxuICAgKiBAZGVmYXVsdCA1XG4gICAqIEBleGFtcGxlIDEwXG4gICAqL1xuICBoYW5kbGVXaWR0aDogbnVtYmVyXG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIHdpZHRoIG9mIGEgY2VsbC5cbiAgICogQGRlZmF1bHQgMjVcbiAgICogQGV4YW1wbGUgNTBcbiAgICovXG4gIGNlbGxNaW5XaWR0aDogbnVtYmVyXG5cbiAgLyoqXG4gICAqIFRoZSBub2RlIHZpZXcgdG8gcmVuZGVyIHRoZSB0YWJsZS5cbiAgICogQGRlZmF1bHQgVGFibGVWaWV3XG4gICAqL1xuICBWaWV3OiAobmV3IChub2RlOiBQcm9zZU1pcnJvck5vZGUsIGNlbGxNaW5XaWR0aDogbnVtYmVyLCB2aWV3OiBFZGl0b3JWaWV3KSA9PiBOb2RlVmlldykgfCBudWxsXG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIHJlc2l6aW5nIG9mIHRoZSBsYXN0IGNvbHVtbi5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgKi9cbiAgbGFzdENvbHVtblJlc2l6YWJsZTogYm9vbGVhblxuXG4gIC8qKlxuICAgKiBBbGxvdyB0YWJsZSBub2RlIHNlbGVjdGlvbi5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgYWxsb3dUYWJsZU5vZGVTZWxlY3Rpb246IGJvb2xlYW5cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHRhYmxlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEluc2VydCBhIHRhYmxlXG4gICAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgdGFibGUgYXR0cmlidXRlc1xuICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY29tbWFuZCB3YXMgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuaW5zZXJ0VGFibGUoeyByb3dzOiAzLCBjb2xzOiAzLCB3aXRoSGVhZGVyUm93OiB0cnVlIH0pXG4gICAgICAgKi9cbiAgICAgIGluc2VydFRhYmxlOiAob3B0aW9ucz86IHsgcm93cz86IG51bWJlcjsgY29scz86IG51bWJlcjsgd2l0aEhlYWRlclJvdz86IGJvb2xlYW4gfSkgPT4gUmV0dXJuVHlwZVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhIGNvbHVtbiBiZWZvcmUgdGhlIGN1cnJlbnQgY29sdW1uXG4gICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjb21tYW5kIHdhcyBzdWNjZXNzZnVsLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5hZGRDb2x1bW5CZWZvcmUoKVxuICAgICAgICovXG4gICAgICBhZGRDb2x1bW5CZWZvcmU6ICgpID0+IFJldHVyblR5cGVcblxuICAgICAgLyoqXG4gICAgICAgKiBBZGQgYSBjb2x1bW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY29sdW1uXG4gICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjb21tYW5kIHdhcyBzdWNjZXNzZnVsLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5hZGRDb2x1bW5BZnRlcigpXG4gICAgICAgKi9cbiAgICAgIGFkZENvbHVtbkFmdGVyOiAoKSA9PiBSZXR1cm5UeXBlXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVsZXRlIHRoZSBjdXJyZW50IGNvbHVtblxuICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY29tbWFuZCB3YXMgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuZGVsZXRlQ29sdW1uKClcbiAgICAgICAqL1xuICAgICAgZGVsZXRlQ29sdW1uOiAoKSA9PiBSZXR1cm5UeXBlXG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkIGEgcm93IGJlZm9yZSB0aGUgY3VycmVudCByb3dcbiAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNvbW1hbmQgd2FzIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmFkZFJvd0JlZm9yZSgpXG4gICAgICAgKi9cbiAgICAgIGFkZFJvd0JlZm9yZTogKCkgPT4gUmV0dXJuVHlwZVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBhIHJvdyBhZnRlciB0aGUgY3VycmVudCByb3dcbiAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNvbW1hbmQgd2FzIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmFkZFJvd0FmdGVyKClcbiAgICAgICAqL1xuICAgICAgYWRkUm93QWZ0ZXI6ICgpID0+IFJldHVyblR5cGVcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgdGhlIGN1cnJlbnQgcm93XG4gICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjb21tYW5kIHdhcyBzdWNjZXNzZnVsLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5kZWxldGVSb3coKVxuICAgICAgICovXG4gICAgICBkZWxldGVSb3c6ICgpID0+IFJldHVyblR5cGVcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWxldGUgdGhlIGN1cnJlbnQgdGFibGVcbiAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNvbW1hbmQgd2FzIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVRhYmxlKClcbiAgICAgICAqL1xuICAgICAgZGVsZXRlVGFibGU6ICgpID0+IFJldHVyblR5cGVcblxuICAgICAgLyoqXG4gICAgICAgKiBNZXJnZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNlbGxzXG4gICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjb21tYW5kIHdhcyBzdWNjZXNzZnVsLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5tZXJnZUNlbGxzKClcbiAgICAgICAqL1xuICAgICAgbWVyZ2VDZWxsczogKCkgPT4gUmV0dXJuVHlwZVxuXG4gICAgICAvKipcbiAgICAgICAqIFNwbGl0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2VsbFxuICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY29tbWFuZCB3YXMgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc3BsaXRDZWxsKClcbiAgICAgICAqL1xuICAgICAgc3BsaXRDZWxsOiAoKSA9PiBSZXR1cm5UeXBlXG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIHRoZSBoZWFkZXIgY29sdW1uXG4gICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjb21tYW5kIHdhcyBzdWNjZXNzZnVsLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy50b2dnbGVIZWFkZXJDb2x1bW4oKVxuICAgICAgICovXG4gICAgICB0b2dnbGVIZWFkZXJDb2x1bW46ICgpID0+IFJldHVyblR5cGVcblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGUgdGhlIGhlYWRlciByb3dcbiAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNvbW1hbmQgd2FzIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUhlYWRlclJvdygpXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUhlYWRlclJvdzogKCkgPT4gUmV0dXJuVHlwZVxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZSB0aGUgaGVhZGVyIGNlbGxcbiAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNvbW1hbmQgd2FzIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUhlYWRlckNlbGwoKVxuICAgICAgICovXG4gICAgICB0b2dnbGVIZWFkZXJDZWxsOiAoKSA9PiBSZXR1cm5UeXBlXG5cbiAgICAgIC8qKlxuICAgICAgICogTWVyZ2Ugb3Igc3BsaXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsc1xuICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY29tbWFuZCB3YXMgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMubWVyZ2VPclNwbGl0KClcbiAgICAgICAqL1xuICAgICAgbWVyZ2VPclNwbGl0OiAoKSA9PiBSZXR1cm5UeXBlXG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IGEgY2VsbCBhdHRyaWJ1dGVcbiAgICAgICAqIEBwYXJhbSBuYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICogQHBhcmFtIHZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNvbW1hbmQgd2FzIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICogQGV4YW1wbGUgZWRpdG9yLmNvbW1hbmRzLnNldENlbGxBdHRyaWJ1dGUoJ2FsaWduJywgJ3JpZ2h0JylcbiAgICAgICAqL1xuICAgICAgc2V0Q2VsbEF0dHJpYnV0ZTogKG5hbWU6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gUmV0dXJuVHlwZVxuXG4gICAgICAvKipcbiAgICAgICAqIE1vdmVzIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5leHQgY2VsbFxuICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY29tbWFuZCB3YXMgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuZ29Ub05leHRDZWxsKClcbiAgICAgICAqL1xuICAgICAgZ29Ub05leHRDZWxsOiAoKSA9PiBSZXR1cm5UeXBlXG5cbiAgICAgIC8qKlxuICAgICAgICogTW92ZXMgdGhlIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgY2VsbFxuICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY29tbWFuZCB3YXMgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuZ29Ub1ByZXZpb3VzQ2VsbCgpXG4gICAgICAgKi9cbiAgICAgIGdvVG9QcmV2aW91c0NlbGw6ICgpID0+IFJldHVyblR5cGVcblxuICAgICAgLyoqXG4gICAgICAgKiBUcnkgdG8gZml4IHRoZSB0YWJsZSBzdHJ1Y3R1cmUgaWYgbmVjZXNzYXJ5XG4gICAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjb21tYW5kIHdhcyBzdWNjZXNzZnVsLCBvdGhlcndpc2UgZmFsc2VcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5maXhUYWJsZXMoKVxuICAgICAgICovXG4gICAgICBmaXhUYWJsZXM6ICgpID0+IFJldHVyblR5cGVcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYSBjZWxsIHNlbGVjdGlvbiBpbnNpZGUgdGhlIGN1cnJlbnQgdGFibGVcbiAgICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgY2VsbCBwb3NpdGlvblxuICAgICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY29tbWFuZCB3YXMgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMuc2V0Q2VsbFNlbGVjdGlvbih7IGFuY2hvckNlbGw6IDEsIGhlYWRDZWxsOiAyIH0pXG4gICAgICAgKi9cbiAgICAgIHNldENlbGxTZWxlY3Rpb246IChwb3NpdGlvbjogeyBhbmNob3JDZWxsOiBudW1iZXI7IGhlYWRDZWxsPzogbnVtYmVyIH0pID0+IFJldHVyblR5cGVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0YWJsZXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3RhYmxlXG4gKi9cbmV4cG9ydCBjb25zdCBUYWJsZSA9IE5vZGUuY3JlYXRlPFRhYmxlT3B0aW9ucz4oe1xuICBuYW1lOiAndGFibGUnLFxuXG4gIC8vIEB0cy1pZ25vcmVcbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgcmVzaXphYmxlOiBmYWxzZSxcbiAgICAgIGhhbmRsZVdpZHRoOiA1LFxuICAgICAgY2VsbE1pbldpZHRoOiAyNSxcbiAgICAgIC8vIFRPRE86IGZpeFxuICAgICAgVmlldzogVGFibGVWaWV3LFxuICAgICAgbGFzdENvbHVtblJlc2l6YWJsZTogdHJ1ZSxcbiAgICAgIGFsbG93VGFibGVOb2RlU2VsZWN0aW9uOiBmYWxzZSxcbiAgICB9XG4gIH0sXG5cbiAgY29udGVudDogJ3RhYmxlUm93KycsXG5cbiAgdGFibGVSb2xlOiAndGFibGUnLFxuXG4gIGlzb2xhdGluZzogdHJ1ZSxcblxuICBncm91cDogJ2Jsb2NrJyxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFt7IHRhZzogJ3RhYmxlJyB9XVxuICB9LFxuXG4gIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgY29uc3QgeyBjb2xncm91cCwgdGFibGVXaWR0aCwgdGFibGVNaW5XaWR0aCB9ID0gY3JlYXRlQ29sR3JvdXAobm9kZSwgdGhpcy5vcHRpb25zLmNlbGxNaW5XaWR0aClcblxuICAgIGNvbnN0IHRhYmxlOiBET01PdXRwdXRTcGVjID0gW1xuICAgICAgJ3RhYmxlJyxcbiAgICAgIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzLCB7XG4gICAgICAgIHN0eWxlOiB0YWJsZVdpZHRoID8gYHdpZHRoOiAke3RhYmxlV2lkdGh9YCA6IGBtaW4td2lkdGg6ICR7dGFibGVNaW5XaWR0aH1gLFxuICAgICAgfSksXG4gICAgICBjb2xncm91cCxcbiAgICAgIFsndGJvZHknLCAwXSxcbiAgICBdXG5cbiAgICByZXR1cm4gdGFibGVcbiAgfSxcblxuICBhZGRDb21tYW5kcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5zZXJ0VGFibGU6XG4gICAgICAgICh7IHJvd3MgPSAzLCBjb2xzID0gMywgd2l0aEhlYWRlclJvdyA9IHRydWUgfSA9IHt9KSA9PlxuICAgICAgICAoeyB0ciwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGNyZWF0ZVRhYmxlKGVkaXRvci5zY2hlbWEsIHJvd3MsIGNvbHMsIHdpdGhIZWFkZXJSb3cpXG5cbiAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRyLnNlbGVjdGlvbi5mcm9tICsgMVxuXG4gICAgICAgICAgICB0ci5yZXBsYWNlU2VsZWN0aW9uV2l0aChub2RlKVxuICAgICAgICAgICAgICAuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICAgICAgICAuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShvZmZzZXQpKSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgYWRkQ29sdW1uQmVmb3JlOlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBhZGRDb2x1bW5CZWZvcmUoc3RhdGUsIGRpc3BhdGNoKVxuICAgICAgICB9LFxuICAgICAgYWRkQ29sdW1uQWZ0ZXI6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGFkZENvbHVtbkFmdGVyKHN0YXRlLCBkaXNwYXRjaClcbiAgICAgICAgfSxcbiAgICAgIGRlbGV0ZUNvbHVtbjpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gZGVsZXRlQ29sdW1uKHN0YXRlLCBkaXNwYXRjaClcbiAgICAgICAgfSxcbiAgICAgIGFkZFJvd0JlZm9yZTpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gYWRkUm93QmVmb3JlKHN0YXRlLCBkaXNwYXRjaClcbiAgICAgICAgfSxcbiAgICAgIGFkZFJvd0FmdGVyOlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBhZGRSb3dBZnRlcihzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICAgIH0sXG4gICAgICBkZWxldGVSb3c6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGRlbGV0ZVJvdyhzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICAgIH0sXG4gICAgICBkZWxldGVUYWJsZTpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gZGVsZXRlVGFibGUoc3RhdGUsIGRpc3BhdGNoKVxuICAgICAgICB9LFxuICAgICAgbWVyZ2VDZWxsczpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gbWVyZ2VDZWxscyhzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICAgIH0sXG4gICAgICBzcGxpdENlbGw6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHNwbGl0Q2VsbChzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICAgIH0sXG4gICAgICB0b2dnbGVIZWFkZXJDb2x1bW46XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRvZ2dsZUhlYWRlcignY29sdW1uJykoc3RhdGUsIGRpc3BhdGNoKVxuICAgICAgICB9LFxuICAgICAgdG9nZ2xlSGVhZGVyUm93OlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgIHJldHVybiB0b2dnbGVIZWFkZXIoJ3JvdycpKHN0YXRlLCBkaXNwYXRjaClcbiAgICAgICAgfSxcbiAgICAgIHRvZ2dsZUhlYWRlckNlbGw6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRvZ2dsZUhlYWRlckNlbGwoc3RhdGUsIGRpc3BhdGNoKVxuICAgICAgICB9LFxuICAgICAgbWVyZ2VPclNwbGl0OlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgIGlmIChtZXJnZUNlbGxzKHN0YXRlLCBkaXNwYXRjaCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNwbGl0Q2VsbChzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICAgIH0sXG4gICAgICBzZXRDZWxsQXR0cmlidXRlOlxuICAgICAgICAobmFtZSwgdmFsdWUpID0+XG4gICAgICAgICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHNldENlbGxBdHRyKG5hbWUsIHZhbHVlKShzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICAgIH0sXG4gICAgICBnb1RvTmV4dENlbGw6XG4gICAgICAgICgpID0+XG4gICAgICAgICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGdvVG9OZXh0Q2VsbCgxKShzdGF0ZSwgZGlzcGF0Y2gpXG4gICAgICAgIH0sXG4gICAgICBnb1RvUHJldmlvdXNDZWxsOlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBnb1RvTmV4dENlbGwoLTEpKHN0YXRlLCBkaXNwYXRjaClcbiAgICAgICAgfSxcbiAgICAgIGZpeFRhYmxlczpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGZpeFRhYmxlcyhzdGF0ZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgc2V0Q2VsbFNlbGVjdGlvbjpcbiAgICAgICAgcG9zaXRpb24gPT5cbiAgICAgICAgKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IENlbGxTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9zaXRpb24uYW5jaG9yQ2VsbCwgcG9zaXRpb24uaGVhZENlbGwpXG5cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSxcbiAgICB9XG4gIH0sXG5cbiAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFRhYjogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IuY29tbWFuZHMuZ29Ub05leHRDZWxsKCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5jYW4oKS5hZGRSb3dBZnRlcigpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuY2hhaW4oKS5hZGRSb3dBZnRlcigpLmdvVG9OZXh0Q2VsbCgpLnJ1bigpXG4gICAgICB9LFxuICAgICAgJ1NoaWZ0LVRhYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmdvVG9QcmV2aW91c0NlbGwoKSxcbiAgICAgIEJhY2tzcGFjZTogZGVsZXRlVGFibGVXaGVuQWxsQ2VsbHNTZWxlY3RlZCxcbiAgICAgICdNb2QtQmFja3NwYWNlJzogZGVsZXRlVGFibGVXaGVuQWxsQ2VsbHNTZWxlY3RlZCxcbiAgICAgIERlbGV0ZTogZGVsZXRlVGFibGVXaGVuQWxsQ2VsbHNTZWxlY3RlZCxcbiAgICAgICdNb2QtRGVsZXRlJzogZGVsZXRlVGFibGVXaGVuQWxsQ2VsbHNTZWxlY3RlZCxcbiAgICB9XG4gIH0sXG5cbiAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgIGNvbnN0IGlzUmVzaXphYmxlID0gdGhpcy5vcHRpb25zLnJlc2l6YWJsZSAmJiB0aGlzLmVkaXRvci5pc0VkaXRhYmxlXG5cbiAgICByZXR1cm4gW1xuICAgICAgLi4uKGlzUmVzaXphYmxlXG4gICAgICAgID8gW1xuICAgICAgICAgICAgY29sdW1uUmVzaXppbmcoe1xuICAgICAgICAgICAgICBoYW5kbGVXaWR0aDogdGhpcy5vcHRpb25zLmhhbmRsZVdpZHRoLFxuICAgICAgICAgICAgICBjZWxsTWluV2lkdGg6IHRoaXMub3B0aW9ucy5jZWxsTWluV2lkdGgsXG4gICAgICAgICAgICAgIGRlZmF1bHRDZWxsTWluV2lkdGg6IHRoaXMub3B0aW9ucy5jZWxsTWluV2lkdGgsXG4gICAgICAgICAgICAgIFZpZXc6IHRoaXMub3B0aW9ucy5WaWV3LFxuICAgICAgICAgICAgICBsYXN0Q29sdW1uUmVzaXphYmxlOiB0aGlzLm9wdGlvbnMubGFzdENvbHVtblJlc2l6YWJsZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIF1cbiAgICAgICAgOiBbXSksXG4gICAgICB0YWJsZUVkaXRpbmcoe1xuICAgICAgICBhbGxvd1RhYmxlTm9kZVNlbGVjdGlvbjogdGhpcy5vcHRpb25zLmFsbG93VGFibGVOb2RlU2VsZWN0aW9uLFxuICAgICAgfSksXG4gICAgXVxuICB9LFxuXG4gIGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGFibGVSb2xlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAndGFibGVSb2xlJywgY29udGV4dCkpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGdldENvbFN0eWxlRGVjbGFyYXRpb24obWluV2lkdGg6IG51bWJlciwgd2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCk6IFtzdHJpbmcsIHN0cmluZ10ge1xuICBpZiAod2lkdGgpIHtcbiAgICAvLyBhcHBseSB0aGUgc3RvcmVkIHdpZHRoIHVubGVzcyBpdCBpcyBiZWxvdyB0aGUgY29uZmlndXJlZCBtaW5pbXVtIGNlbGwgd2lkdGhcbiAgICByZXR1cm4gWyd3aWR0aCcsIGAke01hdGgubWF4KHdpZHRoLCBtaW5XaWR0aCl9cHhgXVxuICB9XG5cbiAgLy8gc2V0IHRoZSBtaW5pbXVtIHdpdGggb24gdGhlIGNvbHVtbiBpZiBpdCBoYXMgbm8gc3RvcmVkIHdpZHRoXG4gIHJldHVybiBbJ21pbi13aWR0aCcsIGAke21pbldpZHRofXB4YF1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcbmltcG9ydCB0eXBlIHsgTm9kZVZpZXcsIFZpZXdNdXRhdGlvblJlY29yZCB9IGZyb20gJ0B0aXB0YXAvcG0vdmlldydcblxuaW1wb3J0IHsgZ2V0Q29sU3R5bGVEZWNsYXJhdGlvbiB9IGZyb20gJy4vdXRpbGl0aWVzL2NvbFN0eWxlLmpzJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQ29sdW1ucyhcbiAgbm9kZTogUHJvc2VNaXJyb3JOb2RlLFxuICBjb2xncm91cDogSFRNTFRhYmxlQ29sRWxlbWVudCwgLy8gPGNvbGdyb3VwPiBoYXMgdGhlIHNhbWUgcHJvdG90eXBlIGFzIDxjb2w+XG4gIHRhYmxlOiBIVE1MVGFibGVFbGVtZW50LFxuICBjZWxsTWluV2lkdGg6IG51bWJlcixcbiAgb3ZlcnJpZGVDb2w/OiBudW1iZXIsXG4gIG92ZXJyaWRlVmFsdWU/OiBudW1iZXIsXG4pIHtcbiAgbGV0IHRvdGFsV2lkdGggPSAwXG4gIGxldCBmaXhlZFdpZHRoID0gdHJ1ZVxuICBsZXQgbmV4dERPTSA9IGNvbGdyb3VwLmZpcnN0Q2hpbGRcbiAgY29uc3Qgcm93ID0gbm9kZS5maXJzdENoaWxkXG5cbiAgaWYgKHJvdyAhPT0gbnVsbCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBjb2wgPSAwOyBpIDwgcm93LmNoaWxkQ291bnQ7IGkgKz0gMSkge1xuICAgICAgY29uc3QgeyBjb2xzcGFuLCBjb2x3aWR0aCB9ID0gcm93LmNoaWxkKGkpLmF0dHJzXG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sc3BhbjsgaiArPSAxLCBjb2wgKz0gMSkge1xuICAgICAgICBjb25zdCBoYXNXaWR0aCA9IG92ZXJyaWRlQ29sID09PSBjb2wgPyBvdmVycmlkZVZhbHVlIDogKChjb2x3aWR0aCAmJiBjb2x3aWR0aFtqXSkgYXMgbnVtYmVyIHwgdW5kZWZpbmVkKVxuICAgICAgICBjb25zdCBjc3NXaWR0aCA9IGhhc1dpZHRoID8gYCR7aGFzV2lkdGh9cHhgIDogJydcblxuICAgICAgICB0b3RhbFdpZHRoICs9IGhhc1dpZHRoIHx8IGNlbGxNaW5XaWR0aFxuXG4gICAgICAgIGlmICghaGFzV2lkdGgpIHtcbiAgICAgICAgICBmaXhlZFdpZHRoID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV4dERPTSkge1xuICAgICAgICAgIGNvbnN0IGNvbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2wnKVxuXG4gICAgICAgICAgY29uc3QgW3Byb3BlcnR5S2V5LCBwcm9wZXJ0eVZhbHVlXSA9IGdldENvbFN0eWxlRGVjbGFyYXRpb24oY2VsbE1pbldpZHRoLCBoYXNXaWR0aClcblxuICAgICAgICAgIGNvbEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHlLZXksIHByb3BlcnR5VmFsdWUpXG5cbiAgICAgICAgICBjb2xncm91cC5hcHBlbmRDaGlsZChjb2xFbGVtZW50KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgobmV4dERPTSBhcyBIVE1MVGFibGVDb2xFbGVtZW50KS5zdHlsZS53aWR0aCAhPT0gY3NzV2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eUtleSwgcHJvcGVydHlWYWx1ZV0gPSBnZXRDb2xTdHlsZURlY2xhcmF0aW9uKGNlbGxNaW5XaWR0aCwgaGFzV2lkdGgpXG5cbiAgICAgICAgICAgIDsobmV4dERPTSBhcyBIVE1MVGFibGVDb2xFbGVtZW50KS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eUtleSwgcHJvcGVydHlWYWx1ZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0RE9NID0gbmV4dERPTS5uZXh0U2libGluZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKG5leHRET00pIHtcbiAgICBjb25zdCBhZnRlciA9IG5leHRET00ubmV4dFNpYmxpbmdcblxuICAgIG5leHRET00ucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQobmV4dERPTSlcbiAgICBuZXh0RE9NID0gYWZ0ZXJcbiAgfVxuXG4gIGlmIChmaXhlZFdpZHRoKSB7XG4gICAgdGFibGUuc3R5bGUud2lkdGggPSBgJHt0b3RhbFdpZHRofXB4YFxuICAgIHRhYmxlLnN0eWxlLm1pbldpZHRoID0gJydcbiAgfSBlbHNlIHtcbiAgICB0YWJsZS5zdHlsZS53aWR0aCA9ICcnXG4gICAgdGFibGUuc3R5bGUubWluV2lkdGggPSBgJHt0b3RhbFdpZHRofXB4YFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUYWJsZVZpZXcgaW1wbGVtZW50cyBOb2RlVmlldyB7XG4gIG5vZGU6IFByb3NlTWlycm9yTm9kZVxuXG4gIGNlbGxNaW5XaWR0aDogbnVtYmVyXG5cbiAgZG9tOiBIVE1MRGl2RWxlbWVudFxuXG4gIHRhYmxlOiBIVE1MVGFibGVFbGVtZW50XG5cbiAgY29sZ3JvdXA6IEhUTUxUYWJsZUNvbEVsZW1lbnRcblxuICBjb250ZW50RE9NOiBIVE1MVGFibGVTZWN0aW9uRWxlbWVudFxuXG4gIGNvbnN0cnVjdG9yKG5vZGU6IFByb3NlTWlycm9yTm9kZSwgY2VsbE1pbldpZHRoOiBudW1iZXIpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlXG4gICAgdGhpcy5jZWxsTWluV2lkdGggPSBjZWxsTWluV2lkdGhcbiAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGhpcy5kb20uY2xhc3NOYW1lID0gJ3RhYmxlV3JhcHBlcidcbiAgICB0aGlzLnRhYmxlID0gdGhpcy5kb20uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKSlcbiAgICB0aGlzLmNvbGdyb3VwID0gdGhpcy50YWJsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2xncm91cCcpKVxuICAgIHVwZGF0ZUNvbHVtbnMobm9kZSwgdGhpcy5jb2xncm91cCwgdGhpcy50YWJsZSwgY2VsbE1pbldpZHRoKVxuICAgIHRoaXMuY29udGVudERPTSA9IHRoaXMudGFibGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKSlcbiAgfVxuXG4gIHVwZGF0ZShub2RlOiBQcm9zZU1pcnJvck5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlICE9PSB0aGlzLm5vZGUudHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy5ub2RlID0gbm9kZVxuICAgIHVwZGF0ZUNvbHVtbnMobm9kZSwgdGhpcy5jb2xncm91cCwgdGhpcy50YWJsZSwgdGhpcy5jZWxsTWluV2lkdGgpXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWdub3JlTXV0YXRpb24obXV0YXRpb246IFZpZXdNdXRhdGlvblJlY29yZCkge1xuICAgIHJldHVybiBtdXRhdGlvbi50eXBlID09PSAnYXR0cmlidXRlcycgJiYgKG11dGF0aW9uLnRhcmdldCA9PT0gdGhpcy50YWJsZSB8fCB0aGlzLmNvbGdyb3VwLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7IERPTU91dHB1dFNwZWMsIE5vZGUgYXMgUHJvc2VNaXJyb3JOb2RlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgZ2V0Q29sU3R5bGVEZWNsYXJhdGlvbiB9IGZyb20gJy4vY29sU3R5bGUuanMnXG5cbmV4cG9ydCB0eXBlIENvbEdyb3VwID1cbiAgfCB7XG4gICAgICBjb2xncm91cDogRE9NT3V0cHV0U3BlY1xuICAgICAgdGFibGVXaWR0aDogc3RyaW5nXG4gICAgICB0YWJsZU1pbldpZHRoOiBzdHJpbmdcbiAgICB9XG4gIHwgUmVjb3JkPHN0cmluZywgbmV2ZXI+XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbGdyb3VwIGVsZW1lbnQgZm9yIGEgdGFibGUgbm9kZSBpbiBQcm9zZU1pcnJvci5cbiAqXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBQcm9zZU1pcnJvciBub2RlIHJlcHJlc2VudGluZyB0aGUgdGFibGUuXG4gKiBAcGFyYW0gY2VsbE1pbldpZHRoIC0gVGhlIG1pbmltdW0gd2lkdGggb2YgYSBjZWxsIGluIHRoZSB0YWJsZS5cbiAqIEBwYXJhbSBvdmVycmlkZUNvbCAtIChPcHRpb25hbCkgVGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gdG8gb3ZlcnJpZGUgdGhlIHdpZHRoIG9mLlxuICogQHBhcmFtIG92ZXJyaWRlVmFsdWUgLSAoT3B0aW9uYWwpIFRoZSB3aWR0aCB2YWx1ZSB0byB1c2UgZm9yIHRoZSBvdmVycmlkZGVuIGNvbHVtbi5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjb2xncm91cCBlbGVtZW50LCB0aGUgdG90YWwgd2lkdGggb2YgdGhlIHRhYmxlLCBhbmQgdGhlIG1pbmltdW0gd2lkdGggb2YgdGhlIHRhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29sR3JvdXAobm9kZTogUHJvc2VNaXJyb3JOb2RlLCBjZWxsTWluV2lkdGg6IG51bWJlcik6IENvbEdyb3VwXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29sR3JvdXAoXG4gIG5vZGU6IFByb3NlTWlycm9yTm9kZSxcbiAgY2VsbE1pbldpZHRoOiBudW1iZXIsXG4gIG92ZXJyaWRlQ29sOiBudW1iZXIsXG4gIG92ZXJyaWRlVmFsdWU6IG51bWJlcixcbik6IENvbEdyb3VwXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29sR3JvdXAoXG4gIG5vZGU6IFByb3NlTWlycm9yTm9kZSxcbiAgY2VsbE1pbldpZHRoOiBudW1iZXIsXG4gIG92ZXJyaWRlQ29sPzogbnVtYmVyLFxuICBvdmVycmlkZVZhbHVlPzogbnVtYmVyLFxuKTogQ29sR3JvdXAge1xuICBsZXQgdG90YWxXaWR0aCA9IDBcbiAgbGV0IGZpeGVkV2lkdGggPSB0cnVlXG4gIGNvbnN0IGNvbHM6IERPTU91dHB1dFNwZWNbXSA9IFtdXG4gIGNvbnN0IHJvdyA9IG5vZGUuZmlyc3RDaGlsZFxuXG4gIGlmICghcm93KSB7XG4gICAgcmV0dXJuIHt9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMCwgY29sID0gMDsgaSA8IHJvdy5jaGlsZENvdW50OyBpICs9IDEpIHtcbiAgICBjb25zdCB7IGNvbHNwYW4sIGNvbHdpZHRoIH0gPSByb3cuY2hpbGQoaSkuYXR0cnNcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sc3BhbjsgaiArPSAxLCBjb2wgKz0gMSkge1xuICAgICAgY29uc3QgaGFzV2lkdGggPSBvdmVycmlkZUNvbCA9PT0gY29sID8gb3ZlcnJpZGVWYWx1ZSA6IGNvbHdpZHRoICYmIChjb2x3aWR0aFtqXSBhcyBudW1iZXIgfCB1bmRlZmluZWQpXG5cbiAgICAgIHRvdGFsV2lkdGggKz0gaGFzV2lkdGggfHwgY2VsbE1pbldpZHRoXG5cbiAgICAgIGlmICghaGFzV2lkdGgpIHtcbiAgICAgICAgZml4ZWRXaWR0aCA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsdWVdID0gZ2V0Q29sU3R5bGVEZWNsYXJhdGlvbihjZWxsTWluV2lkdGgsIGhhc1dpZHRoKVxuXG4gICAgICBjb2xzLnB1c2goWydjb2wnLCB7IHN0eWxlOiBgJHtwcm9wZXJ0eX06ICR7dmFsdWV9YCB9XSlcbiAgICB9XG4gIH1cblxuICBjb25zdCB0YWJsZVdpZHRoID0gZml4ZWRXaWR0aCA/IGAke3RvdGFsV2lkdGh9cHhgIDogJydcbiAgY29uc3QgdGFibGVNaW5XaWR0aCA9IGZpeGVkV2lkdGggPyAnJyA6IGAke3RvdGFsV2lkdGh9cHhgXG5cbiAgY29uc3QgY29sZ3JvdXA6IERPTU91dHB1dFNwZWMgPSBbJ2NvbGdyb3VwJywge30sIC4uLmNvbHNdXG5cbiAgcmV0dXJuIHsgY29sZ3JvdXAsIHRhYmxlV2lkdGgsIHRhYmxlTWluV2lkdGggfVxufVxuIiwgImltcG9ydCB0eXBlIHsgRnJhZ21lbnQsIE5vZGUgYXMgUHJvc2VtaXJyb3JOb2RlLCBOb2RlVHlwZSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDZWxsKFxuICBjZWxsVHlwZTogTm9kZVR5cGUsXG4gIGNlbGxDb250ZW50PzogRnJhZ21lbnQgfCBQcm9zZW1pcnJvck5vZGUgfCBBcnJheTxQcm9zZW1pcnJvck5vZGU+LFxuKTogUHJvc2VtaXJyb3JOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIGlmIChjZWxsQ29udGVudCkge1xuICAgIHJldHVybiBjZWxsVHlwZS5jcmVhdGVDaGVja2VkKG51bGwsIGNlbGxDb250ZW50KVxuICB9XG5cbiAgcmV0dXJuIGNlbGxUeXBlLmNyZWF0ZUFuZEZpbGwoKVxufVxuIiwgImltcG9ydCB0eXBlIHsgTm9kZVR5cGUsIFNjaGVtYSB9IGZyb20gJ0B0aXB0YXAvcG0vbW9kZWwnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUYWJsZU5vZGVUeXBlcyhzY2hlbWE6IFNjaGVtYSk6IHsgW2tleTogc3RyaW5nXTogTm9kZVR5cGUgfSB7XG4gIGlmIChzY2hlbWEuY2FjaGVkLnRhYmxlTm9kZVR5cGVzKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQudGFibGVOb2RlVHlwZXNcbiAgfVxuXG4gIGNvbnN0IHJvbGVzOiB7IFtrZXk6IHN0cmluZ106IE5vZGVUeXBlIH0gPSB7fVxuXG4gIE9iamVjdC5rZXlzKHNjaGVtYS5ub2RlcykuZm9yRWFjaCh0eXBlID0+IHtcbiAgICBjb25zdCBub2RlVHlwZSA9IHNjaGVtYS5ub2Rlc1t0eXBlXVxuXG4gICAgaWYgKG5vZGVUeXBlLnNwZWMudGFibGVSb2xlKSB7XG4gICAgICByb2xlc1tub2RlVHlwZS5zcGVjLnRhYmxlUm9sZV0gPSBub2RlVHlwZVxuICAgIH1cbiAgfSlcblxuICBzY2hlbWEuY2FjaGVkLnRhYmxlTm9kZVR5cGVzID0gcm9sZXNcblxuICByZXR1cm4gcm9sZXNcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEZyYWdtZW50LCBOb2RlIGFzIFByb3NlbWlycm9yTm9kZSwgU2NoZW1hIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCdcblxuaW1wb3J0IHsgY3JlYXRlQ2VsbCB9IGZyb20gJy4vY3JlYXRlQ2VsbC5qcydcbmltcG9ydCB7IGdldFRhYmxlTm9kZVR5cGVzIH0gZnJvbSAnLi9nZXRUYWJsZU5vZGVUeXBlcy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhYmxlKFxuICBzY2hlbWE6IFNjaGVtYSxcbiAgcm93c0NvdW50OiBudW1iZXIsXG4gIGNvbHNDb3VudDogbnVtYmVyLFxuICB3aXRoSGVhZGVyUm93OiBib29sZWFuLFxuICBjZWxsQ29udGVudD86IEZyYWdtZW50IHwgUHJvc2VtaXJyb3JOb2RlIHwgQXJyYXk8UHJvc2VtaXJyb3JOb2RlPixcbik6IFByb3NlbWlycm9yTm9kZSB7XG4gIGNvbnN0IHR5cGVzID0gZ2V0VGFibGVOb2RlVHlwZXMoc2NoZW1hKVxuICBjb25zdCBoZWFkZXJDZWxsczogUHJvc2VtaXJyb3JOb2RlW10gPSBbXVxuICBjb25zdCBjZWxsczogUHJvc2VtaXJyb3JOb2RlW10gPSBbXVxuXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjb2xzQ291bnQ7IGluZGV4ICs9IDEpIHtcbiAgICBjb25zdCBjZWxsID0gY3JlYXRlQ2VsbCh0eXBlcy5jZWxsLCBjZWxsQ29udGVudClcblxuICAgIGlmIChjZWxsKSB7XG4gICAgICBjZWxscy5wdXNoKGNlbGwpXG4gICAgfVxuXG4gICAgaWYgKHdpdGhIZWFkZXJSb3cpIHtcbiAgICAgIGNvbnN0IGhlYWRlckNlbGwgPSBjcmVhdGVDZWxsKHR5cGVzLmhlYWRlcl9jZWxsLCBjZWxsQ29udGVudClcblxuICAgICAgaWYgKGhlYWRlckNlbGwpIHtcbiAgICAgICAgaGVhZGVyQ2VsbHMucHVzaChoZWFkZXJDZWxsKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJvd3M6IFByb3NlbWlycm9yTm9kZVtdID0gW11cblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcm93c0NvdW50OyBpbmRleCArPSAxKSB7XG4gICAgcm93cy5wdXNoKHR5cGVzLnJvdy5jcmVhdGVDaGVja2VkKG51bGwsIHdpdGhIZWFkZXJSb3cgJiYgaW5kZXggPT09IDAgPyBoZWFkZXJDZWxscyA6IGNlbGxzKSlcbiAgfVxuXG4gIHJldHVybiB0eXBlcy50YWJsZS5jcmVhdGVDaGVja2VkKG51bGwsIHJvd3MpXG59XG4iLCAiaW1wb3J0IHR5cGUgeyBLZXlib2FyZFNob3J0Y3V0Q29tbWFuZCB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG5pbXBvcnQgeyBpc0NlbGxTZWxlY3Rpb24gfSBmcm9tICcuL2lzQ2VsbFNlbGVjdGlvbi5qcydcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVRhYmxlV2hlbkFsbENlbGxzU2VsZWN0ZWQ6IEtleWJvYXJkU2hvcnRjdXRDb21tYW5kID0gKHsgZWRpdG9yIH0pID0+IHtcbiAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IGVkaXRvci5zdGF0ZVxuXG4gIGlmICghaXNDZWxsU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGxldCBjZWxsQ291bnQgPSAwXG4gIGNvbnN0IHRhYmxlID0gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3Moc2VsZWN0aW9uLnJhbmdlc1swXS4kZnJvbSwgbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUudHlwZS5uYW1lID09PSAndGFibGUnXG4gIH0pXG5cbiAgdGFibGU/Lm5vZGUuZGVzY2VuZGFudHMobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUudHlwZS5uYW1lID09PSAndGFibGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoWyd0YWJsZUNlbGwnLCAndGFibGVIZWFkZXInXS5pbmNsdWRlcyhub2RlLnR5cGUubmFtZSkpIHtcbiAgICAgIGNlbGxDb3VudCArPSAxXG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IGFsbENlbGxzU2VsZWN0ZWQgPSBjZWxsQ291bnQgPT09IHNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoXG5cbiAgaWYgKCFhbGxDZWxsc1NlbGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBlZGl0b3IuY29tbWFuZHMuZGVsZXRlVGFibGUoKVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgQ2VsbFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vdGFibGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gaXNDZWxsU2VsZWN0aW9uKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgQ2VsbFNlbGVjdGlvbiB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIENlbGxTZWxlY3Rpb25cbn1cbiIsICJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHRleHQgbm9kZXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL3RleHRcbiAqL1xuZXhwb3J0IGNvbnN0IFRleHQgPSBOb2RlLmNyZWF0ZSh7XG4gIG5hbWU6ICd0ZXh0JyxcbiAgZ3JvdXA6ICdpbmxpbmUnLFxufSlcbiIsICJpbXBvcnQgeyBUZXh0IH0gZnJvbSAnLi90ZXh0LmpzJ1xuXG5leHBvcnQgKiBmcm9tICcuL3RleHQuanMnXG5cbmV4cG9ydCBkZWZhdWx0IFRleHRcbiIsICJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVW5kZXJsaW5lT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBIVE1MIGF0dHJpYnV0ZXMgdG8gYWRkIHRvIHRoZSB1bmRlcmxpbmUgZWxlbWVudC5cbiAgICogQGRlZmF1bHQge31cbiAgICogQGV4YW1wbGUgeyBjbGFzczogJ2ZvbycgfVxuICAgKi9cbiAgSFRNTEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT5cbn1cblxuZGVjbGFyZSBtb2R1bGUgJ0B0aXB0YXAvY29yZScge1xuICBpbnRlcmZhY2UgQ29tbWFuZHM8UmV0dXJuVHlwZT4ge1xuICAgIHVuZGVybGluZToge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgYW4gdW5kZXJsaW5lIG1hcmtcbiAgICAgICAqIEBleGFtcGxlIGVkaXRvci5jb21tYW5kcy5zZXRVbmRlcmxpbmUoKVxuICAgICAgICovXG4gICAgICBzZXRVbmRlcmxpbmU6ICgpID0+IFJldHVyblR5cGVcbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlIGFuIHVuZGVybGluZSBtYXJrXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudG9nZ2xlVW5kZXJsaW5lKClcbiAgICAgICAqL1xuICAgICAgdG9nZ2xlVW5kZXJsaW5lOiAoKSA9PiBSZXR1cm5UeXBlXG4gICAgICAvKipcbiAgICAgICAqIFVuc2V0IGFuIHVuZGVybGluZSBtYXJrXG4gICAgICAgKiBAZXhhbXBsZSBlZGl0b3IuY29tbWFuZHMudW5zZXRVbmRlcmxpbmUoKVxuICAgICAgICovXG4gICAgICB1bnNldFVuZGVybGluZTogKCkgPT4gUmV0dXJuVHlwZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHVuZGVybGluZSB0ZXh0LlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9tYXJrcy91bmRlcmxpbmVcbiAqL1xuZXhwb3J0IGNvbnN0IFVuZGVybGluZSA9IE1hcmsuY3JlYXRlPFVuZGVybGluZU9wdGlvbnM+KHtcbiAgbmFtZTogJ3VuZGVybGluZScsXG5cbiAgYWRkT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgIH1cbiAgfSxcblxuICBwYXJzZUhUTUwoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdGFnOiAndScsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdHlsZTogJ3RleHQtZGVjb3JhdGlvbicsXG4gICAgICAgIGNvbnN1bWluZzogZmFsc2UsXG4gICAgICAgIGdldEF0dHJzOiBzdHlsZSA9PiAoKHN0eWxlIGFzIHN0cmluZykuaW5jbHVkZXMoJ3VuZGVybGluZScpID8ge30gOiBmYWxzZSksXG4gICAgICB9LFxuICAgIF1cbiAgfSxcblxuICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgIHJldHVybiBbJ3UnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdXG4gIH0sXG5cbiAgYWRkQ29tbWFuZHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldFVuZGVybGluZTpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSlcbiAgICAgICAgfSxcbiAgICAgIHRvZ2dsZVVuZGVybGluZTpcbiAgICAgICAgKCkgPT5cbiAgICAgICAgKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSlcbiAgICAgICAgfSxcbiAgICAgIHVuc2V0VW5kZXJsaW5lOlxuICAgICAgICAoKSA9PlxuICAgICAgICAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpXG4gICAgICAgIH0sXG4gICAgfVxuICB9LFxuXG4gIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnTW9kLXUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVVbmRlcmxpbmUoKSxcbiAgICAgICdNb2QtVSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVVuZGVybGluZSgpLFxuICAgIH1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHsgVW5kZXJsaW5lIH0gZnJvbSAnLi91bmRlcmxpbmUuanMnXG5cbmV4cG9ydCAqIGZyb20gJy4vdW5kZXJsaW5lLmpzJ1xuXG5leHBvcnQgZGVmYXVsdCBVbmRlcmxpbmVcbiIsICIvKipcbiAqIEN1c3RvbSBwb3NpdGlvbmluZyByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy92aXJ0dWFsLWVsZW1lbnRzXG4gKi9cblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5mdW5jdGlvbiBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSkgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIGlmIChydGwgPT09IHZvaWQgMCkge1xuICAgIHJ0bCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSAneCcgPyBhbGlnbm1lbnQgPT09IChydGwgPyAnZW5kJyA6ICdzdGFydCcpID8gJ3JpZ2h0JyA6ICdsZWZ0JyA6IGFsaWdubWVudCA9PT0gJ3N0YXJ0JyA/ICdib3R0b20nIDogJ3RvcCc7XG4gIGlmIChyZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSA+IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF0pIHtcbiAgICBtYWluQWxpZ25tZW50U2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKTtcbiAgfVxuICByZXR1cm4gW21haW5BbGlnbm1lbnRTaWRlLCBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSldO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBjb25zdCBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgYWxpZ25tZW50ID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuZnVuY3Rpb24gZ2V0U2lkZUxpc3Qoc2lkZSwgaXNTdGFydCwgcnRsKSB7XG4gIGNvbnN0IGxyID0gWydsZWZ0JywgJ3JpZ2h0J107XG4gIGNvbnN0IHJsID0gWydyaWdodCcsICdsZWZ0J107XG4gIGNvbnN0IHRiID0gWyd0b3AnLCAnYm90dG9tJ107XG4gIGNvbnN0IGJ0ID0gWydib3R0b20nLCAndG9wJ107XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGlmIChydGwpIHJldHVybiBpc1N0YXJ0ID8gcmwgOiBscjtcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gbHIgOiBybDtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICByZXR1cm4gaXNTdGFydCA/IHRiIDogYnQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhwbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGRpcmVjdGlvbiwgcnRsKSB7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBsZXQgbGlzdCA9IGdldFNpZGVMaXN0KGdldFNpZGUocGxhY2VtZW50KSwgZGlyZWN0aW9uID09PSAnc3RhcnQnLCBydGwpO1xuICBpZiAoYWxpZ25tZW50KSB7XG4gICAgbGlzdCA9IGxpc3QubWFwKHNpZGUgPT4gc2lkZSArIFwiLVwiICsgYWxpZ25tZW50KTtcbiAgICBpZiAoZmxpcEFsaWdubWVudCkge1xuICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KGxpc3QubWFwKGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0O1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIHNpZGUgPT4gb3Bwb3NpdGVTaWRlTWFwW3NpZGVdKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykgOiB7XG4gICAgdG9wOiBwYWRkaW5nLFxuICAgIHJpZ2h0OiBwYWRkaW5nLFxuICAgIGJvdHRvbTogcGFkZGluZyxcbiAgICBsZWZ0OiBwYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHJlY3Q7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICBsZWZ0OiB4LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5leHBvcnQgeyBhbGlnbm1lbnRzLCBjbGFtcCwgY3JlYXRlQ29vcmRzLCBldmFsdWF0ZSwgZXhwYW5kUGFkZGluZ09iamVjdCwgZmxvb3IsIGdldEFsaWdubWVudCwgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldEF4aXNMZW5ndGgsIGdldEV4cGFuZGVkUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQsIGdldE9wcG9zaXRlQXhpcywgZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQsIGdldFBhZGRpbmdPYmplY3QsIGdldFNpZGUsIGdldFNpZGVBeGlzLCBtYXgsIG1pbiwgcGxhY2VtZW50cywgcmVjdFRvQ2xpZW50UmVjdCwgcm91bmQsIHNpZGVzIH07XG4iLCAiaW1wb3J0IHsgZ2V0U2lkZUF4aXMsIGdldEFsaWdubWVudEF4aXMsIGdldEF4aXNMZW5ndGgsIGdldFNpZGUsIGdldEFsaWdubWVudCwgZXZhbHVhdGUsIGdldFBhZGRpbmdPYmplY3QsIHJlY3RUb0NsaWVudFJlY3QsIG1pbiwgY2xhbXAsIHBsYWNlbWVudHMsIGdldEFsaWdubWVudFNpZGVzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQsIGdldEV4cGFuZGVkUGxhY2VtZW50cywgZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cywgc2lkZXMsIG1heCwgZ2V0T3Bwb3NpdGVBeGlzIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmV4cG9ydCB7IHJlY3RUb0NsaWVudFJlY3QgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuXG5mdW5jdGlvbiBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChfcmVmLCBwbGFjZW1lbnQsIHJ0bCkge1xuICBsZXQge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9ID0gX3JlZjtcbiAgY29uc3Qgc2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbkxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYWxpZ25tZW50QXhpcyk7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBzaWRlQXhpcyA9PT0gJ3knO1xuICBjb25zdCBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZmxvYXRpbmcud2lkdGggLyAyO1xuICBjb25zdCBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGZsb2F0aW5nLmhlaWdodCAvIDI7XG4gIGNvbnN0IGNvbW1vbkFsaWduID0gcmVmZXJlbmNlW2FsaWduTGVuZ3RoXSAvIDIgLSBmbG9hdGluZ1thbGlnbkxlbmd0aF0gLyAyO1xuICBsZXQgY29vcmRzO1xuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGZsb2F0aW5nLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBmbG9hdGluZy53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuICBzd2l0Y2ggKGdldEFsaWdubWVudChwbGFjZW1lbnQpKSB7XG4gICAgY2FzZSAnc3RhcnQnOlxuICAgICAgY29vcmRzW2FsaWdubWVudEF4aXNdIC09IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuZCc6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gKz0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGNvb3Jkcztcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgZ2l2ZW4gcmVmZXJlbmNlIGVsZW1lbnQuXG4gKlxuICogVGhpcyBleHBvcnQgZG9lcyBub3QgaGF2ZSBhbnkgYHBsYXRmb3JtYCBpbnRlcmZhY2UgbG9naWMuIFlvdSB3aWxsIG5lZWQgdG9cbiAqIHdyaXRlIG9uZSBmb3IgdGhlIHBsYXRmb3JtIHlvdSBhcmUgdXNpbmcgRmxvYXRpbmcgVUkgd2l0aC5cbiAqL1xuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gYXN5bmMgKHJlZmVyZW5jZSwgZmxvYXRpbmcsIGNvbmZpZykgPT4ge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gJ2JvdHRvbScsXG4gICAgc3RyYXRlZ3kgPSAnYWJzb2x1dGUnLFxuICAgIG1pZGRsZXdhcmUgPSBbXSxcbiAgICBwbGF0Zm9ybVxuICB9ID0gY29uZmlnO1xuICBjb25zdCB2YWxpZE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChmbG9hdGluZykpO1xuICBsZXQgcmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZyxcbiAgICBzdHJhdGVneVxuICB9KTtcbiAgbGV0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBwbGFjZW1lbnQsIHJ0bCk7XG4gIGxldCBzdGF0ZWZ1bFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgbGV0IG1pZGRsZXdhcmVEYXRhID0ge307XG4gIGxldCByZXNldENvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZE1pZGRsZXdhcmUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgZm5cbiAgICB9ID0gdmFsaWRNaWRkbGV3YXJlW2ldO1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IG5leHRYLFxuICAgICAgeTogbmV4dFksXG4gICAgICBkYXRhLFxuICAgICAgcmVzZXRcbiAgICB9ID0gYXdhaXQgZm4oe1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBpbml0aWFsUGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgICAgc3RyYXRlZ3ksXG4gICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSk7XG4gICAgeCA9IG5leHRYICE9IG51bGwgPyBuZXh0WCA6IHg7XG4gICAgeSA9IG5leHRZICE9IG51bGwgPyBuZXh0WSA6IHk7XG4gICAgbWlkZGxld2FyZURhdGEgPSB7XG4gICAgICAuLi5taWRkbGV3YXJlRGF0YSxcbiAgICAgIFtuYW1lXToge1xuICAgICAgICAuLi5taWRkbGV3YXJlRGF0YVtuYW1lXSxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHJlc2V0ICYmIHJlc2V0Q291bnQgPD0gNTApIHtcbiAgICAgIHJlc2V0Q291bnQrKztcbiAgICAgIGlmICh0eXBlb2YgcmVzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChyZXNldC5wbGFjZW1lbnQpIHtcbiAgICAgICAgICBzdGF0ZWZ1bFBsYWNlbWVudCA9IHJlc2V0LnBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZXQucmVjdHMpIHtcbiAgICAgICAgICByZWN0cyA9IHJlc2V0LnJlY3RzID09PSB0cnVlID8gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICAgIGZsb2F0aW5nLFxuICAgICAgICAgICAgc3RyYXRlZ3lcbiAgICAgICAgICB9KSA6IHJlc2V0LnJlY3RzO1xuICAgICAgICB9XG4gICAgICAgICh7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgc3RhdGVmdWxQbGFjZW1lbnQsIHJ0bCkpO1xuICAgICAgfVxuICAgICAgaSA9IC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgIHN0cmF0ZWd5LFxuICAgIG1pZGRsZXdhcmVEYXRhXG4gIH07XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IG9mIG92ZXJmbG93IHNpZGUgb2Zmc2V0cyB0aGF0IGRldGVybWluZSBob3cgbXVjaCB0aGVcbiAqIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgYSBnaXZlbiBjbGlwcGluZyBib3VuZGFyeSBvbiBlYWNoIHNpZGUuXG4gKiAtIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGJvdW5kYXJ5IGJ5IHRoYXQgbnVtYmVyIG9mIHBpeGVsc1xuICogLSBuZWdhdGl2ZSA9IGhvdyBtYW55IHBpeGVscyBsZWZ0IGJlZm9yZSBpdCB3aWxsIG92ZXJmbG93XG4gKiAtIDAgPSBsaWVzIGZsdXNoIHdpdGggdGhlIGJvdW5kYXJ5XG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZGV0ZWN0T3ZlcmZsb3dcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgdmFyIF9hd2FpdCRwbGF0Zm9ybSRpc0VsZTtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYXRmb3JtLFxuICAgIHJlY3RzLFxuICAgIGVsZW1lbnRzLFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBzdGF0ZTtcbiAgY29uc3Qge1xuICAgIGJvdW5kYXJ5ID0gJ2NsaXBwaW5nQW5jZXN0b3JzJyxcbiAgICByb290Qm91bmRhcnkgPSAndmlld3BvcnQnLFxuICAgIGVsZW1lbnRDb250ZXh0ID0gJ2Zsb2F0aW5nJyxcbiAgICBhbHRCb3VuZGFyeSA9IGZhbHNlLFxuICAgIHBhZGRpbmcgPSAwXG4gIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICBjb25zdCBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyAncmVmZXJlbmNlJyA6ICdmbG9hdGluZyc7XG4gIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIGNvbnN0IGNsaXBwaW5nQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoYXdhaXQgcGxhdGZvcm0uZ2V0Q2xpcHBpbmdSZWN0KHtcbiAgICBlbGVtZW50OiAoKF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA9IGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChlbGVtZW50KSkpICE9IG51bGwgPyBfYXdhaXQkcGxhdGZvcm0kaXNFbGUgOiB0cnVlKSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IChhd2FpdCAocGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpKSksXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0pKTtcbiAgY29uc3QgcmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8ge1xuICAgIHgsXG4gICAgeSxcbiAgICB3aWR0aDogcmVjdHMuZmxvYXRpbmcud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0cy5mbG9hdGluZy5oZWlnaHRcbiAgfSA6IHJlY3RzLnJlZmVyZW5jZTtcbiAgY29uc3Qgb2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gIGNvbnN0IG9mZnNldFNjYWxlID0gKGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSkgPyAoYXdhaXQgKHBsYXRmb3JtLmdldFNjYWxlID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRTY2FsZShvZmZzZXRQYXJlbnQpKSkgfHwge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9IDoge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9O1xuICBjb25zdCBlbGVtZW50Q2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QocGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QgPyBhd2FpdCBwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCh7XG4gICAgZWxlbWVudHMsXG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSkgOiByZWN0KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IChjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3ApIC8gb2Zmc2V0U2NhbGUueSxcbiAgICBib3R0b206IChlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIC8gb2Zmc2V0U2NhbGUueSxcbiAgICBsZWZ0OiAoY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0KSAvIG9mZnNldFNjYWxlLngsXG4gICAgcmlnaHQ6IChlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQpIC8gb2Zmc2V0U2NhbGUueFxuICB9O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IG9wdGlvbnMgPT4gKHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgb3B0aW9ucyxcbiAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgfSA9IHN0YXRlO1xuICAgIC8vIFNpbmNlIGBlbGVtZW50YCBpcyByZXF1aXJlZCwgd2UgZG9uJ3QgUGFydGlhbDw+IHRoZSB0eXBlLlxuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwYWRkaW5nID0gMFxuICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSkgfHwge307XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gICAgY29uc3QgYXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGF4aXMpO1xuICAgIGNvbnN0IGFycm93RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudCk7XG4gICAgY29uc3QgaXNZQXhpcyA9IGF4aXMgPT09ICd5JztcbiAgICBjb25zdCBtaW5Qcm9wID0gaXNZQXhpcyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgIGNvbnN0IG1heFByb3AgPSBpc1lBeGlzID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgIGNvbnN0IGNsaWVudFByb3AgPSBpc1lBeGlzID8gJ2NsaWVudEhlaWdodCcgOiAnY2xpZW50V2lkdGgnO1xuICAgIGNvbnN0IGVuZERpZmYgPSByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSArIHJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIGNvb3Jkc1theGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgY29uc3Qgc3RhcnREaWZmID0gY29vcmRzW2F4aXNdIC0gcmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICAgIGNvbnN0IGFycm93T2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpKTtcbiAgICBsZXQgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXJyb3dPZmZzZXRQYXJlbnRbY2xpZW50UHJvcF0gOiAwO1xuXG4gICAgLy8gRE9NIHBsYXRmb3JtIGNhbiByZXR1cm4gYHdpbmRvd2AgYXMgdGhlIGBvZmZzZXRQYXJlbnRgLlxuICAgIGlmICghY2xpZW50U2l6ZSB8fCAhKGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChhcnJvd09mZnNldFBhcmVudCkpKSkge1xuICAgICAgY2xpZW50U2l6ZSA9IGVsZW1lbnRzLmZsb2F0aW5nW2NsaWVudFByb3BdIHx8IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgfVxuICAgIGNvbnN0IGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyO1xuXG4gICAgLy8gSWYgdGhlIHBhZGRpbmcgaXMgbGFyZ2UgZW5vdWdoIHRoYXQgaXQgY2F1c2VzIHRoZSBhcnJvdyB0byBubyBsb25nZXIgYmVcbiAgICAvLyBjZW50ZXJlZCwgbW9kaWZ5IHRoZSBwYWRkaW5nIHNvIHRoYXQgaXQgaXMgY2VudGVyZWQuXG4gICAgY29uc3QgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIC0gMTtcbiAgICBjb25zdCBtaW5QYWRkaW5nID0gbWluKHBhZGRpbmdPYmplY3RbbWluUHJvcF0sIGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcpO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttYXhQcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaWYgdGhlIGNlbnRlclxuICAgIC8vIHBvaW50IGlzIG91dHNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQncyBib3VuZHMuXG4gICAgY29uc3QgbWluJDEgPSBtaW5QYWRkaW5nO1xuICAgIGNvbnN0IG1heCA9IGNsaWVudFNpemUgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAtIG1heFBhZGRpbmc7XG4gICAgY29uc3QgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgICBjb25zdCBvZmZzZXQgPSBjbGFtcChtaW4kMSwgY2VudGVyLCBtYXgpO1xuXG4gICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbCBlbm91Z2ggdGhhdCB0aGUgYXJyb3cncyBwYWRkaW5nIGNhdXNlcyBpdCB0b1xuICAgIC8vIHRvIHBvaW50IHRvIG5vdGhpbmcgZm9yIGFuIGFsaWduZWQgcGxhY2VtZW50LCBhZGp1c3QgdGhlIG9mZnNldCBvZiB0aGVcbiAgICAvLyBmbG9hdGluZyBlbGVtZW50IGl0c2VsZi4gVG8gZW5zdXJlIGBzaGlmdCgpYCBjb250aW51ZXMgdG8gdGFrZSBhY3Rpb24sXG4gICAgLy8gYSBzaW5nbGUgcmVzZXQgaXMgcGVyZm9ybWVkIHdoZW4gdGhpcyBpcyB0cnVlLlxuICAgIGNvbnN0IHNob3VsZEFkZE9mZnNldCA9ICFtaWRkbGV3YXJlRGF0YS5hcnJvdyAmJiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSAhPSBudWxsICYmIGNlbnRlciAhPT0gb2Zmc2V0ICYmIHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdIC8gMiAtIChjZW50ZXIgPCBtaW4kMSA/IG1pblBhZGRpbmcgOiBtYXhQYWRkaW5nKSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiA8IDA7XG4gICAgY29uc3QgYWxpZ25tZW50T2Zmc2V0ID0gc2hvdWxkQWRkT2Zmc2V0ID8gY2VudGVyIDwgbWluJDEgPyBjZW50ZXIgLSBtaW4kMSA6IGNlbnRlciAtIG1heCA6IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtheGlzXTogY29vcmRzW2F4aXNdICsgYWxpZ25tZW50T2Zmc2V0LFxuICAgICAgZGF0YToge1xuICAgICAgICBbYXhpc106IG9mZnNldCxcbiAgICAgICAgY2VudGVyT2Zmc2V0OiBjZW50ZXIgLSBvZmZzZXQgLSBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICAgIC4uLihzaG91bGRBZGRPZmZzZXQgJiYge1xuICAgICAgICAgIGFsaWdubWVudE9mZnNldFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHJlc2V0OiBzaG91bGRBZGRPZmZzZXRcbiAgICB9O1xuICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0UGxhY2VtZW50TGlzdChhbGlnbm1lbnQsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSB7XG4gIGNvbnN0IGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQgPSBhbGlnbm1lbnQgPyBbLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSA9PT0gYWxpZ25tZW50KSwgLi4uYWxsb3dlZFBsYWNlbWVudHMuZmlsdGVyKHBsYWNlbWVudCA9PiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSAhPT0gYWxpZ25tZW50KV0gOiBhbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldFNpZGUocGxhY2VtZW50KSA9PT0gcGxhY2VtZW50KTtcbiAgcmV0dXJuIGFsbG93ZWRQbGFjZW1lbnRzU29ydGVkQnlBbGlnbm1lbnQuZmlsdGVyKHBsYWNlbWVudCA9PiB7XG4gICAgaWYgKGFsaWdubWVudCkge1xuICAgICAgcmV0dXJuIGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQgfHwgKGF1dG9BbGlnbm1lbnQgPyBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpICE9PSBwbGFjZW1lbnQgOiBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhdXRvUGxhY2VtZW50JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGF1dG9QLCBfbWlkZGxld2FyZURhdGEkYXV0b1AyLCBfcGxhY2VtZW50c1RoYXRGaXRPbkU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3Jvc3NBeGlzID0gZmFsc2UsXG4gICAgICAgIGFsaWdubWVudCxcbiAgICAgICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLFxuICAgICAgICBhdXRvQWxpZ25tZW50ID0gdHJ1ZSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgcGxhY2VtZW50cyQxID0gYWxpZ25tZW50ICE9PSB1bmRlZmluZWQgfHwgYWxsb3dlZFBsYWNlbWVudHMgPT09IHBsYWNlbWVudHMgPyBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCB8fCBudWxsLCBhdXRvQWxpZ25tZW50LCBhbGxvd2VkUGxhY2VtZW50cykgOiBhbGxvd2VkUGxhY2VtZW50cztcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSAoKF9taWRkbGV3YXJlRGF0YSRhdXRvUCA9IG1pZGRsZXdhcmVEYXRhLmF1dG9QbGFjZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkYXV0b1AuaW5kZXgpIHx8IDA7XG4gICAgICBjb25zdCBjdXJyZW50UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleF07XG4gICAgICBpZiAoY3VycmVudFBsYWNlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsaWdubWVudFNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMoY3VycmVudFBsYWNlbWVudCwgcmVjdHMsIGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSk7XG5cbiAgICAgIC8vIE1ha2UgYGNvbXB1dGVDb29yZHNgIHN0YXJ0IGZyb20gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgaWYgKHBsYWNlbWVudCAhPT0gY3VycmVudFBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudHMkMVswXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRPdmVyZmxvd3MgPSBbb3ZlcmZsb3dbZ2V0U2lkZShjdXJyZW50UGxhY2VtZW50KV0sIG92ZXJmbG93W2FsaWdubWVudFNpZGVzWzBdXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMV1dXTtcbiAgICAgIGNvbnN0IGFsbE92ZXJmbG93cyA9IFsuLi4oKChfbWlkZGxld2FyZURhdGEkYXV0b1AyID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUDIub3ZlcmZsb3dzKSB8fCBbXSksIHtcbiAgICAgICAgcGxhY2VtZW50OiBjdXJyZW50UGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3M6IGN1cnJlbnRPdmVyZmxvd3NcbiAgICAgIH1dO1xuICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHMkMVtjdXJyZW50SW5kZXggKyAxXTtcblxuICAgICAgLy8gVGhlcmUgYXJlIG1vcmUgcGxhY2VtZW50cyB0byBjaGVjay5cbiAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaW5kZXg6IGN1cnJlbnRJbmRleCArIDEsXG4gICAgICAgICAgICBvdmVyZmxvd3M6IGFsbE92ZXJmbG93c1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogbmV4dFBsYWNlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHNTb3J0ZWRCeU1vc3RTcGFjZSA9IGFsbE92ZXJmbG93cy5tYXAoZCA9PiB7XG4gICAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChkLnBsYWNlbWVudCk7XG4gICAgICAgIHJldHVybiBbZC5wbGFjZW1lbnQsIGFsaWdubWVudCAmJiBjcm9zc0F4aXMgP1xuICAgICAgICAvLyBDaGVjayBhbG9uZyB0aGUgbWFpbkF4aXMgYW5kIG1haW4gY3Jvc3NBeGlzIHNpZGUuXG4gICAgICAgIGQub3ZlcmZsb3dzLnNsaWNlKDAsIDIpLnJlZHVjZSgoYWNjLCB2KSA9PiBhY2MgKyB2LCAwKSA6XG4gICAgICAgIC8vIENoZWNrIG9ubHkgdGhlIG1haW5BeGlzLlxuICAgICAgICBkLm92ZXJmbG93c1swXSwgZC5vdmVyZmxvd3NdO1xuICAgICAgfSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pO1xuICAgICAgY29uc3QgcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlID0gcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlLmZpbHRlcihkID0+IGRbMl0uc2xpY2UoMCxcbiAgICAgIC8vIEFsaWduZWQgcGxhY2VtZW50cyBzaG91bGQgbm90IGNoZWNrIHRoZWlyIG9wcG9zaXRlIGNyb3NzQXhpc1xuICAgICAgLy8gc2lkZS5cbiAgICAgIGdldEFsaWdubWVudChkWzBdKSA/IDIgOiAzKS5ldmVyeSh2ID0+IHYgPD0gMCkpO1xuICAgICAgY29uc3QgcmVzZXRQbGFjZW1lbnQgPSAoKF9wbGFjZW1lbnRzVGhhdEZpdE9uRSA9IHBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbGFjZW1lbnRzVGhhdEZpdE9uRVswXSkgfHwgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlWzBdWzBdO1xuICAgICAgaWYgKHJlc2V0UGxhY2VtZW50ICE9PSBwbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnZmxpcCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRhcnJvdywgX21pZGRsZXdhcmVEYXRhJGZsaXA7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBpbml0aWFsUGxhY2VtZW50LFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZSxcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICAgIGZhbGxiYWNrU3RyYXRlZ3kgPSAnYmVzdEZpdCcsXG4gICAgICAgIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSAnbm9uZScsXG4gICAgICAgIGZsaXBBbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG5cbiAgICAgIC8vIElmIGEgcmVzZXQgYnkgdGhlIGFycm93IHdhcyBjYXVzZWQgZHVlIHRvIGFuIGFsaWdubWVudCBvZmZzZXQgYmVpbmdcbiAgICAgIC8vIGFkZGVkLCB3ZSBzaG91bGQgc2tpcCBhbnkgbG9naWMgbm93IHNpbmNlIGBmbGlwKClgIGhhcyBhbHJlYWR5IGRvbmUgaXRzXG4gICAgICAvLyB3b3JrLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNTQ5I2lzc3VlY29tbWVudC0xNzE5NjAxNjQzXG4gICAgICBpZiAoKF9taWRkbGV3YXJlRGF0YSRhcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93KSAhPSBudWxsICYmIF9taWRkbGV3YXJlRGF0YSRhcnJvdy5hbGlnbm1lbnRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGluaXRpYWxTaWRlQXhpcyA9IGdldFNpZGVBeGlzKGluaXRpYWxQbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNCYXNlUGxhY2VtZW50ID0gZ2V0U2lkZShpbml0aWFsUGxhY2VtZW50KSA9PT0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwQWxpZ25tZW50ID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KGluaXRpYWxQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50KSk7XG4gICAgICBjb25zdCBoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uID0gZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiAhPT0gJ25vbmUnO1xuICAgICAgaWYgKCFzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgJiYgaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbikge1xuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHMucHVzaCguLi5nZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24sIHJ0bCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50cyA9IFtpbml0aWFsUGxhY2VtZW50LCAuLi5mYWxsYmFja1BsYWNlbWVudHNdO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93cyA9IFtdO1xuICAgICAgbGV0IG92ZXJmbG93c0RhdGEgPSAoKF9taWRkbGV3YXJlRGF0YSRmbGlwID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwLm92ZXJmbG93cykgfHwgW107XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlXSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3Qgc2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpO1xuICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlc1swXV0sIG92ZXJmbG93W3NpZGVzWzFdXSk7XG4gICAgICB9XG4gICAgICBvdmVyZmxvd3NEYXRhID0gWy4uLm92ZXJmbG93c0RhdGEsIHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBvdmVyZmxvd3NcbiAgICAgIH1dO1xuXG4gICAgICAvLyBPbmUgb3IgbW9yZSBzaWRlcyBpcyBvdmVyZmxvd2luZy5cbiAgICAgIGlmICghb3ZlcmZsb3dzLmV2ZXJ5KHNpZGUgPT4gc2lkZSA8PSAwKSkge1xuICAgICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGZsaXAyLCBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXI7XG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9ICgoKF9taWRkbGV3YXJlRGF0YSRmbGlwMiA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcDIuaW5kZXgpIHx8IDApICsgMTtcbiAgICAgICAgY29uc3QgbmV4dFBsYWNlbWVudCA9IHBsYWNlbWVudHNbbmV4dEluZGV4XTtcbiAgICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCBpZ25vcmVDcm9zc0F4aXNPdmVyZmxvdyA9IGNoZWNrQ3Jvc3NBeGlzID09PSAnYWxpZ25tZW50JyA/IGluaXRpYWxTaWRlQXhpcyAhPT0gZ2V0U2lkZUF4aXMobmV4dFBsYWNlbWVudCkgOiBmYWxzZTtcbiAgICAgICAgICBpZiAoIWlnbm9yZUNyb3NzQXhpc092ZXJmbG93IHx8XG4gICAgICAgICAgLy8gV2UgbGVhdmUgdGhlIGN1cnJlbnQgbWFpbiBheGlzIG9ubHkgaWYgZXZlcnkgcGxhY2VtZW50IG9uIHRoYXQgYXhpc1xuICAgICAgICAgIC8vIG92ZXJmbG93cyB0aGUgbWFpbiBheGlzLlxuICAgICAgICAgIG92ZXJmbG93c0RhdGEuZXZlcnkoZCA9PiBkLm92ZXJmbG93c1swXSA+IDAgJiYgZ2V0U2lkZUF4aXMoZC5wbGFjZW1lbnQpID09PSBpbml0aWFsU2lkZUF4aXMpKSB7XG4gICAgICAgICAgICAvLyBUcnkgbmV4dCBwbGFjZW1lbnQgYW5kIHJlLXJ1biB0aGUgbGlmZWN5Y2xlLlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBvdmVyZmxvd3NEYXRhXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGZpbmQgdGhlIGNhbmRpZGF0ZXMgdGhhdCBmaXQgb24gdGhlIG1haW5BeGlzIHNpZGUgb2Ygb3ZlcmZsb3csXG4gICAgICAgIC8vIHRoZW4gZmluZCB0aGUgcGxhY2VtZW50IHRoYXQgZml0cyB0aGUgYmVzdCBvbiB0aGUgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlciA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4gZC5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMV0gLSBiLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmYWxsYmFjay5cbiAgICAgICAgaWYgKCFyZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkZmlsdGVyMjtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyMiA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoZC5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudFNpZGVBeGlzID09PSBpbml0aWFsU2lkZUF4aXMgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgYmlhcyB0byB0aGUgYHlgIHNpZGUgYXhpcyBkdWUgdG8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkaW5nIGRpcmVjdGlvbnMgZmF2b3JpbmcgZ3JlYXRlciB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpZGVBeGlzID09PSAneSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KS5tYXAoZCA9PiBbZC5wbGFjZW1lbnQsIGQub3ZlcmZsb3dzLmZpbHRlcihvdmVyZmxvdyA9PiBvdmVyZmxvdyA+IDApLnJlZHVjZSgoYWNjLCBvdmVyZmxvdykgPT4gYWNjICsgb3ZlcmZsb3csIDApXSkuc29ydCgoYSwgYikgPT4gYVsxXSAtIGJbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX292ZXJmbG93c0RhdGEkZmlsdGVyMlswXTtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxQbGFjZW1lbnQnOlxuICAgICAgICAgICAgICByZXNldFBsYWNlbWVudCA9IGluaXRpYWxQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQsXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gc2lkZXMuc29tZShzaWRlID0+IG92ZXJmbG93W3NpZGVdID49IDApO1xufVxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RyYXRlZ3kgPSAncmVmZXJlbmNlSGlkZGVuJyxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgICAgICBjYXNlICdyZWZlcmVuY2VIaWRkZW4nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbk9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VzY2FwZWQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLmZsb2F0aW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICBlc2NhcGVkOiBpc0FueVNpZGVGdWxseUNsaXBwZWQob2Zmc2V0cylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ1JlY3QocmVjdHMpIHtcbiAgY29uc3QgbWluWCA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgY29uc3QgbWluWSA9IG1pbiguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnRvcCkpO1xuICBjb25zdCBtYXhYID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgY29uc3QgbWF4WSA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LmJvdHRvbSkpO1xuICByZXR1cm4ge1xuICAgIHg6IG1pblgsXG4gICAgeTogbWluWSxcbiAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgaGVpZ2h0OiBtYXhZIC0gbWluWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjdHNCeUxpbmUocmVjdHMpIHtcbiAgY29uc3Qgc29ydGVkUmVjdHMgPSByZWN0cy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGEueSAtIGIueSk7XG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuICBsZXQgcHJldlJlY3QgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmVjdCA9IHNvcnRlZFJlY3RzW2ldO1xuICAgIGlmICghcHJldlJlY3QgfHwgcmVjdC55IC0gcHJldlJlY3QueSA+IHByZXZSZWN0LmhlaWdodCAvIDIpIHtcbiAgICAgIGdyb3Vwcy5wdXNoKFtyZWN0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3Vwc1tncm91cHMubGVuZ3RoIC0gMV0ucHVzaChyZWN0KTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSByZWN0O1xuICB9XG4gIHJldHVybiBncm91cHMubWFwKHJlY3QgPT4gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QocmVjdCkpKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaW5saW5lJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIC8vIEEgTW91c2VFdmVudCdzIGNsaWVudHtYLFl9IGNvb3JkcyBjYW4gYmUgdXAgdG8gMiBwaXhlbHMgb2ZmIGFcbiAgICAgIC8vIENsaWVudFJlY3QncyBib3VuZHMsIGRlc3BpdGUgdGhlIGV2ZW50IGxpc3RlbmVyIGJlaW5nIHRyaWdnZXJlZC4gQVxuICAgICAgLy8gcGFkZGluZyBvZiAyIHNlZW1zIHRvIGhhbmRsZSB0aGlzIGlzc3VlLlxuICAgICAgY29uc3Qge1xuICAgICAgICBwYWRkaW5nID0gMixcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZUNsaWVudFJlY3RzID0gQXJyYXkuZnJvbSgoYXdhaXQgKHBsYXRmb3JtLmdldENsaWVudFJlY3RzID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyhlbGVtZW50cy5yZWZlcmVuY2UpKSkgfHwgW10pO1xuICAgICAgY29uc3QgY2xpZW50UmVjdHMgPSBnZXRSZWN0c0J5TGluZShuYXRpdmVDbGllbnRSZWN0cyk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KG5hdGl2ZUNsaWVudFJlY3RzKSk7XG4gICAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICAgIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHR3byByZWN0cyBhbmQgdGhleSBhcmUgZGlzam9pbmVkLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID09PSAyICYmIGNsaWVudFJlY3RzWzBdLmxlZnQgPiBjbGllbnRSZWN0c1sxXS5yaWdodCAmJiB4ICE9IG51bGwgJiYgeSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgcmVjdCBpbiB3aGljaCB0aGUgcG9pbnQgaXMgZnVsbHkgaW5zaWRlLlxuICAgICAgICAgIHJldHVybiBjbGllbnRSZWN0cy5maW5kKHJlY3QgPT4geCA+IHJlY3QubGVmdCAtIHBhZGRpbmdPYmplY3QubGVmdCAmJiB4IDwgcmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQgJiYgeSA+IHJlY3QudG9wIC0gcGFkZGluZ09iamVjdC50b3AgJiYgeSA8IHJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIHx8IGZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgYXJlIDIgb3IgbW9yZSBjb25uZWN0ZWQgcmVjdHMuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGlmIChnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneScpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGlzVG9wID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAndG9wJztcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGZpcnN0UmVjdC50b3A7XG4gICAgICAgICAgICBjb25zdCBib3R0b20gPSBsYXN0UmVjdC5ib3R0b207XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gaXNUb3AgPyBmaXJzdFJlY3QubGVmdCA6IGxhc3RSZWN0LmxlZnQ7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGlzVG9wID8gZmlyc3RSZWN0LnJpZ2h0IDogbGFzdFJlY3QucmlnaHQ7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpc0xlZnRTaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpID09PSAnbGVmdCc7XG4gICAgICAgICAgY29uc3QgbWF4UmlnaHQgPSBtYXgoLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICAgICAgICAgIGNvbnN0IG1pbkxlZnQgPSBtaW4oLi4uY2xpZW50UmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gICAgICAgICAgY29uc3QgbWVhc3VyZVJlY3RzID0gY2xpZW50UmVjdHMuZmlsdGVyKHJlY3QgPT4gaXNMZWZ0U2lkZSA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0KTtcbiAgICAgICAgICBjb25zdCB0b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSBtaW5MZWZ0O1xuICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbWF4UmlnaHQ7XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc2V0UmVjdHMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRpbmc6IGVsZW1lbnRzLmZsb2F0aW5nLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjdHMucmVmZXJlbmNlLnggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnggfHwgcmVjdHMucmVmZXJlbmNlLnkgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLnkgfHwgcmVjdHMucmVmZXJlbmNlLndpZHRoICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS53aWR0aCB8fCByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHJlc2V0UmVjdHNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuLy8gRm9yIHR5cGUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIHRoZSBgT2Zmc2V0T3B0aW9uc2AgdHlwZSB3YXMgYWxzb1xuLy8gRGVyaXZhYmxlLlxuXG5hc3luYyBmdW5jdGlvbiBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50LFxuICAgIHBsYXRmb3JtLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBzdGF0ZTtcbiAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgY29uc3QgbWFpbkF4aXNNdWx0aSA9IFsnbGVmdCcsICd0b3AnXS5pbmNsdWRlcyhzaWRlKSA/IC0xIDogMTtcbiAgY29uc3QgY3Jvc3NBeGlzTXVsdGkgPSBydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMTtcbiAgY29uc3QgcmF3VmFsdWUgPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge1xuICAgIG1haW5BeGlzLFxuICAgIGNyb3NzQXhpcyxcbiAgICBhbGlnbm1lbnRBeGlzXG4gIH0gPSB0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZSxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbFxuICB9IDoge1xuICAgIG1haW5BeGlzOiByYXdWYWx1ZS5tYWluQXhpcyB8fCAwLFxuICAgIGNyb3NzQXhpczogcmF3VmFsdWUuY3Jvc3NBeGlzIHx8IDAsXG4gICAgYWxpZ25tZW50QXhpczogcmF3VmFsdWUuYWxpZ25tZW50QXhpc1xuICB9O1xuICBpZiAoYWxpZ25tZW50ICYmIHR5cGVvZiBhbGlnbm1lbnRBeGlzID09PSAnbnVtYmVyJykge1xuICAgIGNyb3NzQXhpcyA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyBhbGlnbm1lbnRBeGlzICogLTEgOiBhbGlnbm1lbnRBeGlzO1xuICB9XG4gIHJldHVybiBpc1ZlcnRpY2FsID8ge1xuICAgIHg6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpLFxuICAgIHk6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aVxuICB9IDoge1xuICAgIHg6IG1haW5BeGlzICogbWFpbkF4aXNNdWx0aSxcbiAgICB5OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aVxuICB9O1xufVxuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkYXJyb3c7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IGRpZmZDb29yZHMgPSBhd2FpdCBjb252ZXJ0VmFsdWVUb0Nvb3JkcyhzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIElmIHRoZSBwbGFjZW1lbnQgaXMgdGhlIHNhbWUgYW5kIHRoZSBhcnJvdyBjYXVzZWQgYW4gYWxpZ25tZW50IG9mZnNldFxuICAgICAgLy8gdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGNoYW5nZSB0aGUgcG9zaXRpb25pbmcgY29vcmRpbmF0ZXMuXG4gICAgICBpZiAocGxhY2VtZW50ID09PSAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZS5wbGFjZW1lbnQpICYmIChfbWlkZGxld2FyZURhdGEkYXJyb3cgPSBtaWRkbGV3YXJlRGF0YS5hcnJvdykgIT0gbnVsbCAmJiBfbWlkZGxld2FyZURhdGEkYXJyb3cuYWxpZ25tZW50T2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKyBkaWZmQ29vcmRzLngsXG4gICAgICAgIHk6IHkgKyBkaWZmQ29vcmRzLnksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5kaWZmQ29vcmRzLFxuICAgICAgICAgIHBsYWNlbWVudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnc2hpZnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gdHJ1ZSxcbiAgICAgICAgY3Jvc3NBeGlzOiBjaGVja0Nyb3NzQXhpcyA9IGZhbHNlLFxuICAgICAgICBsaW1pdGVyID0ge1xuICAgICAgICAgIGZuOiBfcmVmID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH0gPSBfcmVmO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBjcm9zc0F4aXMgPSBnZXRTaWRlQXhpcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgY29uc3QgbWFpbkF4aXMgPSBnZXRPcHBvc2l0ZUF4aXMoY3Jvc3NBeGlzKTtcbiAgICAgIGxldCBtYWluQXhpc0Nvb3JkID0gY29vcmRzW21haW5BeGlzXTtcbiAgICAgIGxldCBjcm9zc0F4aXNDb29yZCA9IGNvb3Jkc1tjcm9zc0F4aXNdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IG1haW5BeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IG1haW5BeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXTtcbiAgICAgICAgY29uc3QgbWF4ID0gbWFpbkF4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBtYWluQXhpc0Nvb3JkID0gY2xhbXAobWluLCBtYWluQXhpc0Nvb3JkLCBtYXgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBjcm9zc0F4aXMgPT09ICd5JyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgICBjb25zdCBtYXhTaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIGNvbnN0IG1pbiA9IGNyb3NzQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IGNyb3NzQXhpc0Nvb3JkIC0gb3ZlcmZsb3dbbWF4U2lkZV07XG4gICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gY2xhbXAobWluLCBjcm9zc0F4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbWl0ZWRDb29yZHMgPSBsaW1pdGVyLmZuKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5saW1pdGVkQ29vcmRzLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgeDogbGltaXRlZENvb3Jkcy54IC0geCxcbiAgICAgICAgICB5OiBsaW1pdGVkQ29vcmRzLnkgLSB5LFxuICAgICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICAgIFttYWluQXhpc106IGNoZWNrTWFpbkF4aXMsXG4gICAgICAgICAgICBbY3Jvc3NBeGlzXTogY2hlY2tDcm9zc0F4aXNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgY29vcmRzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGNvbnN0IHJhd09mZnNldCA9IGV2YWx1YXRlKG9mZnNldCwgc3RhdGUpO1xuICAgICAgY29uc3QgY29tcHV0ZWRPZmZzZXQgPSB0eXBlb2YgcmF3T2Zmc2V0ID09PSAnbnVtYmVyJyA/IHtcbiAgICAgICAgbWFpbkF4aXM6IHJhd09mZnNldCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwXG4gICAgICB9IDoge1xuICAgICAgICBtYWluQXhpczogMCxcbiAgICAgICAgY3Jvc3NBeGlzOiAwLFxuICAgICAgICAuLi5yYXdPZmZzZXRcbiAgICAgIH07XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW21haW5BeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dIC0gY29tcHV0ZWRPZmZzZXQubWFpbkF4aXM7XG4gICAgICAgIGlmIChtYWluQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBtYWluQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAobWFpbkF4aXNDb29yZCA+IGxpbWl0TWF4KSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJG9mZnNlMjtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgaXNPcmlnaW5TaWRlID0gWyd0b3AnLCAnbGVmdCddLmluY2x1ZGVzKGdldFNpZGUocGxhY2VtZW50KSk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWluID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gLSByZWN0cy5mbG9hdGluZ1tsZW5dICsgKGlzT3JpZ2luU2lkZSA/ICgoX21pZGRsZXdhcmVEYXRhJG9mZnNlID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlW2Nyb3NzQXhpc10pIHx8IDAgOiAwKSArIChpc09yaWdpblNpZGUgPyAwIDogY29tcHV0ZWRPZmZzZXQuY3Jvc3NBeGlzKTtcbiAgICAgICAgY29uc3QgbGltaXRNYXggPSByZWN0cy5yZWZlcmVuY2VbY3Jvc3NBeGlzXSArIHJlY3RzLnJlZmVyZW5jZVtsZW5dICsgKGlzT3JpZ2luU2lkZSA/IDAgOiAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZTIgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UyW2Nyb3NzQXhpc10pIHx8IDApIC0gKGlzT3JpZ2luU2lkZSA/IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyA6IDApO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzQ29vcmQgPCBsaW1pdE1pbikge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNaW47XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIGNyb3NzQXhpc0Nvb3JkID0gbGltaXRNYXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFttYWluQXhpc106IG1haW5BeGlzQ29vcmQsXG4gICAgICAgIFtjcm9zc0F4aXNdOiBjcm9zc0F4aXNDb29yZFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBcdTIwMTRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfc3RhdGUkbWlkZGxld2FyZURhdGEsIF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhcHBseSA9ICgpID0+IHt9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHJlY3RzLmZsb2F0aW5nO1xuICAgICAgbGV0IGhlaWdodFNpZGU7XG4gICAgICBsZXQgd2lkdGhTaWRlO1xuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGhlaWdodFNpZGUgPSBzaWRlO1xuICAgICAgICB3aWR0aFNpZGUgPSBhbGlnbm1lbnQgPT09ICgoYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKSA/ICdzdGFydCcgOiAnZW5kJykgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGhTaWRlID0gc2lkZTtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nSGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3cudG9wIC0gb3ZlcmZsb3cuYm90dG9tO1xuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93LmxlZnQgLSBvdmVyZmxvdy5yaWdodDtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0ID0gbWluKGhlaWdodCAtIG92ZXJmbG93W2hlaWdodFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVXaWR0aCA9IG1pbih3aWR0aCAtIG92ZXJmbG93W3dpZHRoU2lkZV0sIG1heGltdW1DbGlwcGluZ1dpZHRoKTtcbiAgICAgIGNvbnN0IG5vU2hpZnQgPSAhc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQ7XG4gICAgICBsZXQgYXZhaWxhYmxlSGVpZ2h0ID0gb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQ7XG4gICAgICBsZXQgYXZhaWxhYmxlV2lkdGggPSBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEuZW5hYmxlZC54KSB7XG4gICAgICAgIGF2YWlsYWJsZVdpZHRoID0gbWF4aW11bUNsaXBwaW5nV2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoKF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTIgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEyLmVuYWJsZWQueSkge1xuICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9TaGlmdCAmJiAhYWxpZ25tZW50KSB7XG4gICAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCk7XG4gICAgICAgIGNvbnN0IHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApO1xuICAgICAgICBjb25zdCB5TWluID0gbWF4KG92ZXJmbG93LnRvcCwgMCk7XG4gICAgICAgIGNvbnN0IHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgICAgaWYgKGlzWUF4aXMpIHtcbiAgICAgICAgICBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gMiAqICh4TWluICE9PSAwIHx8IHhNYXggIT09IDAgPyB4TWluICsgeE1heCA6IG1heChvdmVyZmxvdy5sZWZ0LCBvdmVyZmxvdy5yaWdodCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIDIgKiAoeU1pbiAhPT0gMCB8fCB5TWF4ICE9PSAwID8geU1pbiArIHlNYXggOiBtYXgob3ZlcmZsb3cudG9wLCBvdmVyZmxvdy5ib3R0b20pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgYXBwbHkoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodFxuICAgICAgfSk7XG4gICAgICBjb25zdCBuZXh0RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgaWYgKHdpZHRoICE9PSBuZXh0RGltZW5zaW9ucy53aWR0aCB8fCBoZWlnaHQgIT09IG5leHREaW1lbnNpb25zLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH07XG4iLCAiZnVuY3Rpb24gaGFzV2luZG93KCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIGlmIChpc05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLy8gTW9ja2VkIG5vZGVzIGluIHRlc3RpbmcgZW52aXJvbm1lbnRzIG1heSBub3QgYmUgaW5zdGFuY2VzIG9mIE5vZGUuIEJ5XG4gIC8vIHJldHVybmluZyBgI2RvY3VtZW50YCBhbiBpbmZpbml0ZSBsb29wIHdvbid0IG9jY3VyLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzIzMTdcbiAgcmV0dXJuICcjZG9jdW1lbnQnO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiAobm9kZSA9PSBudWxsIHx8IChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgdmFyIF9yZWY7XG4gIHJldHVybiAoX3JlZiA9IChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVmLmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLk5vZGU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5FbGVtZW50O1xufVxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpIHx8IHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTaGFkb3dSb290IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5TaGFkb3dSb290O1xufVxuZnVuY3Rpb24gaXNPdmVyZmxvd0VsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgb3ZlcmZsb3csXG4gICAgb3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WSxcbiAgICBkaXNwbGF5XG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVufGNsaXAvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpICYmICFbJ2lubGluZScsICdjb250ZW50cyddLmluY2x1ZGVzKGRpc3BsYXkpO1xufVxuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKGVsZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGlzVG9wTGF5ZXIoZWxlbWVudCkge1xuICByZXR1cm4gWyc6cG9wb3Zlci1vcGVuJywgJzptb2RhbCddLnNvbWUoc2VsZWN0b3IgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmluZ0Jsb2NrKGVsZW1lbnRPckNzcykge1xuICBjb25zdCB3ZWJraXQgPSBpc1dlYktpdCgpO1xuICBjb25zdCBjc3MgPSBpc0VsZW1lbnQoZWxlbWVudE9yQ3NzKSA/IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudE9yQ3NzKSA6IGVsZW1lbnRPckNzcztcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXRyYW5zZm9ybXMtMi8jaW5kaXZpZHVhbC10cmFuc2Zvcm1zXG4gIHJldHVybiBbJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUnLCAnc2NhbGUnLCAncm90YXRlJywgJ3BlcnNwZWN0aXZlJ10uc29tZSh2YWx1ZSA9PiBjc3NbdmFsdWVdID8gY3NzW3ZhbHVlXSAhPT0gJ25vbmUnIDogZmFsc2UpIHx8IChjc3MuY29udGFpbmVyVHlwZSA/IGNzcy5jb250YWluZXJUeXBlICE9PSAnbm9ybWFsJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuYmFja2Ryb3BGaWx0ZXIgPyBjc3MuYmFja2Ryb3BGaWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuZmlsdGVyID8gY3NzLmZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8IFsndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZScsICdzY2FsZScsICdyb3RhdGUnLCAncGVyc3BlY3RpdmUnLCAnZmlsdGVyJ10uc29tZSh2YWx1ZSA9PiAoY3NzLndpbGxDaGFuZ2UgfHwgJycpLmluY2x1ZGVzKHZhbHVlKSkgfHwgWydwYWludCcsICdsYXlvdXQnLCAnc3RyaWN0JywgJ2NvbnRlbnQnXS5zb21lKHZhbHVlID0+IChjc3MuY29udGFpbiB8fCAnJykuaW5jbHVkZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGlmIChpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKGlzVG9wTGF5ZXIoY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGN1cnJlbnROb2RlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2ViS2l0KCkge1xuICBpZiAodHlwZW9mIENTUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIUNTUy5zdXBwb3J0cykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gQ1NTLnN1cHBvcnRzKCctd2Via2l0LWJhY2tkcm9wLWZpbHRlcicsICdub25lJyk7XG59XG5mdW5jdGlvbiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwoZWxlbWVudCkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxYLFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPVxuICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cbiAgbm9kZS5hc3NpZ25lZFNsb3QgfHxcbiAgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gIG5vZGUucGFyZW50Tm9kZSB8fFxuICAvLyBTaGFkb3dSb290IGRldGVjdGVkLlxuICBpc1NoYWRvd1Jvb3Qobm9kZSkgJiYgbm9kZS5ob3N0IHx8XG4gIC8vIEZhbGxiYWNrLlxuICBnZXREb2N1bWVudEVsZW1lbnQobm9kZSk7XG4gIHJldHVybiBpc1NoYWRvd1Jvb3QocmVzdWx0KSA/IHJlc3VsdC5ob3N0IDogcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgPyBub2RlLm93bmVyRG9jdW1lbnQuYm9keSA6IG5vZGUuYm9keTtcbiAgfVxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcihwYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKG5vZGUsIGxpc3QsIHRyYXZlcnNlSWZyYW1lcykge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDI7XG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cbiAgaWYgKHRyYXZlcnNlSWZyYW1lcyA9PT0gdm9pZCAwKSB7XG4gICAgdHJhdmVyc2VJZnJhbWVzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKTtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsYWJsZUFuY2VzdG9yID09PSAoKF9ub2RlJG93bmVyRG9jdW1lbnQyID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudDIuYm9keSk7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlQW5jZXN0b3IpO1xuICBpZiAoaXNCb2R5KSB7XG4gICAgY29uc3QgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KHdpbik7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KHdpbiwgd2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc092ZXJmbG93RWxlbWVudChzY3JvbGxhYmxlQW5jZXN0b3IpID8gc2Nyb2xsYWJsZUFuY2VzdG9yIDogW10sIGZyYW1lRWxlbWVudCAmJiB0cmF2ZXJzZUlmcmFtZXMgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhmcmFtZUVsZW1lbnQpIDogW10pO1xuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChzY3JvbGxhYmxlQW5jZXN0b3IsIGdldE92ZXJmbG93QW5jZXN0b3JzKHNjcm9sbGFibGVBbmNlc3RvciwgW10sIHRyYXZlcnNlSWZyYW1lcykpO1xufVxuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50KHdpbikge1xuICByZXR1cm4gd2luLnBhcmVudCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yod2luLnBhcmVudCkgPyB3aW4uZnJhbWVFbGVtZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgZ2V0Q29udGFpbmluZ0Jsb2NrLCBnZXREb2N1bWVudEVsZW1lbnQsIGdldEZyYW1lRWxlbWVudCwgZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IsIGdldE5vZGVOYW1lLCBnZXROb2RlU2Nyb2xsLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgZ2V0V2luZG93LCBpc0NvbnRhaW5pbmdCbG9jaywgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzTm9kZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGlzU2hhZG93Um9vdCwgaXNUYWJsZUVsZW1lbnQsIGlzVG9wTGF5ZXIsIGlzV2ViS2l0IH07XG4iLCAiaW1wb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCwgYXJyb3cgYXMgYXJyb3ckMSwgYXV0b1BsYWNlbWVudCBhcyBhdXRvUGxhY2VtZW50JDEsIGRldGVjdE92ZXJmbG93IGFzIGRldGVjdE92ZXJmbG93JDEsIGZsaXAgYXMgZmxpcCQxLCBoaWRlIGFzIGhpZGUkMSwgaW5saW5lIGFzIGlubGluZSQxLCBsaW1pdFNoaWZ0IGFzIGxpbWl0U2hpZnQkMSwgb2Zmc2V0IGFzIG9mZnNldCQxLCBzaGlmdCBhcyBzaGlmdCQxLCBzaXplIGFzIHNpemUkMSwgY29tcHV0ZVBvc2l0aW9uIGFzIGNvbXB1dGVQb3NpdGlvbiQxIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2NvcmUnO1xuaW1wb3J0IHsgcm91bmQsIGNyZWF0ZUNvb3JkcywgbWF4LCBtaW4sIGZsb29yIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmltcG9ydCB7IGdldENvbXB1dGVkU3R5bGUsIGlzSFRNTEVsZW1lbnQsIGlzRWxlbWVudCwgZ2V0V2luZG93LCBpc1dlYktpdCwgZ2V0RnJhbWVFbGVtZW50LCBnZXROb2RlU2Nyb2xsLCBnZXREb2N1bWVudEVsZW1lbnQsIGlzVG9wTGF5ZXIsIGdldE5vZGVOYW1lLCBpc092ZXJmbG93RWxlbWVudCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNDb250YWluaW5nQmxvY2ssIGlzVGFibGVFbGVtZW50LCBnZXRDb250YWluaW5nQmxvY2sgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcbmV4cG9ydCB7IGdldE92ZXJmbG93QW5jZXN0b3JzIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5cbmZ1bmN0aW9uIGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAvLyBJbiB0ZXN0aW5nIGVudmlyb25tZW50cywgdGhlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHByb3BlcnRpZXMgYXJlIGVtcHR5XG4gIC8vIHN0cmluZ3MgZm9yIFNWRyBlbGVtZW50cywgcmV0dXJuaW5nIE5hTi4gRmFsbGJhY2sgdG8gYDBgIGluIHRoaXMgY2FzZS5cbiAgbGV0IHdpZHRoID0gcGFyc2VGbG9hdChjc3Mud2lkdGgpIHx8IDA7XG4gIGxldCBoZWlnaHQgPSBwYXJzZUZsb2F0KGNzcy5oZWlnaHQpIHx8IDA7XG4gIGNvbnN0IGhhc09mZnNldCA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IG9mZnNldFdpZHRoID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRXaWR0aCA6IHdpZHRoO1xuICBjb25zdCBvZmZzZXRIZWlnaHQgPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldEhlaWdodCA6IGhlaWdodDtcbiAgY29uc3Qgc2hvdWxkRmFsbGJhY2sgPSByb3VuZCh3aWR0aCkgIT09IG9mZnNldFdpZHRoIHx8IHJvdW5kKGhlaWdodCkgIT09IG9mZnNldEhlaWdodDtcbiAgaWYgKHNob3VsZEZhbGxiYWNrKSB7XG4gICAgd2lkdGggPSBvZmZzZXRXaWR0aDtcbiAgICBoZWlnaHQgPSBvZmZzZXRIZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgJDogc2hvdWxkRmFsbGJhY2tcbiAgfTtcbn1cblxuZnVuY3Rpb24gdW53cmFwRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiAhaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5jb250ZXh0RWxlbWVudCA6IGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlKGVsZW1lbnQpIHtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGlmICghaXNIVE1MRWxlbWVudChkb21FbGVtZW50KSkge1xuICAgIHJldHVybiBjcmVhdGVDb29yZHMoMSk7XG4gIH1cbiAgY29uc3QgcmVjdCA9IGRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgJFxuICB9ID0gZ2V0Q3NzRGltZW5zaW9ucyhkb21FbGVtZW50KTtcbiAgbGV0IHggPSAoJCA/IHJvdW5kKHJlY3Qud2lkdGgpIDogcmVjdC53aWR0aCkgLyB3aWR0aDtcbiAgbGV0IHkgPSAoJCA/IHJvdW5kKHJlY3QuaGVpZ2h0KSA6IHJlY3QuaGVpZ2h0KSAvIGhlaWdodDtcblxuICAvLyAwLCBOYU4sIG9yIEluZmluaXR5IHNob3VsZCBhbHdheXMgZmFsbGJhY2sgdG8gMS5cblxuICBpZiAoIXggfHwgIU51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgIHggPSAxO1xuICB9XG4gIGlmICgheSB8fCAhTnVtYmVyLmlzRmluaXRlKHkpKSB7XG4gICAgeSA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuY29uc3Qgbm9PZmZzZXRzID0gLyojX19QVVJFX18qL2NyZWF0ZUNvb3JkcygwKTtcbmZ1bmN0aW9uIGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmICghaXNXZWJLaXQoKSB8fCAhd2luLnZpc3VhbFZpZXdwb3J0KSB7XG4gICAgcmV0dXJuIG5vT2Zmc2V0cztcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0LFxuICAgIHk6IHdpbi52aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3BcbiAgfTtcbn1cbmZ1bmN0aW9uIHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZWxlbWVudCwgaXNGaXhlZCwgZmxvYXRpbmdPZmZzZXRQYXJlbnQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuICBpZiAoIWZsb2F0aW5nT2Zmc2V0UGFyZW50IHx8IGlzRml4ZWQgJiYgZmxvYXRpbmdPZmZzZXRQYXJlbnQgIT09IGdldFdpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZDtcbn1cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGlmIChpbmNsdWRlU2NhbGUpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50KSB7XG4gICAgICBpZiAoaXNFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCB2aXN1YWxPZmZzZXRzID0gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50LCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkgPyBnZXRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDApO1xuICBsZXQgeCA9IChjbGllbnRSZWN0LmxlZnQgKyB2aXN1YWxPZmZzZXRzLngpIC8gc2NhbGUueDtcbiAgbGV0IHkgPSAoY2xpZW50UmVjdC50b3AgKyB2aXN1YWxPZmZzZXRzLnkpIC8gc2NhbGUueTtcbiAgbGV0IHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlLng7XG4gIGxldCBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlLnk7XG4gIGlmIChkb21FbGVtZW50KSB7XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGRvbUVsZW1lbnQpO1xuICAgIGNvbnN0IG9mZnNldFdpbiA9IG9mZnNldFBhcmVudCAmJiBpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSA/IGdldFdpbmRvdyhvZmZzZXRQYXJlbnQpIDogb2Zmc2V0UGFyZW50O1xuICAgIGxldCBjdXJyZW50V2luID0gd2luO1xuICAgIGxldCBjdXJyZW50SUZyYW1lID0gZ2V0RnJhbWVFbGVtZW50KGN1cnJlbnRXaW4pO1xuICAgIHdoaWxlIChjdXJyZW50SUZyYW1lICYmIG9mZnNldFBhcmVudCAmJiBvZmZzZXRXaW4gIT09IGN1cnJlbnRXaW4pIHtcbiAgICAgIGNvbnN0IGlmcmFtZVNjYWxlID0gZ2V0U2NhbGUoY3VycmVudElGcmFtZSk7XG4gICAgICBjb25zdCBpZnJhbWVSZWN0ID0gY3VycmVudElGcmFtZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudElGcmFtZSk7XG4gICAgICBjb25zdCBsZWZ0ID0gaWZyYW1lUmVjdC5sZWZ0ICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50TGVmdCArIHBhcnNlRmxvYXQoY3NzLnBhZGRpbmdMZWZ0KSkgKiBpZnJhbWVTY2FsZS54O1xuICAgICAgY29uc3QgdG9wID0gaWZyYW1lUmVjdC50b3AgKyAoY3VycmVudElGcmFtZS5jbGllbnRUb3AgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nVG9wKSkgKiBpZnJhbWVTY2FsZS55O1xuICAgICAgeCAqPSBpZnJhbWVTY2FsZS54O1xuICAgICAgeSAqPSBpZnJhbWVTY2FsZS55O1xuICAgICAgd2lkdGggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIGhlaWdodCAqPSBpZnJhbWVTY2FsZS55O1xuICAgICAgeCArPSBsZWZ0O1xuICAgICAgeSArPSB0b3A7XG4gICAgICBjdXJyZW50V2luID0gZ2V0V2luZG93KGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3Qoe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfSk7XG59XG5cbi8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbi8vIGluY29ycmVjdCBmb3IgUlRMLlxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50LCByZWN0KSB7XG4gIGNvbnN0IGxlZnRTY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG4gIGlmICghcmVjdCkge1xuICAgIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgbGVmdFNjcm9sbDtcbiAgfVxuICByZXR1cm4gcmVjdC5sZWZ0ICsgbGVmdFNjcm9sbDtcbn1cblxuZnVuY3Rpb24gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCwgaWdub3JlU2Nyb2xsYmFyWCkge1xuICBpZiAoaWdub3JlU2Nyb2xsYmFyWCA9PT0gdm9pZCAwKSB7XG4gICAgaWdub3JlU2Nyb2xsYmFyWCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGh0bWxSZWN0ID0gZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB4ID0gaHRtbFJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gKGlnbm9yZVNjcm9sbGJhclggPyAwIDpcbiAgLy8gUlRMIDxib2R5PiBzY3JvbGxiYXIuXG4gIGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50LCBodG1sUmVjdCkpO1xuICBjb25zdCB5ID0gaHRtbFJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcDtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnRzLFxuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCB0b3BMYXllciA9IGVsZW1lbnRzID8gaXNUb3BMYXllcihlbGVtZW50cy5mbG9hdGluZykgOiBmYWxzZTtcbiAgaWYgKG9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50IHx8IHRvcExheWVyICYmIGlzRml4ZWQpIHtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuICBsZXQgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH1cbiAgfVxuICBjb25zdCBodG1sT2Zmc2V0ID0gZG9jdW1lbnRFbGVtZW50ICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCA/IGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwsIHRydWUpIDogY3JlYXRlQ29vcmRzKDApO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoICogc2NhbGUueCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICogc2NhbGUueSxcbiAgICB4OiByZWN0LnggKiBzY2FsZS54IC0gc2Nyb2xsLnNjcm9sbExlZnQgKiBzY2FsZS54ICsgb2Zmc2V0cy54ICsgaHRtbE9mZnNldC54LFxuICAgIHk6IHJlY3QueSAqIHNjYWxlLnkgLSBzY3JvbGwuc2Nyb2xsVG9wICogc2NhbGUueSArIG9mZnNldHMueSArIGh0bWxPZmZzZXQueVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0cyhlbGVtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKSk7XG59XG5cbi8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGUuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuc2Nyb2xsV2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5LnNjcm9sbEhlaWdodCwgYm9keS5jbGllbnRIZWlnaHQpO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpIC0gd2lkdGg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydEJhc2VkID0gaXNXZWJLaXQoKTtcbiAgICBpZiAoIXZpc3VhbFZpZXdwb3J0QmFzZWQgfHwgdmlzdWFsVmlld3BvcnRCYXNlZCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gUmV0dXJucyB0aGUgaW5uZXIgY2xpZW50IHJlY3QsIHN1YnRyYWN0aW5nIHNjcm9sbGJhcnMgaWYgcHJlc2VudC5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09ICdmaXhlZCcpO1xuICBjb25zdCB0b3AgPSBjbGllbnRSZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICBjb25zdCBsZWZ0ID0gY2xpZW50UmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICBjb25zdCBzY2FsZSA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRTY2FsZShlbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoICogc2NhbGUueDtcbiAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQgKiBzY2FsZS55O1xuICBjb25zdCB4ID0gbGVmdCAqIHNjYWxlLng7XG4gIGNvbnN0IHkgPSB0b3AgKiBzY2FsZS55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkge1xuICBsZXQgcmVjdDtcbiAgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAnZG9jdW1lbnQnKSB7XG4gICAgcmVjdCA9IGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpO1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChjbGlwcGluZ0FuY2VzdG9yKSkge1xuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IGdldFZpc3VhbE9mZnNldHMoZWxlbWVudCk7XG4gICAgcmVjdCA9IHtcbiAgICAgIHg6IGNsaXBwaW5nQW5jZXN0b3IueCAtIHZpc3VhbE9mZnNldHMueCxcbiAgICAgIHk6IGNsaXBwaW5nQW5jZXN0b3IueSAtIHZpc3VhbE9mZnNldHMueSxcbiAgICAgIHdpZHRoOiBjbGlwcGluZ0FuY2VzdG9yLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjbGlwcGluZ0FuY2VzdG9yLmhlaWdodFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QocmVjdCk7XG59XG5mdW5jdGlvbiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgc3RvcE5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmIChwYXJlbnROb2RlID09PSBzdG9wTm9kZSB8fCAhaXNFbGVtZW50KHBhcmVudE5vZGUpIHx8IGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnROb2RlKS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IocGFyZW50Tm9kZSwgc3RvcE5vZGUpO1xufVxuXG4vLyBBIFwiY2xpcHBpbmcgYW5jZXN0b3JcIiBpcyBhbiBgb3ZlcmZsb3dgIGVsZW1lbnQgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIGNoaWxkIGVsZW1lbnRzLiBUaGlzIHJldHVybnMgYWxsIGNsaXBwaW5nIGFuY2VzdG9yc1xuLy8gb2YgdGhlIGdpdmVuIGVsZW1lbnQgdXAgdGhlIHRyZWUuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgY2FjaGUpIHtcbiAgY29uc3QgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KGVsZW1lbnQpO1xuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZWxlbWVudCwgW10sIGZhbHNlKS5maWx0ZXIoZWwgPT4gaXNFbGVtZW50KGVsKSAmJiBnZXROb2RlTmFtZShlbCkgIT09ICdib2R5Jyk7XG4gIGxldCBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gIGNvbnN0IGVsZW1lbnRJc0ZpeGVkID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJztcbiAgbGV0IGN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIDogZWxlbWVudDtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuICB3aGlsZSAoaXNFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlzQ29udGFpbmluZyA9IGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKTtcbiAgICBpZiAoIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkRHJvcEN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIDogIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnICYmICEhY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgJiYgWydhYnNvbHV0ZScsICdmaXhlZCddLmluY2x1ZGVzKGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlLnBvc2l0aW9uKSB8fCBpc092ZXJmbG93RWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBjdXJyZW50Tm9kZSk7XG4gICAgaWYgKHNob3VsZERyb3BDdXJyZW50Tm9kZSkge1xuICAgICAgLy8gRHJvcCBub24tY29udGFpbmluZyBibG9ja3MuXG4gICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGFuY2VzdG9yID0+IGFuY2VzdG9yICE9PSBjdXJyZW50Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlY29yZCBsYXN0IGNvbnRhaW5pbmcgYmxvY2sgZm9yIG5leHQgaXRlcmF0aW9uLlxuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIGNhY2hlLnNldChlbGVtZW50LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBhbmNlc3RvcnMuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnQsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nQW5jZXN0b3JzJyA/IGlzVG9wTGF5ZXIoZWxlbWVudCkgPyBbXSA6IGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCB0aGlzLl9jKSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nQW5jZXN0b3JzID0gWy4uLmVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycywgcm9vdEJvdW5kYXJ5XTtcbiAgY29uc3QgZmlyc3RDbGlwcGluZ0FuY2VzdG9yID0gY2xpcHBpbmdBbmNlc3RvcnNbMF07XG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nQW5jZXN0b3JzLnJlZHVjZSgoYWNjUmVjdCwgY2xpcHBpbmdBbmNlc3RvcikgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBmaXJzdENsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIGhlaWdodDogY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3AsXG4gICAgeDogY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgeTogY2xpcHBpbmdSZWN0LnRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gZ2V0Q3NzRGltZW5zaW9ucyhlbGVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZWxlbWVudCwgb2Zmc2V0UGFyZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gJ2ZpeGVkJztcbiAgY29uc3QgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICBsZXQgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG5cbiAgLy8gSWYgdGhlIDxib2R5PiBzY3JvbGxiYXIgYXBwZWFycyBvbiB0aGUgbGVmdCAoZS5nLiBSVEwgc3lzdGVtcykuIFVzZVxuICAvLyBGaXJlZm94IHdpdGggbGF5b3V0LnNjcm9sbGJhci5zaWRlID0gMyBpbiBhYm91dDpjb25maWcgdG8gdGVzdCB0aGlzLlxuICBmdW5jdGlvbiBzZXRMZWZ0UlRMU2Nyb2xsYmFyT2Zmc2V0KCkge1xuICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgfVxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHNldExlZnRSVExTY3JvbGxiYXJPZmZzZXQoKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRml4ZWQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIGRvY3VtZW50RWxlbWVudCkge1xuICAgIHNldExlZnRSVExTY3JvbGxiYXJPZmZzZXQoKTtcbiAgfVxuICBjb25zdCBodG1sT2Zmc2V0ID0gZG9jdW1lbnRFbGVtZW50ICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCA/IGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwpIDogY3JlYXRlQ29vcmRzKDApO1xuICBjb25zdCB4ID0gcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLnggLSBodG1sT2Zmc2V0Lng7XG4gIGNvbnN0IHkgPSByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnkgLSBodG1sT2Zmc2V0Lnk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNQb3NpdGlvbmVkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnO1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBvbHlmaWxsKSB7XG4gICAgcmV0dXJuIHBvbHlmaWxsKGVsZW1lbnQpO1xuICB9XG4gIGxldCByYXdPZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxuICAvLyBGaXJlZm94IHJldHVybnMgdGhlIDxodG1sPiBlbGVtZW50IGFzIHRoZSBvZmZzZXRQYXJlbnQgaWYgaXQncyBub24tc3RhdGljLFxuICAvLyB3aGlsZSBDaHJvbWUgYW5kIFNhZmFyaSByZXR1cm4gdGhlIDxib2R5PiBlbGVtZW50LiBUaGUgPGJvZHk+IGVsZW1lbnQgbXVzdFxuICAvLyBiZSB1c2VkIHRvIHBlcmZvcm0gdGhlIGNvcnJlY3QgY2FsY3VsYXRpb25zIGV2ZW4gaWYgdGhlIDxodG1sPiBlbGVtZW50IGlzXG4gIC8vIG5vbi1zdGF0aWMuXG4gIGlmIChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgPT09IHJhd09mZnNldFBhcmVudCkge1xuICAgIHJhd09mZnNldFBhcmVudCA9IHJhd09mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cbiAgcmV0dXJuIHJhd09mZnNldFBhcmVudDtcbn1cblxuLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmIChpc1RvcExheWVyKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBsZXQgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICB3aGlsZSAoc3ZnT2Zmc2V0UGFyZW50ICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgaWYgKGlzRWxlbWVudChzdmdPZmZzZXRQYXJlbnQpICYmICFpc1N0YXRpY1Bvc2l0aW9uZWQoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgICByZXR1cm4gc3ZnT2Zmc2V0UGFyZW50O1xuICAgICAgfVxuICAgICAgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShzdmdPZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQsIHBvbHlmaWxsKTtcbiAgfVxuICBpZiAob2Zmc2V0UGFyZW50ICYmIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW47XG59XG5cbmNvbnN0IGdldEVsZW1lbnRSZWN0cyA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhKSB7XG4gIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIGNvbnN0IGZsb2F0aW5nRGltZW5zaW9ucyA9IGF3YWl0IGdldERpbWVuc2lvbnNGbihkYXRhLmZsb2F0aW5nKTtcbiAgcmV0dXJuIHtcbiAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGRhdGEucmVmZXJlbmNlLCBhd2FpdCBnZXRPZmZzZXRQYXJlbnRGbihkYXRhLmZsb2F0aW5nKSwgZGF0YS5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGZsb2F0aW5nRGltZW5zaW9ucy53aWR0aCxcbiAgICAgIGhlaWdodDogZmxvYXRpbmdEaW1lbnNpb25zLmhlaWdodFxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJztcbn1cblxuY29uc3QgcGxhdGZvcm0gPSB7XG4gIGNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0LFxuICBnZXREb2N1bWVudEVsZW1lbnQsXG4gIGdldENsaXBwaW5nUmVjdCxcbiAgZ2V0T2Zmc2V0UGFyZW50LFxuICBnZXRFbGVtZW50UmVjdHMsXG4gIGdldENsaWVudFJlY3RzLFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRTY2FsZSxcbiAgaXNFbGVtZW50LFxuICBpc1JUTFxufTtcblxuZnVuY3Rpb24gcmVjdHNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueSAmJiBhLndpZHRoID09PSBiLndpZHRoICYmIGEuaGVpZ2h0ID09PSBiLmhlaWdodDtcbn1cblxuLy8gaHR0cHM6Ly9zYW10aG9yLmF1LzIwMjEvb2JzZXJ2aW5nLWRvbS9cbmZ1bmN0aW9uIG9ic2VydmVNb3ZlKGVsZW1lbnQsIG9uTW92ZSkge1xuICBsZXQgaW8gPSBudWxsO1xuICBsZXQgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHZhciBfaW87XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgKF9pbyA9IGlvKSA9PSBudWxsIHx8IF9pby5kaXNjb25uZWN0KCk7XG4gICAgaW8gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHJlZnJlc2goc2tpcCwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHNraXAgPT09IHZvaWQgMCkge1xuICAgICAgc2tpcCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDE7XG4gICAgfVxuICAgIGNsZWFudXAoKTtcbiAgICBjb25zdCBlbGVtZW50UmVjdEZvclJvb3RNYXJnaW4gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBlbGVtZW50UmVjdEZvclJvb3RNYXJnaW47XG4gICAgaWYgKCFza2lwKSB7XG4gICAgICBvbk1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluc2V0VG9wID0gZmxvb3IodG9wKTtcbiAgICBjb25zdCBpbnNldFJpZ2h0ID0gZmxvb3Iocm9vdC5jbGllbnRXaWR0aCAtIChsZWZ0ICsgd2lkdGgpKTtcbiAgICBjb25zdCBpbnNldEJvdHRvbSA9IGZsb29yKHJvb3QuY2xpZW50SGVpZ2h0IC0gKHRvcCArIGhlaWdodCkpO1xuICAgIGNvbnN0IGluc2V0TGVmdCA9IGZsb29yKGxlZnQpO1xuICAgIGNvbnN0IHJvb3RNYXJnaW4gPSAtaW5zZXRUb3AgKyBcInB4IFwiICsgLWluc2V0UmlnaHQgKyBcInB4IFwiICsgLWluc2V0Qm90dG9tICsgXCJweCBcIiArIC1pbnNldExlZnQgKyBcInB4XCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0aHJlc2hvbGQ6IG1heCgwLCBtaW4oMSwgdGhyZXNob2xkKSkgfHwgMVxuICAgIH07XG4gICAgbGV0IGlzRmlyc3RVcGRhdGUgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU9ic2VydmUoZW50cmllcykge1xuICAgICAgY29uc3QgcmF0aW8gPSBlbnRyaWVzWzBdLmludGVyc2VjdGlvblJhdGlvO1xuICAgICAgaWYgKHJhdGlvICE9PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0VXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhdGlvKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBjbGlwcGVkLCB0aGUgcmF0aW8gaXMgMC4gVGhyb3R0bGUgdGhlIHJlZnJlc2hcbiAgICAgICAgICAvLyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3Agb2YgdXBkYXRlcy5cbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlZnJlc2goZmFsc2UsIDFlLTcpO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goZmFsc2UsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJhdGlvID09PSAxICYmICFyZWN0c0FyZUVxdWFsKGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiwgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkpIHtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGV2ZW4gdGhvdWdoIHRoZSByYXRpbyBpcyByZXBvcnRlZCBhcyAxLCB0aGVcbiAgICAgICAgLy8gZWxlbWVudCBpcyBub3QgYWN0dWFsbHkgZnVsbHkgd2l0aGluIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlcidzIHJvb3RcbiAgICAgICAgLy8gYXJlYSBhbnltb3JlLiBUaGlzIGNhbiBoYXBwZW4gdW5kZXIgcGVyZm9ybWFuY2UgY29uc3RyYWludHMuIFRoaXMgbWF5XG4gICAgICAgIC8vIGJlIGEgYnVnIGluIHRoZSBicm93c2VyJ3MgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaW1wbGVtZW50YXRpb24uIFRvXG4gICAgICAgIC8vIHdvcmsgYXJvdW5kIHRoaXMsIHdlIGNvbXBhcmUgdGhlIGVsZW1lbnQncyBib3VuZGluZyByZWN0IG5vdyB3aXRoXG4gICAgICAgIC8vIHdoYXQgaXQgd2FzIGF0IHRoZSB0aW1lIHdlIGNyZWF0ZWQgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyLiBJZiB0aGV5XG4gICAgICAgIC8vIGFyZSBub3QgZXF1YWwgdGhlbiB0aGUgZWxlbWVudCBtb3ZlZCwgc28gd2UgcmVmcmVzaC5cbiAgICAgICAgcmVmcmVzaCgpO1xuICAgICAgfVxuICAgICAgaXNGaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgYSBgZG9jdW1lbnRgIGFzIHRoZSByb290IGFuZCB3aWxsIHRocm93IGFuXG4gICAgLy8gZXJyb3IuXG4gICAgdHJ5IHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLy8gSGFuZGxlIDxpZnJhbWU+c1xuICAgICAgICByb290OiByb290Lm93bmVyRG9jdW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaW8ub2JzZXJ2ZShlbGVtZW50KTtcbiAgfVxuICByZWZyZXNoKHRydWUpO1xuICByZXR1cm4gY2xlYW51cDtcbn1cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IHVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoZW4gbmVjZXNzYXJ5LlxuICogU2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgbW91bnRlZCBvbiB0aGUgRE9NIG9yXG4gKiB2aXNpYmxlIG9uIHRoZSBzY3JlZW4uXG4gKiBAcmV0dXJucyBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGludm9rZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpc1xuICogcmVtb3ZlZCBmcm9tIHRoZSBET00gb3IgaGlkZGVuIGZyb20gdGhlIHNjcmVlbi5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvVXBkYXRlXG4gKi9cbmZ1bmN0aW9uIGF1dG9VcGRhdGUocmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsID0gdHJ1ZSxcbiAgICBhbmNlc3RvclJlc2l6ZSA9IHRydWUsXG4gICAgZWxlbWVudFJlc2l6ZSA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBsYXlvdXRTaGlmdCA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBhbmltYXRpb25GcmFtZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCByZWZlcmVuY2VFbCA9IHVud3JhcEVsZW1lbnQocmVmZXJlbmNlKTtcbiAgY29uc3QgYW5jZXN0b3JzID0gYW5jZXN0b3JTY3JvbGwgfHwgYW5jZXN0b3JSZXNpemUgPyBbLi4uKHJlZmVyZW5jZUVsID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlRWwpIDogW10pLCAuLi5nZXRPdmVyZmxvd0FuY2VzdG9ycyhmbG9hdGluZyldIDogW107XG4gIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICB9KTtcbiAgY29uc3QgY2xlYW51cElvID0gcmVmZXJlbmNlRWwgJiYgbGF5b3V0U2hpZnQgPyBvYnNlcnZlTW92ZShyZWZlcmVuY2VFbCwgdXBkYXRlKSA6IG51bGw7XG4gIGxldCByZW9ic2VydmVGcmFtZSA9IC0xO1xuICBsZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICBpZiAoZWxlbWVudFJlc2l6ZSkge1xuICAgIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKF9yZWYgPT4ge1xuICAgICAgbGV0IFtmaXJzdEVudHJ5XSA9IF9yZWY7XG4gICAgICBpZiAoZmlyc3RFbnRyeSAmJiBmaXJzdEVudHJ5LnRhcmdldCA9PT0gcmVmZXJlbmNlRWwgJiYgcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgLy8gUHJldmVudCB1cGRhdGUgbG9vcHMgd2hlbiB1c2luZyB0aGUgYHNpemVgIG1pZGRsZXdhcmUuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTc0MFxuICAgICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZW9ic2VydmVGcmFtZSk7XG4gICAgICAgIHJlb2JzZXJ2ZUZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB2YXIgX3Jlc2l6ZU9ic2VydmVyO1xuICAgICAgICAgIChfcmVzaXplT2JzZXJ2ZXIgPSByZXNpemVPYnNlcnZlcikgPT0gbnVsbCB8fCBfcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdXBkYXRlKCk7XG4gICAgfSk7XG4gICAgaWYgKHJlZmVyZW5jZUVsICYmICFhbmltYXRpb25GcmFtZSkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyZWZlcmVuY2VFbCk7XG4gICAgfVxuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICB9XG4gIGxldCBmcmFtZUlkO1xuICBsZXQgcHJldlJlZlJlY3QgPSBhbmltYXRpb25GcmFtZSA/IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpIDogbnVsbDtcbiAgaWYgKGFuaW1hdGlvbkZyYW1lKSB7XG4gICAgZnJhbWVMb29wKCk7XG4gIH1cbiAgZnVuY3Rpb24gZnJhbWVMb29wKCkge1xuICAgIGNvbnN0IG5leHRSZWZSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSk7XG4gICAgaWYgKHByZXZSZWZSZWN0ICYmICFyZWN0c0FyZUVxdWFsKHByZXZSZWZSZWN0LCBuZXh0UmVmUmVjdCkpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgICBwcmV2UmVmUmVjdCA9IG5leHRSZWZSZWN0O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWVMb29wKTtcbiAgfVxuICB1cGRhdGUoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgX3Jlc2l6ZU9ic2VydmVyMjtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUpO1xuICAgICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgICB9KTtcbiAgICBjbGVhbnVwSW8gPT0gbnVsbCB8fCBjbGVhbnVwSW8oKTtcbiAgICAoX3Jlc2l6ZU9ic2VydmVyMiA9IHJlc2l6ZU9ic2VydmVyKSA9PSBudWxsIHx8IF9yZXNpemVPYnNlcnZlcjIuZGlzY29ubmVjdCgpO1xuICAgIHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBvZiBvdmVyZmxvdyBzaWRlIG9mZnNldHMgdGhhdCBkZXRlcm1pbmUgaG93IG11Y2ggdGhlXG4gKiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIGEgZ2l2ZW4gY2xpcHBpbmcgYm91bmRhcnkgb24gZWFjaCBzaWRlLlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmNvbnN0IGRldGVjdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3ckMTtcblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0JDE7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gYXV0b1BsYWNlbWVudCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBzaGlmdCQxO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IGZsaXAkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgXHUyMDE0XG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gc2l6ZSQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGhpZGUkMTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSBhcnJvdyQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBpbmxpbmUkMTtcblxuLyoqXG4gKiBCdWlsdC1pbiBgbGltaXRlcmAgdGhhdCB3aWxsIHN0b3AgYHNoaWZ0KClgIGF0IGEgY2VydGFpbiBwb2ludC5cbiAqL1xuY29uc3QgbGltaXRTaGlmdCA9IGxpbWl0U2hpZnQkMTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgZ2l2ZW4gcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBvcHRpb25zKSA9PiB7XG4gIC8vIFRoaXMgY2FjaGVzIHRoZSBleHBlbnNpdmUgYGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9yc2AgZnVuY3Rpb24gc28gdGhhdFxuICAvLyBtdWx0aXBsZSBsaWZlY3ljbGUgcmVzZXRzIHJlLXVzZSB0aGUgc2FtZSByZXN1bHQuIEl0IG9ubHkgbGl2ZXMgZm9yIGFcbiAgLy8gc2luZ2xlIGNhbGwuIElmIG90aGVyIGZ1bmN0aW9ucyBiZWNvbWUgZXhwZW5zaXZlLCB3ZSBjYW4gYWRkIHRoZW0gYXMgd2VsbC5cbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7XG4gICAgcGxhdGZvcm0sXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLnBsYXRmb3JtLFxuICAgIF9jOiBjYWNoZVxuICB9O1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtV2l0aENhY2hlXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBwbGF0Zm9ybSwgc2hpZnQsIHNpemUgfTtcbiIsICJpbXBvcnQgeyBjb21wdXRlUG9zaXRpb24sIGZsaXAsIHNoaWZ0IH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSdcblxuY29uc3QgdXBkYXRlUG9zaXRpb24gPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgcmVmZXJlbmNlRWxlbWVudCA9IHtcbiAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGVkaXRvci52aWV3LmNvb3Jkc0F0UG9zKGZyb20pXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBlZGl0b3Iudmlldy5jb29yZHNBdFBvcyh0bylcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IE1hdGgubWluKHN0YXJ0LnRvcCwgZW5kLnRvcCksXG4gICAgICAgICAgICAgICAgYm90dG9tOiBNYXRoLm1heChzdGFydC5ib3R0b20sIGVuZC5ib3R0b20pLFxuICAgICAgICAgICAgICAgIGxlZnQ6IE1hdGgubWluKHN0YXJ0LmxlZnQsIGVuZC5sZWZ0KSxcbiAgICAgICAgICAgICAgICByaWdodDogTWF0aC5tYXgoc3RhcnQucmlnaHQsIGVuZC5yaWdodCksXG4gICAgICAgICAgICAgICAgd2lkdGg6IE1hdGguYWJzKGVuZC5yaWdodCAtIHN0YXJ0LmxlZnQpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5hYnMoZW5kLmJvdHRvbSAtIHN0YXJ0LnRvcCksXG4gICAgICAgICAgICAgICAgeDogTWF0aC5taW4oc3RhcnQubGVmdCwgZW5kLmxlZnQpLFxuICAgICAgICAgICAgICAgIHk6IE1hdGgubWluKHN0YXJ0LnRvcCwgZW5kLnRvcCksXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfVxuXG4gICAgY29tcHV0ZVBvc2l0aW9uKHJlZmVyZW5jZUVsZW1lbnQsIGVsZW1lbnQsIHtcbiAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tLXN0YXJ0JyxcbiAgICAgICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgICAgIG1pZGRsZXdhcmU6IFtzaGlmdCgpLCBmbGlwKCldLFxuICAgIH0pLnRoZW4oKHsgeCwgeSwgc3RyYXRlZ3kgfSkgPT4ge1xuICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gJ21heC1jb250ZW50J1xuICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gc3RyYXRlZ3lcbiAgICAgICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7eH1weGBcbiAgICAgICAgZWxlbWVudC5zdHlsZS50b3AgPSBgJHt5fXB4YFxuICAgIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0ICh7IG1lcmdlVGFncywgbm9NZXJnZVRhZ1NlYXJjaFJlc3VsdHNNZXNzYWdlIH0pID0+ICh7XG4gICAgaXRlbXM6ICh7IHF1ZXJ5IH0pID0+IHtcbiAgICAgICAgcmV0dXJuIG1lcmdlVGFncy5maWx0ZXIoKGl0ZW0pID0+XG4gICAgICAgICAgICBpdGVtLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzL2csICcnKS5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgKVxuICAgIH0sXG5cbiAgICByZW5kZXI6ICgpID0+IHtcbiAgICAgICAgbGV0IGVsZW1lbnRcbiAgICAgICAgbGV0IHNlbGVjdGVkSW5kZXggPSAwXG4gICAgICAgIGxldCBjdXJyZW50UHJvcHMgPSBudWxsXG5cbiAgICAgICAgY29uc3QgY3JlYXRlRHJvcGRvd24gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkcm9wZG93biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgICAgICBkcm9wZG93bi5jbGFzc05hbWUgPSAnZmktZHJvcGRvd24tcGFuZWwgZmktZHJvcGRvd24tbGlzdCdcblxuICAgICAgICAgICAgcmV0dXJuIGRyb3Bkb3duXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZW5kZXJJdGVtcyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudCB8fCAhY3VycmVudFByb3BzKSByZXR1cm5cblxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBjdXJyZW50UHJvcHMuaXRlbXMgfHwgW11cblxuICAgICAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgaXRlbXNcbiAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJydcblxuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBgZmktZHJvcGRvd24tbGlzdC1pdGVtIGZpLWRyb3Bkb3duLWxpc3QtaXRlbS1sYWJlbCAke2luZGV4ID09PSBzZWxlY3RlZEluZGV4ID8gJ2ZpLXNlbGVjdGVkJyA6ICcnfWBcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gaXRlbVxuICAgICAgICAgICAgICAgICAgICBidXR0b24udHlwZSA9ICdidXR0b24nXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHNlbGVjdEl0ZW0oaW5kZXgpKVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGJ1dHRvbilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub1NlYXJjaFJlc3VsdHNNZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgICAgICBub1NlYXJjaFJlc3VsdHNNZXNzYWdlLmNsYXNzTmFtZSA9ICdmaS1kcm9wZG93bi1oZWFkZXInXG4gICAgICAgICAgICAgICAgbm9TZWFyY2hSZXN1bHRzTWVzc2FnZS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgICAgIG5vTWVyZ2VUYWdTZWFyY2hSZXN1bHRzTWVzc2FnZVxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQobm9TZWFyY2hSZXN1bHRzTWVzc2FnZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlbGVjdEl0ZW0gPSAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICghY3VycmVudFByb3BzKSByZXR1cm5cblxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBjdXJyZW50UHJvcHMuaXRlbXMgfHwgW11cbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpbmRleF1cblxuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvcHMuY29tbWFuZCh7IGlkOiBpdGVtIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9wcykgcmV0dXJuXG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gY3VycmVudFByb3BzLml0ZW1zIHx8IFtdXG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IChzZWxlY3RlZEluZGV4ICsgaXRlbXMubGVuZ3RoIC0gMSkgJSBpdGVtcy5sZW5ndGhcbiAgICAgICAgICAgIHJlbmRlckl0ZW1zKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRvd25IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvcHMpIHJldHVyblxuXG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGN1cnJlbnRQcm9wcy5pdGVtcyB8fCBbXVxuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSAoc2VsZWN0ZWRJbmRleCArIDEpICUgaXRlbXMubGVuZ3RoXG4gICAgICAgICAgICByZW5kZXJJdGVtcygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbnRlckhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBzZWxlY3RJdGVtKHNlbGVjdGVkSW5kZXgpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb25TdGFydDogKHByb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgY3VycmVudCBwcm9wc1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wcyA9IHByb3BzXG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCBzZWxlY3RlZCBpbmRleCB3aGVuIGl0ZW1zIGNoYW5nZVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSAwXG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZHJvcGRvd24gZWxlbWVudFxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBjcmVhdGVEcm9wZG93bigpXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcblxuICAgICAgICAgICAgICAgIC8vIFJlbmRlciBpbml0aWFsIGl0ZW1zXG4gICAgICAgICAgICAgICAgcmVuZGVySXRlbXMoKVxuXG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRvIERPTVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudClcblxuICAgICAgICAgICAgICAgIGlmICghcHJvcHMuY2xpZW50UmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVQb3NpdGlvbihwcm9wcy5lZGl0b3IsIGVsZW1lbnQpXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvblVwZGF0ZTogKHByb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgY3VycmVudCBwcm9wc1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wcyA9IHByb3BzXG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCBzZWxlY3RlZCBpbmRleCB3aGVuIGl0ZW1zIGNoYW5nZVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSAwXG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZHJvcGRvd24gaXRlbXNcbiAgICAgICAgICAgICAgICByZW5kZXJJdGVtcygpXG5cbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmNsaWVudFJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdXBkYXRlUG9zaXRpb24ocHJvcHMuZWRpdG9yLCBlbGVtZW50KVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25LZXlEb3duOiAocHJvcHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuZXZlbnQua2V5ID09PSAnQXJyb3dVcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBIYW5kbGVyKClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJykge1xuICAgICAgICAgICAgICAgICAgICBkb3duSGFuZGxlcigpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLmV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICBlbnRlckhhbmRsZXIoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25FeGl0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICB9LFxufSlcbiIsICJpbXBvcnQgeyBVbmRvUmVkbyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9ucydcbmltcG9ydCBCbG9ja3F1b3RlIGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJsb2NrcXVvdGUnXG5pbXBvcnQgQm9sZCBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1ib2xkJ1xuaW1wb3J0IENvZGUgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tY29kZSdcbmltcG9ydCBDb2RlQmxvY2sgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jaydcbmltcG9ydCBDdXN0b21CbG9jayBmcm9tICcuL2V4dGVuc2lvbi1jdXN0b20tYmxvY2suanMnXG5pbXBvcnQgRG9jdW1lbnQgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQnXG5pbXBvcnQgRHJvcGN1cnNvciBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1kcm9wY3Vyc29yJ1xuaW1wb3J0IEhlYWRpbmcgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taGVhZGluZydcbmltcG9ydCBJdGFsaWMgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taXRhbGljJ1xuaW1wb3J0IEltYWdlIGZyb20gJy4vZXh0ZW5zaW9uLWltYWdlLmpzJ1xuaW1wb3J0IExpbmsgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tbGluaydcbmltcG9ydCB7IEJ1bGxldExpc3QsIExpc3RJdGVtLCBPcmRlcmVkTGlzdCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QnXG5pbXBvcnQgTG9jYWxGaWxlcyBmcm9tICcuL2V4dGVuc2lvbi1sb2NhbC1maWxlcy5qcydcbmltcG9ydCBNZXJnZVRhZyBmcm9tICcuL2V4dGVuc2lvbi1tZXJnZS10YWcuanMnXG5pbXBvcnQgUGFyYWdyYXBoIGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXBhcmFncmFwaCdcbmltcG9ydCBQbGFjZWhvbGRlciBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1wbGFjZWhvbGRlcidcbmltcG9ydCBTdHJpa2UgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlJ1xuaW1wb3J0IFN1YnNjcmlwdCBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1zdWJzY3JpcHQnXG5pbXBvcnQgU3VwZXJzY3JpcHQgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tc3VwZXJzY3JpcHQnXG5pbXBvcnQgeyBUYWJsZUtpdCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXRhYmxlJ1xuaW1wb3J0IFRleHQgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tdGV4dCdcbmltcG9ydCBVbmRlcmxpbmUgZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lJ1xuXG5pbXBvcnQgZ2V0TWVyZ2VUYWdTdWdnZXN0aW9uIGZyb20gJy4vbWVyZ2UtdGFnLXN1Z2dlc3Rpb24uanMnXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jICh7XG4gICAgY3VzdG9tRXh0ZW5zaW9uVXJscyxcbiAgICBkZWxldGVDdXN0b21CbG9ja0J1dHRvbkljb25IdG1sLFxuICAgIGVkaXRDdXN0b21CbG9ja0J1dHRvbkljb25IdG1sLFxuICAgIGVkaXRDdXN0b21CbG9ja1VzaW5nLFxuICAgIGluc2VydEN1c3RvbUJsb2NrVXNpbmcsXG4gICAga2V5LFxuICAgIG1lcmdlVGFncyxcbiAgICBub01lcmdlVGFnU2VhcmNoUmVzdWx0c01lc3NhZ2UsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgc3RhdGVQYXRoLFxuICAgIHVwbG9hZGluZ0ZpbGVNZXNzYWdlLFxuICAgICR3aXJlLFxufSkgPT4gW1xuICAgIEJsb2NrcXVvdGUsXG4gICAgQm9sZCxcbiAgICBCdWxsZXRMaXN0LFxuICAgIENvZGUsXG4gICAgQ29kZUJsb2NrLFxuICAgIEN1c3RvbUJsb2NrLmNvbmZpZ3VyZSh7XG4gICAgICAgIGRlbGV0ZUN1c3RvbUJsb2NrQnV0dG9uSWNvbkh0bWwsXG4gICAgICAgIGVkaXRDdXN0b21CbG9ja0J1dHRvbkljb25IdG1sLFxuICAgICAgICBlZGl0Q3VzdG9tQmxvY2tVc2luZyxcbiAgICAgICAgaW5zZXJ0Q3VzdG9tQmxvY2tVc2luZyxcbiAgICB9KSxcbiAgICBEb2N1bWVudCxcbiAgICBEcm9wY3Vyc29yLFxuICAgIEhlYWRpbmcsXG4gICAgSXRhbGljLFxuICAgIEltYWdlLFxuICAgIExpbmsuY29uZmlndXJlKHtcbiAgICAgICAgYXV0b2xpbms6IHRydWUsXG4gICAgICAgIG9wZW5PbkNsaWNrOiBmYWxzZSxcbiAgICB9KSxcbiAgICBMaXN0SXRlbSxcbiAgICBMb2NhbEZpbGVzLmNvbmZpZ3VyZSh7XG4gICAgICAgIGdldCRXaXJlVXNpbmc6ICgpID0+ICR3aXJlLFxuICAgICAgICBrZXksXG4gICAgICAgIHN0YXRlUGF0aCxcbiAgICAgICAgdXBsb2FkaW5nTWVzc2FnZTogdXBsb2FkaW5nRmlsZU1lc3NhZ2UsXG4gICAgfSksXG4gICAgLi4uKG1lcmdlVGFncy5sZW5ndGhcbiAgICAgICAgPyBbXG4gICAgICAgICAgICAgIE1lcmdlVGFnLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgICBkZWxldGVUcmlnZ2VyV2l0aEJhY2tzcGFjZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb246IGdldE1lcmdlVGFnU3VnZ2VzdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgbWVyZ2VUYWdzLFxuICAgICAgICAgICAgICAgICAgICAgIG5vTWVyZ2VUYWdTZWFyY2hSZXN1bHRzTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICBdXG4gICAgICAgIDogW10pLFxuICAgIE9yZGVyZWRMaXN0LFxuICAgIFBhcmFncmFwaCxcbiAgICBQbGFjZWhvbGRlci5jb25maWd1cmUoe1xuICAgICAgICBwbGFjZWhvbGRlcixcbiAgICB9KSxcbiAgICBTdHJpa2UsXG4gICAgU3Vic2NyaXB0LFxuICAgIFN1cGVyc2NyaXB0LFxuXG4gICAgVGFibGVLaXQuY29uZmlndXJlKHtcbiAgICAgICAgdGFibGU6IHtcbiAgICAgICAgICAgIHJlc2l6YWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9KSxcblxuICAgIFRleHQsXG4gICAgVW5kZXJsaW5lLFxuICAgIFVuZG9SZWRvLFxuICAgIC4uLihcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBjdXN0b21FeHRlbnNpb25VcmxzLm1hcChhc3luYyAodXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWJzb2x1dGVVcmxSZWdFeHAgPSBuZXcgUmVnRXhwKCdeKD86W2EteitdKzopPy8vJywgJ2knKVxuXG4gICAgICAgICAgICAgICAgaWYgKCFhYnNvbHV0ZVVybFJlZ0V4cC50ZXN0KHVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gbmV3IFVSTCh1cmwsIGRvY3VtZW50LmJhc2VVUkkpLmhyZWZcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKGF3YWl0IGltcG9ydCh1cmwpKS5kZWZhdWx0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgKVxuICAgICkuZmxhdCgpLFxuXVxuIiwgImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSdcblxuaW1wb3J0IHR5cGUgeyBCdWJibGVNZW51UGx1Z2luUHJvcHMgfSBmcm9tICcuL2J1YmJsZS1tZW51LXBsdWdpbi5qcydcbmltcG9ydCB7IEJ1YmJsZU1lbnVQbHVnaW4gfSBmcm9tICcuL2J1YmJsZS1tZW51LXBsdWdpbi5qcydcblxuZXhwb3J0IHR5cGUgQnViYmxlTWVudU9wdGlvbnMgPSBPbWl0PEJ1YmJsZU1lbnVQbHVnaW5Qcm9wcywgJ2VkaXRvcicgfCAnZWxlbWVudCc+ICYge1xuICAvKipcbiAgICogVGhlIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgeW91ciBtZW51LlxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgbnVsbFxufVxuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGEgYnViYmxlIG1lbnUuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9idWJibGUtbWVudVxuICovXG5leHBvcnQgY29uc3QgQnViYmxlTWVudSA9IEV4dGVuc2lvbi5jcmVhdGU8QnViYmxlTWVudU9wdGlvbnM+KHtcbiAgbmFtZTogJ2J1YmJsZU1lbnUnLFxuXG4gIGFkZE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICBwbHVnaW5LZXk6ICdidWJibGVNZW51JyxcbiAgICAgIHVwZGF0ZURlbGF5OiB1bmRlZmluZWQsXG4gICAgICBzaG91bGRTaG93OiBudWxsLFxuICAgIH1cbiAgfSxcblxuICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIEJ1YmJsZU1lbnVQbHVnaW4oe1xuICAgICAgICBwbHVnaW5LZXk6IHRoaXMub3B0aW9ucy5wbHVnaW5LZXksXG4gICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgIGVsZW1lbnQ6IHRoaXMub3B0aW9ucy5lbGVtZW50LFxuICAgICAgICB1cGRhdGVEZWxheTogdGhpcy5vcHRpb25zLnVwZGF0ZURlbGF5LFxuICAgICAgICBzaG91bGRTaG93OiB0aGlzLm9wdGlvbnMuc2hvdWxkU2hvdyxcbiAgICAgIH0pLFxuICAgIF1cbiAgfSxcbn0pXG4iLCAiaW1wb3J0IHtcbiAgdHlwZSBNaWRkbGV3YXJlLFxuICBhcnJvdyxcbiAgYXV0b1BsYWNlbWVudCxcbiAgY29tcHV0ZVBvc2l0aW9uLFxuICBmbGlwLFxuICBoaWRlLFxuICBpbmxpbmUsXG4gIG9mZnNldCxcbiAgc2hpZnQsXG4gIHNpemUsXG59IGZyb20gJ0BmbG9hdGluZy11aS9kb20nXG5pbXBvcnQgdHlwZSB7IEVkaXRvciB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCB7IGlzVGV4dFNlbGVjdGlvbiwgcG9zVG9ET01SZWN0IH0gZnJvbSAnQHRpcHRhcC9jb3JlJ1xuaW1wb3J0IHR5cGUgeyBFZGl0b3JTdGF0ZSwgUGx1Z2luVmlldyB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBDZWxsU2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS90YWJsZXMnXG5pbXBvcnQgdHlwZSB7IEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnXG5cbmZ1bmN0aW9uIGNvbWJpbmVET01SZWN0cyhyZWN0MTogRE9NUmVjdCwgcmVjdDI6IERPTVJlY3QpOiBET01SZWN0IHtcbiAgY29uc3QgdG9wID0gTWF0aC5taW4ocmVjdDEudG9wLCByZWN0Mi50b3ApXG4gIGNvbnN0IGJvdHRvbSA9IE1hdGgubWF4KHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKVxuICBjb25zdCBsZWZ0ID0gTWF0aC5taW4ocmVjdDEubGVmdCwgcmVjdDIubGVmdClcbiAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpXG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcFxuICBjb25zdCB4ID0gbGVmdFxuICBjb25zdCB5ID0gdG9wXG4gIHJldHVybiBuZXcgRE9NUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJ1YmJsZU1lbnVQbHVnaW5Qcm9wcyB7XG4gIC8qKlxuICAgKiBUaGUgcGx1Z2luIGtleS5cbiAgICogQHR5cGUge1BsdWdpbktleSB8IHN0cmluZ31cbiAgICogQGRlZmF1bHQgJ2J1YmJsZU1lbnUnXG4gICAqL1xuICBwbHVnaW5LZXk6IFBsdWdpbktleSB8IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgZWRpdG9yIGluc3RhbmNlLlxuICAgKi9cbiAgZWRpdG9yOiBFZGl0b3JcblxuICAvKipcbiAgICogVGhlIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgeW91ciBtZW51LlxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50XG5cbiAgLyoqXG4gICAqIFRoZSBkZWxheSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBtZW51IHNob3VsZCBiZSB1cGRhdGVkLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gcHJldmVudCBwZXJmb3JtYW5jZSBpc3N1ZXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDI1MFxuICAgKi9cbiAgdXBkYXRlRGVsYXk/OiBudW1iZXJcblxuICAvKipcbiAgICogVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIG1lbnUgcG9zaXRpb24gc2hvdWxkIGJlIHVwZGF0ZWQgb24gd2luZG93IHJlc2l6ZS5cbiAgICogVGhpcyBjYW4gYmUgdXNlZnVsIHRvIHByZXZlbnQgcGVyZm9ybWFuY2UgaXNzdWVzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCA2MFxuICAgKi9cbiAgcmVzaXplRGVsYXk/OiBudW1iZXJcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbWVudSBzaG91bGQgYmUgc2hvd24gb3Igbm90LlxuICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCwgdGhlIG1lbnUgd2lsbCBiZSBoaWRkZW4sIG90aGVyd2lzZSBpdCB3aWxsIGJlIHNob3duLlxuICAgKi9cbiAgc2hvdWxkU2hvdzpcbiAgICB8ICgocHJvcHM6IHtcbiAgICAgICAgZWRpdG9yOiBFZGl0b3JcbiAgICAgICAgZWxlbWVudDogSFRNTEVsZW1lbnRcbiAgICAgICAgdmlldzogRWRpdG9yVmlld1xuICAgICAgICBzdGF0ZTogRWRpdG9yU3RhdGVcbiAgICAgICAgb2xkU3RhdGU/OiBFZGl0b3JTdGF0ZVxuICAgICAgICBmcm9tOiBudW1iZXJcbiAgICAgICAgdG86IG51bWJlclxuICAgICAgfSkgPT4gYm9vbGVhbilcbiAgICB8IG51bGxcblxuICAvKipcbiAgICogRmxvYXRpbmdVSSBvcHRpb25zLlxuICAgKi9cbiAgb3B0aW9ucz86IHtcbiAgICBzdHJhdGVneT86ICdhYnNvbHV0ZScgfCAnZml4ZWQnXG4gICAgcGxhY2VtZW50PzpcbiAgICAgIHwgJ3RvcCdcbiAgICAgIHwgJ3JpZ2h0J1xuICAgICAgfCAnYm90dG9tJ1xuICAgICAgfCAnbGVmdCdcbiAgICAgIHwgJ3RvcC1zdGFydCdcbiAgICAgIHwgJ3RvcC1lbmQnXG4gICAgICB8ICdyaWdodC1zdGFydCdcbiAgICAgIHwgJ3JpZ2h0LWVuZCdcbiAgICAgIHwgJ2JvdHRvbS1zdGFydCdcbiAgICAgIHwgJ2JvdHRvbS1lbmQnXG4gICAgICB8ICdsZWZ0LXN0YXJ0J1xuICAgICAgfCAnbGVmdC1lbmQnXG4gICAgb2Zmc2V0PzogUGFyYW1ldGVyczx0eXBlb2Ygb2Zmc2V0PlswXSB8IGJvb2xlYW5cbiAgICBmbGlwPzogUGFyYW1ldGVyczx0eXBlb2YgZmxpcD5bMF0gfCBib29sZWFuXG4gICAgc2hpZnQ/OiBQYXJhbWV0ZXJzPHR5cGVvZiBzaGlmdD5bMF0gfCBib29sZWFuXG4gICAgYXJyb3c/OiBQYXJhbWV0ZXJzPHR5cGVvZiBhcnJvdz5bMF0gfCBmYWxzZVxuICAgIHNpemU/OiBQYXJhbWV0ZXJzPHR5cGVvZiBzaXplPlswXSB8IGJvb2xlYW5cbiAgICBhdXRvUGxhY2VtZW50PzogUGFyYW1ldGVyczx0eXBlb2YgYXV0b1BsYWNlbWVudD5bMF0gfCBib29sZWFuXG4gICAgaGlkZT86IFBhcmFtZXRlcnM8dHlwZW9mIGhpZGU+WzBdIHwgYm9vbGVhblxuICAgIGlubGluZT86IFBhcmFtZXRlcnM8dHlwZW9mIGlubGluZT5bMF0gfCBib29sZWFuXG5cbiAgICBvblNob3c/OiAoKSA9PiB2b2lkXG4gICAgb25IaWRlPzogKCkgPT4gdm9pZFxuICAgIG9uVXBkYXRlPzogKCkgPT4gdm9pZFxuICAgIG9uRGVzdHJveT86ICgpID0+IHZvaWRcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBCdWJibGVNZW51Vmlld1Byb3BzID0gQnViYmxlTWVudVBsdWdpblByb3BzICYge1xuICB2aWV3OiBFZGl0b3JWaWV3XG59XG5cbmV4cG9ydCBjbGFzcyBCdWJibGVNZW51VmlldyBpbXBsZW1lbnRzIFBsdWdpblZpZXcge1xuICBwdWJsaWMgZWRpdG9yOiBFZGl0b3JcblxuICBwdWJsaWMgZWxlbWVudDogSFRNTEVsZW1lbnRcblxuICBwdWJsaWMgdmlldzogRWRpdG9yVmlld1xuXG4gIHB1YmxpYyBwcmV2ZW50SGlkZSA9IGZhbHNlXG5cbiAgcHVibGljIHVwZGF0ZURlbGF5OiBudW1iZXJcblxuICBwdWJsaWMgcmVzaXplRGVsYXk6IG51bWJlclxuXG4gIHByaXZhdGUgdXBkYXRlRGVib3VuY2VUaW1lcjogbnVtYmVyIHwgdW5kZWZpbmVkXG5cbiAgcHJpdmF0ZSByZXNpemVEZWJvdW5jZVRpbWVyOiBudW1iZXIgfCB1bmRlZmluZWRcblxuICBwcml2YXRlIGlzVmlzaWJsZSA9IGZhbHNlXG5cbiAgcHJpdmF0ZSBmbG9hdGluZ1VJT3B0aW9uczogTm9uTnVsbGFibGU8QnViYmxlTWVudVBsdWdpblByb3BzWydvcHRpb25zJ10+ID0ge1xuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgb2Zmc2V0OiA4LFxuICAgIGZsaXA6IHt9LFxuICAgIHNoaWZ0OiB7fSxcbiAgICBhcnJvdzogZmFsc2UsXG4gICAgc2l6ZTogZmFsc2UsXG4gICAgYXV0b1BsYWNlbWVudDogZmFsc2UsXG4gICAgaGlkZTogZmFsc2UsXG4gICAgaW5saW5lOiBmYWxzZSxcbiAgICBvblNob3c6IHVuZGVmaW5lZCxcbiAgICBvbkhpZGU6IHVuZGVmaW5lZCxcbiAgICBvblVwZGF0ZTogdW5kZWZpbmVkLFxuICAgIG9uRGVzdHJveTogdW5kZWZpbmVkLFxuICB9XG5cbiAgcHVibGljIHNob3VsZFNob3c6IEV4Y2x1ZGU8QnViYmxlTWVudVBsdWdpblByb3BzWydzaG91bGRTaG93J10sIG51bGw+ID0gKHsgdmlldywgc3RhdGUsIGZyb20sIHRvIH0pID0+IHtcbiAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZVxuICAgIGNvbnN0IHsgZW1wdHkgfSA9IHNlbGVjdGlvblxuXG4gICAgLy8gU29tZXRpbWUgY2hlY2sgZm9yIGBlbXB0eWAgaXMgbm90IGVub3VnaC5cbiAgICAvLyBEb3VibGVjbGljayBhbiBlbXB0eSBwYXJhZ3JhcGggcmV0dXJucyBhIG5vZGUgc2l6ZSBvZiAyLlxuICAgIC8vIFNvIHdlIGNoZWNrIGFsc28gZm9yIGFuIGVtcHR5IHRleHQgc2l6ZS5cbiAgICBjb25zdCBpc0VtcHR5VGV4dEJsb2NrID0gIWRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bykubGVuZ3RoICYmIGlzVGV4dFNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pXG5cbiAgICAvLyBXaGVuIGNsaWNraW5nIG9uIGEgZWxlbWVudCBpbnNpZGUgdGhlIGJ1YmJsZSBtZW51IHRoZSBlZGl0b3IgXCJibHVyXCIgZXZlbnRcbiAgICAvLyBpcyBjYWxsZWQgYW5kIHRoZSBidWJibGUgbWVudSBpdGVtIGlzIGZvY3Vzc2VkLiBJbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkXG4gICAgLy8gY29uc2lkZXIgdGhlIG1lbnUgYXMgcGFydCBvZiB0aGUgZWRpdG9yIGFuZCBrZWVwIHNob3dpbmcgdGhlIG1lbnVcbiAgICBjb25zdCBpc0NoaWxkT2ZNZW51ID0gdGhpcy5lbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpXG5cbiAgICBjb25zdCBoYXNFZGl0b3JGb2N1cyA9IHZpZXcuaGFzRm9jdXMoKSB8fCBpc0NoaWxkT2ZNZW51XG5cbiAgICBpZiAoIWhhc0VkaXRvckZvY3VzIHx8IGVtcHR5IHx8IGlzRW1wdHlUZXh0QmxvY2sgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBnZXQgbWlkZGxld2FyZXMoKSB7XG4gICAgY29uc3QgbWlkZGxld2FyZXM6IE1pZGRsZXdhcmVbXSA9IFtdXG5cbiAgICBpZiAodGhpcy5mbG9hdGluZ1VJT3B0aW9ucy5mbGlwKSB7XG4gICAgICBtaWRkbGV3YXJlcy5wdXNoKGZsaXAodHlwZW9mIHRoaXMuZmxvYXRpbmdVSU9wdGlvbnMuZmxpcCAhPT0gJ2Jvb2xlYW4nID8gdGhpcy5mbG9hdGluZ1VJT3B0aW9ucy5mbGlwIDogdW5kZWZpbmVkKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mbG9hdGluZ1VJT3B0aW9ucy5zaGlmdCkge1xuICAgICAgbWlkZGxld2FyZXMucHVzaChcbiAgICAgICAgc2hpZnQodHlwZW9mIHRoaXMuZmxvYXRpbmdVSU9wdGlvbnMuc2hpZnQgIT09ICdib29sZWFuJyA/IHRoaXMuZmxvYXRpbmdVSU9wdGlvbnMuc2hpZnQgOiB1bmRlZmluZWQpLFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZsb2F0aW5nVUlPcHRpb25zLm9mZnNldCkge1xuICAgICAgbWlkZGxld2FyZXMucHVzaChcbiAgICAgICAgb2Zmc2V0KHR5cGVvZiB0aGlzLmZsb2F0aW5nVUlPcHRpb25zLm9mZnNldCAhPT0gJ2Jvb2xlYW4nID8gdGhpcy5mbG9hdGluZ1VJT3B0aW9ucy5vZmZzZXQgOiB1bmRlZmluZWQpLFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZsb2F0aW5nVUlPcHRpb25zLmFycm93KSB7XG4gICAgICBtaWRkbGV3YXJlcy5wdXNoKGFycm93KHRoaXMuZmxvYXRpbmdVSU9wdGlvbnMuYXJyb3cpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZsb2F0aW5nVUlPcHRpb25zLnNpemUpIHtcbiAgICAgIG1pZGRsZXdhcmVzLnB1c2goc2l6ZSh0eXBlb2YgdGhpcy5mbG9hdGluZ1VJT3B0aW9ucy5zaXplICE9PSAnYm9vbGVhbicgPyB0aGlzLmZsb2F0aW5nVUlPcHRpb25zLnNpemUgOiB1bmRlZmluZWQpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZsb2F0aW5nVUlPcHRpb25zLmF1dG9QbGFjZW1lbnQpIHtcbiAgICAgIG1pZGRsZXdhcmVzLnB1c2goXG4gICAgICAgIGF1dG9QbGFjZW1lbnQoXG4gICAgICAgICAgdHlwZW9mIHRoaXMuZmxvYXRpbmdVSU9wdGlvbnMuYXV0b1BsYWNlbWVudCAhPT0gJ2Jvb2xlYW4nID8gdGhpcy5mbG9hdGluZ1VJT3B0aW9ucy5hdXRvUGxhY2VtZW50IDogdW5kZWZpbmVkLFxuICAgICAgICApLFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZsb2F0aW5nVUlPcHRpb25zLmhpZGUpIHtcbiAgICAgIG1pZGRsZXdhcmVzLnB1c2goaGlkZSh0eXBlb2YgdGhpcy5mbG9hdGluZ1VJT3B0aW9ucy5oaWRlICE9PSAnYm9vbGVhbicgPyB0aGlzLmZsb2F0aW5nVUlPcHRpb25zLmhpZGUgOiB1bmRlZmluZWQpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmZsb2F0aW5nVUlPcHRpb25zLmlubGluZSkge1xuICAgICAgbWlkZGxld2FyZXMucHVzaChcbiAgICAgICAgaW5saW5lKHR5cGVvZiB0aGlzLmZsb2F0aW5nVUlPcHRpb25zLmlubGluZSAhPT0gJ2Jvb2xlYW4nID8gdGhpcy5mbG9hdGluZ1VJT3B0aW9ucy5pbmxpbmUgOiB1bmRlZmluZWQpLFxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiBtaWRkbGV3YXJlc1xuICB9XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIGVkaXRvcixcbiAgICBlbGVtZW50LFxuICAgIHZpZXcsXG4gICAgdXBkYXRlRGVsYXkgPSAyNTAsXG4gICAgcmVzaXplRGVsYXkgPSA2MCxcbiAgICBzaG91bGRTaG93LFxuICAgIG9wdGlvbnMsXG4gIH06IEJ1YmJsZU1lbnVWaWV3UHJvcHMpIHtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnRcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy51cGRhdGVEZWxheSA9IHVwZGF0ZURlbGF5XG4gICAgdGhpcy5yZXNpemVEZWxheSA9IHJlc2l6ZURlbGF5XG5cbiAgICB0aGlzLmZsb2F0aW5nVUlPcHRpb25zID0ge1xuICAgICAgLi4udGhpcy5mbG9hdGluZ1VJT3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFNob3cpIHtcbiAgICAgIHRoaXMuc2hvdWxkU2hvdyA9IHNob3VsZFNob3dcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd25IYW5kbGVyLCB7IGNhcHR1cmU6IHRydWUgfSlcbiAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcilcbiAgICB0aGlzLmVkaXRvci5vbignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcilcbiAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlc2l6ZURlYm91bmNlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplRGVib3VuY2VUaW1lcilcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXNpemVEZWJvdW5jZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKClcbiAgICAgIH0sIHRoaXMucmVzaXplRGVsYXkpXG4gICAgfSlcblxuICAgIHRoaXMudXBkYXRlKHZpZXcsIHZpZXcuc3RhdGUpXG5cbiAgICBpZiAodGhpcy5nZXRTaG91bGRTaG93KCkpIHtcbiAgICAgIHRoaXMuc2hvdygpXG4gICAgfVxuICB9XG5cbiAgbW91c2Vkb3duSGFuZGxlciA9ICgpID0+IHtcbiAgICB0aGlzLnByZXZlbnRIaWRlID0gdHJ1ZVxuICB9XG5cbiAgZHJhZ3N0YXJ0SGFuZGxlciA9ICgpID0+IHtcbiAgICB0aGlzLmhpZGUoKVxuICB9XG5cbiAgZm9jdXNIYW5kbGVyID0gKCkgPT4ge1xuICAgIC8vIHdlIHVzZSBgc2V0VGltZW91dGAgdG8gbWFrZSBzdXJlIGBzZWxlY3Rpb25gIGlzIGFscmVhZHkgdXBkYXRlZFxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGUodGhpcy5lZGl0b3IudmlldykpXG4gIH1cblxuICBibHVySGFuZGxlciA9ICh7IGV2ZW50IH06IHsgZXZlbnQ6IEZvY3VzRXZlbnQgfSkgPT4ge1xuICAgIGlmICh0aGlzLnByZXZlbnRIaWRlKSB7XG4gICAgICB0aGlzLnByZXZlbnRIaWRlID0gZmFsc2VcblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50Py5yZWxhdGVkVGFyZ2V0ICYmIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlPy5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0IGFzIE5vZGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoZXZlbnQ/LnJlbGF0ZWRUYXJnZXQgPT09IHRoaXMuZWRpdG9yLnZpZXcuZG9tKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmhpZGUoKVxuICB9XG5cbiAgdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRoaXMuZWRpdG9yLnN0YXRlXG4gICAgbGV0IHZpcnR1YWxFbGVtZW50ID0ge1xuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKSA9PiBwb3NUb0RPTVJlY3QodGhpcy52aWV3LCBzZWxlY3Rpb24uZnJvbSwgc2VsZWN0aW9uLnRvKSxcbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlIGZvciBjZWxsIHNlbGVjdGlvbnNcbiAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgQ2VsbFNlbGVjdGlvbikge1xuICAgICAgY29uc3QgeyAkYW5jaG9yQ2VsbCwgJGhlYWRDZWxsIH0gPSBzZWxlY3Rpb25cblxuICAgICAgY29uc3QgZnJvbSA9ICRhbmNob3JDZWxsID8gJGFuY2hvckNlbGwucG9zIDogJGhlYWRDZWxsIS5wb3NcbiAgICAgIGNvbnN0IHRvID0gJGhlYWRDZWxsID8gJGhlYWRDZWxsLnBvcyA6ICRhbmNob3JDZWxsIS5wb3NcblxuICAgICAgY29uc3QgZnJvbURPTSA9IHRoaXMudmlldy5ub2RlRE9NKGZyb20pXG4gICAgICBjb25zdCB0b0RPTSA9IHRoaXMudmlldy5ub2RlRE9NKHRvKVxuXG4gICAgICBpZiAoIWZyb21ET00gfHwgIXRvRE9NKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBjbGllbnRSZWN0ID1cbiAgICAgICAgZnJvbURPTSA9PT0gdG9ET01cbiAgICAgICAgICA/IChmcm9tRE9NIGFzIEhUTUxFbGVtZW50KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgIDogY29tYmluZURPTVJlY3RzKFxuICAgICAgICAgICAgICAoZnJvbURPTSBhcyBIVE1MRWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICh0b0RPTSBhcyBIVE1MRWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICApXG5cbiAgICAgIHZpcnR1YWxFbGVtZW50ID0ge1xuICAgICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6ICgpID0+IGNsaWVudFJlY3QsXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcHV0ZVBvc2l0aW9uKHZpcnR1YWxFbGVtZW50LCB0aGlzLmVsZW1lbnQsIHtcbiAgICAgIHBsYWNlbWVudDogdGhpcy5mbG9hdGluZ1VJT3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneTogdGhpcy5mbG9hdGluZ1VJT3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmU6IHRoaXMubWlkZGxld2FyZXMsXG4gICAgfSkudGhlbigoeyB4LCB5LCBzdHJhdGVneSB9KSA9PiB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSAnbWF4LWNvbnRlbnQnXG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBzdHJhdGVneVxuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSBgJHt4fXB4YFxuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IGAke3l9cHhgXG5cbiAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSAmJiB0aGlzLmZsb2F0aW5nVUlPcHRpb25zLm9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuZmxvYXRpbmdVSU9wdGlvbnMub25VcGRhdGUoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGUodmlldzogRWRpdG9yVmlldywgb2xkU3RhdGU/OiBFZGl0b3JTdGF0ZSkge1xuICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXdcbiAgICBjb25zdCBoYXNWYWxpZFNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbi5mcm9tICE9PSBzdGF0ZS5zZWxlY3Rpb24udG9cblxuICAgIGlmICh0aGlzLnVwZGF0ZURlbGF5ID4gMCAmJiBoYXNWYWxpZFNlbGVjdGlvbikge1xuICAgICAgdGhpcy5oYW5kbGVEZWJvdW5jZWRVcGRhdGUodmlldywgb2xkU3RhdGUpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb25DaGFuZ2VkID0gIW9sZFN0YXRlPy5zZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pXG4gICAgY29uc3QgZG9jQ2hhbmdlZCA9ICFvbGRTdGF0ZT8uZG9jLmVxKHZpZXcuc3RhdGUuZG9jKVxuXG4gICAgdGhpcy51cGRhdGVIYW5kbGVyKHZpZXcsIHNlbGVjdGlvbkNoYW5nZWQsIGRvY0NoYW5nZWQsIG9sZFN0YXRlKVxuICB9XG5cbiAgaGFuZGxlRGVib3VuY2VkVXBkYXRlID0gKHZpZXc6IEVkaXRvclZpZXcsIG9sZFN0YXRlPzogRWRpdG9yU3RhdGUpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb25DaGFuZ2VkID0gIW9sZFN0YXRlPy5zZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pXG4gICAgY29uc3QgZG9jQ2hhbmdlZCA9ICFvbGRTdGF0ZT8uZG9jLmVxKHZpZXcuc3RhdGUuZG9jKVxuXG4gICAgaWYgKCFzZWxlY3Rpb25DaGFuZ2VkICYmICFkb2NDaGFuZ2VkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyKVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlRGVib3VuY2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlSGFuZGxlcih2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSlcbiAgICB9LCB0aGlzLnVwZGF0ZURlbGF5KVxuICB9XG5cbiAgZ2V0U2hvdWxkU2hvdyhvbGRTdGF0ZT86IEVkaXRvclN0YXRlKSB7XG4gICAgY29uc3QgeyBzdGF0ZSB9ID0gdGhpcy52aWV3XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlXG5cbiAgICAvLyBzdXBwb3J0IGZvciBDZWxsU2VsZWN0aW9uc1xuICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb25cbiAgICBjb25zdCBmcm9tID0gTWF0aC5taW4oLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kZnJvbS5wb3MpKVxuICAgIGNvbnN0IHRvID0gTWF0aC5tYXgoLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kdG8ucG9zKSlcblxuICAgIGNvbnN0IHNob3VsZFNob3cgPSB0aGlzLnNob3VsZFNob3c/Lih7XG4gICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50LFxuICAgICAgdmlldzogdGhpcy52aWV3LFxuICAgICAgc3RhdGUsXG4gICAgICBvbGRTdGF0ZSxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICB9KVxuXG4gICAgcmV0dXJuIHNob3VsZFNob3dcbiAgfVxuXG4gIHVwZGF0ZUhhbmRsZXIgPSAodmlldzogRWRpdG9yVmlldywgc2VsZWN0aW9uQ2hhbmdlZDogYm9vbGVhbiwgZG9jQ2hhbmdlZDogYm9vbGVhbiwgb2xkU3RhdGU/OiBFZGl0b3JTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHsgY29tcG9zaW5nIH0gPSB2aWV3XG5cbiAgICBjb25zdCBpc1NhbWUgPSAhc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZFxuXG4gICAgaWYgKGNvbXBvc2luZyB8fCBpc1NhbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHNob3VsZFNob3cgPSB0aGlzLmdldFNob3VsZFNob3cob2xkU3RhdGUpXG5cbiAgICBpZiAoIXNob3VsZFNob3cpIHtcbiAgICAgIHRoaXMuaGlkZSgpXG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKVxuICAgIHRoaXMuc2hvdygpXG4gIH1cblxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgIC8vIGF0dGFjaCB0byBlZGl0b3IncyBwYXJlbnQgZWxlbWVudFxuICAgIHRoaXMudmlldy5kb20ucGFyZW50RWxlbWVudD8uYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KVxuXG4gICAgaWYgKHRoaXMuZmxvYXRpbmdVSU9wdGlvbnMub25TaG93KSB7XG4gICAgICB0aGlzLmZsb2F0aW5nVUlPcHRpb25zLm9uU2hvdygpXG4gICAgfVxuXG4gICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlXG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUub3BhY2l0eSA9ICcwJ1xuICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKVxuXG4gICAgaWYgKHRoaXMuZmxvYXRpbmdVSU9wdGlvbnMub25IaWRlKSB7XG4gICAgICB0aGlzLmZsb2F0aW5nVUlPcHRpb25zLm9uSGlkZSgpXG4gICAgfVxuXG4gICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmhpZGUoKVxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KVxuICAgIHRoaXMudmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5kcmFnc3RhcnRIYW5kbGVyKVxuICAgIHRoaXMuZWRpdG9yLm9mZignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcilcbiAgICB0aGlzLmVkaXRvci5vZmYoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuZmxvYXRpbmdVSU9wdGlvbnMub25EZXN0cm95KSB7XG4gICAgICB0aGlzLmZsb2F0aW5nVUlPcHRpb25zLm9uRGVzdHJveSgpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBCdWJibGVNZW51UGx1Z2luID0gKG9wdGlvbnM6IEJ1YmJsZU1lbnVQbHVnaW5Qcm9wcykgPT4ge1xuICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAga2V5OiB0eXBlb2Ygb3B0aW9ucy5wbHVnaW5LZXkgPT09ICdzdHJpbmcnID8gbmV3IFBsdWdpbktleShvcHRpb25zLnBsdWdpbktleSkgOiBvcHRpb25zLnBsdWdpbktleSxcbiAgICB2aWV3OiB2aWV3ID0+IG5ldyBCdWJibGVNZW51Vmlldyh7IHZpZXcsIC4uLm9wdGlvbnMgfSksXG4gIH0pXG59XG4iLCAiaW1wb3J0IHsgQnViYmxlTWVudSB9IGZyb20gJy4vYnViYmxlLW1lbnUuanMnXG5cbmV4cG9ydCAqIGZyb20gJy4vYnViYmxlLW1lbnUuanMnXG5leHBvcnQgKiBmcm9tICcuL2J1YmJsZS1tZW51LXBsdWdpbi5qcydcblxuZXhwb3J0IGRlZmF1bHQgQnViYmxlTWVudVxuIiwgImltcG9ydCB7IEVkaXRvciB9IGZyb20gJ0B0aXB0YXAvY29yZSdcbmltcG9ydCBnZXRFeHRlbnNpb25zIGZyb20gJy4vcmljaC1lZGl0b3IvZXh0ZW5zaW9ucydcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnXG5pbXBvcnQgeyBCdWJibGVNZW51UGx1Z2luIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYnViYmxlLW1lbnUnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJpY2hFZGl0b3JGb3JtQ29tcG9uZW50KHtcbiAgICBhY3RpdmVQYW5lbCxcbiAgICBkZWxldGVDdXN0b21CbG9ja0J1dHRvbkljb25IdG1sLFxuICAgIGVkaXRDdXN0b21CbG9ja0J1dHRvbkljb25IdG1sLFxuICAgIGV4dGVuc2lvbnMsXG4gICAga2V5LFxuICAgIGlzRGlzYWJsZWQsXG4gICAgaXNMaXZlRGVib3VuY2VkLFxuICAgIGlzTGl2ZU9uQmx1cixcbiAgICBsaXZlRGVib3VuY2UsXG4gICAgbGl2ZXdpcmVJZCxcbiAgICBtZXJnZVRhZ3MsXG4gICAgbm9NZXJnZVRhZ1NlYXJjaFJlc3VsdHNNZXNzYWdlLFxuICAgIHBsYWNlaG9sZGVyLFxuICAgIHN0YXRlLFxuICAgIHN0YXRlUGF0aCxcbiAgICB1cGxvYWRpbmdGaWxlTWVzc2FnZSxcbiAgICBidWJibGVNZW51cyxcbn0pIHtcbiAgICBsZXQgZWRpdG9yXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0ZSxcblxuICAgICAgICBhY3RpdmVQYW5lbCxcblxuICAgICAgICBlZGl0b3JTZWxlY3Rpb246IHsgdHlwZTogJ3RleHQnLCBhbmNob3I6IDEsIGhlYWQ6IDEgfSxcblxuICAgICAgICBpc1VwbG9hZGluZ0ZpbGU6IGZhbHNlLFxuXG4gICAgICAgIHNob3VsZFVwZGF0ZVN0YXRlOiB0cnVlLFxuXG4gICAgICAgIGVkaXRvclVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcblxuICAgICAgICBhc3luYyBpbml0KCkge1xuICAgICAgICAgICAgZWRpdG9yID0gbmV3IEVkaXRvcih7XG4gICAgICAgICAgICAgICAgZWRpdGFibGU6ICFpc0Rpc2FibGVkLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuJHJlZnMuZWRpdG9yLFxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IGF3YWl0IGdldEV4dGVuc2lvbnMoe1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21FeHRlbnNpb25VcmxzOiBleHRlbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVDdXN0b21CbG9ja0J1dHRvbkljb25IdG1sLFxuICAgICAgICAgICAgICAgICAgICBlZGl0Q3VzdG9tQmxvY2tCdXR0b25JY29uSHRtbCxcbiAgICAgICAgICAgICAgICAgICAgZWRpdEN1c3RvbUJsb2NrVXNpbmc6IChpZCwgY29uZmlnKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kd2lyZS5tb3VudEFjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY3VzdG9tQmxvY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yU2VsZWN0aW9uOiB0aGlzLmVkaXRvclNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogJ2VkaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzY2hlbWFDb21wb25lbnQ6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0Q3VzdG9tQmxvY2tVc2luZzogKGlkLCBkcmFnUG9zaXRpb24gPSBudWxsKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kd2lyZS5tb3VudEFjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY3VzdG9tQmxvY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQsIGRyYWdQb3NpdGlvbiwgbW9kZTogJ2luc2VydCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHNjaGVtYUNvbXBvbmVudDoga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlVGFncyxcbiAgICAgICAgICAgICAgICAgICAgbm9NZXJnZVRhZ1NlYXJjaFJlc3VsdHNNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICB1cGxvYWRpbmdGaWxlTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgJHdpcmU6IHRoaXMuJHdpcmUsXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZU1lbnVzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBidWJibGVNZW51cy5mb3JFYWNoKChtZW51Q29uZmlnKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuJHJlZnNbbWVudUNvbmZpZy5yZWZdXG5cbiAgICAgICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgYEJ1YmJsZU1lbnUgZWxlbWVudCBcIiR7bWVudUNvbmZpZy5yZWZ9XCIgbm90IGZvdW5kLmAsXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBtZW51Q29uZmlnLmlzQWN0aXZlQ29uZGl0aW9uIHx8IFtdXG5cbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRTaG93ID0gKHsgZWRpdG9yIH0pID0+XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnNvbWUoKHR5cGUpID0+IGVkaXRvci5pc0FjdGl2ZSh0eXBlKSlcblxuICAgICAgICAgICAgICAgIGVkaXRvci5yZWdpc3RlclBsdWdpbihcbiAgICAgICAgICAgICAgICAgICAgQnViYmxlTWVudVBsdWdpbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luS2V5OiBgYnViYmxlTWVudS0ke21lbnVDb25maWcucmVmfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTaG93OiBzaG91bGRTaG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIGVkaXRvci5vbignY3JlYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yVXBkYXRlZEF0ID0gRGF0ZS5ub3coKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgZWRpdG9yLm9uKFxuICAgICAgICAgICAgICAgICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgIEFscGluZS5kZWJvdW5jZSgoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvclVwZGF0ZWRBdCA9IERhdGUubm93KClcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gZWRpdG9yLmdldEpTT04oKVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkVXBkYXRlU3RhdGUgPSBmYWxzZVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xpdmVEZWJvdW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpcmUuY29tbWl0KClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGxpdmVEZWJvdW5jZSA/PyAzMDApLFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBlZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsICh7IHRyYW5zYWN0aW9uIH0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvclVwZGF0ZWRBdCA9IERhdGUubm93KClcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvclNlbGVjdGlvbiA9IHRyYW5zYWN0aW9uLnNlbGVjdGlvbi50b0pTT04oKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgaWYgKGlzTGl2ZU9uQmx1cikge1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbignYmx1cicsICgpID0+IHRoaXMuJHdpcmUuY29tbWl0KCkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuJHdhdGNoKCdzdGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkVXBkYXRlU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG91bGRVcGRhdGVTdGF0ZSA9IHRydWVcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlZGl0b3IuY29tbWFuZHMuc2V0Q29udGVudCh0aGlzLnN0YXRlKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3J1bi1yaWNoLWVkaXRvci1jb21tYW5kcycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZXRhaWwubGl2ZXdpcmVJZCAhPT0gbGl2ZXdpcmVJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGV0YWlsLmtleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucnVuRWRpdG9yQ29tbWFuZHMoZXZlbnQuZGV0YWlsKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3JpY2gtZWRpdG9yLXVwbG9hZGluZy1maWxlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRldGFpbC5saXZld2lyZUlkICE9PSBsaXZld2lyZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZXRhaWwua2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5pc1VwbG9hZGluZ0ZpbGUgPSB0cnVlXG5cbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3JpY2gtZWRpdG9yLXVwbG9hZGVkLWZpbGUnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGV0YWlsLmxpdmV3aXJlSWQgIT09IGxpdmV3aXJlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRldGFpbC5rZXkgIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmlzVXBsb2FkaW5nRmlsZSA9IGZhbHNlXG5cbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KGBzY2hlbWEtY29tcG9uZW50LSR7bGl2ZXdpcmVJZH0tJHtrZXl9LWxvYWRlZGApLFxuICAgICAgICAgICAgKVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldEVkaXRvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBlZGl0b3JcbiAgICAgICAgfSxcblxuICAgICAgICAkZ2V0RWRpdG9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RWRpdG9yKClcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRFZGl0b3JTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVkaXRvclNlbGVjdGlvbiA9IHNlbGVjdGlvblxuXG4gICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgICAgICAuY2hhaW4oKVxuICAgICAgICAgICAgICAgIC5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgU2VsZWN0aW9uLmZyb21KU09OKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zdGF0ZS5kb2MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3JTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5ydW4oKVxuICAgICAgICB9LFxuXG4gICAgICAgIHJ1bkVkaXRvckNvbW1hbmRzKHsgY29tbWFuZHMsIGVkaXRvclNlbGVjdGlvbiB9KSB7XG4gICAgICAgICAgICB0aGlzLnNldEVkaXRvclNlbGVjdGlvbihlZGl0b3JTZWxlY3Rpb24pXG5cbiAgICAgICAgICAgIGxldCBjb21tYW5kQ2hhaW4gPSBlZGl0b3IuY2hhaW4oKVxuXG4gICAgICAgICAgICBjb21tYW5kcy5mb3JFYWNoKFxuICAgICAgICAgICAgICAgIChjb21tYW5kKSA9PlxuICAgICAgICAgICAgICAgICAgICAoY29tbWFuZENoYWluID0gY29tbWFuZENoYWluW2NvbW1hbmQubmFtZV0oXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi4oY29tbWFuZC5hcmd1bWVudHMgPz8gW10pLFxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgY29tbWFuZENoYWluLnJ1bigpXG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9nZ2xlUGFuZWwoaWQgPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1BhbmVsQWN0aXZlKGlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlUGFuZWwgPSBudWxsXG5cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hY3RpdmVQYW5lbCA9IGlkXG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNQYW5lbEFjdGl2ZShpZCA9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVBhbmVsICE9PSBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVBhbmVsID09PSBpZFxuICAgICAgICB9LFxuXG4gICAgICAgIGluc2VydE1lcmdlVGFnKGlkKSB7XG4gICAgICAgICAgICBlZGl0b3JcbiAgICAgICAgICAgICAgICAuY2hhaW4oKVxuICAgICAgICAgICAgICAgIC5mb2N1cygpXG4gICAgICAgICAgICAgICAgLmluc2VydENvbnRlbnQoW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbWVyZ2VUYWcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJyAnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLnJ1bigpXG4gICAgICAgIH0sXG4gICAgfVxufVxuIl0sCiAgIm1hcHBpbmdzIjogIjtBQUVBLFNBQVMsV0FBVyxTQUFTO0FBQzNCLE9BQUssVUFBVTtBQUNqQjtBQUVBLFdBQVcsWUFBWTtBQUFBLEVBQ3JCLGFBQWE7QUFBQSxFQUViLE1BQU0sU0FBUyxLQUFLO0FBQ2xCLGFB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QSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFDUDtBQUVPLElBQUksUUFBUTtBQUFBLEVBQ2pCLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLElBQUk7QUFBQSxFQUNKLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtB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QUFBLFVBQ3JDLEdBQUlBLFNBQVEsYUFBYSxDQUFDO0FBQUEsUUFDOUI7QUFBQSxNQUNSO0FBRUEsbUJBQWEsSUFBSTtBQUFBLElBQ3JCO0FBQUEsSUFFQSxZQUFZLEtBQUssTUFBTTtBQUNuQixVQUFJLEtBQUssY0FBYyxFQUFFLEdBQUc7QUFDeEIsYUFBSyxjQUFjO0FBRW5CO0FBQUEsTUFDSjtBQUVBLFdBQUssY0FBYztBQUFBLElBQ3ZCO0FBQUEsSUFFQSxjQUFjLEtBQUssTUFBTTtBQUNyQixVQUFJLE9BQU8sTUFBTTtBQUNiLGVBQU8sS0FBSyxnQkFBZ0I7QUFBQSxNQUNoQztBQUVBLGFBQU8sS0FBSyxnQkFBZ0I7QUFBQSxJQUNoQztBQUFBLElBRUEsZUFBZSxJQUFJO0FBQ2YsYUFDSyxNQUFNLEVBQ04sTUFBTSxFQUNOLGNBQWM7QUFBQSxRQUNYO0FBQUEsVUFDSSxNQUFNO0FBQUEsVUFDTixPQUFPLEVBQUUsR0FBRztBQUFBLFFBQ2hCO0FBQUEsUUFDQTtBQUFBLFVBQ0ksTUFBTTtBQUFBLFVBQ04sTUFBTTtBQUFBLFFBQ1Y7QUFBQSxNQUNKLENBQUMsRUFDQSxJQUFJO0FBQUEsSUFDYjtBQUFBLEVBQ0o7QUFDSjsiLAogICJuYW1lcyI6IFsiZm91bmQiLCAibWFwIiwgInNpemUiLCAiZnJvbSIsICJmaXJzdCIsICJjb3B5IiwgImZvdW5kIiwgInJvdW5kIiwgIm9mZnNldCIsICJfTWFyayIsICJzbGljZSIsICJkb2MiLCAiTm9kZSIsICJfTm9kZSIsICJiYXNlIiwgImkiLCAibWluIiwgIm1heCIsICJ0eXBlIiwgIm5mYSIsICJlZGdlIiwgImV4cHIiLCAibm9kZSIsICJzdGF0ZXMiLCAiZGVmYXVsdHMiLCAibmFtZSIsICJtYXJrIiwgInN0eWxlIiwgIndyYXAiLCAiaW5saW5lIiwgInNwYWNlIiwgIm9mZnNldCIsICJkZWwiLCAiZnJvbSIsICJtYXAiLCAiZG9jIiwgInNsaWNlIiwgInBhcmVudCIsICJ0ciIsICJmb3VuZCIsICJzdHlsZSIsICJiYXNlIiwgImluZGV4IiwgImpvaW5hYmxlIiwgImZpcnN0IiwgIndyYXAiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJ0eXBlIiwgImNsb3NlIiwgIlRyYW5zZm9ybUVycm9yIiwgInRyIiwgImZyb20iLCAiZm91bmQiLCAiZG9jIiwgIm1hcCIsICJzbGljZSIsICJOb2RlIiwgImZyb20iLCAib2Zmc2V0IiwgImRvYyIsICJmaXJzdCIsICJzaXplIiwgImkiLCAiZW50ZXIiLCAiYmFzZSIsICJ3cmFwIiwgImlubGluZSIsICJjb3B5IiwgInNwZWMiLCAiZm91bmQiLCAicHJlTWF0Y2giLCAibWF0Y2hlcyIsICJtaW4iLCAibWF4IiwgImVtcHR5IiwgInRyIiwgInNsaWNlIiwgImRvbSIsICJldmVudCIsICJoYW5kbGVycyIsICJzZWwiLCAiY3V0IiwgImlzTm9kZSIsICJOb2RlVHlwZSIsICJvbGRPZmZzZXQiLCAiZmluZCIsICJhbmNob3IiLCAiZnJvbSIsICJmb3VuZCIsICJwcm9wIiwgIm9mZnNldCIsICJzbGljZSIsICJ0ciIsICJtYWMiLCAiaWUiLCAibWFjIiwgIndpbmRvd3MiLCAic2hpZnQiLCAibWFwIiwgImNvcHkiLCAidHIiLCAiZW1wdHkiLCAibGlmdCIsICJmaXJzdCIsICJ3cmFwIiwgInRyIiwgInNldEJsb2NrVHlwZSIsICJmcm9tIiwgIm1hYyIsICJ0ciIsICJkb2MiLCAid3JhcCIsICJmb3VuZCIsICJmaXJzdCIsICJ0ciIsICJzbGljZSIsICJkb2MiLCAidHIiLCAiY29tbWFuZCIsICJydW4iLCAiTm9kZSIsICJkZWZhdWx0QmxvY2tBdCIsICJzdHlsZSIsICJfYSIsICJTY2hlbWEiLCAiZnJvbSIsICJnZXRUZXh0IiwgImZyb20iLCAiZW1wdHkiLCAibm9kZSIsICJrZXlzIiwgIm1hcmsiLCAiZnJvbSIsICJkb2MiLCAiZW1wdHkiLCAicmFuZ2UiLCAicGFyZW50Tm9kZSIsICJtaW4iLCAibWF4IiwgIlRleHRTZWxlY3Rpb24iLCAic2VsZWN0aW9uVG9JbnNlcnRpb25FbmQiLCAidHIiLCAibWFwIiwgIlNlbGVjdGlvbiIsICJmaW5kIiwgImZyb20iLCAiRnJhZ21lbnQiLCAiTWFyayIsICJyZW1vdmVNYXJrIiwgIm1hdGNoZXMiLCAicnVuIiwgImhhbmRsZXJzIiwgIlBsdWdpbiIsICJ0byIsICJpbmxpbmUiLCAiZG9jIiwgInJhbmdlIiwgImNyZWF0ZVBhcmFncmFwaE5lYXIiLCAiZGVsZXRlUmFuZ2UiLCAiZGVsZXRlU2VsZWN0aW9uIiwgImV4aXRDb2RlIiwgImpvaW5CYWNrd2FyZCIsICJqb2luRG93biIsICJqb2luRm9yd2FyZCIsICJqb2luVGV4dGJsb2NrQmFja3dhcmQiLCAiam9pblRleHRibG9ja0ZvcndhcmQiLCAiam9pblVwIiwgImxpZnQiLCAibGlmdEVtcHR5QmxvY2siLCAibGlmdExpc3RJdGVtIiwgIm5ld2xpbmVJbkNvZGUiLCAic2VsZWN0QWxsIiwgInNlbGVjdE5vZGVCYWNrd2FyZCIsICJzZWxlY3ROb2RlRm9yd2FyZCIsICJzZWxlY3RQYXJlbnROb2RlIiwgInNlbGVjdFRleHRibG9ja0VuZCIsICJzZWxlY3RUZXh0YmxvY2tTdGFydCIsICJzaW5rTGlzdEl0ZW0iLCAic3BsaXRCbG9jayIsICJ3cmFwSW4iLCAid3JhcEluTGlzdCIsICJUZXh0U2VsZWN0aW9uIiwgImlzVGV4dFNlbGVjdGlvbiIsICJqb2luUG9pbnQiLCAib3JpZ2luYWxDb21tYW5kIiwgIm5vcm1hbGl6ZUtleU5hbWUiLCAic2hpZnQiLCAia2V5cyIsICJpc0FjdGl2ZSIsICJkb2N1bWVudCIsICJlbXB0eSIsICJzZXRCbG9ja1R5cGUiLCAiTm9kZVNlbGVjdGlvbiIsICJkZWZhdWx0QmxvY2tBdCIsICJmaXJzdCIsICJ3cmFwIiwgIm5ld05leHRUeXBlQXR0cmlidXRlcyIsICJuZXh0VHlwZSIsICJjYW5TcGxpdCIsICJfYSIsICJfYiIsICJfYyIsICJQbHVnaW5LZXkiLCAic2xpY2UiLCAiaGFuZGxlQmFja3NwYWNlIiwgImhhbmRsZURlbGV0ZSIsICJpc0VtcHR5IiwgIm9mZnNldCIsICJzdHlsZSIsICJmb2N1cyIsICJibHVyIiwgImdldFRleHQiLCAidHIiLCAiY2FuSm9pbiIsICJOb2RlIiwgInRyIiwgInJlY3QiLCAiZG9jIiwgInRyIiwgIlJvcGVTZXF1ZW5jZSIsICJmcm9tIiwgImZvckVhY2giLCAiTGVhZiIsICJBcHBlbmQiLCAiYXBwZW5kSW5uZXIiLCAiZGlzdF9kZWZhdWx0IiwgIm1hcCIsICJmcm9tIiwgImRpc3RfZGVmYXVsdCIsICJoaXN0b3J5IiwgInRyIiwgInJlZG8iLCAidHIiLCAiY29tbWFuZCIsICJyZWRvIiwgImZyb20iLCAidHIiLCAiRXh0ZW5zaW9uIiwgIlBsdWdpbiIsICJQbHVnaW5LZXkiLCAiZG9jIiwgImlzRW1wdHkiLCAiRGVjb3JhdGlvbiIsICJEZWNvcmF0aW9uU2V0IiwgIlNlbGVjdGlvbiIsICJNYXJrIiwgImluZGV4X2RlZmF1bHQiLCAiaW5wdXRSZWdleCIsICJNYXJrIiwgImluZGV4X2RlZmF1bHQiLCAiZW1wdHkiLCAidHIiLCAiZG9jIiwgImluZGV4X2RlZmF1bHQiLCAidHIiLCAiZW1wdHkiLCAiTm9kZSIsICJpbmRleF9kZWZhdWx0IiwgImluZGV4X2RlZmF1bHQiLCAiaW5kZXhfZGVmYXVsdCIsICJzdGFySW5wdXRSZWdleCIsICJzdGFyUGFzdGVSZWdleCIsICJ1bmRlcnNjb3JlSW5wdXRSZWdleCIsICJ1bmRlcnNjb3JlUGFzdGVSZWdleCIsICJNYXJrIiwgImluZGV4X2RlZmF1bHQiLCAiaW5wdXRSZWdleCIsICJpbmRleF9kZWZhdWx0IiwgImluZGV4X2RlZmF1bHQiLCAibmV4dFN0YXRlIiwgIk5sIiwgImZpcnN0IiwgInNjaGVtZSIsICJydW4iLCAic2NoZW1lIiwgInJ1biIsICJ0ciIsICJQbHVnaW4iLCAiUGx1Z2luS2V5IiwgInNsaWNlIiwgImVtcHR5IiwgIk1hcmsiLCAiZmluZCIsICJpbmRleF9kZWZhdWx0IiwgIk5vZGUiLCAibWVyZ2VBdHRyaWJ1dGVzIiwgIl9fZXhwb3J0IiwgImdldE5vZGVUeXBlIiwgImlzTm9kZUFjdGl2ZSIsICJMaXN0SXRlbU5hbWUiLCAiVGV4dFN0eWxlTmFtZSIsICJ3cmFwcGluZ0lucHV0UnVsZSIsICJpbnB1dFJlZ2V4IiwgInRyIiwgIkV4dGVuc2lvbiIsICJmcm9tIiwgImNvbW1hbmQiLCAiZmluZFN1Z2dlc3Rpb25NYXRjaCIsICJfYSIsICJlbXB0eSIsICJpbmRleF9kZWZhdWx0IiwgInRyIiwgImVtcHR5IiwgIk5vZGUiLCAiaW5kZXhfZGVmYXVsdCIsICJpbmRleF9kZWZhdWx0IiwgImluZGV4X2RlZmF1bHQiLCAiaW5wdXRSZWdleCIsICJwYXN0ZVJlZ2V4IiwgIk1hcmsiLCAic3R5bGUiLCAiaW5kZXhfZGVmYXVsdCIsICJNYXJrIiwgImluZGV4X2RlZmF1bHQiLCAiTWFyayIsICJpbmRleF9kZWZhdWx0IiwgIm1hcCIsICJoIiwgIm1hcCIsICJkb2MiLCAiZnJvbSIsICJ0ciIsICJub3JtYWxpemUiLCAib2Zmc2V0IiwgImZpcnN0IiwgImNvcHkiLCAic2xpY2UiLCAiZW1wdHkiLCAiZm91bmQiLCAiaGFuZGxlS2V5RG93biIsICJhcnJvdyIsICJoYW5kbGVUcmlwbGVDbGljayIsICJOb2RlIiwgIm1lcmdlQXR0cmlidXRlcyIsICJUYWJsZVZpZXciLCAidHIiLCAib2Zmc2V0IiwgIkNlbGxTZWxlY3Rpb24iLCAiVGV4dCIsICJpbmRleF9kZWZhdWx0IiwgIk1hcmsiLCAic3R5bGUiLCAiaW5kZXhfZGVmYXVsdCIsICJnZXRTaWRlIiwgImdldFNpZGUiLCAicGxhdGZvcm0iLCAicmVzZXQiLCAiYXJyb3ciLCAibWF4IiwgIm9mZnNldCIsICJhbGlnbm1lbnQiLCAicGxhY2VtZW50cyIsICJzaWRlcyIsICJzaWRlIiwgInBsYWNlbWVudCIsICJvdmVyZmxvdyIsICJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCAidG9wIiwgImJvdHRvbSIsICJsZWZ0IiwgInJpZ2h0IiwgIndpZHRoIiwgImhlaWdodCIsICJzaGlmdCIsICJ4IiwgInkiLCAibWluIiwgInBsYXRmb3JtIiwgImFwcGx5IiwgImdldFNpZGUiLCAiZ2V0Q29tcHV0ZWRTdHlsZSIsICJ3ZWJraXQiLCAicGFyZW50Tm9kZSIsICJnZXRDb21wdXRlZFN0eWxlIiwgImNsaWVudFJlY3QiLCAicGFyZW50Tm9kZSIsICJjYWNoZWRSZXN1bHQiLCAib2Zmc2V0IiwgImF1dG9QbGFjZW1lbnQiLCAic2hpZnQiLCAiZmxpcCIsICJzaXplIiwgImhpZGUiLCAiYXJyb3ciLCAiaW5saW5lIiwgImNvbXB1dGVQb3NpdGlvbiIsICJmcm9tIiwgImNvbXB1dGVQb3NpdGlvbiIsICJzaGlmdCIsICJmbGlwIiwgImluZGV4X2RlZmF1bHQiLCAidmlldyIsICJmcm9tIiwgImRvYyIsICJlbXB0eSIsICJzaG91bGRTaG93IiwgImZsaXAiLCAic2hpZnQiLCAib2Zmc2V0IiwgImFycm93IiwgInNpemUiLCAiYXV0b1BsYWNlbWVudCIsICJoaWRlIiwgImlubGluZSIsICJjbGllbnRSZWN0IiwgImNvbXB1dGVQb3NpdGlvbiIsICJlZGl0b3IiLCAidHIiLCAiY29tbWFuZCJdCn0K
